Implementation smell,Namespace,Class,File,Method,Description
Long Method,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The method has 193 lines of code.
Long Method,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The method has 135 lines of code.
Long Method,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The method has 106 lines of code.
Long Method,Engine.Debugging.Timing,TimeRuler,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Timing\TimeRuler.cs,Draw,The method has 132 lines of code.
Complex Method,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,Draw,Cyclomatic complexity of the method is 8
Complex Method,Engine.Core.Config,EngineConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\EngineConfig.cs,Validate,Cyclomatic complexity of the method is 8
Complex Method,Engine.Debugging.Console,CommandManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\CommandManager.cs,Parse,Cyclomatic complexity of the method is 8
Complex Method,Engine.Debugging.Timing,TimeRuler,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Timing\TimeRuler.cs,Draw,Cyclomatic complexity of the method is 18
Complex Method,Engine.Input,InputManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Input\InputManager.cs,ProcessKeyboard,Cyclomatic complexity of the method is 13
Long Parameter List,Engine.Chunks.Generators.Biomes,AntarticTundra,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Generators\Biomes\AntarticTundra.cs,ApplyBiome,The method has 5 parameters. Parameters: chunk' groundLevel' groundOffset' worldPositionX' worldPositionZ
Long Parameter List,Engine.Chunks.Generators.Biomes,BiomeGenerator,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Generators\Biomes\BiomeGenerator.cs,ApplyBiome,The method has 5 parameters. Parameters: chunk' groundLevel' groundOffset' worldPositionX' worldPositionZ
Long Parameter List,Engine.Chunks.Generators.Biomes,Desert,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Generators\Biomes\Desert.cs,ApplyBiome,The method has 5 parameters. Parameters: chunk' groundLevel' groundOffset' worldPositionX' worldPositionZ
Long Parameter List,Engine.Chunks.Generators.Biomes,RainForest,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Generators\Biomes\RainForest.cs,ApplyBiome,The method has 5 parameters. Parameters: chunk' groundLevel' groundOffset' worldPositionX' worldPositionZ
Long Parameter List,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The method has 12 parameters. Parameters: chunk' position' blockType' faceDir' sunLightTL' sunLightTR' sunLightBL' sunLightBR' localLightTL' localLightTR' localLightBL' localLightBR
Long Parameter List,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,AddVertex,The method has 6 parameters. Parameters: chunk' position' addition' textureCoordinate' sunlight' localLight
Long Parameter List,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,AddIndex,The method has 7 parameters. Parameters: chunk' i1' i2' i3' i4' i5' i6
Long Parameter List,Engine.Common.Logging,FileTarget,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Logging\FileTarget.cs,FileTarget,The method has 5 parameters. Parameters: fileName' minLevel' maxLevel' includeTimeStamps' reset
Long Parameter List,Engine.Common.Math,MathHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Math\MathHelper.cs,Lerp,The method has 5 parameters. Parameters: x' x1' x2' q00' q01
Long Parameter List,Engine.Common.Math,MathHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Math\MathHelper.cs,BiLerp,The method has 10 parameters. Parameters: x' y' q11' q12' q21' q22' x1' x2' y1' y2
Long Parameter List,Engine.Common.Math,MathHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Math\MathHelper.cs,TriLerp,The method has 17 parameters. Parameters: x' y' z' q000' q001' q010' q011' q100' q101' q110' q111' x1' x2' y1' y2' z1' z2
Long Parameter List,Engine.Common.Noise,PerlinNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\PerlinNoise.cs,Lattice,The method has 6 parameters. Parameters: ix' iy' iz' fx' fy' fz
Long Parameter List,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,dot,The method has 5 parameters. Parameters: g' x' y' z' w
Long Parameter List,Engine.Debugging.Graphs,DebugGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\DebugGraph.cs,AttachGraphics,The method has 5 parameters. Parameters: primitiveBatch' spriteBatch' spriteFont' localProjection' localView
Long Parameter List,Engine.Debugging.Ingame,BoundingBoxRenderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Ingame\BoundingBoxRenderer.cs,Render,The method has 5 parameters. Parameters: box' graphicsDevice' view' projection' color
Long Parameter List,Engine.Graphics.Drawing,BasicShapes,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Drawing\BasicShapes.cs,DrawSolidPolygon,The method has 6 parameters. Parameters: primitiveBatch' vertices' count' red' green' blue
Long Parameter List,Engine.Graphics.Drawing,BasicShapes,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Drawing\BasicShapes.cs,DrawSolidPolygon,The method has 5 parameters. Parameters: primitiveBatch' vertices' count' color' outline
Long Parameter List,Engine.Graphics.Drawing,BasicShapes,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Drawing\BasicShapes.cs,DrawPolygon,The method has 6 parameters. Parameters: primitiveBatch' vertices' count' red' green' blue
Long Parameter List,Engine.Graphics.Drawing,BasicShapes,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Drawing\BasicShapes.cs,DrawSegment,The method has 6 parameters. Parameters: primitiveBatch' start' end' red' green' blue
Long Parameter List,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,DrawFullscreenQuad,The method has 5 parameters. Parameters: texture' width' height' effect' currentBuffer
Long Parameter List,Engine.Graphics.Effects.PostProcessing.Bloom,BloomSettings,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomSettings.cs,BloomSettings,The method has 7 parameters. Parameters: name' bloomThreshold' blurAmount' bloomIntensity' baseIntensity' bloomSaturation' baseSaturation
Long Parameter List,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,AddIndex,The method has 6 parameters. Parameters: i1' i2' i3' i4' i5' i6
Long Statement,Engine.Audio,AudioManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Audio\AudioManager.cs,AmbientMusicLoop,The length of the statement  "                if (this._currentAmbientMusic == null || this._currentAmbientMusic.IsDisposed || this._currentAmbientMusic.State == SoundState.Playing) " is 135.
Long Statement,Engine.Audio,AudioManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Audio\AudioManager.cs,fadeOut,The length of the statement  "            if (this._currentAmbientMusic.State == SoundState.Stopped || this._currentAmbientMusic.State == SoundState.Paused) return; " is 122.
Long Statement,Engine.Blocks,BlockStorage,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Blocks\BlockStorage.cs,SetBlockAt,The length of the statement  "            // note: we re-process the originally altered chunk last because we wan't neighbor chunk's to get ready before' so we don't see any graphical glitches. " is 151.
Long Statement,Engine.Chunks,Chunk,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Chunk.cs,DrawInGameDebugVisual,The length of the statement  "                                                            Matrix.CreateTranslation(new Vector3(WorldPosition.X + WidthInBlocks / 2' HighestSolidBlockOffset - 1' WorldPosition.Z + LengthInBlocks / 2))); " is 143.
Long Statement,Engine.Chunks,Chunk,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Chunk.cs,DrawInGameDebugVisual,The length of the statement  "            spriteBatch.DrawString(spriteFont' position' new Vector2(projected.X - positionSize.X/2' projected.Y - positionSize.Y/2)' Color.Yellow); " is 136.
Long Statement,Engine.Chunks,Chunk,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Chunk.cs,Dispose,The length of the statement  "            GC.SuppressFinalize(this); // Take object out the finalization queue to prevent finalization code for it from executing a second time. " is 134.
Long Statement,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,RecacheChunks,The length of the statement  "                    if (this._chunkStorage.ContainsKey(this._player.CurrentChunk.RelativePosition.X + x' this._player.CurrentChunk.RelativePosition.Z + z)) " is 135.
Long Statement,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,RecacheChunks,The length of the statement  "                    var chunk = new Chunk(new Vector2Int(this._player.CurrentChunk.RelativePosition.X + x' this._player.CurrentChunk.RelativePosition.Z + z)); " is 138.
Long Statement,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,RecacheChunks,The length of the statement  "            var southWestEdge = new Vector2Int(this._player.CurrentChunk.RelativePosition.X - ViewRange' this._player.CurrentChunk.RelativePosition.Z - ViewRange); " is 151.
Long Statement,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,RecacheChunks,The length of the statement  "            var northEastEdge = new Vector2Int(this._player.CurrentChunk.RelativePosition.X + ViewRange' this._player.CurrentChunk.RelativePosition.Z + ViewRange); " is 151.
Long Statement,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,Draw,The length of the statement  "                    Game.GraphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0' chunk.VertexBuffer.VertexCount' 0' chunk.IndexBuffer.IndexCount/3); " is 143.
Long Statement,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,Draw,The length of the statement  "            this.StateStatistics[ChunkState.AwaitingGenerate] = this._chunkStorage.Values.Count(chunk => chunk.ChunkState == ChunkState.AwaitingGenerate); " is 142.
Long Statement,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,Draw,The length of the statement  "            this.StateStatistics[ChunkState.Generating] = this._chunkStorage.Values.Count(chunk => chunk.ChunkState == ChunkState.Generating); " is 130.
Long Statement,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,Draw,The length of the statement  "            this.StateStatistics[ChunkState.AwaitingLighting] = this._chunkStorage.Values.Count(chunk => chunk.ChunkState == ChunkState.AwaitingLighting); " is 142.
Long Statement,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,Draw,The length of the statement  "            this.StateStatistics[ChunkState.Lighting] = this._chunkStorage.Values.Count(chunk => chunk.ChunkState == ChunkState.Lighting); " is 126.
Long Statement,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,Draw,The length of the statement  "            this.StateStatistics[ChunkState.AwaitingRelighting] = this._chunkStorage.Values.Count(chunk => chunk.ChunkState == ChunkState.AwaitingRelighting); " is 146.
Long Statement,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,Draw,The length of the statement  "            this.StateStatistics[ChunkState.AwaitingBuild] = this._chunkStorage.Values.Count(chunk => chunk.ChunkState == ChunkState.AwaitingBuild); " is 136.
Long Statement,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,Draw,The length of the statement  "            this.StateStatistics[ChunkState.Building] = this._chunkStorage.Values.Count(chunk => chunk.ChunkState == ChunkState.Building); " is 126.
Long Statement,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,Draw,The length of the statement  "            this.StateStatistics[ChunkState.AwaitingRebuild] = this._chunkStorage.Values.Count(chunk => chunk.ChunkState == ChunkState.AwaitingRebuild); " is 140.
Long Statement,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,Draw,The length of the statement  "            this.StateStatistics[ChunkState.Ready] = this._chunkStorage.Values.Count(chunk => chunk.ChunkState == ChunkState.Ready); " is 120.
Long Statement,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,Draw,The length of the statement  "            this.StateStatistics[ChunkState.AwaitingRemoval] = this._chunkStorage.Values.Count(chunk => chunk.ChunkState == ChunkState.AwaitingRemoval); " is 140.
Long Statement,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,GetChunkByWorldPosition,The length of the statement  "            return !this._chunkStorage.ContainsKey(x / Chunk.WidthInBlocks' z / Chunk.LengthInBlocks) ? null : this._chunkStorage[x / Chunk.WidthInBlocks' z / Chunk.LengthInBlocks]; " is 169.
Long Statement,Engine.Chunks.Generators.Terrain,FlatDebugTerrain,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Generators\Terrain\FlatDebugTerrain.cs,GenerateBlocks,The length of the statement  "            this.BiomeGenerator.ApplyBiome(chunk' DirtHeight - 1' offset + DirtHeight - 1' worldPositionX + this.Seed' worldPositionZ); " is 123.
Long Statement,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,Process,The length of the statement  "            if (chunk.ChunkState != ChunkState.AwaitingLighting && chunk.ChunkState != ChunkState.AwaitingRelighting) // if chunk is not awaiting lighting " is 142.
Long Statement,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,SetInitialLighting,The length of the statement  "                        if(!inShade && BlockStorage.Blocks[offset + y].Type != BlockType.None) // if we're under direct sunlight and just hit a solid block. " is 132.
Long Statement,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,PropagateSunLight,The length of the statement  "            if (incomingLight <= BlockStorage.Blocks[blockIndex].Sun) // if incoming light is already lower than blocks current light' stop propagating. " is 140.
Long Statement,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,PropagateLightR,The length of the statement  "            if (incomingLight <= BlockStorage.Blocks[blockIndex].R) // if incoming light is already lower than blocks current light' stop propagating. " is 138.
Long Statement,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,PropagateLightG,The length of the statement  "            if (incomingLight <= BlockStorage.Blocks[blockIndex].G) // if incoming light is already lower than blocks current light' stop propagating. " is 138.
Long Statement,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,PropagateLightB,The length of the statement  "            if (incomingLight <= BlockStorage.Blocks[blockIndex].B) // if incoming light is already lower than blocks current light' stop propagating. " is 138.
Long Statement,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,Build,The length of the statement  "                new Vector3(chunk.WorldPosition.X + Chunk.WidthInBlocks' chunk.HighestSolidBlockOffset' chunk.WorldPosition.Z + Chunk.LengthInBlocks)); " is 135.
Long Statement,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildVertexList,The length of the statement  "            chunk.VertexBuffer = new VertexBuffer(this.Game.GraphicsDevice' typeof(BlockVertex)' vertices.Length' BufferUsage.WriteOnly); " is 125.
Long Statement,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildVertexList,The length of the statement  "            chunk.IndexBuffer = new IndexBuffer(this.Game.GraphicsDevice' IndexElementSize.SixteenBits' indices.Length' BufferUsage.WriteOnly); " is 131.
Long Statement,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The length of the statement  "                BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR); " is 148.
Long Statement,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The length of the statement  "                BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR); " is 148.
Long Statement,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The length of the statement  "                BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR); " is 148.
Long Statement,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The length of the statement  "                BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR); " is 148.
Long Statement,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The length of the statement  "                BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR); " is 148.
Long Statement,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The length of the statement  "                BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR); " is 148.
Long Statement,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,AddVertex,The length of the statement  "            //chunk.VertexList.Add(new BlockVertex(position.AsVector3() + addition' textureCoordinate' sunlight' localLight.ToVector3()));             " is 126.
Long Statement,Engine.Common.Extensions,EnumerableExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\EnumerableExtensions.cs,Dump,The length of the statement  "                text.Append(string.Format("{0}"' (char.IsWhiteSpace((char)value) && (char)value != ' ') ? '.' : (char)value)); // prettify text " is 127.
Long Statement,Engine.Common.Logging,ConsoleTarget,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Logging\ConsoleTarget.cs,LogException,The length of the statement  "            Console.WriteLine(string.Format("{0}[{1}] [{2}]: {3} - [Exception] {4}"' timeStamp' level.ToString().PadLeft(5)' logger' message' exception)); " is 142.
Long Statement,Engine.Common.Logging,FileTarget,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Logging\FileTarget.cs,LogMessage,The length of the statement  "                    this._logStream.WriteLine(string.Format("{0}[{1}] [{2}]: {3}"' timeStamp' level.ToString().PadLeft(5)' logger' message)); " is 121.
Long Statement,Engine.Common.Logging,FileTarget,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Logging\FileTarget.cs,LogException,The length of the statement  "                    this._logStream.WriteLine(string.Format("{0}[{1}] [{2}]: {3} - [Exception] {4}"' timeStamp' level.ToString().PadLeft(5)' logger' message' exception)); " is 150.
Long Statement,Engine.Common.Logging,FileTarget,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Logging\FileTarget.cs,Dispose,The length of the statement  "            GC.SuppressFinalize(this); // Take object out the finalization queue to prevent finalization code for it from executing a second time. " is 134.
Long Statement,Engine.Common.Logging,Logger,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Logging\Logger.cs,Log,The length of the statement  "            LogRouter.RouteMessage(level' this.Name' args == null ? message : string.Format(CultureInfo.InvariantCulture' message' args)); " is 126.
Long Statement,Engine.Common.Logging,Logger,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Logging\Logger.cs,LogException,The length of the statement  "            LogRouter.RouteException(level' this.Name' args == null ? message : string.Format(CultureInfo.InvariantCulture' message' args)' exception); " is 139.
Long Statement,Engine.Common.Logging,LogRouter,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Logging\LogRouter.cs,RouteMessage,The length of the statement  "            foreach (var target in LogManager.Targets.Where(target => level >= target.MinimumLevel && level <= target.MaximumLevel)) " is 120.
Long Statement,Engine.Common.Logging,LogRouter,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Logging\LogRouter.cs,RouteException,The length of the statement  "            foreach (var target in LogManager.Targets.Where(target => level >= target.MinimumLevel && level <= target.MaximumLevel)) " is 120.
Long Statement,Engine.Core.Config,CacheConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\CacheConfig.cs,Validate,The length of the statement  "                throw new CacheConfigException("Cache range can not be different than view range when CacheExtraChunk option is set to false."); " is 128.
Long Statement,Engine.Core,Engine,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Engine.cs,Dispose,The length of the statement  "            GC.SuppressFinalize(this); // Take object out the finalization queue to prevent finalization code for it from executing a second time. " is 134.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The length of the statement  "            this._localProjection = Matrix.CreateOrthographicOffCenter(0f' this.GraphicsDevice.Viewport.Width' this.GraphicsDevice.Viewport.Height' 0f' 0f' 1f); " is 148.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The length of the statement  "            this._backgroundPolygon[2] = new Vector2(_bounds.X + 2 + _bounds.Width' _bounds.Y + _bounds.Height + 14); // bottom right " is 121.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The length of the statement  "            _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 105' this._bounds.Y + 5)' Color.White); " is 121.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The length of the statement  "            _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 205' this._bounds.Y + 5)' Color.White); " is 121.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The length of the statement  "            _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 305' this._bounds.Y + 5)' Color.White); " is 121.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The length of the statement  "            this.GenerateQueue = this._chunkCache.StateStatistics[ChunkState.AwaitingGenerate] + this._chunkCache.StateStatistics[ChunkState.Generating]; " is 141.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The length of the statement  "            this.LightenQueue = this._chunkCache.StateStatistics[ChunkState.AwaitingLighting] + this._chunkCache.StateStatistics[ChunkState.Lighting] + this._chunkCache.StateStatistics[ChunkState.AwaitingRelighting]; " is 204.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The length of the statement  "            this.BuildQueue = this._chunkCache.StateStatistics[ChunkState.AwaitingBuild] + this._chunkCache.StateStatistics[ChunkState.Building] + this._chunkCache.StateStatistics[ChunkState.AwaitingRebuild]; " is 196.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The length of the statement  "            _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 450' this._bounds.Y + 5)' Color.White); " is 121.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The length of the statement  "            _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 550' this._bounds.Y + 5)' Color.White); " is 121.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The length of the statement  "            _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 650' this._bounds.Y + 5)' Color.White); " is 121.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The length of the statement  "            _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 750' this._bounds.Y + 5)' Color.White); " is 121.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The length of the statement  "            _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 850' this._bounds.Y + 5)' Color.White); " is 121.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The length of the statement  "            _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 5' this._bounds.Y + 15)' Color.White); " is 120.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The length of the statement  "            _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 105' this._bounds.Y + 15)' Color.White); " is 122.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The length of the statement  "            _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 205' this._bounds.Y + 15)' Color.White); " is 122.
Long Statement,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The length of the statement  "            _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 305' this._bounds.Y + 15)' Color.White); " is 122.
Long Statement,Engine.Debugging.Console,InputProcessor,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\InputProcessor.cs,TranslateChar,The length of the statement  "            if (xnaKey >= global::Microsoft.Xna.Framework.Input.Keys.NumPad0 && xnaKey <= global::Microsoft.Xna.Framework.Input.Keys.NumPad9) " is 129.
Long Statement,Engine.Debugging.Console,InputProcessor,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\InputProcessor.cs,AutoComplete,The length of the statement  "            var textToMatch = lastSpacePosition < 0 ? Buffer.Output : Buffer.Output.Substring(lastSpacePosition + 1' Buffer.Output.Length - lastSpacePosition - 1); " is 151.
Long Statement,Engine.Debugging.Console,Renderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\Renderer.cs,Update,The length of the statement  "                position.Y = MathHelper.SmoothStep(position.Y' openedPosition.Y' ((float)((DateTime.Now - stateChangeTime).TotalSeconds / GameConsoleOptions.Options.AnimationSpeed))); " is 167.
Long Statement,Engine.Debugging.Console,Renderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\Renderer.cs,Update,The length of the statement  "                position.Y = MathHelper.SmoothStep(position.Y' closedPosition.Y' ((float)((DateTime.Now - stateChangeTime).TotalSeconds / GameConsoleOptions.Options.AnimationSpeed))); " is 167.
Long Statement,Engine.Debugging.Console,Renderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\Renderer.cs,Draw,The length of the statement  "            var bufferPosition = DrawCommand(inputProcessor.Buffer.ToString()' nextCommandPosition' GameConsoleOptions.Options.BufferColor); //Draw the buffer " is 146.
Long Statement,Engine.Debugging.Console,Renderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\Renderer.cs,DrawRoundedEdges,The length of the statement  "            spriteBatch.Draw(GameConsoleOptions.Options.RoundedCorner' new Vector2(position.X' position.Y + GameConsoleOptions.Options.Height)' null' GameConsoleOptions.Options.BackgroundColor' 0' Vector2.Zero' 1' SpriteEffects.None' 1); " is 225.
Long Statement,Engine.Debugging.Console,Renderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\Renderer.cs,DrawRoundedEdges,The length of the statement  "            spriteBatch.Draw(GameConsoleOptions.Options.RoundedCorner' new Vector2(position.X + Bounds.Width - GameConsoleOptions.Options.RoundedCorner.Width' position.Y + GameConsoleOptions.Options.Height)' null' GameConsoleOptions.Options.BackgroundColor' 0' Vector2.Zero' 1' SpriteEffects.FlipHorizontally' 1); " is 301.
Long Statement,Engine.Debugging.Console,Renderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\Renderer.cs,DrawRoundedEdges,The length of the statement  "            spriteBatch.Draw(pixel' new Rectangle(Bounds.X + GameConsoleOptions.Options.RoundedCorner.Width' Bounds.Y + GameConsoleOptions.Options.Height' Bounds.Width - GameConsoleOptions.Options.RoundedCorner.Width * 2' GameConsoleOptions.Options.RoundedCorner.Height)' GameConsoleOptions.Options.BackgroundColor); " is 304.
Long Statement,Engine.Debugging.Console,Renderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\Renderer.cs,DrawCursor,The length of the statement  "            spriteBatch.DrawString(GameConsoleOptions.Options.Font' (int)(gameTime.TotalGameTime.TotalSeconds / GameConsoleOptions.Options.CursorBlinkSpeed) % 2 == 0 ? GameConsoleOptions.Options.Cursor.ToString() : ""' pos' GameConsoleOptions.Options.CursorColor); " is 252.
Long Statement,Engine.Debugging.Console,Renderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\Renderer.cs,DrawCommand,The length of the statement  "            var splitLines = command.Length > maxCharactersPerLine ? SplitCommand(command' maxCharactersPerLine) : new[] { command }; " is 121.
Long Statement,Engine.Debugging.Console,Renderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\Renderer.cs,DrawCommands,The length of the statement  "                pos.Y = DrawCommand(command.ToString()' pos' command.Type == OutputLineType.Command ? GameConsoleOptions.Options.PastCommandColor : GameConsoleOptions.Options.PastCommandOutputColor).Y; " is 185.
Long Statement,Engine.Debugging.Console,Renderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\Renderer.cs,DrawPrompt,The length of the statement  "            spriteBatch.DrawString(GameConsoleOptions.Options.Font' GameConsoleOptions.Options.Prompt' pos' GameConsoleOptions.Options.PromptColor); " is 136.
Long Statement,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The length of the statement  "            this._graphs.Add(new FPSGraph(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 50' 270' 35))); " is 127.
Long Statement,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The length of the statement  "            this._graphs.Add(new MemGraph(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 105' 270' 35))); " is 128.
Long Statement,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The length of the statement  "            this._graphs.Add(new GenerateQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 160' 270' 35))); " is 129.
Long Statement,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The length of the statement  "            this._graphs.Add(new LightenQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 215' 270' 35))); " is 128.
Long Statement,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The length of the statement  "            this._graphs.Add(new BuildQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 270' 270' 35))); " is 126.
Long Statement,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The length of the statement  "            this._graphs.Add(new ReadyQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 325' 270' 35))); " is 126.
Long Statement,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The length of the statement  "            this._graphs.Add(new RemoveQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 380' 270' 35))); " is 127.
Long Statement,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,LoadContent,The length of the statement  "            _localProjection = Matrix.CreateOrthographicOffCenter(0f' this.GraphicsDevice.Viewport.Width' this.GraphicsDevice.Viewport.Height' 0f' 0f' 1f); " is 143.
Long Statement,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,LoadContent,The length of the statement  "                graph.AttachGraphics(this._primitiveBatch' this._spriteBatch' this._spriteFont' this._localProjection' this._localView); " is 120.
Long Statement,Engine.Debugging.Graphs.Implementations.ChunkGraphs,BuildQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\BuildQ.cs,DrawGraph,The length of the statement  "                var x2 = new Vector2(MathHelper.Clamp(x + deltaX' Bounds.Left' Bounds.Right)' MathHelper.Clamp(y2' Bounds.Top' Bounds.Bottom)); " is 127.
Long Statement,Engine.Debugging.Graphs.Implementations.ChunkGraphs,GenerateQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\GenerateQ.cs,DrawGraph,The length of the statement  "                var x2 = new Vector2(MathHelper.Clamp(x + deltaX' Bounds.Left' Bounds.Right)' MathHelper.Clamp(y2' Bounds.Top' Bounds.Bottom)); " is 127.
Long Statement,Engine.Debugging.Graphs.Implementations.ChunkGraphs,LightenQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\LightenQ.cs,DrawGraph,The length of the statement  "                var x2 = new Vector2(MathHelper.Clamp(x + deltaX' Bounds.Left' Bounds.Right)' MathHelper.Clamp(y2' Bounds.Top' Bounds.Bottom)); " is 127.
Long Statement,Engine.Debugging.Graphs.Implementations.ChunkGraphs,ReadyQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\ReadyQ.cs,DrawGraph,The length of the statement  "                var x2 = new Vector2(MathHelper.Clamp(x + deltaX' Bounds.Left' Bounds.Right)' MathHelper.Clamp(y2' Bounds.Top' Bounds.Bottom)); " is 127.
Long Statement,Engine.Debugging.Graphs.Implementations.ChunkGraphs,RemoveQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\RemoveQ.cs,DrawGraph,The length of the statement  "                var x2 = new Vector2(MathHelper.Clamp(x + deltaX' Bounds.Left' Bounds.Right)' MathHelper.Clamp(y2' Bounds.Top' Bounds.Bottom)); " is 127.
Long Statement,Engine.Debugging.Graphs.Implementations,FPSGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\FPSGraph.cs,DrawGraph,The length of the statement  "                var x2 = new Vector2(MathHelper.Clamp(x + deltaX' Bounds.Left' Bounds.Right)' MathHelper.Clamp(y2' Bounds.Top' Bounds.Bottom)); " is 127.
Long Statement,Engine.Debugging.Graphs.Implementations,MemGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\MemGraph.cs,DrawStrings,The length of the statement  "            SpriteBatch.DrawString(SpriteFont' "mem:" + CurrentValue.GetKiloString()' new Vector2(Bounds.Left' Bounds.Bottom)' Color.White); " is 128.
Long Statement,Engine.Debugging.Graphs.Implementations,MemGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\MemGraph.cs,DrawStrings,The length of the statement  "            //SpriteBatch.DrawString(SpriteFont' "max:" + MaxValue.GetKiloString()' new Vector2(Bounds.Left + 90' Bounds.Bottom)' Color.White); " is 131.
Long Statement,Engine.Debugging.Graphs.Implementations,MemGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\MemGraph.cs,DrawStrings,The length of the statement  "            //SpriteBatch.DrawString(SpriteFont' "avg:" + AverageValue.GetKiloString()' new Vector2(Bounds.Left + 150' Bounds.Bottom)' Color.White); " is 136.
Long Statement,Engine.Debugging.Graphs.Implementations,MemGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\MemGraph.cs,DrawStrings,The length of the statement  "            //SpriteBatch.DrawString(SpriteFont' "min:" + MinimumValue.GetKiloString()' new Vector2(Bounds.Left + 210' Bounds.Bottom)' Color.White); " is 136.
Long Statement,Engine.Debugging.Graphs.Implementations,MemGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\MemGraph.cs,DrawGraph,The length of the statement  "                var x2 = new Vector2(MathHelper.Clamp(x + deltaX' Bounds.Left' Bounds.Right)' MathHelper.Clamp(y2' Bounds.Top' Bounds.Bottom)); " is 127.
Long Statement,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,Draw,The length of the statement  "            bloomExtractEffect.Parameters["BloomThreshold"].SetValue(BloomSettings.PresetSettings[Core.Engine.Instance.Configuration.Bloom.State].BloomThreshold); " is 150.
Long Statement,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,Draw,The length of the statement  "            parameters["BloomIntensity"].SetValue(BloomSettings.PresetSettings[Core.Engine.Instance.Configuration.Bloom.State].BloomIntensity); " is 131.
Long Statement,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,Draw,The length of the statement  "            parameters["BaseIntensity"].SetValue(BloomSettings.PresetSettings[Core.Engine.Instance.Configuration.Bloom.State].BaseIntensity); " is 129.
Long Statement,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,Draw,The length of the statement  "            parameters["BloomSaturation"].SetValue(BloomSettings.PresetSettings[Core.Engine.Instance.Configuration.Bloom.State].BloomSaturation); " is 133.
Long Statement,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,Draw,The length of the statement  "            parameters["BaseSaturation"].SetValue(BloomSettings.PresetSettings[Core.Engine.Instance.Configuration.Bloom.State].BaseSaturation); " is 131.
Long Statement,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,BuildBlockTextureMappings,The length of the statement  "                BlockTextureMappings.Add((i*6)' GetBlockTextureMapping(i' BlockFaceDirection.XIncreasing)); // build x-increasing mapping for the texture. " is 138.
Long Statement,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,BuildBlockTextureMappings,The length of the statement  "                BlockTextureMappings.Add((i*6) + 1' GetBlockTextureMapping(i' BlockFaceDirection.XDecreasing)); // build x-decreasing mapping for the texture. " is 142.
Long Statement,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,BuildBlockTextureMappings,The length of the statement  "                BlockTextureMappings.Add((i*6) + 2' GetBlockTextureMapping(i' BlockFaceDirection.YIncreasing)); // build y-increasing mapping for the texture. " is 142.
Long Statement,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,BuildBlockTextureMappings,The length of the statement  "                BlockTextureMappings.Add((i*6) + 3' GetBlockTextureMapping(i' BlockFaceDirection.YDecreasing)); // build y-decreasing mapping for the texture. " is 142.
Long Statement,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,BuildBlockTextureMappings,The length of the statement  "                BlockTextureMappings.Add((i*6) + 4' GetBlockTextureMapping(i' BlockFaceDirection.ZIncreasing)); // build z-increasing mapping for the texture. " is 142.
Long Statement,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,BuildBlockTextureMappings,The length of the statement  "                BlockTextureMappings.Add((i*6) + 5' GetBlockTextureMapping(i' BlockFaceDirection.ZDecreasing)); // build z-increasing mapping for the texture.    " is 142.
Long Statement,Engine.Input,InputManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Input\InputManager.cs,ProcessMouse,The length of the statement  "            if (currentState == this._previousMouseState || !this.CaptureMouse) // if there's no mouse-state change or if it's not captured' just return. " is 141.
Long Statement,Engine.Platforms,PlatformManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Platforms\PlatformManager.cs,IdentifyPlatform,The length of the statement  "                DotNetFrameworkVersion = System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(Object)).Assembly.GetName().Version; " is 122.
Long Statement,Engine.Platforms,PlatformManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Platforms\PlatformManager.cs,IdentifyPlatform,The length of the statement  "                GameFrameworkVersion = System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(Microsoft.Xna.Framework.Game)).Assembly.GetName().Version; " is 142.
Long Statement,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,Draw,The length of the statement  "                Game.GraphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0' VertexBuffer.VertexCount' 0' IndexBuffer.IndexCount / 3); " is 133.
Long Statement,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildMesh,The length of the statement  "            IndexBuffer = new IndexBuffer(this.Game.GraphicsDevice' IndexElementSize.SixteenBits' indices.Length' BufferUsage.WriteOnly); " is 125.
Long Statement,Engine.Universe,Player,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Player.cs,Draw,The length of the statement  "            //        effect.World = transforms[mesh.ParentBone.Index] * Matrix.CreateRotationY(modelRotation) * Matrix.CreateTranslation(modelPosition); " is 141.
Long Statement,Engine.Universe,Player,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Player.cs,Draw,The length of the statement  "            //        effect.Projection = Matrix.CreatePerspectiveFieldOfView(MathHelper.ToRadians(45.0f)' Game.GraphicsDevice.Viewport.AspectRatio' 1.0f' 10000.0f); " is 153.
Long Statement,Engine.Universe,Shovel,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Shovel.cs,SecondaryUse,The length of the statement  "            if (!_player.AimedEmptyBlock.HasValue || _player.AimedEmptyBlock.Value.Position == new Vector3Int(_player.Position + new Vector3(0f' -0.5f' 0f))) " is 145.
Long Statement,Engine.Universe,Shovel,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Shovel.cs,DrawInGameDebugVisual,The length of the statement  "            var text = string.Format("Block: {0}' Pos: {1}' Chunk: {2}"' positionedBlock.Block.ToString()' positionedBlock.Position' hostChunk.ToString()); " is 143.
Long Statement,Engine.Universe,Shovel,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Shovel.cs,DrawInGameDebugVisual,The length of the statement  "                                                                Matrix.CreateTranslation(new Vector3(positionedBlock.Position.X + 0.5f' positionedBlock.Position.Y + 0.5f' positionedBlock.Position.Z + 0.5f))); " is 144.
Long Statement,Engine.Universe,Shovel,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Shovel.cs,DrawInGameDebugVisual,The length of the statement  "            spriteBatch.DrawString(spriteFont' text' new Vector2(projected.X - textSize.X/2' projected.Y - textSize.Y/2)' Color.Yellow); " is 124.
Long Statement,Engine.Universe,Sky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Sky.cs,LoadContent,The length of the statement  "            this._cloudsRenderTarget = new RenderTarget2D(GraphicsDevice' presentationParameters.BackBufferWidth'presentationParameters.BackBufferHeight' false' SurfaceFormat.Color' DepthFormat.None); // the mipmap does not work on all configurations             " is 238.
Long Statement,Engine.Universe,Sky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Sky.cs,Draw,The length of the statement  "            Game.GraphicsDevice.DepthStencilState = DepthStencilState.None; // disable the depth-buffer for drawing the sky because it's the farthest object we'll be drawing. " is 162.
Long Statement,Engine.Universe,Sky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Sky.cs,Draw,The length of the statement  "            Matrix wStarMatrix = Matrix.CreateTranslation(Vector3.Zero)*Matrix.CreateScale(100)* Matrix.CreateTranslation(new Vector3(this._camera.Position.X' this._camera.Position.Y - 40' this._camera.Position.Z)); // move sky to camera position and should be scaled -- bigger than the world. " is 281.
Long Statement,Engine.Universe,Sky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Sky.cs,Draw,The length of the statement  "            var matrix = Matrix.CreateTranslation(Vector3.Zero)*Matrix.CreateScale(100)* Matrix.CreateTranslation(new Vector3(this._camera.Position.X' this._camera.Position.Y - 40' this._camera.Position.Z)); // move sky to camera position and should be scaled -- bigger than the world. " is 273.
Long Statement,Engine.Universe,Time,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Time.cs,GetGameTimeOfDay,The length of the statement  "            //return (float)((DateTime.Now.TimeOfDay.TotalSeconds / GameHourInRealSeconds) % 24); // quick demonstration of day & night cycles. " is 131.
Long Statement,Engine.Universe,World,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\World.cs,SpawnPlayer,The length of the statement  "                    new Vector3((this.Chunks.NorthEastEdge.X + 1) * Chunk.WidthInBlocks' Chunk.HeightInBlocks' (this.Chunks.NorthEastEdge.Z + 1) * Chunk.LengthInBlocks)); " is 150.
Complex Conditional,Engine.Chunks,Chunk,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Chunk.cs,IsInBounds,The conditional expression  "x < this.BoundingBox.Min.X || z < this.BoundingBox.Min.Z || x >= this.BoundingBox.Max.X ||                  z >= this.BoundingBox.Max.Z"  is complex.
Complex Conditional,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,IsInBounds,The conditional expression  "x < BoundingBox.Min.X || z < BoundingBox.Min.Z || x >= BoundingBox.Max.X ||                  z >= BoundingBox.Max.Z || y < BoundingBox.Min.Y || y >= BoundingBox.Max.Y"  is complex.
Magic Number,Engine.Audio,AudioManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Audio\AudioManager.cs,AmbientMusicLoop,The following statement contains a magic number: while (true)              {                  if (this._currentAmbientMusic == null || this._currentAmbientMusic.IsDisposed || this._currentAmbientMusic.State == SoundState.Playing)                  {                      Thread.Sleep(1000);                  }                    this.PlayRandomAmbientMusic();                  Thread.Sleep(2000);              }
Magic Number,Engine.Audio,AudioManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Audio\AudioManager.cs,AmbientMusicLoop,The following statement contains a magic number: while (true)              {                  if (this._currentAmbientMusic == null || this._currentAmbientMusic.IsDisposed || this._currentAmbientMusic.State == SoundState.Playing)                  {                      Thread.Sleep(1000);                  }                    this.PlayRandomAmbientMusic();                  Thread.Sleep(2000);              }
Magic Number,Engine.Audio,AudioManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Audio\AudioManager.cs,fadeOut,The following statement contains a magic number: for (float f = this._currentAmbientMusic.Volume; f > 0f; f -= 0.05f)              {                  Thread.Sleep(10);                  this._currentAmbientMusic.Volume -= f;              }
Magic Number,Engine.Audio,AudioManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Audio\AudioManager.cs,fadeIn,The following statement contains a magic number: for (float f = this._currentAmbientMusic.Volume; f < 1f; f += 0.05f)              {                  Thread.Sleep(10);                  this._currentAmbientMusic.Volume += f;              }
Magic Number,Engine.Blocks,Block,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Blocks\Block.cs,Block,The following statement contains a magic number: Sun = 16;
Magic Number,Engine.Blocks,Block,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Blocks\Block.cs,Block,The following statement contains a magic number: R = 16;
Magic Number,Engine.Blocks,Block,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Blocks\Block.cs,Block,The following statement contains a magic number: G = 16;
Magic Number,Engine.Blocks,Block,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Blocks\Block.cs,Block,The following statement contains a magic number: B = 16;
Magic Number,Engine.Chunks,Chunk,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Chunk.cs,DrawInGameDebugVisual,The following statement contains a magic number: var projected = graphicsDevice.Viewport.Project(Vector3.Zero' camera.Projection' camera.View'                                                              Matrix.CreateTranslation(new Vector3(WorldPosition.X + WidthInBlocks / 2' HighestSolidBlockOffset - 1' WorldPosition.Z + LengthInBlocks / 2)));
Magic Number,Engine.Chunks,Chunk,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Chunk.cs,DrawInGameDebugVisual,The following statement contains a magic number: var projected = graphicsDevice.Viewport.Project(Vector3.Zero' camera.Projection' camera.View'                                                              Matrix.CreateTranslation(new Vector3(WorldPosition.X + WidthInBlocks / 2' HighestSolidBlockOffset - 1' WorldPosition.Z + LengthInBlocks / 2)));
Magic Number,Engine.Chunks,Chunk,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Chunk.cs,DrawInGameDebugVisual,The following statement contains a magic number: spriteBatch.DrawString(spriteFont' position' new Vector2(projected.X - positionSize.X/2' projected.Y - positionSize.Y/2)' Color.Yellow);
Magic Number,Engine.Chunks,Chunk,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Chunk.cs,DrawInGameDebugVisual,The following statement contains a magic number: spriteBatch.DrawString(spriteFont' position' new Vector2(projected.X - positionSize.X/2' projected.Y - positionSize.Y/2)' Color.Yellow);
Magic Number,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,Draw,The following statement contains a magic number: foreach (EffectPass pass in this._blockEffect.CurrentTechnique.Passes)              {                  pass.Apply();                    foreach (Chunk chunk in this._chunkStorage.Values)                  {                      if (chunk.IndexBuffer == null || chunk.VertexBuffer == null)                          continue;                        if (chunk.VertexBuffer.VertexCount == 0)                          continue;                        if (chunk.IndexBuffer.IndexCount == 0)                          continue;                        if (!IsChunkInViewRange(chunk))                          continue;                        if (!chunk.BoundingBox.Intersects(viewFrustrum)) // if chunk is not in view frustrum'                          continue; // pas it.                        Game.GraphicsDevice.SetVertexBuffer(chunk.VertexBuffer);                      Game.GraphicsDevice.Indices = chunk.IndexBuffer;                      Game.GraphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0' chunk.VertexBuffer.VertexCount' 0' chunk.IndexBuffer.IndexCount/3);                        this.ChunksDrawn++;                  }              }
Magic Number,Engine.Chunks.Generators.Biomes,RainForest,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Generators\Biomes\RainForest.cs,GetRockHeight,The following statement contains a magic number: return SimplexNoise.noise(blockX * 0.02f' blockZ * 0.02f) * 100;
Magic Number,Engine.Chunks.Generators.Terrain,BiomedTerrain,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Generators\Terrain\BiomedTerrain.cs,GetDirtHeight,The following statement contains a magic number: return (int)(octaveSum * (Chunk.HeightInBlocks / 8)) + (int)(rockHeight);
Magic Number,Engine.Chunks.Generators.Terrain,BiomedTerrain,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Generators\Terrain\BiomedTerrain.cs,GetRockHeight,The following statement contains a magic number: int minimumGroundheight = Chunk.HeightInBlocks / 2;
Magic Number,Engine.Chunks.Generators.Terrain,MountainousTerrain,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Generators\Terrain\MountainousTerrain.cs,GetRockHeight,The following statement contains a magic number: int minimumGroundheight = Chunk.HeightInBlocks/4;
Magic Number,Engine.Chunks.Generators.Terrain,ValleyTerrain,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Generators\Terrain\ValleyTerrain.cs,GetDirtHeight,The following statement contains a magic number: float octave1 = SimplexNoise.noise((blockX + 100)*0.001f' blockZ*0.001f)*0.5f;
Magic Number,Engine.Chunks.Generators.Terrain,ValleyTerrain,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Generators\Terrain\ValleyTerrain.cs,GetDirtHeight,The following statement contains a magic number: float octave2 = SimplexNoise.noise((blockX + 100)*0.002f' blockZ*0.002f)*0.25f;
Magic Number,Engine.Chunks.Generators.Terrain,ValleyTerrain,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Generators\Terrain\ValleyTerrain.cs,GetDirtHeight,The following statement contains a magic number: float octave3 = SimplexNoise.noise((blockX + 100)*0.01f' blockZ*0.01f)*0.25f;
Magic Number,Engine.Chunks.Generators.Terrain,ValleyTerrain,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Generators\Terrain\ValleyTerrain.cs,GetRockHeight,The following statement contains a magic number: int minimumGroundheight = Chunk.HeightInBlocks/4;
Magic Number,Engine.Chunks.Populators,TreePopulator,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Populators\TreePopulator.cs,PopulateTree,The following statement contains a magic number: var trunkHeight = 5;
Magic Number,Engine.Chunks.Populators,TreePopulator,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Populators\TreePopulator.cs,PopulateTree,The following statement contains a magic number: var radius = 3;
Magic Number,Engine.Chunks.Populators,TreePopulator,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Populators\TreePopulator.cs,PopulateTree,The following statement contains a magic number: for (int i = -radius; i < radius; i++)              {                  for (int j = -radius; j < radius; j++)                  {                      var offset = BlockStorage.BlockIndexByWorldPosition(worldPositionX + i' worldPositionZ + j);                      for (int k = radius * 2; k > 0; k--)                      {                          BlockStorage.Blocks[offset + k + trunkHeight + 1] = new Block(BlockType.Leaves);                      }                  }              }
Magic Number,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,FluidFillSunLight,The following statement contains a magic number: for (byte x = 0; x < Chunk.WidthInBlocks; x++)              {                  for (byte z = 0; z < Chunk.LengthInBlocks; z++)                  {                      int offset = BlockStorage.BlockIndexByRelativePosition(chunk' x' z);                        for (byte y = Chunk.MaxHeightIndexInBlocks; y > 0; y--)                      {                          var blockIndex = offset + y;                            if (BlockStorage.Blocks[blockIndex].Type != BlockType.None) // solid blocks can't propagate light.                              continue;                            var blockLight = BlockStorage.Blocks[blockIndex].Sun;                          if (blockLight <= 1) // if block's light value is too low (dark)'                              continue; // just skip it.                            var propagatedLight = (byte)((blockLight*9)/10);                            PropagateSunLight(blockIndex + BlockStorage.XStep' propagatedLight); // propagate light to block in east.                          PropagateSunLight(blockIndex - BlockStorage.XStep' propagatedLight); // propagate light to block in west.                          PropagateSunLight(blockIndex + BlockStorage.ZStep' propagatedLight); // propagate light to block in north.                          PropagateSunLight(blockIndex - BlockStorage.ZStep' propagatedLight); // propagate light to block in south.                          // DO NOT repropagete to upper block which we don't need to do so and may cause loops!                          PropagateSunLight(blockIndex - 1' propagatedLight);   // propagate light to block down.                      }                  }              }
Magic Number,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,FluidFillSunLight,The following statement contains a magic number: for (byte x = 0; x < Chunk.WidthInBlocks; x++)              {                  for (byte z = 0; z < Chunk.LengthInBlocks; z++)                  {                      int offset = BlockStorage.BlockIndexByRelativePosition(chunk' x' z);                        for (byte y = Chunk.MaxHeightIndexInBlocks; y > 0; y--)                      {                          var blockIndex = offset + y;                            if (BlockStorage.Blocks[blockIndex].Type != BlockType.None) // solid blocks can't propagate light.                              continue;                            var blockLight = BlockStorage.Blocks[blockIndex].Sun;                          if (blockLight <= 1) // if block's light value is too low (dark)'                              continue; // just skip it.                            var propagatedLight = (byte)((blockLight*9)/10);                            PropagateSunLight(blockIndex + BlockStorage.XStep' propagatedLight); // propagate light to block in east.                          PropagateSunLight(blockIndex - BlockStorage.XStep' propagatedLight); // propagate light to block in west.                          PropagateSunLight(blockIndex + BlockStorage.ZStep' propagatedLight); // propagate light to block in north.                          PropagateSunLight(blockIndex - BlockStorage.ZStep' propagatedLight); // propagate light to block in south.                          // DO NOT repropagete to upper block which we don't need to do so and may cause loops!                          PropagateSunLight(blockIndex - 1' propagatedLight);   // propagate light to block down.                      }                  }              }
Magic Number,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,PropagateSunLight,The following statement contains a magic number: var propagatedLight = (byte)((incomingLight * 9) / 10);
Magic Number,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,PropagateSunLight,The following statement contains a magic number: var propagatedLight = (byte)((incomingLight * 9) / 10);
Magic Number,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,FluidFillLightR,The following statement contains a magic number: for (byte x = 0; x < Chunk.WidthInBlocks; x++)              {                  for (byte z = 0; z < Chunk.LengthInBlocks; z++)                  {                      int offset = BlockStorage.BlockIndexByRelativePosition(chunk' x' z);                        for (byte y = Chunk.MaxHeightIndexInBlocks; y > 0; y--)                      {                          var blockIndex = offset + y;                            if (BlockStorage.Blocks[blockIndex].Type != BlockType.None) // solid blocks can't propagate light.                              continue;                            var blockLight = BlockStorage.Blocks[blockIndex].R;                          if (blockLight < 1) // if block's light value is too low (dark)'                              continue; // just skip it.                            var propagatedLight = (byte)((blockLight * 9) / 10);                            PropagateLightR(blockIndex + BlockStorage.XStep' propagatedLight); // propagate light to block in east.                          PropagateLightR(blockIndex - BlockStorage.XStep' propagatedLight); // propagate light to block in west.                          PropagateLightR(blockIndex + BlockStorage.ZStep' propagatedLight); // propagate light to block in north.                          PropagateLightR(blockIndex - BlockStorage.ZStep' propagatedLight); // propagate light to block in south.                          // DO NOT repropagete to upper block which we don't need to do so and may cause loops!                          PropagateLightR(blockIndex - 1' propagatedLight);   // propagate light to block down.                      }                  }              }
Magic Number,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,FluidFillLightR,The following statement contains a magic number: for (byte x = 0; x < Chunk.WidthInBlocks; x++)              {                  for (byte z = 0; z < Chunk.LengthInBlocks; z++)                  {                      int offset = BlockStorage.BlockIndexByRelativePosition(chunk' x' z);                        for (byte y = Chunk.MaxHeightIndexInBlocks; y > 0; y--)                      {                          var blockIndex = offset + y;                            if (BlockStorage.Blocks[blockIndex].Type != BlockType.None) // solid blocks can't propagate light.                              continue;                            var blockLight = BlockStorage.Blocks[blockIndex].R;                          if (blockLight < 1) // if block's light value is too low (dark)'                              continue; // just skip it.                            var propagatedLight = (byte)((blockLight * 9) / 10);                            PropagateLightR(blockIndex + BlockStorage.XStep' propagatedLight); // propagate light to block in east.                          PropagateLightR(blockIndex - BlockStorage.XStep' propagatedLight); // propagate light to block in west.                          PropagateLightR(blockIndex + BlockStorage.ZStep' propagatedLight); // propagate light to block in north.                          PropagateLightR(blockIndex - BlockStorage.ZStep' propagatedLight); // propagate light to block in south.                          // DO NOT repropagete to upper block which we don't need to do so and may cause loops!                          PropagateLightR(blockIndex - 1' propagatedLight);   // propagate light to block down.                      }                  }              }
Magic Number,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,PropagateLightR,The following statement contains a magic number: var propagatedLight = (byte)((incomingLight * 9) / 10);
Magic Number,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,PropagateLightR,The following statement contains a magic number: var propagatedLight = (byte)((incomingLight * 9) / 10);
Magic Number,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,FluidFillLightG,The following statement contains a magic number: for (byte x = 0; x < Chunk.WidthInBlocks; x++)              {                  for (byte z = 0; z < Chunk.LengthInBlocks; z++)                  {                      int offset = BlockStorage.BlockIndexByRelativePosition(chunk' x' z);                        for (byte y = Chunk.MaxHeightIndexInBlocks; y > 0; y--)                      {                          var blockIndex = offset + y;                            if (BlockStorage.Blocks[blockIndex].Type != BlockType.None) // solid blocks can't propagate light.                              continue;                            var blockLight = BlockStorage.Blocks[blockIndex].G;                          if (blockLight < 1) // if block's light value is too low (dark)'                              continue; // just skip it.                            var propagatedLight = (byte)((blockLight * 9) / 10);                            PropagateLightG(blockIndex + BlockStorage.XStep' propagatedLight); // propagate light to block in east.                          PropagateLightG(blockIndex - BlockStorage.XStep' propagatedLight); // propagate light to block in west.                          PropagateLightG(blockIndex + BlockStorage.ZStep' propagatedLight); // propagate light to block in north.                          PropagateLightG(blockIndex - BlockStorage.ZStep' propagatedLight); // propagate light to block in south.                          // DO NOT repropagete to upper block which we don't need to do so and may cause loops!                          PropagateLightG(blockIndex - 1' propagatedLight);   // propagate light to block down.                      }                  }              }
Magic Number,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,FluidFillLightG,The following statement contains a magic number: for (byte x = 0; x < Chunk.WidthInBlocks; x++)              {                  for (byte z = 0; z < Chunk.LengthInBlocks; z++)                  {                      int offset = BlockStorage.BlockIndexByRelativePosition(chunk' x' z);                        for (byte y = Chunk.MaxHeightIndexInBlocks; y > 0; y--)                      {                          var blockIndex = offset + y;                            if (BlockStorage.Blocks[blockIndex].Type != BlockType.None) // solid blocks can't propagate light.                              continue;                            var blockLight = BlockStorage.Blocks[blockIndex].G;                          if (blockLight < 1) // if block's light value is too low (dark)'                              continue; // just skip it.                            var propagatedLight = (byte)((blockLight * 9) / 10);                            PropagateLightG(blockIndex + BlockStorage.XStep' propagatedLight); // propagate light to block in east.                          PropagateLightG(blockIndex - BlockStorage.XStep' propagatedLight); // propagate light to block in west.                          PropagateLightG(blockIndex + BlockStorage.ZStep' propagatedLight); // propagate light to block in north.                          PropagateLightG(blockIndex - BlockStorage.ZStep' propagatedLight); // propagate light to block in south.                          // DO NOT repropagete to upper block which we don't need to do so and may cause loops!                          PropagateLightG(blockIndex - 1' propagatedLight);   // propagate light to block down.                      }                  }              }
Magic Number,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,PropagateLightG,The following statement contains a magic number: var propagatedLight = (byte)((incomingLight * 9) / 10);
Magic Number,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,PropagateLightG,The following statement contains a magic number: var propagatedLight = (byte)((incomingLight * 9) / 10);
Magic Number,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,FluidFillLightB,The following statement contains a magic number: for (byte x = 0; x < Chunk.WidthInBlocks; x++)              {                  for (byte z = 0; z < Chunk.LengthInBlocks; z++)                  {                      int offset = BlockStorage.BlockIndexByRelativePosition(chunk' x' z);                        for (byte y = Chunk.MaxHeightIndexInBlocks; y > 0; y--)                      {                          var blockIndex = offset + y;                            if (BlockStorage.Blocks[blockIndex].Type != BlockType.None) // solid blocks can't propagate light.                              continue;                            var blockLight = BlockStorage.Blocks[blockIndex].B;                          if (blockLight < 1) // if block's light value is too low (dark)'                              continue; // just skip it.                            var propagatedLight = (byte)((blockLight * 9) / 10);                            PropagateLightB(blockIndex + BlockStorage.XStep' propagatedLight); // propagate light to block in east.                          PropagateLightB(blockIndex - BlockStorage.XStep' propagatedLight); // propagate light to block in west.                          PropagateLightB(blockIndex + BlockStorage.ZStep' propagatedLight); // propagate light to block in north.                          PropagateLightB(blockIndex - BlockStorage.ZStep' propagatedLight); // propagate light to block in south.                          // DO NOT repropagete to upper block which we don't need to do so and may cause loops!                          PropagateLightB(blockIndex - 1' propagatedLight);   // propagate light to block down.                      }                  }              }
Magic Number,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,FluidFillLightB,The following statement contains a magic number: for (byte x = 0; x < Chunk.WidthInBlocks; x++)              {                  for (byte z = 0; z < Chunk.LengthInBlocks; z++)                  {                      int offset = BlockStorage.BlockIndexByRelativePosition(chunk' x' z);                        for (byte y = Chunk.MaxHeightIndexInBlocks; y > 0; y--)                      {                          var blockIndex = offset + y;                            if (BlockStorage.Blocks[blockIndex].Type != BlockType.None) // solid blocks can't propagate light.                              continue;                            var blockLight = BlockStorage.Blocks[blockIndex].B;                          if (blockLight < 1) // if block's light value is too low (dark)'                              continue; // just skip it.                            var propagatedLight = (byte)((blockLight * 9) / 10);                            PropagateLightB(blockIndex + BlockStorage.XStep' propagatedLight); // propagate light to block in east.                          PropagateLightB(blockIndex - BlockStorage.XStep' propagatedLight); // propagate light to block in west.                          PropagateLightB(blockIndex + BlockStorage.ZStep' propagatedLight); // propagate light to block in north.                          PropagateLightB(blockIndex - BlockStorage.ZStep' propagatedLight); // propagate light to block in south.                          // DO NOT repropagete to upper block which we don't need to do so and may cause loops!                          PropagateLightB(blockIndex - 1' propagatedLight);   // propagate light to block down.                      }                  }              }
Magic Number,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,PropagateLightB,The following statement contains a magic number: var propagatedLight = (byte)((incomingLight * 9) / 10);
Magic Number,Engine.Chunks.Processors,Lightning,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\Lightning.cs,PropagateLightB,The following statement contains a magic number: var propagatedLight = (byte)((incomingLight * 9) / 10);
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidW.Exists && !(block.Type == BlockType.Water && blockMidW.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopW.R + blockMidNW.R + blockMidW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopW.R + blockMidSW.R + blockMidW.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotW.R + blockMidNW.R + blockMidW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotW.R + blockMidSW.R + blockMidW.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopW.G + blockMidNW.G + blockMidW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopW.G + blockMidSW.G + blockMidW.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotW.G + blockMidNW.G + blockMidW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotW.G + blockMidSW.G + blockMidW.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopW.B + blockMidNW.B + blockMidW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopW.B + blockMidSW.B + blockMidW.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotW.B + blockMidNW.B + blockMidW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotW.B + blockMidSW.B + blockMidW.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidW.Exists && !(block.Type == BlockType.Water && blockMidW.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopW.R + blockMidNW.R + blockMidW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopW.R + blockMidSW.R + blockMidW.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotW.R + blockMidNW.R + blockMidW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotW.R + blockMidSW.R + blockMidW.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopW.G + blockMidNW.G + blockMidW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopW.G + blockMidSW.G + blockMidW.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotW.G + blockMidNW.G + blockMidW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotW.G + blockMidSW.G + blockMidW.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopW.B + blockMidNW.B + blockMidW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopW.B + blockMidSW.B + blockMidW.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotW.B + blockMidNW.B + blockMidW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotW.B + blockMidSW.B + blockMidW.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidW.Exists && !(block.Type == BlockType.Water && blockMidW.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopW.R + blockMidNW.R + blockMidW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopW.R + blockMidSW.R + blockMidW.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotW.R + blockMidNW.R + blockMidW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotW.R + blockMidSW.R + blockMidW.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopW.G + blockMidNW.G + blockMidW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopW.G + blockMidSW.G + blockMidW.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotW.G + blockMidNW.G + blockMidW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotW.G + blockMidSW.G + blockMidW.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopW.B + blockMidNW.B + blockMidW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopW.B + blockMidSW.B + blockMidW.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotW.B + blockMidNW.B + blockMidW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotW.B + blockMidSW.B + blockMidW.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidW.Exists && !(block.Type == BlockType.Water && blockMidW.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopW.R + blockMidNW.R + blockMidW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopW.R + blockMidSW.R + blockMidW.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotW.R + blockMidNW.R + blockMidW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotW.R + blockMidSW.R + blockMidW.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopW.G + blockMidNW.G + blockMidW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopW.G + blockMidSW.G + blockMidW.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotW.G + blockMidNW.G + blockMidW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotW.G + blockMidSW.G + blockMidW.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopW.B + blockMidNW.B + blockMidW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopW.B + blockMidSW.B + blockMidW.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotW.B + blockMidNW.B + blockMidW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotW.B + blockMidSW.B + blockMidW.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidW.Exists && !(block.Type == BlockType.Water && blockMidW.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopW.R + blockMidNW.R + blockMidW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopW.R + blockMidSW.R + blockMidW.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotW.R + blockMidNW.R + blockMidW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotW.R + blockMidSW.R + blockMidW.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopW.G + blockMidNW.G + blockMidW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopW.G + blockMidSW.G + blockMidW.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotW.G + blockMidNW.G + blockMidW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotW.G + blockMidSW.G + blockMidW.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopW.B + blockMidNW.B + blockMidW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopW.B + blockMidSW.B + blockMidW.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotW.B + blockMidNW.B + blockMidW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotW.B + blockMidSW.B + blockMidW.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidW.Exists && !(block.Type == BlockType.Water && blockMidW.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopW.R + blockMidNW.R + blockMidW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopW.R + blockMidSW.R + blockMidW.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotW.R + blockMidNW.R + blockMidW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotW.R + blockMidSW.R + blockMidW.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopW.G + blockMidNW.G + blockMidW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopW.G + blockMidSW.G + blockMidW.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotW.G + blockMidNW.G + blockMidW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotW.G + blockMidSW.G + blockMidW.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopW.B + blockMidNW.B + blockMidW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopW.B + blockMidSW.B + blockMidW.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotW.B + blockMidNW.B + blockMidW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotW.B + blockMidSW.B + blockMidW.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidW.Exists && !(block.Type == BlockType.Water && blockMidW.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopW.R + blockMidNW.R + blockMidW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopW.R + blockMidSW.R + blockMidW.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotW.R + blockMidNW.R + blockMidW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotW.R + blockMidSW.R + blockMidW.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopW.G + blockMidNW.G + blockMidW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopW.G + blockMidSW.G + blockMidW.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotW.G + blockMidNW.G + blockMidW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotW.G + blockMidSW.G + blockMidW.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopW.B + blockMidNW.B + blockMidW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopW.B + blockMidSW.B + blockMidW.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotW.B + blockMidNW.B + blockMidW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotW.B + blockMidSW.B + blockMidW.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidW.Exists && !(block.Type == BlockType.Water && blockMidW.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopW.R + blockMidNW.R + blockMidW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopW.R + blockMidSW.R + blockMidW.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotW.R + blockMidNW.R + blockMidW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotW.R + blockMidSW.R + blockMidW.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopW.G + blockMidNW.G + blockMidW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopW.G + blockMidSW.G + blockMidW.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotW.G + blockMidNW.G + blockMidW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotW.G + blockMidSW.G + blockMidW.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopW.B + blockMidNW.B + blockMidW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopW.B + blockMidSW.B + blockMidW.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotW.B + blockMidNW.B + blockMidW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotW.B + blockMidSW.B + blockMidW.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidW.Exists && !(block.Type == BlockType.Water && blockMidW.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopW.R + blockMidNW.R + blockMidW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopW.R + blockMidSW.R + blockMidW.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotW.R + blockMidNW.R + blockMidW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotW.R + blockMidSW.R + blockMidW.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopW.G + blockMidNW.G + blockMidW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopW.G + blockMidSW.G + blockMidW.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotW.G + blockMidNW.G + blockMidW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotW.G + blockMidSW.G + blockMidW.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopW.B + blockMidNW.B + blockMidW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopW.B + blockMidSW.B + blockMidW.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotW.B + blockMidNW.B + blockMidW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotW.B + blockMidSW.B + blockMidW.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidW.Exists && !(block.Type == BlockType.Water && blockMidW.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopW.R + blockMidNW.R + blockMidW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopW.R + blockMidSW.R + blockMidW.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotW.R + blockMidNW.R + blockMidW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotW.R + blockMidSW.R + blockMidW.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopW.G + blockMidNW.G + blockMidW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopW.G + blockMidSW.G + blockMidW.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotW.G + blockMidNW.G + blockMidW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotW.G + blockMidSW.G + blockMidW.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopW.B + blockMidNW.B + blockMidW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopW.B + blockMidSW.B + blockMidW.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotW.B + blockMidNW.B + blockMidW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotW.B + blockMidSW.B + blockMidW.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidW.Exists && !(block.Type == BlockType.Water && blockMidW.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopW.R + blockMidNW.R + blockMidW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopW.R + blockMidSW.R + blockMidW.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotW.R + blockMidNW.R + blockMidW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotW.R + blockMidSW.R + blockMidW.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopW.G + blockMidNW.G + blockMidW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopW.G + blockMidSW.G + blockMidW.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotW.G + blockMidNW.G + blockMidW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotW.G + blockMidSW.G + blockMidW.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopW.B + blockMidNW.B + blockMidW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopW.B + blockMidSW.B + blockMidW.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotW.B + blockMidNW.B + blockMidW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotW.B + blockMidSW.B + blockMidW.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidW.Exists && !(block.Type == BlockType.Water && blockMidW.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopW.R + blockMidNW.R + blockMidW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopW.R + blockMidSW.R + blockMidW.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotW.R + blockMidNW.R + blockMidW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotW.R + blockMidSW.R + blockMidW.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopW.G + blockMidNW.G + blockMidW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopW.G + blockMidSW.G + blockMidW.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotW.G + blockMidNW.G + blockMidW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotW.G + blockMidSW.G + blockMidW.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopW.B + blockMidNW.B + blockMidW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopW.B + blockMidSW.B + blockMidW.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotW.B + blockMidNW.B + blockMidW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotW.B + blockMidSW.B + blockMidW.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidW.Exists && !(block.Type == BlockType.Water && blockMidW.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopW.R + blockMidNW.R + blockMidW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopW.R + blockMidSW.R + blockMidW.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotW.R + blockMidNW.R + blockMidW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotW.R + blockMidSW.R + blockMidW.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopW.G + blockMidNW.G + blockMidW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopW.G + blockMidSW.G + blockMidW.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotW.G + blockMidNW.G + blockMidW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotW.G + blockMidSW.G + blockMidW.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopW.B + blockMidNW.B + blockMidW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopW.B + blockMidSW.B + blockMidW.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotW.B + blockMidNW.B + blockMidW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotW.B + blockMidSW.B + blockMidW.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidW.Exists && !(block.Type == BlockType.Water && blockMidW.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopW.R + blockMidNW.R + blockMidW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopW.R + blockMidSW.R + blockMidW.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotW.R + blockMidNW.R + blockMidW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotW.R + blockMidSW.R + blockMidW.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopW.G + blockMidNW.G + blockMidW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopW.G + blockMidSW.G + blockMidW.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotW.G + blockMidNW.G + blockMidW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotW.G + blockMidSW.G + blockMidW.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopW.B + blockMidNW.B + blockMidW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopW.B + blockMidSW.B + blockMidW.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotW.B + blockMidNW.B + blockMidW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotW.B + blockMidSW.B + blockMidW.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidW.Exists && !(block.Type == BlockType.Water && blockMidW.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopW.R + blockMidNW.R + blockMidW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopW.R + blockMidSW.R + blockMidW.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotW.R + blockMidNW.R + blockMidW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotW.R + blockMidSW.R + blockMidW.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopW.G + blockMidNW.G + blockMidW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopW.G + blockMidSW.G + blockMidW.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotW.G + blockMidNW.G + blockMidW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotW.G + blockMidSW.G + blockMidW.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopW.B + blockMidNW.B + blockMidW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopW.B + blockMidSW.B + blockMidW.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotW.B + blockMidNW.B + blockMidW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotW.B + blockMidSW.B + blockMidW.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidW.Exists && !(block.Type == BlockType.Water && blockMidW.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotW.Sun + blockMidNW.Sun + blockMidW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotW.Sun + blockMidSW.Sun + blockMidW.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopW.R + blockMidNW.R + blockMidW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopW.R + blockMidSW.R + blockMidW.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotW.R + blockMidNW.R + blockMidW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotW.R + blockMidSW.R + blockMidW.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopW.G + blockMidNW.G + blockMidW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopW.G + blockMidSW.G + blockMidW.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotW.G + blockMidNW.G + blockMidW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotW.G + blockMidSW.G + blockMidW.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopW.B + blockMidNW.B + blockMidW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopW.B + blockMidSW.B + blockMidW.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotW.B + blockMidNW.B + blockMidW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotW.B + blockMidSW.B + blockMidW.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidE.Exists && !(block.Type == BlockType.Water && blockMidE.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopE.R + blockMidSE.R + blockMidE.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopE.R + blockMidNE.R + blockMidE.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotE.R + blockMidSE.R + blockMidE.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotE.R + blockMidNE.R + blockMidE.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopE.G + blockMidSE.G + blockMidE.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopE.G + blockMidNE.G + blockMidE.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotE.G + blockMidSE.G + blockMidE.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotE.G + blockMidNE.G + blockMidE.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopE.B + blockMidSE.B + blockMidE.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopE.B + blockMidNE.B + blockMidE.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotE.B + blockMidSE.B + blockMidE.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotE.B + blockMidNE.B + blockMidE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidE.Exists && !(block.Type == BlockType.Water && blockMidE.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopE.R + blockMidSE.R + blockMidE.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopE.R + blockMidNE.R + blockMidE.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotE.R + blockMidSE.R + blockMidE.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotE.R + blockMidNE.R + blockMidE.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopE.G + blockMidSE.G + blockMidE.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopE.G + blockMidNE.G + blockMidE.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotE.G + blockMidSE.G + blockMidE.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotE.G + blockMidNE.G + blockMidE.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopE.B + blockMidSE.B + blockMidE.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopE.B + blockMidNE.B + blockMidE.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotE.B + blockMidSE.B + blockMidE.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotE.B + blockMidNE.B + blockMidE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidE.Exists && !(block.Type == BlockType.Water && blockMidE.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopE.R + blockMidSE.R + blockMidE.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopE.R + blockMidNE.R + blockMidE.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotE.R + blockMidSE.R + blockMidE.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotE.R + blockMidNE.R + blockMidE.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopE.G + blockMidSE.G + blockMidE.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopE.G + blockMidNE.G + blockMidE.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotE.G + blockMidSE.G + blockMidE.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotE.G + blockMidNE.G + blockMidE.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopE.B + blockMidSE.B + blockMidE.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopE.B + blockMidNE.B + blockMidE.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotE.B + blockMidSE.B + blockMidE.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotE.B + blockMidNE.B + blockMidE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidE.Exists && !(block.Type == BlockType.Water && blockMidE.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopE.R + blockMidSE.R + blockMidE.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopE.R + blockMidNE.R + blockMidE.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotE.R + blockMidSE.R + blockMidE.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotE.R + blockMidNE.R + blockMidE.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopE.G + blockMidSE.G + blockMidE.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopE.G + blockMidNE.G + blockMidE.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotE.G + blockMidSE.G + blockMidE.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotE.G + blockMidNE.G + blockMidE.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopE.B + blockMidSE.B + blockMidE.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopE.B + blockMidNE.B + blockMidE.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotE.B + blockMidSE.B + blockMidE.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotE.B + blockMidNE.B + blockMidE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidE.Exists && !(block.Type == BlockType.Water && blockMidE.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopE.R + blockMidSE.R + blockMidE.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopE.R + blockMidNE.R + blockMidE.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotE.R + blockMidSE.R + blockMidE.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotE.R + blockMidNE.R + blockMidE.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopE.G + blockMidSE.G + blockMidE.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopE.G + blockMidNE.G + blockMidE.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotE.G + blockMidSE.G + blockMidE.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotE.G + blockMidNE.G + blockMidE.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopE.B + blockMidSE.B + blockMidE.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopE.B + blockMidNE.B + blockMidE.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotE.B + blockMidSE.B + blockMidE.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotE.B + blockMidNE.B + blockMidE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidE.Exists && !(block.Type == BlockType.Water && blockMidE.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopE.R + blockMidSE.R + blockMidE.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopE.R + blockMidNE.R + blockMidE.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotE.R + blockMidSE.R + blockMidE.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotE.R + blockMidNE.R + blockMidE.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopE.G + blockMidSE.G + blockMidE.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopE.G + blockMidNE.G + blockMidE.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotE.G + blockMidSE.G + blockMidE.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotE.G + blockMidNE.G + blockMidE.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopE.B + blockMidSE.B + blockMidE.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopE.B + blockMidNE.B + blockMidE.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotE.B + blockMidSE.B + blockMidE.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotE.B + blockMidNE.B + blockMidE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidE.Exists && !(block.Type == BlockType.Water && blockMidE.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopE.R + blockMidSE.R + blockMidE.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopE.R + blockMidNE.R + blockMidE.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotE.R + blockMidSE.R + blockMidE.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotE.R + blockMidNE.R + blockMidE.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopE.G + blockMidSE.G + blockMidE.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopE.G + blockMidNE.G + blockMidE.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotE.G + blockMidSE.G + blockMidE.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotE.G + blockMidNE.G + blockMidE.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopE.B + blockMidSE.B + blockMidE.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopE.B + blockMidNE.B + blockMidE.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotE.B + blockMidSE.B + blockMidE.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotE.B + blockMidNE.B + blockMidE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidE.Exists && !(block.Type == BlockType.Water && blockMidE.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopE.R + blockMidSE.R + blockMidE.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopE.R + blockMidNE.R + blockMidE.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotE.R + blockMidSE.R + blockMidE.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotE.R + blockMidNE.R + blockMidE.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopE.G + blockMidSE.G + blockMidE.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopE.G + blockMidNE.G + blockMidE.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotE.G + blockMidSE.G + blockMidE.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotE.G + blockMidNE.G + blockMidE.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopE.B + blockMidSE.B + blockMidE.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopE.B + blockMidNE.B + blockMidE.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotE.B + blockMidSE.B + blockMidE.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotE.B + blockMidNE.B + blockMidE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidE.Exists && !(block.Type == BlockType.Water && blockMidE.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopE.R + blockMidSE.R + blockMidE.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopE.R + blockMidNE.R + blockMidE.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotE.R + blockMidSE.R + blockMidE.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotE.R + blockMidNE.R + blockMidE.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopE.G + blockMidSE.G + blockMidE.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopE.G + blockMidNE.G + blockMidE.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotE.G + blockMidSE.G + blockMidE.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotE.G + blockMidNE.G + blockMidE.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopE.B + blockMidSE.B + blockMidE.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopE.B + blockMidNE.B + blockMidE.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotE.B + blockMidSE.B + blockMidE.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotE.B + blockMidNE.B + blockMidE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidE.Exists && !(block.Type == BlockType.Water && blockMidE.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopE.R + blockMidSE.R + blockMidE.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopE.R + blockMidNE.R + blockMidE.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotE.R + blockMidSE.R + blockMidE.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotE.R + blockMidNE.R + blockMidE.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopE.G + blockMidSE.G + blockMidE.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopE.G + blockMidNE.G + blockMidE.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotE.G + blockMidSE.G + blockMidE.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotE.G + blockMidNE.G + blockMidE.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopE.B + blockMidSE.B + blockMidE.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopE.B + blockMidNE.B + blockMidE.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotE.B + blockMidSE.B + blockMidE.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotE.B + blockMidNE.B + blockMidE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidE.Exists && !(block.Type == BlockType.Water && blockMidE.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopE.R + blockMidSE.R + blockMidE.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopE.R + blockMidNE.R + blockMidE.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotE.R + blockMidSE.R + blockMidE.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotE.R + blockMidNE.R + blockMidE.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopE.G + blockMidSE.G + blockMidE.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopE.G + blockMidNE.G + blockMidE.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotE.G + blockMidSE.G + blockMidE.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotE.G + blockMidNE.G + blockMidE.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopE.B + blockMidSE.B + blockMidE.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopE.B + blockMidNE.B + blockMidE.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotE.B + blockMidSE.B + blockMidE.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotE.B + blockMidNE.B + blockMidE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidE.Exists && !(block.Type == BlockType.Water && blockMidE.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopE.R + blockMidSE.R + blockMidE.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopE.R + blockMidNE.R + blockMidE.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotE.R + blockMidSE.R + blockMidE.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotE.R + blockMidNE.R + blockMidE.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopE.G + blockMidSE.G + blockMidE.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopE.G + blockMidNE.G + blockMidE.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotE.G + blockMidSE.G + blockMidE.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotE.G + blockMidNE.G + blockMidE.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopE.B + blockMidSE.B + blockMidE.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopE.B + blockMidNE.B + blockMidE.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotE.B + blockMidSE.B + blockMidE.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotE.B + blockMidNE.B + blockMidE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidE.Exists && !(block.Type == BlockType.Water && blockMidE.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopE.R + blockMidSE.R + blockMidE.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopE.R + blockMidNE.R + blockMidE.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotE.R + blockMidSE.R + blockMidE.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotE.R + blockMidNE.R + blockMidE.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopE.G + blockMidSE.G + blockMidE.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopE.G + blockMidNE.G + blockMidE.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotE.G + blockMidSE.G + blockMidE.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotE.G + blockMidNE.G + blockMidE.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopE.B + blockMidSE.B + blockMidE.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopE.B + blockMidNE.B + blockMidE.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotE.B + blockMidSE.B + blockMidE.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotE.B + blockMidNE.B + blockMidE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidE.Exists && !(block.Type == BlockType.Water && blockMidE.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopE.R + blockMidSE.R + blockMidE.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopE.R + blockMidNE.R + blockMidE.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotE.R + blockMidSE.R + blockMidE.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotE.R + blockMidNE.R + blockMidE.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopE.G + blockMidSE.G + blockMidE.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopE.G + blockMidNE.G + blockMidE.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotE.G + blockMidSE.G + blockMidE.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotE.G + blockMidNE.G + blockMidE.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopE.B + blockMidSE.B + blockMidE.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopE.B + blockMidNE.B + blockMidE.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotE.B + blockMidSE.B + blockMidE.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotE.B + blockMidNE.B + blockMidE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidE.Exists && !(block.Type == BlockType.Water && blockMidE.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopE.R + blockMidSE.R + blockMidE.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopE.R + blockMidNE.R + blockMidE.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotE.R + blockMidSE.R + blockMidE.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotE.R + blockMidNE.R + blockMidE.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopE.G + blockMidSE.G + blockMidE.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopE.G + blockMidNE.G + blockMidE.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotE.G + blockMidSE.G + blockMidE.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotE.G + blockMidNE.G + blockMidE.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopE.B + blockMidSE.B + blockMidE.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopE.B + blockMidNE.B + blockMidE.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotE.B + blockMidSE.B + blockMidE.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotE.B + blockMidNE.B + blockMidE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidE.Exists && !(block.Type == BlockType.Water && blockMidE.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotE.Sun + blockMidSE.Sun + blockMidE.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotE.Sun + blockMidNE.Sun + blockMidE.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopE.R + blockMidSE.R + blockMidE.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopE.R + blockMidNE.R + blockMidE.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotE.R + blockMidSE.R + blockMidE.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotE.R + blockMidNE.R + blockMidE.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopE.G + blockMidSE.G + blockMidE.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopE.G + blockMidNE.G + blockMidE.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotE.G + blockMidSE.G + blockMidE.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotE.G + blockMidNE.G + blockMidE.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopE.B + blockMidSE.B + blockMidE.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopE.B + blockMidNE.B + blockMidE.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotE.B + blockMidSE.B + blockMidE.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotE.B + blockMidNE.B + blockMidE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.XIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockBotM.Exists && !(block.Type == BlockType.Water && blockBotM.Type == BlockType.Water))              {                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockBotM.Sun + blockTopE.Sun)/4);                  sunTL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockBotM.Sun + blockTopE.Sun)/4);                    redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockBotM.R + blockTopW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockBotM.R + blockTopE.R)/4);                  redTL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockBotM.R + blockTopW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockBotM.R + blockTopE.R)/4);                    grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockBotM.G + blockTopW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockBotM.G + blockTopE.G)/4);                  grnTL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockBotM.G + blockTopW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockBotM.G + blockTopE.G)/4);                    bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockBotM.B + blockTopW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockBotM.B + blockTopE.B)/4);                  bluTL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockBotM.B + blockTopW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockBotM.B + blockTopE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockBotM.Exists && !(block.Type == BlockType.Water && blockBotM.Type == BlockType.Water))              {                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockBotM.Sun + blockTopE.Sun)/4);                  sunTL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockBotM.Sun + blockTopE.Sun)/4);                    redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockBotM.R + blockTopW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockBotM.R + blockTopE.R)/4);                  redTL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockBotM.R + blockTopW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockBotM.R + blockTopE.R)/4);                    grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockBotM.G + blockTopW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockBotM.G + blockTopE.G)/4);                  grnTL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockBotM.G + blockTopW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockBotM.G + blockTopE.G)/4);                    bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockBotM.B + blockTopW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockBotM.B + blockTopE.B)/4);                  bluTL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockBotM.B + blockTopW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockBotM.B + blockTopE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockBotM.Exists && !(block.Type == BlockType.Water && blockBotM.Type == BlockType.Water))              {                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockBotM.Sun + blockTopE.Sun)/4);                  sunTL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockBotM.Sun + blockTopE.Sun)/4);                    redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockBotM.R + blockTopW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockBotM.R + blockTopE.R)/4);                  redTL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockBotM.R + blockTopW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockBotM.R + blockTopE.R)/4);                    grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockBotM.G + blockTopW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockBotM.G + blockTopE.G)/4);                  grnTL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockBotM.G + blockTopW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockBotM.G + blockTopE.G)/4);                    bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockBotM.B + blockTopW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockBotM.B + blockTopE.B)/4);                  bluTL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockBotM.B + blockTopW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockBotM.B + blockTopE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockBotM.Exists && !(block.Type == BlockType.Water && blockBotM.Type == BlockType.Water))              {                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockBotM.Sun + blockTopE.Sun)/4);                  sunTL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockBotM.Sun + blockTopE.Sun)/4);                    redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockBotM.R + blockTopW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockBotM.R + blockTopE.R)/4);                  redTL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockBotM.R + blockTopW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockBotM.R + blockTopE.R)/4);                    grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockBotM.G + blockTopW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockBotM.G + blockTopE.G)/4);                  grnTL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockBotM.G + blockTopW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockBotM.G + blockTopE.G)/4);                    bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockBotM.B + blockTopW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockBotM.B + blockTopE.B)/4);                  bluTL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockBotM.B + blockTopW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockBotM.B + blockTopE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockBotM.Exists && !(block.Type == BlockType.Water && blockBotM.Type == BlockType.Water))              {                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockBotM.Sun + blockTopE.Sun)/4);                  sunTL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockBotM.Sun + blockTopE.Sun)/4);                    redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockBotM.R + blockTopW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockBotM.R + blockTopE.R)/4);                  redTL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockBotM.R + blockTopW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockBotM.R + blockTopE.R)/4);                    grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockBotM.G + blockTopW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockBotM.G + blockTopE.G)/4);                  grnTL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockBotM.G + blockTopW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockBotM.G + blockTopE.G)/4);                    bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockBotM.B + blockTopW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockBotM.B + blockTopE.B)/4);                  bluTL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockBotM.B + blockTopW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockBotM.B + blockTopE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockBotM.Exists && !(block.Type == BlockType.Water && blockBotM.Type == BlockType.Water))              {                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockBotM.Sun + blockTopE.Sun)/4);                  sunTL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockBotM.Sun + blockTopE.Sun)/4);                    redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockBotM.R + blockTopW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockBotM.R + blockTopE.R)/4);                  redTL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockBotM.R + blockTopW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockBotM.R + blockTopE.R)/4);                    grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockBotM.G + blockTopW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockBotM.G + blockTopE.G)/4);                  grnTL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockBotM.G + blockTopW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockBotM.G + blockTopE.G)/4);                    bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockBotM.B + blockTopW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockBotM.B + blockTopE.B)/4);                  bluTL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockBotM.B + blockTopW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockBotM.B + blockTopE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockBotM.Exists && !(block.Type == BlockType.Water && blockBotM.Type == BlockType.Water))              {                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockBotM.Sun + blockTopE.Sun)/4);                  sunTL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockBotM.Sun + blockTopE.Sun)/4);                    redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockBotM.R + blockTopW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockBotM.R + blockTopE.R)/4);                  redTL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockBotM.R + blockTopW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockBotM.R + blockTopE.R)/4);                    grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockBotM.G + blockTopW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockBotM.G + blockTopE.G)/4);                  grnTL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockBotM.G + blockTopW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockBotM.G + blockTopE.G)/4);                    bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockBotM.B + blockTopW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockBotM.B + blockTopE.B)/4);                  bluTL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockBotM.B + blockTopW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockBotM.B + blockTopE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockBotM.Exists && !(block.Type == BlockType.Water && blockBotM.Type == BlockType.Water))              {                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockBotM.Sun + blockTopE.Sun)/4);                  sunTL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockBotM.Sun + blockTopE.Sun)/4);                    redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockBotM.R + blockTopW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockBotM.R + blockTopE.R)/4);                  redTL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockBotM.R + blockTopW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockBotM.R + blockTopE.R)/4);                    grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockBotM.G + blockTopW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockBotM.G + blockTopE.G)/4);                  grnTL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockBotM.G + blockTopW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockBotM.G + blockTopE.G)/4);                    bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockBotM.B + blockTopW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockBotM.B + blockTopE.B)/4);                  bluTL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockBotM.B + blockTopW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockBotM.B + blockTopE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockBotM.Exists && !(block.Type == BlockType.Water && blockBotM.Type == BlockType.Water))              {                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockBotM.Sun + blockTopE.Sun)/4);                  sunTL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockBotM.Sun + blockTopE.Sun)/4);                    redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockBotM.R + blockTopW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockBotM.R + blockTopE.R)/4);                  redTL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockBotM.R + blockTopW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockBotM.R + blockTopE.R)/4);                    grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockBotM.G + blockTopW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockBotM.G + blockTopE.G)/4);                  grnTL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockBotM.G + blockTopW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockBotM.G + blockTopE.G)/4);                    bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockBotM.B + blockTopW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockBotM.B + blockTopE.B)/4);                  bluTL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockBotM.B + blockTopW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockBotM.B + blockTopE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockBotM.Exists && !(block.Type == BlockType.Water && blockBotM.Type == BlockType.Water))              {                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockBotM.Sun + blockTopE.Sun)/4);                  sunTL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockBotM.Sun + blockTopE.Sun)/4);                    redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockBotM.R + blockTopW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockBotM.R + blockTopE.R)/4);                  redTL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockBotM.R + blockTopW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockBotM.R + blockTopE.R)/4);                    grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockBotM.G + blockTopW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockBotM.G + blockTopE.G)/4);                  grnTL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockBotM.G + blockTopW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockBotM.G + blockTopE.G)/4);                    bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockBotM.B + blockTopW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockBotM.B + blockTopE.B)/4);                  bluTL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockBotM.B + blockTopW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockBotM.B + blockTopE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockBotM.Exists && !(block.Type == BlockType.Water && blockBotM.Type == BlockType.Water))              {                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockBotM.Sun + blockTopE.Sun)/4);                  sunTL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockBotM.Sun + blockTopE.Sun)/4);                    redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockBotM.R + blockTopW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockBotM.R + blockTopE.R)/4);                  redTL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockBotM.R + blockTopW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockBotM.R + blockTopE.R)/4);                    grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockBotM.G + blockTopW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockBotM.G + blockTopE.G)/4);                  grnTL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockBotM.G + blockTopW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockBotM.G + blockTopE.G)/4);                    bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockBotM.B + blockTopW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockBotM.B + blockTopE.B)/4);                  bluTL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockBotM.B + blockTopW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockBotM.B + blockTopE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockBotM.Exists && !(block.Type == BlockType.Water && blockBotM.Type == BlockType.Water))              {                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockBotM.Sun + blockTopE.Sun)/4);                  sunTL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockBotM.Sun + blockTopE.Sun)/4);                    redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockBotM.R + blockTopW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockBotM.R + blockTopE.R)/4);                  redTL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockBotM.R + blockTopW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockBotM.R + blockTopE.R)/4);                    grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockBotM.G + blockTopW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockBotM.G + blockTopE.G)/4);                  grnTL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockBotM.G + blockTopW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockBotM.G + blockTopE.G)/4);                    bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockBotM.B + blockTopW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockBotM.B + blockTopE.B)/4);                  bluTL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockBotM.B + blockTopW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockBotM.B + blockTopE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockBotM.Exists && !(block.Type == BlockType.Water && blockBotM.Type == BlockType.Water))              {                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockBotM.Sun + blockTopE.Sun)/4);                  sunTL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockBotM.Sun + blockTopE.Sun)/4);                    redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockBotM.R + blockTopW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockBotM.R + blockTopE.R)/4);                  redTL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockBotM.R + blockTopW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockBotM.R + blockTopE.R)/4);                    grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockBotM.G + blockTopW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockBotM.G + blockTopE.G)/4);                  grnTL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockBotM.G + blockTopW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockBotM.G + blockTopE.G)/4);                    bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockBotM.B + blockTopW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockBotM.B + blockTopE.B)/4);                  bluTL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockBotM.B + blockTopW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockBotM.B + blockTopE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockBotM.Exists && !(block.Type == BlockType.Water && blockBotM.Type == BlockType.Water))              {                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockBotM.Sun + blockTopE.Sun)/4);                  sunTL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockBotM.Sun + blockTopE.Sun)/4);                    redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockBotM.R + blockTopW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockBotM.R + blockTopE.R)/4);                  redTL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockBotM.R + blockTopW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockBotM.R + blockTopE.R)/4);                    grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockBotM.G + blockTopW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockBotM.G + blockTopE.G)/4);                  grnTL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockBotM.G + blockTopW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockBotM.G + blockTopE.G)/4);                    bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockBotM.B + blockTopW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockBotM.B + blockTopE.B)/4);                  bluTL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockBotM.B + blockTopW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockBotM.B + blockTopE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockBotM.Exists && !(block.Type == BlockType.Water && blockBotM.Type == BlockType.Water))              {                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockBotM.Sun + blockTopE.Sun)/4);                  sunTL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockBotM.Sun + blockTopE.Sun)/4);                    redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockBotM.R + blockTopW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockBotM.R + blockTopE.R)/4);                  redTL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockBotM.R + blockTopW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockBotM.R + blockTopE.R)/4);                    grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockBotM.G + blockTopW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockBotM.G + blockTopE.G)/4);                  grnTL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockBotM.G + blockTopW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockBotM.G + blockTopE.G)/4);                    bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockBotM.B + blockTopW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockBotM.B + blockTopE.B)/4);                  bluTL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockBotM.B + blockTopW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockBotM.B + blockTopE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockBotM.Exists && !(block.Type == BlockType.Water && blockBotM.Type == BlockType.Water))              {                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockBotM.Sun + blockTopE.Sun)/4);                  sunTL = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockBotM.Sun + blockTopW.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockBotM.Sun + blockTopE.Sun)/4);                    redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockBotM.R + blockTopW.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockBotM.R + blockTopE.R)/4);                  redTL = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockBotM.R + blockTopW.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockBotM.R + blockTopE.R)/4);                    grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockBotM.G + blockTopW.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockBotM.G + blockTopE.G)/4);                  grnTL = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockBotM.G + blockTopW.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockBotM.G + blockTopE.G)/4);                    bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockBotM.B + blockTopW.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockBotM.B + blockTopE.B)/4);                  bluTL = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockBotM.B + blockTopW.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockBotM.B + blockTopE.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockTopM.Exists && !(block.Type == BlockType.Water && blockTopM.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockTopE.Sun + blockTopM.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockTopE.Sun + blockTopM.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockTopW.R + blockTopM.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockTopE.R + blockTopM.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockTopW.R + blockTopM.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockTopE.R + blockTopM.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockTopW.G + blockTopM.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockTopE.G + blockTopM.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockTopW.G + blockTopM.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockTopE.G + blockTopM.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockTopW.B + blockTopM.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockTopE.B + blockTopM.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockTopW.B + blockTopM.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockTopE.B + blockTopM.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockTopM.Exists && !(block.Type == BlockType.Water && blockTopM.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockTopE.Sun + blockTopM.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockTopE.Sun + blockTopM.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockTopW.R + blockTopM.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockTopE.R + blockTopM.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockTopW.R + blockTopM.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockTopE.R + blockTopM.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockTopW.G + blockTopM.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockTopE.G + blockTopM.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockTopW.G + blockTopM.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockTopE.G + blockTopM.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockTopW.B + blockTopM.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockTopE.B + blockTopM.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockTopW.B + blockTopM.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockTopE.B + blockTopM.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockTopM.Exists && !(block.Type == BlockType.Water && blockTopM.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockTopE.Sun + blockTopM.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockTopE.Sun + blockTopM.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockTopW.R + blockTopM.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockTopE.R + blockTopM.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockTopW.R + blockTopM.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockTopE.R + blockTopM.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockTopW.G + blockTopM.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockTopE.G + blockTopM.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockTopW.G + blockTopM.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockTopE.G + blockTopM.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockTopW.B + blockTopM.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockTopE.B + blockTopM.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockTopW.B + blockTopM.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockTopE.B + blockTopM.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockTopM.Exists && !(block.Type == BlockType.Water && blockTopM.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockTopE.Sun + blockTopM.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockTopE.Sun + blockTopM.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockTopW.R + blockTopM.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockTopE.R + blockTopM.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockTopW.R + blockTopM.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockTopE.R + blockTopM.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockTopW.G + blockTopM.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockTopE.G + blockTopM.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockTopW.G + blockTopM.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockTopE.G + blockTopM.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockTopW.B + blockTopM.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockTopE.B + blockTopM.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockTopW.B + blockTopM.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockTopE.B + blockTopM.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockTopM.Exists && !(block.Type == BlockType.Water && blockTopM.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockTopE.Sun + blockTopM.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockTopE.Sun + blockTopM.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockTopW.R + blockTopM.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockTopE.R + blockTopM.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockTopW.R + blockTopM.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockTopE.R + blockTopM.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockTopW.G + blockTopM.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockTopE.G + blockTopM.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockTopW.G + blockTopM.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockTopE.G + blockTopM.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockTopW.B + blockTopM.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockTopE.B + blockTopM.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockTopW.B + blockTopM.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockTopE.B + blockTopM.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockTopM.Exists && !(block.Type == BlockType.Water && blockTopM.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockTopE.Sun + blockTopM.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockTopE.Sun + blockTopM.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockTopW.R + blockTopM.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockTopE.R + blockTopM.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockTopW.R + blockTopM.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockTopE.R + blockTopM.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockTopW.G + blockTopM.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockTopE.G + blockTopM.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockTopW.G + blockTopM.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockTopE.G + blockTopM.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockTopW.B + blockTopM.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockTopE.B + blockTopM.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockTopW.B + blockTopM.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockTopE.B + blockTopM.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockTopM.Exists && !(block.Type == BlockType.Water && blockTopM.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockTopE.Sun + blockTopM.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockTopE.Sun + blockTopM.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockTopW.R + blockTopM.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockTopE.R + blockTopM.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockTopW.R + blockTopM.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockTopE.R + blockTopM.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockTopW.G + blockTopM.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockTopE.G + blockTopM.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockTopW.G + blockTopM.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockTopE.G + blockTopM.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockTopW.B + blockTopM.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockTopE.B + blockTopM.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockTopW.B + blockTopM.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockTopE.B + blockTopM.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockTopM.Exists && !(block.Type == BlockType.Water && blockTopM.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockTopE.Sun + blockTopM.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockTopE.Sun + blockTopM.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockTopW.R + blockTopM.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockTopE.R + blockTopM.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockTopW.R + blockTopM.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockTopE.R + blockTopM.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockTopW.G + blockTopM.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockTopE.G + blockTopM.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockTopW.G + blockTopM.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockTopE.G + blockTopM.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockTopW.B + blockTopM.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockTopE.B + blockTopM.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockTopW.B + blockTopM.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockTopE.B + blockTopM.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockTopM.Exists && !(block.Type == BlockType.Water && blockTopM.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockTopE.Sun + blockTopM.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockTopE.Sun + blockTopM.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockTopW.R + blockTopM.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockTopE.R + blockTopM.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockTopW.R + blockTopM.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockTopE.R + blockTopM.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockTopW.G + blockTopM.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockTopE.G + blockTopM.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockTopW.G + blockTopM.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockTopE.G + blockTopM.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockTopW.B + blockTopM.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockTopE.B + blockTopM.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockTopW.B + blockTopM.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockTopE.B + blockTopM.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockTopM.Exists && !(block.Type == BlockType.Water && blockTopM.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockTopE.Sun + blockTopM.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockTopE.Sun + blockTopM.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockTopW.R + blockTopM.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockTopE.R + blockTopM.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockTopW.R + blockTopM.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockTopE.R + blockTopM.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockTopW.G + blockTopM.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockTopE.G + blockTopM.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockTopW.G + blockTopM.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockTopE.G + blockTopM.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockTopW.B + blockTopM.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockTopE.B + blockTopM.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockTopW.B + blockTopM.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockTopE.B + blockTopM.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockTopM.Exists && !(block.Type == BlockType.Water && blockTopM.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockTopE.Sun + blockTopM.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockTopE.Sun + blockTopM.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockTopW.R + blockTopM.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockTopE.R + blockTopM.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockTopW.R + blockTopM.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockTopE.R + blockTopM.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockTopW.G + blockTopM.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockTopE.G + blockTopM.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockTopW.G + blockTopM.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockTopE.G + blockTopM.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockTopW.B + blockTopM.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockTopE.B + blockTopM.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockTopW.B + blockTopM.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockTopE.B + blockTopM.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockTopM.Exists && !(block.Type == BlockType.Water && blockTopM.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockTopE.Sun + blockTopM.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockTopE.Sun + blockTopM.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockTopW.R + blockTopM.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockTopE.R + blockTopM.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockTopW.R + blockTopM.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockTopE.R + blockTopM.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockTopW.G + blockTopM.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockTopE.G + blockTopM.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockTopW.G + blockTopM.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockTopE.G + blockTopM.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockTopW.B + blockTopM.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockTopE.B + blockTopM.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockTopW.B + blockTopM.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockTopE.B + blockTopM.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockTopM.Exists && !(block.Type == BlockType.Water && blockTopM.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockTopE.Sun + blockTopM.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockTopE.Sun + blockTopM.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockTopW.R + blockTopM.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockTopE.R + blockTopM.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockTopW.R + blockTopM.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockTopE.R + blockTopM.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockTopW.G + blockTopM.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockTopE.G + blockTopM.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockTopW.G + blockTopM.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockTopE.G + blockTopM.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockTopW.B + blockTopM.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockTopE.B + blockTopM.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockTopW.B + blockTopM.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockTopE.B + blockTopM.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockTopM.Exists && !(block.Type == BlockType.Water && blockTopM.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockTopE.Sun + blockTopM.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockTopE.Sun + blockTopM.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockTopW.R + blockTopM.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockTopE.R + blockTopM.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockTopW.R + blockTopM.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockTopE.R + blockTopM.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockTopW.G + blockTopM.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockTopE.G + blockTopM.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockTopW.G + blockTopM.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockTopE.G + blockTopM.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockTopW.B + blockTopM.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockTopE.B + blockTopM.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockTopW.B + blockTopM.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockTopE.B + blockTopM.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockTopM.Exists && !(block.Type == BlockType.Water && blockTopM.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockTopE.Sun + blockTopM.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockTopE.Sun + blockTopM.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockTopW.R + blockTopM.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockTopE.R + blockTopM.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockTopW.R + blockTopM.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockTopE.R + blockTopM.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockTopW.G + blockTopM.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockTopE.G + blockTopM.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockTopW.G + blockTopM.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockTopE.G + blockTopM.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockTopW.B + blockTopM.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockTopE.B + blockTopM.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockTopW.B + blockTopM.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockTopE.B + blockTopM.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockTopM.Exists && !(block.Type == BlockType.Water && blockTopM.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockTopE.Sun + blockTopM.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockTopW.Sun + blockTopM.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockTopE.Sun + blockTopM.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockTopW.R + blockTopM.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockTopE.R + blockTopM.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockTopW.R + blockTopM.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockTopE.R + blockTopM.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockTopW.G + blockTopM.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockTopE.G + blockTopM.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockTopW.G + blockTopM.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockTopE.G + blockTopM.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockTopW.B + blockTopM.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockTopE.B + blockTopM.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockTopW.B + blockTopM.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockTopE.B + blockTopM.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.YIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidS.Exists && !(block.Type == BlockType.Water && blockMidS.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockMidSW.R + blockMidS.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockMidSE.R + blockMidS.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockMidSW.R + blockMidS.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockMidSE.R + blockMidS.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockMidSW.G + blockMidS.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockMidSE.G + blockMidS.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockMidSW.G + blockMidS.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockMidSE.G + blockMidS.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockMidSW.B + blockMidS.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockMidSE.B + blockMidS.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockMidSW.B + blockMidS.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockMidSE.B + blockMidS.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidS.Exists && !(block.Type == BlockType.Water && blockMidS.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockMidSW.R + blockMidS.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockMidSE.R + blockMidS.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockMidSW.R + blockMidS.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockMidSE.R + blockMidS.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockMidSW.G + blockMidS.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockMidSE.G + blockMidS.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockMidSW.G + blockMidS.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockMidSE.G + blockMidS.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockMidSW.B + blockMidS.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockMidSE.B + blockMidS.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockMidSW.B + blockMidS.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockMidSE.B + blockMidS.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidS.Exists && !(block.Type == BlockType.Water && blockMidS.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockMidSW.R + blockMidS.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockMidSE.R + blockMidS.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockMidSW.R + blockMidS.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockMidSE.R + blockMidS.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockMidSW.G + blockMidS.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockMidSE.G + blockMidS.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockMidSW.G + blockMidS.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockMidSE.G + blockMidS.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockMidSW.B + blockMidS.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockMidSE.B + blockMidS.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockMidSW.B + blockMidS.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockMidSE.B + blockMidS.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidS.Exists && !(block.Type == BlockType.Water && blockMidS.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockMidSW.R + blockMidS.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockMidSE.R + blockMidS.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockMidSW.R + blockMidS.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockMidSE.R + blockMidS.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockMidSW.G + blockMidS.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockMidSE.G + blockMidS.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockMidSW.G + blockMidS.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockMidSE.G + blockMidS.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockMidSW.B + blockMidS.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockMidSE.B + blockMidS.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockMidSW.B + blockMidS.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockMidSE.B + blockMidS.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidS.Exists && !(block.Type == BlockType.Water && blockMidS.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockMidSW.R + blockMidS.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockMidSE.R + blockMidS.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockMidSW.R + blockMidS.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockMidSE.R + blockMidS.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockMidSW.G + blockMidS.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockMidSE.G + blockMidS.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockMidSW.G + blockMidS.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockMidSE.G + blockMidS.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockMidSW.B + blockMidS.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockMidSE.B + blockMidS.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockMidSW.B + blockMidS.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockMidSE.B + blockMidS.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidS.Exists && !(block.Type == BlockType.Water && blockMidS.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockMidSW.R + blockMidS.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockMidSE.R + blockMidS.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockMidSW.R + blockMidS.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockMidSE.R + blockMidS.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockMidSW.G + blockMidS.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockMidSE.G + blockMidS.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockMidSW.G + blockMidS.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockMidSE.G + blockMidS.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockMidSW.B + blockMidS.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockMidSE.B + blockMidS.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockMidSW.B + blockMidS.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockMidSE.B + blockMidS.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidS.Exists && !(block.Type == BlockType.Water && blockMidS.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockMidSW.R + blockMidS.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockMidSE.R + blockMidS.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockMidSW.R + blockMidS.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockMidSE.R + blockMidS.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockMidSW.G + blockMidS.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockMidSE.G + blockMidS.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockMidSW.G + blockMidS.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockMidSE.G + blockMidS.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockMidSW.B + blockMidS.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockMidSE.B + blockMidS.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockMidSW.B + blockMidS.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockMidSE.B + blockMidS.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidS.Exists && !(block.Type == BlockType.Water && blockMidS.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockMidSW.R + blockMidS.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockMidSE.R + blockMidS.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockMidSW.R + blockMidS.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockMidSE.R + blockMidS.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockMidSW.G + blockMidS.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockMidSE.G + blockMidS.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockMidSW.G + blockMidS.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockMidSE.G + blockMidS.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockMidSW.B + blockMidS.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockMidSE.B + blockMidS.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockMidSW.B + blockMidS.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockMidSE.B + blockMidS.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidS.Exists && !(block.Type == BlockType.Water && blockMidS.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockMidSW.R + blockMidS.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockMidSE.R + blockMidS.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockMidSW.R + blockMidS.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockMidSE.R + blockMidS.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockMidSW.G + blockMidS.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockMidSE.G + blockMidS.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockMidSW.G + blockMidS.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockMidSE.G + blockMidS.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockMidSW.B + blockMidS.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockMidSE.B + blockMidS.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockMidSW.B + blockMidS.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockMidSE.B + blockMidS.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidS.Exists && !(block.Type == BlockType.Water && blockMidS.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockMidSW.R + blockMidS.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockMidSE.R + blockMidS.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockMidSW.R + blockMidS.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockMidSE.R + blockMidS.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockMidSW.G + blockMidS.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockMidSE.G + blockMidS.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockMidSW.G + blockMidS.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockMidSE.G + blockMidS.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockMidSW.B + blockMidS.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockMidSE.B + blockMidS.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockMidSW.B + blockMidS.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockMidSE.B + blockMidS.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidS.Exists && !(block.Type == BlockType.Water && blockMidS.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockMidSW.R + blockMidS.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockMidSE.R + blockMidS.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockMidSW.R + blockMidS.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockMidSE.R + blockMidS.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockMidSW.G + blockMidS.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockMidSE.G + blockMidS.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockMidSW.G + blockMidS.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockMidSE.G + blockMidS.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockMidSW.B + blockMidS.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockMidSE.B + blockMidS.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockMidSW.B + blockMidS.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockMidSE.B + blockMidS.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidS.Exists && !(block.Type == BlockType.Water && blockMidS.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockMidSW.R + blockMidS.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockMidSE.R + blockMidS.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockMidSW.R + blockMidS.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockMidSE.R + blockMidS.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockMidSW.G + blockMidS.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockMidSE.G + blockMidS.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockMidSW.G + blockMidS.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockMidSE.G + blockMidS.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockMidSW.B + blockMidS.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockMidSE.B + blockMidS.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockMidSW.B + blockMidS.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockMidSE.B + blockMidS.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidS.Exists && !(block.Type == BlockType.Water && blockMidS.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockMidSW.R + blockMidS.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockMidSE.R + blockMidS.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockMidSW.R + blockMidS.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockMidSE.R + blockMidS.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockMidSW.G + blockMidS.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockMidSE.G + blockMidS.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockMidSW.G + blockMidS.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockMidSE.G + blockMidS.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockMidSW.B + blockMidS.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockMidSE.B + blockMidS.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockMidSW.B + blockMidS.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockMidSE.B + blockMidS.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidS.Exists && !(block.Type == BlockType.Water && blockMidS.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockMidSW.R + blockMidS.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockMidSE.R + blockMidS.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockMidSW.R + blockMidS.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockMidSE.R + blockMidS.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockMidSW.G + blockMidS.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockMidSE.G + blockMidS.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockMidSW.G + blockMidS.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockMidSE.G + blockMidS.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockMidSW.B + blockMidS.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockMidSE.B + blockMidS.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockMidSW.B + blockMidS.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockMidSE.B + blockMidS.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidS.Exists && !(block.Type == BlockType.Water && blockMidS.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockMidSW.R + blockMidS.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockMidSE.R + blockMidS.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockMidSW.R + blockMidS.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockMidSE.R + blockMidS.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockMidSW.G + blockMidS.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockMidSE.G + blockMidS.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockMidSW.G + blockMidS.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockMidSE.G + blockMidS.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockMidSW.B + blockMidS.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockMidSE.B + blockMidS.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockMidSW.B + blockMidS.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockMidSE.B + blockMidS.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidS.Exists && !(block.Type == BlockType.Water && blockMidS.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopSW.Sun + blockTopS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopSE.Sun + blockTopS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotSW.Sun + blockBotS.Sun + blockMidSW.Sun + blockMidS.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotSE.Sun + blockBotS.Sun + blockMidSE.Sun + blockMidS.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopSW.R + blockTopS.R + blockMidSW.R + blockMidS.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopSE.R + blockTopS.R + blockMidSE.R + blockMidS.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotSW.R + blockBotS.R + blockMidSW.R + blockMidS.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotSE.R + blockBotS.R + blockMidSE.R + blockMidS.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopSW.G + blockTopS.G + blockMidSW.G + blockMidS.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopSE.G + blockTopS.G + blockMidSE.G + blockMidS.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotSW.G + blockBotS.G + blockMidSW.G + blockMidS.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotSE.G + blockBotS.G + blockMidSE.G + blockMidS.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopSW.B + blockTopS.B + blockMidSW.B + blockMidS.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopSE.B + blockTopS.B + blockMidSE.B + blockMidS.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotSW.B + blockBotS.B + blockMidSW.B + blockMidS.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotSE.B + blockBotS.B + blockMidSE.B + blockMidS.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZDecreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidN.Exists && !(block.Type == BlockType.Water && blockMidN.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockMidNE.R + blockMidN.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockMidNW.R + blockMidN.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockMidNE.R + blockMidN.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockMidNW.R + blockMidN.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockMidNE.G + blockMidN.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockMidNW.G + blockMidN.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockMidNE.G + blockMidN.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockMidNW.G + blockMidN.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockMidNE.B + blockMidN.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockMidNW.B + blockMidN.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockMidNE.B + blockMidN.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockMidNW.B + blockMidN.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidN.Exists && !(block.Type == BlockType.Water && blockMidN.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockMidNE.R + blockMidN.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockMidNW.R + blockMidN.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockMidNE.R + blockMidN.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockMidNW.R + blockMidN.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockMidNE.G + blockMidN.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockMidNW.G + blockMidN.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockMidNE.G + blockMidN.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockMidNW.G + blockMidN.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockMidNE.B + blockMidN.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockMidNW.B + blockMidN.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockMidNE.B + blockMidN.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockMidNW.B + blockMidN.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidN.Exists && !(block.Type == BlockType.Water && blockMidN.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockMidNE.R + blockMidN.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockMidNW.R + blockMidN.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockMidNE.R + blockMidN.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockMidNW.R + blockMidN.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockMidNE.G + blockMidN.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockMidNW.G + blockMidN.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockMidNE.G + blockMidN.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockMidNW.G + blockMidN.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockMidNE.B + blockMidN.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockMidNW.B + blockMidN.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockMidNE.B + blockMidN.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockMidNW.B + blockMidN.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidN.Exists && !(block.Type == BlockType.Water && blockMidN.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockMidNE.R + blockMidN.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockMidNW.R + blockMidN.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockMidNE.R + blockMidN.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockMidNW.R + blockMidN.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockMidNE.G + blockMidN.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockMidNW.G + blockMidN.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockMidNE.G + blockMidN.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockMidNW.G + blockMidN.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockMidNE.B + blockMidN.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockMidNW.B + blockMidN.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockMidNE.B + blockMidN.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockMidNW.B + blockMidN.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidN.Exists && !(block.Type == BlockType.Water && blockMidN.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockMidNE.R + blockMidN.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockMidNW.R + blockMidN.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockMidNE.R + blockMidN.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockMidNW.R + blockMidN.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockMidNE.G + blockMidN.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockMidNW.G + blockMidN.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockMidNE.G + blockMidN.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockMidNW.G + blockMidN.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockMidNE.B + blockMidN.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockMidNW.B + blockMidN.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockMidNE.B + blockMidN.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockMidNW.B + blockMidN.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidN.Exists && !(block.Type == BlockType.Water && blockMidN.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockMidNE.R + blockMidN.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockMidNW.R + blockMidN.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockMidNE.R + blockMidN.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockMidNW.R + blockMidN.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockMidNE.G + blockMidN.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockMidNW.G + blockMidN.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockMidNE.G + blockMidN.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockMidNW.G + blockMidN.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockMidNE.B + blockMidN.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockMidNW.B + blockMidN.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockMidNE.B + blockMidN.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockMidNW.B + blockMidN.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidN.Exists && !(block.Type == BlockType.Water && blockMidN.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockMidNE.R + blockMidN.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockMidNW.R + blockMidN.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockMidNE.R + blockMidN.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockMidNW.R + blockMidN.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockMidNE.G + blockMidN.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockMidNW.G + blockMidN.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockMidNE.G + blockMidN.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockMidNW.G + blockMidN.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockMidNE.B + blockMidN.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockMidNW.B + blockMidN.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockMidNE.B + blockMidN.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockMidNW.B + blockMidN.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidN.Exists && !(block.Type == BlockType.Water && blockMidN.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockMidNE.R + blockMidN.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockMidNW.R + blockMidN.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockMidNE.R + blockMidN.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockMidNW.R + blockMidN.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockMidNE.G + blockMidN.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockMidNW.G + blockMidN.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockMidNE.G + blockMidN.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockMidNW.G + blockMidN.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockMidNE.B + blockMidN.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockMidNW.B + blockMidN.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockMidNE.B + blockMidN.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockMidNW.B + blockMidN.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidN.Exists && !(block.Type == BlockType.Water && blockMidN.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockMidNE.R + blockMidN.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockMidNW.R + blockMidN.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockMidNE.R + blockMidN.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockMidNW.R + blockMidN.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockMidNE.G + blockMidN.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockMidNW.G + blockMidN.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockMidNE.G + blockMidN.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockMidNW.G + blockMidN.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockMidNE.B + blockMidN.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockMidNW.B + blockMidN.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockMidNE.B + blockMidN.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockMidNW.B + blockMidN.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidN.Exists && !(block.Type == BlockType.Water && blockMidN.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockMidNE.R + blockMidN.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockMidNW.R + blockMidN.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockMidNE.R + blockMidN.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockMidNW.R + blockMidN.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockMidNE.G + blockMidN.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockMidNW.G + blockMidN.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockMidNE.G + blockMidN.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockMidNW.G + blockMidN.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockMidNE.B + blockMidN.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockMidNW.B + blockMidN.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockMidNE.B + blockMidN.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockMidNW.B + blockMidN.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidN.Exists && !(block.Type == BlockType.Water && blockMidN.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockMidNE.R + blockMidN.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockMidNW.R + blockMidN.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockMidNE.R + blockMidN.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockMidNW.R + blockMidN.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockMidNE.G + blockMidN.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockMidNW.G + blockMidN.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockMidNE.G + blockMidN.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockMidNW.G + blockMidN.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockMidNE.B + blockMidN.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockMidNW.B + blockMidN.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockMidNE.B + blockMidN.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockMidNW.B + blockMidN.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidN.Exists && !(block.Type == BlockType.Water && blockMidN.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockMidNE.R + blockMidN.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockMidNW.R + blockMidN.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockMidNE.R + blockMidN.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockMidNW.R + blockMidN.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockMidNE.G + blockMidN.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockMidNW.G + blockMidN.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockMidNE.G + blockMidN.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockMidNW.G + blockMidN.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockMidNE.B + blockMidN.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockMidNW.B + blockMidN.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockMidNE.B + blockMidN.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockMidNW.B + blockMidN.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidN.Exists && !(block.Type == BlockType.Water && blockMidN.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockMidNE.R + blockMidN.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockMidNW.R + blockMidN.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockMidNE.R + blockMidN.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockMidNW.R + blockMidN.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockMidNE.G + blockMidN.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockMidNW.G + blockMidN.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockMidNE.G + blockMidN.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockMidNW.G + blockMidN.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockMidNE.B + blockMidN.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockMidNW.B + blockMidN.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockMidNE.B + blockMidN.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockMidNW.B + blockMidN.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidN.Exists && !(block.Type == BlockType.Water && blockMidN.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockMidNE.R + blockMidN.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockMidNW.R + blockMidN.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockMidNE.R + blockMidN.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockMidNW.R + blockMidN.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockMidNE.G + blockMidN.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockMidNW.G + blockMidN.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockMidNE.G + blockMidN.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockMidNW.G + blockMidN.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockMidNE.B + blockMidN.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockMidNW.B + blockMidN.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockMidNE.B + blockMidN.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockMidNW.B + blockMidN.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidN.Exists && !(block.Type == BlockType.Water && blockMidN.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockMidNE.R + blockMidN.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockMidNW.R + blockMidN.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockMidNE.R + blockMidN.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockMidNW.R + blockMidN.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockMidNE.G + blockMidN.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockMidNW.G + blockMidN.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockMidNE.G + blockMidN.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockMidNW.G + blockMidN.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockMidNE.B + blockMidN.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockMidNW.B + blockMidN.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockMidNE.B + blockMidN.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockMidNW.B + blockMidN.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildBlockVertices,The following statement contains a magic number: if (!blockMidN.Exists && !(block.Type == BlockType.Water && blockMidN.Type == BlockType.Water))              {                  sunTL = (1f/Chunk.MaxSunValue)*((blockTopNE.Sun + blockTopN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunTR = (1f/Chunk.MaxSunValue)*((blockTopNW.Sun + blockTopN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                  sunBL = (1f/Chunk.MaxSunValue)*((blockBotNE.Sun + blockBotN.Sun + blockMidNE.Sun + blockMidN.Sun)/4);                  sunBR = (1f/Chunk.MaxSunValue)*((blockBotNW.Sun + blockBotN.Sun + blockMidNW.Sun + blockMidN.Sun)/4);                    redTL = (1f/Chunk.MaxSunValue)*((blockTopNE.R + blockTopN.R + blockMidNE.R + blockMidN.R)/4);                  redTR = (1f/Chunk.MaxSunValue)*((blockTopNW.R + blockTopN.R + blockMidNW.R + blockMidN.R)/4);                  redBL = (1f/Chunk.MaxSunValue)*((blockBotNE.R + blockBotN.R + blockMidNE.R + blockMidN.R)/4);                  redBR = (1f/Chunk.MaxSunValue)*((blockBotNW.R + blockBotN.R + blockMidNW.R + blockMidN.R)/4);                    grnTL = (1f/Chunk.MaxSunValue)*((blockTopNE.G + blockTopN.G + blockMidNE.G + blockMidN.G)/4);                  grnTR = (1f/Chunk.MaxSunValue)*((blockTopNW.G + blockTopN.G + blockMidNW.G + blockMidN.G)/4);                  grnBL = (1f/Chunk.MaxSunValue)*((blockBotNE.G + blockBotN.G + blockMidNE.G + blockMidN.G)/4);                  grnBR = (1f/Chunk.MaxSunValue)*((blockBotNW.G + blockBotN.G + blockMidNW.G + blockMidN.G)/4);                    bluTL = (1f/Chunk.MaxSunValue)*((blockTopNE.B + blockTopN.B + blockMidNE.B + blockMidN.B)/4);                  bluTR = (1f/Chunk.MaxSunValue)*((blockTopNW.B + blockTopN.B + blockMidNW.B + blockMidN.B)/4);                  bluBL = (1f/Chunk.MaxSunValue)*((blockBotNE.B + blockBotN.B + blockMidNE.B + blockMidN.B)/4);                  bluBR = (1f/Chunk.MaxSunValue)*((blockBotNW.B + blockBotN.B + blockMidNW.B + blockMidN.B)/4);                    localTL = new Color(redTL' grnTL' bluTL);                  localTR = new Color(redTR' grnTR' bluTR);                  localBL = new Color(redBL' grnBL' bluBL);                  localBR = new Color(redBR' grnBR' bluBR);                    BuildFaceVertices(chunk' worldPosition' block.Type' BlockFaceDirection.ZIncreasing' sunTL' sunTR' sunBL' sunBR' localTL' localTR' localBL' localBR);              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: HalfVector2[] textureUVMappings = TextureHelper.BlockTextureMappings[(int) texture*6 + faceIndex];
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Magic Number,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,AddIndex,The following statement contains a magic number: chunk.Index += 4;
Magic Number,Engine.Common.Extensions,ArrayExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\ArrayExtensions.cs,ToByteArray,The following statement contains a magic number: var res = new byte[str.Length / 2];
Magic Number,Engine.Common.Extensions,ArrayExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\ArrayExtensions.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < res.Length; ++i)              {                  string temp = String.Concat(str[i * 2]' str[i * 2 + 1]);                  res[i] = Convert.ToByte(temp' 16);              }
Magic Number,Engine.Common.Extensions,ArrayExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\ArrayExtensions.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < res.Length; ++i)              {                  string temp = String.Concat(str[i * 2]' str[i * 2 + 1]);                  res[i] = Convert.ToByte(temp' 16);              }
Magic Number,Engine.Common.Extensions,ArrayExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\ArrayExtensions.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < res.Length; ++i)              {                  string temp = String.Concat(str[i * 2]' str[i * 2 + 1]);                  res[i] = Convert.ToByte(temp' 16);              }
Magic Number,Engine.Common.Extensions,EnumerableExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\EnumerableExtensions.cs,Dump,The following statement contains a magic number: foreach (byte value in collection)              {                  if (i > 0 && ((i % 16) == 0))                  {                      output.Append(hex);                      output.Append(' ');                      output.Append(text);                      output.Append(Environment.NewLine);                      hex.Clear(); text.Clear();                  }                  hex.Append(value.ToString("X2"));                  hex.Append(' ');                  text.Append(string.Format("{0}"' (char.IsWhiteSpace((char)value) && (char)value != ' ') ? '.' : (char)value)); // prettify text                  ++i;              }
Magic Number,Engine.Common.Extensions,EnumerableExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\EnumerableExtensions.cs,Dump,The following statement contains a magic number: if (text.Length < 16)              {                  hexstring = hexstring.PadRight(48); // pad the hex representation in-case it's smaller than a regular 16 value line.              }
Magic Number,Engine.Common.Extensions,EnumerableExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\EnumerableExtensions.cs,Dump,The following statement contains a magic number: if (text.Length < 16)              {                  hexstring = hexstring.PadRight(48); // pad the hex representation in-case it's smaller than a regular 16 value line.              }
Magic Number,Engine.Common.Extensions,NumberExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\NumberExtensions.cs,GetKiloString,The following statement contains a magic number: for (i = 0; (int)(value / 1024) > 0; i++' value /= 1024) dblSByte = value / 1024.0;
Magic Number,Engine.Common.Extensions,NumberExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\NumberExtensions.cs,GetKiloString,The following statement contains a magic number: for (i = 0; (int)(value / 1024) > 0; i++' value /= 1024) dblSByte = value / 1024.0;
Magic Number,Engine.Common.Extensions,NumberExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\NumberExtensions.cs,GetKiloString,The following statement contains a magic number: for (i = 0; (int)(value / 1024) > 0; i++' value /= 1024) dblSByte = value / 1024.0;
Magic Number,Engine.Common.Extensions,NumberExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\NumberExtensions.cs,GetKiloString,The following statement contains a magic number: for (i = 0; (int)(value / 1024) > 0; i++' value /= 1024) dblSByte = value / 1024.0;
Magic Number,Engine.Common.Extensions,NumberExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\NumberExtensions.cs,GetKiloString,The following statement contains a magic number: for (i = 0; (int)(value / 1024) > 0; i++' value /= 1024) dblSByte = value / 1024.0;
Magic Number,Engine.Common.Extensions,NumberExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\NumberExtensions.cs,GetKiloString,The following statement contains a magic number: for (i = 0; (int)(value / 1024) > 0; i++' value /= 1024) dblSByte = value / 1024.0;
Magic Number,Engine.Common.Extensions,StringBuilderExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\StringBuilderExtensions.cs,AppendNumber,The following statement contains a magic number: AppendNumber(builder' number' 2' AppendNumberOptions.None);
Magic Number,Engine.Common.Extensions,StringBuilderExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\StringBuilderExtensions.cs,AppendNumber,The following statement contains a magic number: AppendNumber(builder' number' 2' options);
Magic Number,Engine.Common.Extensions,StringBuilderExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\StringBuilderExtensions.cs,AppendNumber,The following statement contains a magic number: if (float.IsNaN(number))              {                  builder.Append("NaN");              }              else if (float.IsNegativeInfinity(number))              {                  builder.Append("-Infinity");              }              else if (float.IsPositiveInfinity(number))              {                  builder.Append("+Infinity");              }              else              {                  int intNumber =                          (int)(number * (float)System.Math.Pow(10' decimalCount) + 0.5f);                    AppendNumbernternal(builder' intNumber' decimalCount' options);              }
Magic Number,Engine.Common.Extensions,StringBuilderExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\StringBuilderExtensions.cs,AppendNumbernternal,The following statement contains a magic number: do              {                  // Add decimal separator ("." in US).                  if (idx == decimalPos)                  {                      numberString[--idx] = nfi.NumberDecimalSeparator[0];                  }                    // Added number group separator ("'" in US).                  if (--numberGroupCount < 0 && showNumberGroup)                  {                      numberString[--idx] = nfi.NumberGroupSeparator[0];                        if (numberGroupIdx < numberGroupSizes.Length - 1)                          numberGroupIdx++;                        numberGroupCount = numberGroupSizes[numberGroupIdx] - 1;                  }                    // Convert current digit to character and add to buffer.                  numberString[--idx] = (char)('0' + (number % 10));                  number /= 10;                } while (number > 0 || decimalPos <= idx);
Magic Number,Engine.Common.Extensions,StringBuilderExtensions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Extensions\StringBuilderExtensions.cs,AppendNumbernternal,The following statement contains a magic number: do              {                  // Add decimal separator ("." in US).                  if (idx == decimalPos)                  {                      numberString[--idx] = nfi.NumberDecimalSeparator[0];                  }                    // Added number group separator ("'" in US).                  if (--numberGroupCount < 0 && showNumberGroup)                  {                      numberString[--idx] = nfi.NumberGroupSeparator[0];                        if (numberGroupIdx < numberGroupSizes.Length - 1)                          numberGroupIdx++;                        numberGroupCount = numberGroupSizes[numberGroupIdx] - 1;                  }                    // Convert current digit to character and add to buffer.                  numberString[--idx] = (char)('0' + (number % 10));                  number /= 10;                } while (number > 0 || decimalPos <= idx);
Magic Number,Engine.Common.Logging,ConsoleTarget,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Logging\ConsoleTarget.cs,LogMessage,The following statement contains a magic number: Console.WriteLine(string.Format("{0}[{1}] [{2}]: {3}"' timeStamp' level.ToString().PadLeft(5)' logger' message));
Magic Number,Engine.Common.Logging,ConsoleTarget,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Logging\ConsoleTarget.cs,LogException,The following statement contains a magic number: Console.WriteLine(string.Format("{0}[{1}] [{2}]: {3} - [Exception] {4}"' timeStamp' level.ToString().PadLeft(5)' logger' message' exception));
Magic Number,Engine.Common.Logging,FileTarget,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Logging\FileTarget.cs,LogMessage,The following statement contains a magic number: lock (this) // we need this here until we seperate gs / moonet /raist              {                  var timeStamp = this.IncludeTimeStamps ? "[" + DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss.fff") + "] " : "";                    if (!this._disposed) // make sure we're not disposed.                      this._logStream.WriteLine(string.Format("{0}[{1}] [{2}]: {3}"' timeStamp' level.ToString().PadLeft(5)' logger' message));              }
Magic Number,Engine.Common.Logging,FileTarget,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Logging\FileTarget.cs,LogException,The following statement contains a magic number: lock (this) // we need this here until we seperate gs / moonet /raist              {                  var timeStamp = this.IncludeTimeStamps ? "[" + DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss.fff") + "] " : "";                    if (!this._disposed) // make sure we're not disposed.                      this._logStream.WriteLine(string.Format("{0}[{1}] [{2}]: {3} - [Exception] {4}"' timeStamp' level.ToString().PadLeft(5)' logger' message' exception));              }
Magic Number,Engine.Common.Math,MathHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Math\MathHelper.cs,MapToPositive,The following statement contains a magic number: if (x >= 0)                  return x * 2;
Magic Number,Engine.Common.Math,MathHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Math\MathHelper.cs,MapToPositive,The following statement contains a magic number: return -x * 2 - 1;
Magic Number,Engine.Common.Math,MathHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Math\MathHelper.cs,RedoMapToPositive,The following statement contains a magic number: if (x % 2 == 0)              {                  return x / 2;              }
Magic Number,Engine.Common.Math,MathHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Math\MathHelper.cs,RedoMapToPositive,The following statement contains a magic number: if (x % 2 == 0)              {                  return x / 2;              }
Magic Number,Engine.Common.Math,MathHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Math\MathHelper.cs,RedoMapToPositive,The following statement contains a magic number: return -(x / 2) - 1;
Magic Number,Engine.Common.Math,MathHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Math\MathHelper.cs,Cantorize,The following statement contains a magic number: return ((k1 + k2) * (k1 + k2 + 1) / 2) + k2;
Magic Number,Engine.Common.Math,MathHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Math\MathHelper.cs,CantorY,The following statement contains a magic number: int j = (int)(System.Math.Sqrt(0.25 + 2 * c) - 0.5);
Magic Number,Engine.Common.Math,MathHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Math\MathHelper.cs,CantorY,The following statement contains a magic number: int j = (int)(System.Math.Sqrt(0.25 + 2 * c) - 0.5);
Magic Number,Engine.Common.Math,MathHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Math\MathHelper.cs,CantorY,The following statement contains a magic number: int j = (int)(System.Math.Sqrt(0.25 + 2 * c) - 0.5);
Magic Number,Engine.Common.Math,MathHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Math\MathHelper.cs,CantorY,The following statement contains a magic number: return c - j * (j + 1) / 2;
Magic Number,Engine.Common.Math,MathHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Math\MathHelper.cs,CantorX,The following statement contains a magic number: int j = (int)(System.Math.Sqrt(0.25 + 2 * c) - 0.5);
Magic Number,Engine.Common.Math,MathHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Math\MathHelper.cs,CantorX,The following statement contains a magic number: int j = (int)(System.Math.Sqrt(0.25 + 2 * c) - 0.5);
Magic Number,Engine.Common.Math,MathHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Math\MathHelper.cs,CantorX,The following statement contains a magic number: int j = (int)(System.Math.Sqrt(0.25 + 2 * c) - 0.5);
Magic Number,Engine.Common.Noise,PerlinNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\PerlinNoise.cs,InitGradients,The following statement contains a magic number: for (int i = 0; i < GradientSizeTable; i++)                  {                      double z = 1f - 2f * _random.NextDouble();                      double r = System.Math.Sqrt(1f - z * z);                      double theta = 2 * System.Math.PI * _random.NextDouble();                      _gradients[i * 3] = r * System.Math.Cos(theta);                      _gradients[i * 3 + 1] = r * System.Math.Sin(theta);                      _gradients[i * 3 + 2] = z;                  }
Magic Number,Engine.Common.Noise,PerlinNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\PerlinNoise.cs,InitGradients,The following statement contains a magic number: for (int i = 0; i < GradientSizeTable; i++)                  {                      double z = 1f - 2f * _random.NextDouble();                      double r = System.Math.Sqrt(1f - z * z);                      double theta = 2 * System.Math.PI * _random.NextDouble();                      _gradients[i * 3] = r * System.Math.Cos(theta);                      _gradients[i * 3 + 1] = r * System.Math.Sin(theta);                      _gradients[i * 3 + 2] = z;                  }
Magic Number,Engine.Common.Noise,PerlinNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\PerlinNoise.cs,InitGradients,The following statement contains a magic number: for (int i = 0; i < GradientSizeTable; i++)                  {                      double z = 1f - 2f * _random.NextDouble();                      double r = System.Math.Sqrt(1f - z * z);                      double theta = 2 * System.Math.PI * _random.NextDouble();                      _gradients[i * 3] = r * System.Math.Cos(theta);                      _gradients[i * 3 + 1] = r * System.Math.Sin(theta);                      _gradients[i * 3 + 2] = z;                  }
Magic Number,Engine.Common.Noise,PerlinNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\PerlinNoise.cs,InitGradients,The following statement contains a magic number: for (int i = 0; i < GradientSizeTable; i++)                  {                      double z = 1f - 2f * _random.NextDouble();                      double r = System.Math.Sqrt(1f - z * z);                      double theta = 2 * System.Math.PI * _random.NextDouble();                      _gradients[i * 3] = r * System.Math.Cos(theta);                      _gradients[i * 3 + 1] = r * System.Math.Sin(theta);                      _gradients[i * 3 + 2] = z;                  }
Magic Number,Engine.Common.Noise,PerlinNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\PerlinNoise.cs,InitGradients,The following statement contains a magic number: for (int i = 0; i < GradientSizeTable; i++)                  {                      double z = 1f - 2f * _random.NextDouble();                      double r = System.Math.Sqrt(1f - z * z);                      double theta = 2 * System.Math.PI * _random.NextDouble();                      _gradients[i * 3] = r * System.Math.Cos(theta);                      _gradients[i * 3 + 1] = r * System.Math.Sin(theta);                      _gradients[i * 3 + 2] = z;                  }
Magic Number,Engine.Common.Noise,PerlinNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\PerlinNoise.cs,Lattice,The following statement contains a magic number: int g = index * 3;
Magic Number,Engine.Common.Noise,PerlinNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\PerlinNoise.cs,Lattice,The following statement contains a magic number: return _gradients[g] * fx + _gradients[g + 1] * fy + _gradients[g + 2] * fz;
Magic Number,Engine.Common.Noise,PerlinNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\PerlinNoise.cs,Smooth,The following statement contains a magic number: return x * x * (3 - 2 * x);
Magic Number,Engine.Common.Noise,PerlinNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\PerlinNoise.cs,Smooth,The following statement contains a magic number: return x * x * (3 - 2 * x);
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,SimplexNoise,The following statement contains a magic number: for (int i = 0; i < 512; i++) perm[i] = p[i & 255];
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,SimplexNoise,The following statement contains a magic number: for (int i = 0; i < 512; i++) perm[i] = p[i & 255];
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,dot,The following statement contains a magic number: return g[0]*x + g[1]*y + g[2]*z;
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,dot,The following statement contains a magic number: return g[0]*x + g[1]*y + g[2]*z + g[3]*w;
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,dot,The following statement contains a magic number: return g[0]*x + g[1]*y + g[2]*z + g[3]*w;
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: int ii = i & 255;
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: int jj = j & 255;
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: int kk = k & 255;
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: int gi0 = perm[ii + perm[jj + perm[kk]]]%12;
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: int gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]]%12;
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: int gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]]%12;
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: int gi3 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]]%12;
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: float F2 = (float) (0.5*(System.Math.Sqrt(3.0) - 1.0));
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: float F2 = (float) (0.5*(System.Math.Sqrt(3.0) - 1.0));
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: float g2 = (float) ((3.0 - System.Math.Sqrt(3.0))/6.0);
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: float g2 = (float) ((3.0 - System.Math.Sqrt(3.0))/6.0);
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: float g2 = (float) ((3.0 - System.Math.Sqrt(3.0))/6.0);
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: int ii = i & 255;
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: int jj = j & 255;
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: int gi0 = perm[ii + perm[jj]]%12;
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: int gi1 = perm[ii + i1 + perm[jj + j1]]%12;
Magic Number,Engine.Common.Noise,SimplexNoise,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Noise\SimplexNoise.cs,noise,The following statement contains a magic number: int gi2 = perm[ii + 1 + perm[jj + 1]]%12;
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,Next,The following statement contains a magic number: uint t = _x ^ (_x << 11);
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,Next,The following statement contains a magic number: _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,Next,The following statement contains a magic number: _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,Next,The following statement contains a magic number: uint t = _x ^ (_x << 11);
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,Next,The following statement contains a magic number: return (int)((REAL_UNIT_INT * (int)(0x7FFFFFFF & (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8))))) * upperBound);
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,Next,The following statement contains a magic number: return (int)((REAL_UNIT_INT * (int)(0x7FFFFFFF & (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8))))) * upperBound);
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,Next,The following statement contains a magic number: uint t = _x ^ (_x << 11);
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,Next,The following statement contains a magic number: if (range < 0)              {                  // If range is <0 then an overflow has occured and must resort to using long integer arithmetic instead (slower).                  // We also must use all 32 bits of precision' instead of the normal 31' which again is slower.                    return lowerBound +                         (int)                         ((REAL_UNIT_UINT * (double)(_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)))) *                          (double)((long)upperBound - (long)lowerBound));              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,Next,The following statement contains a magic number: if (range < 0)              {                  // If range is <0 then an overflow has occured and must resort to using long integer arithmetic instead (slower).                  // We also must use all 32 bits of precision' instead of the normal 31' which again is slower.                    return lowerBound +                         (int)                         ((REAL_UNIT_UINT * (double)(_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8)))) *                          (double)((long)upperBound - (long)lowerBound));              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,Next,The following statement contains a magic number: return lowerBound +                     (int)                     ((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8))))) *                      (double)range);
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,Next,The following statement contains a magic number: return lowerBound +                     (int)                     ((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8))))) *                      (double)range);
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextDouble,The following statement contains a magic number: uint t = _x ^ (_x << 11);
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextDouble,The following statement contains a magic number: return REAL_UNIT_INT * (int)(0x7FFFFFFF & (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8))));
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextDouble,The following statement contains a magic number: return REAL_UNIT_INT * (int)(0x7FFFFFFF & (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8))));
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Trosch�tz for pointing this out.                  t = x ^ (x << 11);                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Trosch�tz for pointing this out.                  t = x ^ (x << 11);                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Trosch�tz for pointing this out.                  t = x ^ (x << 11);                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Trosch�tz for pointing this out.                  t = x ^ (x << 11);                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Trosch�tz for pointing this out.                  t = x ^ (x << 11);                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Trosch�tz for pointing this out.                  t = x ^ (x << 11);                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )              {                  // Generate 4 bytes.                   // Increased performance is achieved by generating 4 random bytes per loop.                  // Also note that no mask needs to be applied to zero out the higher order bytes before                  // casting because the cast ignores thos bytes. Thanks to Stefan Trosch�tz for pointing this out.                  t = x ^ (x << 11);                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  buffer[i++] = (byte)(w >> 8);                  buffer[i++] = (byte)(w >> 16);                  buffer[i++] = (byte)(w >> 24);              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = x ^ (x << 11);                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = x ^ (x << 11);                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = x ^ (x << 11);                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = x ^ (x << 11);                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = x ^ (x << 11);                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Generate 4 bytes.                  t = x ^ (x << 11);                  x = y;                  y = z;                  z = w;                  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));                    buffer[i++] = (byte)w;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(w >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(w >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(w >> 24);                          }                      }                  }              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextUInt,The following statement contains a magic number: uint t = _x ^ (_x << 11);
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextUInt,The following statement contains a magic number: return _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextUInt,The following statement contains a magic number: return _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextInt,The following statement contains a magic number: uint t = _x ^ (_x << 11);
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextInt,The following statement contains a magic number: return (int)(0x7FFFFFFF & (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8))));
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextInt,The following statement contains a magic number: return (int)(0x7FFFFFFF & (_w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8))));
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextBool,The following statement contains a magic number: if (0 == _bitMask)              {                  // Generate 32 more bits.                  uint t = _x ^ (_x << 11);                  _x = _y;                  _y = _z;                  _z = _w;                  _bitBuffer = _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));                    // Reset the bitMask that tells us which bit to read next.                  _bitMask = 0x80000000;                  return (_bitBuffer & _bitMask) == 0;              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextBool,The following statement contains a magic number: if (0 == _bitMask)              {                  // Generate 32 more bits.                  uint t = _x ^ (_x << 11);                  _x = _y;                  _y = _z;                  _z = _w;                  _bitBuffer = _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));                    // Reset the bitMask that tells us which bit to read next.                  _bitMask = 0x80000000;                  return (_bitBuffer & _bitMask) == 0;              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextBool,The following statement contains a magic number: if (0 == _bitMask)              {                  // Generate 32 more bits.                  uint t = _x ^ (_x << 11);                  _x = _y;                  _y = _z;                  _z = _w;                  _bitBuffer = _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));                    // Reset the bitMask that tells us which bit to read next.                  _bitMask = 0x80000000;                  return (_bitBuffer & _bitMask) == 0;              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextByte,The following statement contains a magic number: if (0 == _byteBufferState)              {                  // Generate 4 more bytes.                  uint t = _x ^ (_x << 11);                  _x = _y;                  _y = _z;                  _z = _w;                  _byteBuffer = _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));                  _byteBufferState = 0x4;                  return (byte)_byteBuffer; // Note. Masking with 0xFF is unnecessary.              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextByte,The following statement contains a magic number: if (0 == _byteBufferState)              {                  // Generate 4 more bytes.                  uint t = _x ^ (_x << 11);                  _x = _y;                  _y = _z;                  _z = _w;                  _byteBuffer = _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));                  _byteBufferState = 0x4;                  return (byte)_byteBuffer; // Note. Masking with 0xFF is unnecessary.              }
Magic Number,Engine.Common.Randomization,FastRandom,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\FastRandom.cs,NextByte,The following statement contains a magic number: if (0 == _byteBufferState)              {                  // Generate 4 more bytes.                  uint t = _x ^ (_x << 11);                  _x = _y;                  _y = _z;                  _z = _w;                  _byteBuffer = _w = (_w ^ (_w >> 19)) ^ (t ^ (t >> 8));                  _byteBufferState = 0x4;                  return (byte)_byteBuffer; // Note. Masking with 0xFF is unnecessary.              }
Magic Number,Engine.Common.Randomization,ItemRandomHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\RandomHelper.cs,ItemRandomHelper,The following statement contains a magic number: b = 666;
Magic Number,Engine.Common.Randomization,ItemRandomHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\RandomHelper.cs,ReinitSeed,The following statement contains a magic number: b = 666;
Magic Number,Engine.Common.Randomization,ItemRandomHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Common\Randomization\RandomHelper.cs,Next,The following statement contains a magic number: b = (uint)(temp >> 32);
Magic Number,Engine.Core.Config,CacheConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\CacheConfig.cs,CacheConfig,The following statement contains a magic number: this.ViewRange = 3;
Magic Number,Engine.Core.Config,CacheConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\CacheConfig.cs,CacheConfig,The following statement contains a magic number: this.CacheRange = 5;
Magic Number,Engine.Core.Config,CacheConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\CacheConfig.cs,Setup,The following statement contains a magic number: this.ChunksInCacheRange = (this.CacheRange * 2 + 1) * (this.CacheRange * 2 + 1);
Magic Number,Engine.Core.Config,CacheConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\CacheConfig.cs,Setup,The following statement contains a magic number: this.ChunksInCacheRange = (this.CacheRange * 2 + 1) * (this.CacheRange * 2 + 1);
Magic Number,Engine.Core.Config,CacheConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\CacheConfig.cs,Setup,The following statement contains a magic number: this.ChunksInViewRange = (this.ViewRange * 2 + 1) * (this.ViewRange * 2 + 1);
Magic Number,Engine.Core.Config,CacheConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\CacheConfig.cs,Setup,The following statement contains a magic number: this.ChunksInViewRange = (this.ViewRange * 2 + 1) * (this.ViewRange * 2 + 1);
Magic Number,Engine.Core.Config,CacheConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\CacheConfig.cs,Setup,The following statement contains a magic number: this.CacheRangeWidthInBlocks = (this.CacheRange * 2 + 1) * Engine.Instance.Configuration.Chunk.WidthInBlocks;
Magic Number,Engine.Core.Config,CacheConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\CacheConfig.cs,Setup,The following statement contains a magic number: this.CacheRangeLenghtInBlocks = (this.CacheRange * 2 + 1) * Engine.Instance.Configuration.Chunk.LengthInBlocks;
Magic Number,Engine.Core.Config,CacheConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\CacheConfig.cs,Setup,The following statement contains a magic number: this.ViewRangeWidthInBlocks = (this.ViewRange * 2 + 1) * Engine.Instance.Configuration.Chunk.WidthInBlocks;
Magic Number,Engine.Core.Config,CacheConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\CacheConfig.cs,Setup,The following statement contains a magic number: this.ViewRangeLenghtInBlocks = (this.ViewRange * 2 + 1) * Engine.Instance.Configuration.Chunk.LengthInBlocks;
Magic Number,Engine.Core.Config,ChunkConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\ChunkConfig.cs,ChunkConfig,The following statement contains a magic number: this.WidthInBlocks = 16;
Magic Number,Engine.Core.Config,ChunkConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\ChunkConfig.cs,ChunkConfig,The following statement contains a magic number: this.HeightInBlocks = 128;
Magic Number,Engine.Core.Config,ChunkConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\ChunkConfig.cs,ChunkConfig,The following statement contains a magic number: this.LengthInBlocks = 16;
Magic Number,Engine.Core.Config,GraphicsConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\GraphicsConfig.cs,GraphicsConfig,The following statement contains a magic number: this.Width = 1280;
Magic Number,Engine.Core.Config,GraphicsConfig,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Core\Config\GraphicsConfig.cs,GraphicsConfig,The following statement contains a magic number: this.Height = 720;
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The following statement contains a magic number: this._primitiveBatch = new PrimitiveBatch(this.GraphicsDevice' 1000);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The following statement contains a magic number: this._bounds = new Rectangle(10' 10' this.Game.GraphicsDevice.Viewport.Bounds.Width - 20' 20);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The following statement contains a magic number: this._bounds = new Rectangle(10' 10' this.Game.GraphicsDevice.Viewport.Bounds.Width - 20' 20);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The following statement contains a magic number: this._bounds = new Rectangle(10' 10' this.Game.GraphicsDevice.Viewport.Bounds.Width - 20' 20);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The following statement contains a magic number: this._bounds = new Rectangle(10' 10' this.Game.GraphicsDevice.Viewport.Bounds.Width - 20' 20);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The following statement contains a magic number: this._backgroundPolygon[0] = new Vector2(_bounds.X - 2' _bounds.Y - 2);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The following statement contains a magic number: this._backgroundPolygon[0] = new Vector2(_bounds.X - 2' _bounds.Y - 2);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The following statement contains a magic number: this._backgroundPolygon[1] = new Vector2(_bounds.X - 2' _bounds.Y + _bounds.Height + 14);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The following statement contains a magic number: this._backgroundPolygon[1] = new Vector2(_bounds.X - 2' _bounds.Y + _bounds.Height + 14);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The following statement contains a magic number: this._backgroundPolygon[2] = new Vector2(_bounds.X + 2 + _bounds.Width' _bounds.Y + _bounds.Height + 14);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The following statement contains a magic number: this._backgroundPolygon[2] = new Vector2(_bounds.X + 2 + _bounds.Width' _bounds.Y + _bounds.Height + 14);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The following statement contains a magic number: this._backgroundPolygon[2] = new Vector2(_bounds.X + 2 + _bounds.Width' _bounds.Y + _bounds.Height + 14);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The following statement contains a magic number: this._backgroundPolygon[3] = new Vector2(_bounds.X + 2 + _bounds.Width' _bounds.Y - 2);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The following statement contains a magic number: this._backgroundPolygon[3] = new Vector2(_bounds.X + 2 + _bounds.Width' _bounds.Y - 2);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,LoadContent,The following statement contains a magic number: this._backgroundPolygon[3] = new Vector2(_bounds.X + 2 + _bounds.Width' _bounds.Y - 2);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: BasicShapes.DrawSolidPolygon(this._primitiveBatch' this._backgroundPolygon' 4' Color.Black' true);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: if (this._chunkCache.ChunksDrawn >= 31)                  _drawnBlocks = (this._chunkCache.ChunksDrawn / 31f).ToString("F2") + "M";              else if (this._chunkCache.ChunksDrawn > 1)                  _drawnBlocks = (this._chunkCache.ChunksDrawn / 0.03f).ToString("F2") + "K";              else _drawnBlocks = "0";
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: if (this._chunkStorage.Count > 31)                   _totalBlocks = (this._chunkStorage.Count / 31f).ToString("F2") + "M";              else if (this._chunkStorage.Count > 1)                   _totalBlocks = (this._chunkStorage.Count / 0.03f).ToString("F2") + "K";              else                   _totalBlocks = Core.Engine.Instance.Configuration.Chunk.Volume.ToString(CultureInfo.InvariantCulture);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 5' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 5' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 105' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 105' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 205' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 205' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 305' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 305' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 450' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 450' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 550' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 550' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 650' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 650' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 750' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 750' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 850' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 850' this._bounds.Y + 5)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 5' this._bounds.Y + 15)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 5' this._bounds.Y + 15)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 105' this._bounds.Y + 15)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 105' this._bounds.Y + 15)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 205' this._bounds.Y + 15)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 205' this._bounds.Y + 15)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 305' this._bounds.Y + 15)' Color.White);
Magic Number,Engine.Debugging,DebugBar,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\DebugBar.cs,Draw,The following statement contains a magic number: _spriteBatch.DrawString(_spriteFont' _stringBuilder' new Vector2(this._bounds.X + 305' this._bounds.Y + 15)' Color.White);
Magic Number,Engine.Debugging.Console,Command,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\Command.cs,Fallback,The following statement contains a magic number: return output.Substring(0' output.Length - 2) + ".";
Magic Number,Engine.Debugging.Console,CommandsList,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\CommandManager.cs,Fallback,The following statement contains a magic number: output = output.Substring(0' output.Length - 2) + ".";
Magic Number,Engine.Debugging.Console,GameConsoleOptions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\GameConsoleOptions.cs,GameConsoleOptions,The following statement contains a magic number: BackgroundColor = new Color(0' 0' 0' 125);
Magic Number,Engine.Debugging.Console,GameConsoleOptions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\GameConsoleOptions.cs,GameConsoleOptions,The following statement contains a magic number: Height = 300;
Magic Number,Engine.Debugging.Console,GameConsoleOptions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\GameConsoleOptions.cs,GameConsoleOptions,The following statement contains a magic number: Padding = 30;
Magic Number,Engine.Debugging.Console,GameConsoleOptions,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\GameConsoleOptions.cs,GameConsoleOptions,The following statement contains a magic number: Margin = 30;
Magic Number,Engine.Debugging.Console,Renderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\Renderer.cs,Renderer,The following statement contains a magic number: maxCharactersPerLine = (int)((Bounds.Width - GameConsoleOptions.Options.Padding * 2) / oneCharacterWidth);
Magic Number,Engine.Debugging.Console,Renderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\Renderer.cs,DrawRoundedEdges,The following statement contains a magic number: spriteBatch.Draw(pixel' new Rectangle(Bounds.X + GameConsoleOptions.Options.RoundedCorner.Width' Bounds.Y + GameConsoleOptions.Options.Height' Bounds.Width - GameConsoleOptions.Options.RoundedCorner.Width * 2' GameConsoleOptions.Options.RoundedCorner.Height)' GameConsoleOptions.Options.BackgroundColor);
Magic Number,Engine.Debugging.Console,Renderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Console\Renderer.cs,DrawCursor,The following statement contains a magic number: spriteBatch.DrawString(GameConsoleOptions.Options.Font' (int)(gameTime.TotalGameTime.TotalSeconds / GameConsoleOptions.Options.CursorBlinkSpeed) % 2 == 0 ? GameConsoleOptions.Options.Cursor.ToString() : ""' pos' GameConsoleOptions.Options.CursorColor);
Magic Number,Engine.Debugging.Graphs,DebugGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\DebugGraph.cs,DebugGraph,The following statement contains a magic number: this.ValuesToGraph = 2500;
Magic Number,Engine.Debugging.Graphs,DebugGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\DebugGraph.cs,LoadContent,The following statement contains a magic number: BackgroundPolygon[0] = new Vector2(Bounds.X - 2' Bounds.Y - 2);
Magic Number,Engine.Debugging.Graphs,DebugGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\DebugGraph.cs,LoadContent,The following statement contains a magic number: BackgroundPolygon[0] = new Vector2(Bounds.X - 2' Bounds.Y - 2);
Magic Number,Engine.Debugging.Graphs,DebugGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\DebugGraph.cs,LoadContent,The following statement contains a magic number: BackgroundPolygon[3] = new Vector2(Bounds.X + 2 + Bounds.Width' Bounds.Y - 2);
Magic Number,Engine.Debugging.Graphs,DebugGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\DebugGraph.cs,LoadContent,The following statement contains a magic number: BackgroundPolygon[3] = new Vector2(Bounds.X + 2 + Bounds.Width' Bounds.Y - 2);
Magic Number,Engine.Debugging.Graphs,DebugGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\DebugGraph.cs,LoadContent,The following statement contains a magic number: BackgroundPolygon[3] = new Vector2(Bounds.X + 2 + Bounds.Width' Bounds.Y - 2);
Magic Number,Engine.Debugging.Graphs,DebugGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\DebugGraph.cs,LoadContent,The following statement contains a magic number: BackgroundPolygon[1] = new Vector2(Bounds.X - 2' Bounds.Y + Bounds.Height + 14);
Magic Number,Engine.Debugging.Graphs,DebugGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\DebugGraph.cs,LoadContent,The following statement contains a magic number: BackgroundPolygon[1] = new Vector2(Bounds.X - 2' Bounds.Y + Bounds.Height + 14);
Magic Number,Engine.Debugging.Graphs,DebugGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\DebugGraph.cs,LoadContent,The following statement contains a magic number: BackgroundPolygon[2] = new Vector2(Bounds.X + 2 + Bounds.Width' Bounds.Y + Bounds.Height + 14);
Magic Number,Engine.Debugging.Graphs,DebugGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\DebugGraph.cs,LoadContent,The following statement contains a magic number: BackgroundPolygon[2] = new Vector2(Bounds.X + 2 + Bounds.Width' Bounds.Y + Bounds.Height + 14);
Magic Number,Engine.Debugging.Graphs,DebugGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\DebugGraph.cs,LoadContent,The following statement contains a magic number: BackgroundPolygon[2] = new Vector2(Bounds.X + 2 + Bounds.Width' Bounds.Y + Bounds.Height + 14);
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new FPSGraph(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 50' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new FPSGraph(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 50' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new FPSGraph(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 50' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new FPSGraph(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 50' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new MemGraph(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 105' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new MemGraph(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 105' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new MemGraph(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 105' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new MemGraph(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 105' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new GenerateQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 160' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new GenerateQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 160' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new GenerateQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 160' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new GenerateQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 160' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new LightenQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 215' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new LightenQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 215' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new LightenQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 215' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new LightenQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 215' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new BuildQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 270' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new BuildQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 270' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new BuildQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 270' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new BuildQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 270' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new ReadyQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 325' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new ReadyQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 325' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new ReadyQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 325' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new ReadyQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 325' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new RemoveQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 380' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new RemoveQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 380' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new RemoveQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 380' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,Initialize,The following statement contains a magic number: this._graphs.Add(new RemoveQ(this.Game' new Rectangle(Core.Engine.Instance.Configuration.Graphics.Width - 280' 380' 270' 35)));
Magic Number,Engine.Debugging.Graphs,GraphManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\GraphManager.cs,LoadContent,The following statement contains a magic number: _primitiveBatch = new PrimitiveBatch(this.GraphicsDevice' 1000);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,BuildQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\BuildQ.cs,Update,The following statement contains a magic number: if (GraphValues.Count <= 2)                  return;
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,BuildQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\BuildQ.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "max:" + MaxValue' new Vector2(Bounds.Left + 90' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,BuildQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\BuildQ.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "avg:" + AverageValue' new Vector2(Bounds.Left + 150' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,BuildQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\BuildQ.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "min:" + MinimumValue' new Vector2(Bounds.Left + 210' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,BuildQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\BuildQ.cs,DrawGraph,The following statement contains a magic number: BasicShapes.DrawSolidPolygon(this.PrimitiveBatch' BackgroundPolygon' 4' Color.Black' true);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,BuildQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\BuildQ.cs,DrawGraph,The following statement contains a magic number: if (GraphValues.Count <= 2)                  return;
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,GenerateQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\GenerateQ.cs,Update,The following statement contains a magic number: if (GraphValues.Count <= 2)                  return;
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,GenerateQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\GenerateQ.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "max:" + MaxValue' new Vector2(Bounds.Left + 90' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,GenerateQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\GenerateQ.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "avg:" + AverageValue' new Vector2(Bounds.Left + 150' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,GenerateQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\GenerateQ.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "min:" + MinimumValue' new Vector2(Bounds.Left + 210' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,GenerateQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\GenerateQ.cs,DrawGraph,The following statement contains a magic number: BasicShapes.DrawSolidPolygon(this.PrimitiveBatch' BackgroundPolygon' 4' Color.Black' true);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,GenerateQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\GenerateQ.cs,DrawGraph,The following statement contains a magic number: if (GraphValues.Count <= 2)                  return;
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,LightenQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\LightenQ.cs,Update,The following statement contains a magic number: if (GraphValues.Count <= 2)                  return;
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,LightenQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\LightenQ.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "max:" + MaxValue' new Vector2(Bounds.Left + 90' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,LightenQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\LightenQ.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "avg:" + AverageValue' new Vector2(Bounds.Left + 150' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,LightenQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\LightenQ.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "min:" + MinimumValue' new Vector2(Bounds.Left + 210' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,LightenQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\LightenQ.cs,DrawGraph,The following statement contains a magic number: BasicShapes.DrawSolidPolygon(this.PrimitiveBatch' BackgroundPolygon' 4' Color.Black' true);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,LightenQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\LightenQ.cs,DrawGraph,The following statement contains a magic number: if (GraphValues.Count <= 2)                  return;
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,ReadyQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\ReadyQ.cs,Update,The following statement contains a magic number: if (GraphValues.Count <= 2)                  return;
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,ReadyQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\ReadyQ.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "max:" + MaxValue' new Vector2(Bounds.Left + 90' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,ReadyQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\ReadyQ.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "avg:" + AverageValue' new Vector2(Bounds.Left + 150' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,ReadyQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\ReadyQ.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "min:" + MinimumValue' new Vector2(Bounds.Left + 210' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,ReadyQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\ReadyQ.cs,DrawGraph,The following statement contains a magic number: BasicShapes.DrawSolidPolygon(this.PrimitiveBatch' BackgroundPolygon' 4' Color.Black' true);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,ReadyQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\ReadyQ.cs,DrawGraph,The following statement contains a magic number: if (GraphValues.Count <= 2)                  return;
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,RemoveQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\RemoveQ.cs,Update,The following statement contains a magic number: if (GraphValues.Count <= 2)                  return;
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,RemoveQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\RemoveQ.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "max:" + MaxValue' new Vector2(Bounds.Left + 90' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,RemoveQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\RemoveQ.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "avg:" + AverageValue' new Vector2(Bounds.Left + 150' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,RemoveQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\RemoveQ.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "min:" + MinimumValue' new Vector2(Bounds.Left + 210' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,RemoveQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\RemoveQ.cs,DrawGraph,The following statement contains a magic number: BasicShapes.DrawSolidPolygon(this.PrimitiveBatch' BackgroundPolygon' 4' Color.Black' true);
Magic Number,Engine.Debugging.Graphs.Implementations.ChunkGraphs,RemoveQ,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\ChunkGraphs\RemoveQ.cs,DrawGraph,The following statement contains a magic number: if (GraphValues.Count <= 2)                  return;
Magic Number,Engine.Debugging.Graphs.Implementations,FPSGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\FPSGraph.cs,Update,The following statement contains a magic number: if (GraphValues.Count <= 2)                  return;
Magic Number,Engine.Debugging.Graphs.Implementations,FPSGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\FPSGraph.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "max:" + MaxValue' new Vector2(Bounds.Left + 90' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations,FPSGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\FPSGraph.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "avg:" + AverageValue' new Vector2(Bounds.Left + 150' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations,FPSGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\FPSGraph.cs,DrawStrings,The following statement contains a magic number: SpriteBatch.DrawString(SpriteFont' "min:" + MinimumValue' new Vector2(Bounds.Left + 210' Bounds.Bottom)' Color.White);
Magic Number,Engine.Debugging.Graphs.Implementations,FPSGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\FPSGraph.cs,DrawGraph,The following statement contains a magic number: BasicShapes.DrawSolidPolygon(this.PrimitiveBatch' BackgroundPolygon' 4' Color.Black' true);
Magic Number,Engine.Debugging.Graphs.Implementations,FPSGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\FPSGraph.cs,DrawGraph,The following statement contains a magic number: if (GraphValues.Count <= 2)                  return;
Magic Number,Engine.Debugging.Graphs.Implementations,MemGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\MemGraph.cs,Update,The following statement contains a magic number: if (GraphValues.Count <= 2)                  return;
Magic Number,Engine.Debugging.Graphs.Implementations,MemGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\MemGraph.cs,DrawGraph,The following statement contains a magic number: BasicShapes.DrawSolidPolygon(this.PrimitiveBatch' BackgroundPolygon' 4' Color.Black' true);
Magic Number,Engine.Debugging.Graphs.Implementations,MemGraph,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Graphs\Implementations\MemGraph.cs,DrawGraph,The following statement contains a magic number: if (GraphValues.Count <= 2)                  return;
Magic Number,Engine.Debugging.Ingame,BoundingBoxRenderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Ingame\BoundingBoxRenderer.cs,Render,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  verts[i].Position = corners[i];                  verts[i].Color = color;              }
Magic Number,Engine.Debugging.Ingame,BoundingBoxRenderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Ingame\BoundingBoxRenderer.cs,Render,The following statement contains a magic number: foreach (EffectPass pass in effect.CurrentTechnique.Passes)              {                  pass.Apply();                  graphicsDevice.DrawUserIndexedPrimitives(PrimitiveType.LineList' verts' 0' 8' indices' 0'                                                           indices.Length/2);              }
Magic Number,Engine.Debugging.Ingame,BoundingBoxRenderer,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Ingame\BoundingBoxRenderer.cs,Render,The following statement contains a magic number: foreach (EffectPass pass in effect.CurrentTechnique.Passes)              {                  pass.Apply();                  graphicsDevice.DrawUserIndexedPrimitives(PrimitiveType.LineList' verts' 0' 8' indices' 0'                                                           indices.Length/2);              }
Magic Number,Engine.Debugging.Timing,Layout,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Timing\Layout.cs,Place,The following statement contains a magic number: if ((alignment & Alignment.Left) != 0)              {                  region.X = ClientArea.X + (int)(ClientArea.Width * horizontalMargin);              }              else if ((alignment & Alignment.Right) != 0)              {                  region.X = ClientArea.X +                              (int)(ClientArea.Width * (1.0f - horizontalMargin)) -                              region.Width;              }              else if ((alignment & Alignment.HorizontalCenter) != 0)              {                  region.X = ClientArea.X + (ClientArea.Width - region.Width) / 2 +                              (int)(horizontalMargin * ClientArea.Width);              }              else              {                  // Don't do layout.              }
Magic Number,Engine.Debugging.Timing,Layout,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Timing\Layout.cs,Place,The following statement contains a magic number: if ((alignment & Alignment.Top) != 0)              {                  region.Y = ClientArea.Y + (int)(ClientArea.Height * verticalMargine);              }              else if ((alignment & Alignment.Bottom) != 0)              {                  region.Y = ClientArea.Y +                              (int)(ClientArea.Height * (1.0f - verticalMargine)) -                              region.Height;              }              else if ((alignment & Alignment.VerticalCenter) != 0)              {                  region.Y = ClientArea.Y + (ClientArea.Height - region.Height) / 2 +                              (int)(verticalMargine * ClientArea.Height);              }              else              {                  // Don't do layout.              }
Magic Number,Engine.Debugging.Timing,TimeRuler,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Timing\TimeRuler.cs,Initialize,The following statement contains a magic number: logs = new FrameLog[2];
Magic Number,Engine.Debugging.Timing,TimeRuler,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Timing\TimeRuler.cs,Draw,The following statement contains a magic number: foreach (MarkerCollection bar in prevLog.Bars)              {                  if (bar.MarkCount > 0)                  {                      height += BarHeight + BarPadding * 2;                      maxTime = Math.Max(maxTime'                                              bar.Markers[bar.MarkCount - 1].EndTime);                  }              }
Magic Number,Engine.Debugging.Timing,TimeRuler,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Timing\TimeRuler.cs,Draw,The following statement contains a magic number: spriteBatch.Draw(texture' rc' new Color(0' 0' 0' 128));
Magic Number,Engine.Debugging.Timing,TimeRuler,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Timing\TimeRuler.cs,Draw,The following statement contains a magic number: if (ShowLog)              {                  // Generate log string.                  y = startY - debugFont.LineSpacing;                  logString.Length = 0;                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              if (logString.Length > 0)                                  logString.Append("\n");                                logString.Append(" Bar ");                              logString.AppendNumber(i);                              logString.Append(" ");                              logString.Append(markerInfo.Name);                                logString.Append(" Avg.:");                              logString.AppendNumber(markerInfo.Logs[i].SnapAvg);                              logString.Append("ms ");                                y -= debugFont.LineSpacing;                          }                      }                  }                    // Compute background size and draw it.                  Vector2 size = debugFont.MeasureString(logString);                  rc = new Rectangle((int)position.X' (int)y' (int)size.X + 12' (int)size.Y);                  spriteBatch.Draw(texture' rc' new Color(0' 0' 0' 128));                    // Draw log string.                  spriteBatch.DrawString(debugFont' logString'                                          new Vector2(position.X + 12' y)' Color.White);                      // Draw log color boxes.                  y += (int)((float)debugFont.LineSpacing * 0.3f);                  rc = new Rectangle((int)position.X + 4' y' 10' 10);                  Rectangle rc2 = new Rectangle((int)position.X + 5' y + 1' 8' 8);                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              rc.Y = y;                              rc2.Y = y + 1;                              spriteBatch.Draw(texture' rc' Color.White);                              spriteBatch.Draw(texture' rc2' markerInfo.Logs[i].Color);                                y += debugFont.LineSpacing;                          }                      }                  }                  }
Magic Number,Engine.Debugging.Timing,TimeRuler,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Timing\TimeRuler.cs,Draw,The following statement contains a magic number: if (ShowLog)              {                  // Generate log string.                  y = startY - debugFont.LineSpacing;                  logString.Length = 0;                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              if (logString.Length > 0)                                  logString.Append("\n");                                logString.Append(" Bar ");                              logString.AppendNumber(i);                              logString.Append(" ");                              logString.Append(markerInfo.Name);                                logString.Append(" Avg.:");                              logString.AppendNumber(markerInfo.Logs[i].SnapAvg);                              logString.Append("ms ");                                y -= debugFont.LineSpacing;                          }                      }                  }                    // Compute background size and draw it.                  Vector2 size = debugFont.MeasureString(logString);                  rc = new Rectangle((int)position.X' (int)y' (int)size.X + 12' (int)size.Y);                  spriteBatch.Draw(texture' rc' new Color(0' 0' 0' 128));                    // Draw log string.                  spriteBatch.DrawString(debugFont' logString'                                          new Vector2(position.X + 12' y)' Color.White);                      // Draw log color boxes.                  y += (int)((float)debugFont.LineSpacing * 0.3f);                  rc = new Rectangle((int)position.X + 4' y' 10' 10);                  Rectangle rc2 = new Rectangle((int)position.X + 5' y + 1' 8' 8);                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              rc.Y = y;                              rc2.Y = y + 1;                              spriteBatch.Draw(texture' rc' Color.White);                              spriteBatch.Draw(texture' rc2' markerInfo.Logs[i].Color);                                y += debugFont.LineSpacing;                          }                      }                  }                  }
Magic Number,Engine.Debugging.Timing,TimeRuler,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Timing\TimeRuler.cs,Draw,The following statement contains a magic number: if (ShowLog)              {                  // Generate log string.                  y = startY - debugFont.LineSpacing;                  logString.Length = 0;                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              if (logString.Length > 0)                                  logString.Append("\n");                                logString.Append(" Bar ");                              logString.AppendNumber(i);                              logString.Append(" ");                              logString.Append(markerInfo.Name);                                logString.Append(" Avg.:");                              logString.AppendNumber(markerInfo.Logs[i].SnapAvg);                              logString.Append("ms ");                                y -= debugFont.LineSpacing;                          }                      }                  }                    // Compute background size and draw it.                  Vector2 size = debugFont.MeasureString(logString);                  rc = new Rectangle((int)position.X' (int)y' (int)size.X + 12' (int)size.Y);                  spriteBatch.Draw(texture' rc' new Color(0' 0' 0' 128));                    // Draw log string.                  spriteBatch.DrawString(debugFont' logString'                                          new Vector2(position.X + 12' y)' Color.White);                      // Draw log color boxes.                  y += (int)((float)debugFont.LineSpacing * 0.3f);                  rc = new Rectangle((int)position.X + 4' y' 10' 10);                  Rectangle rc2 = new Rectangle((int)position.X + 5' y + 1' 8' 8);                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              rc.Y = y;                              rc2.Y = y + 1;                              spriteBatch.Draw(texture' rc' Color.White);                              spriteBatch.Draw(texture' rc2' markerInfo.Logs[i].Color);                                y += debugFont.LineSpacing;                          }                      }                  }                  }
Magic Number,Engine.Debugging.Timing,TimeRuler,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Timing\TimeRuler.cs,Draw,The following statement contains a magic number: if (ShowLog)              {                  // Generate log string.                  y = startY - debugFont.LineSpacing;                  logString.Length = 0;                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              if (logString.Length > 0)                                  logString.Append("\n");                                logString.Append(" Bar ");                              logString.AppendNumber(i);                              logString.Append(" ");                              logString.Append(markerInfo.Name);                                logString.Append(" Avg.:");                              logString.AppendNumber(markerInfo.Logs[i].SnapAvg);                              logString.Append("ms ");                                y -= debugFont.LineSpacing;                          }                      }                  }                    // Compute background size and draw it.                  Vector2 size = debugFont.MeasureString(logString);                  rc = new Rectangle((int)position.X' (int)y' (int)size.X + 12' (int)size.Y);                  spriteBatch.Draw(texture' rc' new Color(0' 0' 0' 128));                    // Draw log string.                  spriteBatch.DrawString(debugFont' logString'                                          new Vector2(position.X + 12' y)' Color.White);                      // Draw log color boxes.                  y += (int)((float)debugFont.LineSpacing * 0.3f);                  rc = new Rectangle((int)position.X + 4' y' 10' 10);                  Rectangle rc2 = new Rectangle((int)position.X + 5' y + 1' 8' 8);                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              rc.Y = y;                              rc2.Y = y + 1;                              spriteBatch.Draw(texture' rc' Color.White);                              spriteBatch.Draw(texture' rc2' markerInfo.Logs[i].Color);                                y += debugFont.LineSpacing;                          }                      }                  }                  }
Magic Number,Engine.Debugging.Timing,TimeRuler,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Timing\TimeRuler.cs,Draw,The following statement contains a magic number: if (ShowLog)              {                  // Generate log string.                  y = startY - debugFont.LineSpacing;                  logString.Length = 0;                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              if (logString.Length > 0)                                  logString.Append("\n");                                logString.Append(" Bar ");                              logString.AppendNumber(i);                              logString.Append(" ");                              logString.Append(markerInfo.Name);                                logString.Append(" Avg.:");                              logString.AppendNumber(markerInfo.Logs[i].SnapAvg);                              logString.Append("ms ");                                y -= debugFont.LineSpacing;                          }                      }                  }                    // Compute background size and draw it.                  Vector2 size = debugFont.MeasureString(logString);                  rc = new Rectangle((int)position.X' (int)y' (int)size.X + 12' (int)size.Y);                  spriteBatch.Draw(texture' rc' new Color(0' 0' 0' 128));                    // Draw log string.                  spriteBatch.DrawString(debugFont' logString'                                          new Vector2(position.X + 12' y)' Color.White);                      // Draw log color boxes.                  y += (int)((float)debugFont.LineSpacing * 0.3f);                  rc = new Rectangle((int)position.X + 4' y' 10' 10);                  Rectangle rc2 = new Rectangle((int)position.X + 5' y + 1' 8' 8);                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              rc.Y = y;                              rc2.Y = y + 1;                              spriteBatch.Draw(texture' rc' Color.White);                              spriteBatch.Draw(texture' rc2' markerInfo.Logs[i].Color);                                y += debugFont.LineSpacing;                          }                      }                  }                  }
Magic Number,Engine.Debugging.Timing,TimeRuler,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Timing\TimeRuler.cs,Draw,The following statement contains a magic number: if (ShowLog)              {                  // Generate log string.                  y = startY - debugFont.LineSpacing;                  logString.Length = 0;                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              if (logString.Length > 0)                                  logString.Append("\n");                                logString.Append(" Bar ");                              logString.AppendNumber(i);                              logString.Append(" ");                              logString.Append(markerInfo.Name);                                logString.Append(" Avg.:");                              logString.AppendNumber(markerInfo.Logs[i].SnapAvg);                              logString.Append("ms ");                                y -= debugFont.LineSpacing;                          }                      }                  }                    // Compute background size and draw it.                  Vector2 size = debugFont.MeasureString(logString);                  rc = new Rectangle((int)position.X' (int)y' (int)size.X + 12' (int)size.Y);                  spriteBatch.Draw(texture' rc' new Color(0' 0' 0' 128));                    // Draw log string.                  spriteBatch.DrawString(debugFont' logString'                                          new Vector2(position.X + 12' y)' Color.White);                      // Draw log color boxes.                  y += (int)((float)debugFont.LineSpacing * 0.3f);                  rc = new Rectangle((int)position.X + 4' y' 10' 10);                  Rectangle rc2 = new Rectangle((int)position.X + 5' y + 1' 8' 8);                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              rc.Y = y;                              rc2.Y = y + 1;                              spriteBatch.Draw(texture' rc' Color.White);                              spriteBatch.Draw(texture' rc2' markerInfo.Logs[i].Color);                                y += debugFont.LineSpacing;                          }                      }                  }                  }
Magic Number,Engine.Debugging.Timing,TimeRuler,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Timing\TimeRuler.cs,Draw,The following statement contains a magic number: if (ShowLog)              {                  // Generate log string.                  y = startY - debugFont.LineSpacing;                  logString.Length = 0;                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              if (logString.Length > 0)                                  logString.Append("\n");                                logString.Append(" Bar ");                              logString.AppendNumber(i);                              logString.Append(" ");                              logString.Append(markerInfo.Name);                                logString.Append(" Avg.:");                              logString.AppendNumber(markerInfo.Logs[i].SnapAvg);                              logString.Append("ms ");                                y -= debugFont.LineSpacing;                          }                      }                  }                    // Compute background size and draw it.                  Vector2 size = debugFont.MeasureString(logString);                  rc = new Rectangle((int)position.X' (int)y' (int)size.X + 12' (int)size.Y);                  spriteBatch.Draw(texture' rc' new Color(0' 0' 0' 128));                    // Draw log string.                  spriteBatch.DrawString(debugFont' logString'                                          new Vector2(position.X + 12' y)' Color.White);                      // Draw log color boxes.                  y += (int)((float)debugFont.LineSpacing * 0.3f);                  rc = new Rectangle((int)position.X + 4' y' 10' 10);                  Rectangle rc2 = new Rectangle((int)position.X + 5' y + 1' 8' 8);                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              rc.Y = y;                              rc2.Y = y + 1;                              spriteBatch.Draw(texture' rc' Color.White);                              spriteBatch.Draw(texture' rc2' markerInfo.Logs[i].Color);                                y += debugFont.LineSpacing;                          }                      }                  }                  }
Magic Number,Engine.Debugging.Timing,TimeRuler,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Timing\TimeRuler.cs,Draw,The following statement contains a magic number: if (ShowLog)              {                  // Generate log string.                  y = startY - debugFont.LineSpacing;                  logString.Length = 0;                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              if (logString.Length > 0)                                  logString.Append("\n");                                logString.Append(" Bar ");                              logString.AppendNumber(i);                              logString.Append(" ");                              logString.Append(markerInfo.Name);                                logString.Append(" Avg.:");                              logString.AppendNumber(markerInfo.Logs[i].SnapAvg);                              logString.Append("ms ");                                y -= debugFont.LineSpacing;                          }                      }                  }                    // Compute background size and draw it.                  Vector2 size = debugFont.MeasureString(logString);                  rc = new Rectangle((int)position.X' (int)y' (int)size.X + 12' (int)size.Y);                  spriteBatch.Draw(texture' rc' new Color(0' 0' 0' 128));                    // Draw log string.                  spriteBatch.DrawString(debugFont' logString'                                          new Vector2(position.X + 12' y)' Color.White);                      // Draw log color boxes.                  y += (int)((float)debugFont.LineSpacing * 0.3f);                  rc = new Rectangle((int)position.X + 4' y' 10' 10);                  Rectangle rc2 = new Rectangle((int)position.X + 5' y + 1' 8' 8);                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              rc.Y = y;                              rc2.Y = y + 1;                              spriteBatch.Draw(texture' rc' Color.White);                              spriteBatch.Draw(texture' rc2' markerInfo.Logs[i].Color);                                y += debugFont.LineSpacing;                          }                      }                  }                  }
Magic Number,Engine.Debugging.Timing,TimeRuler,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Debugging\Timing\TimeRuler.cs,Draw,The following statement contains a magic number: if (ShowLog)              {                  // Generate log string.                  y = startY - debugFont.LineSpacing;                  logString.Length = 0;                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              if (logString.Length > 0)                                  logString.Append("\n");                                logString.Append(" Bar ");                              logString.AppendNumber(i);                              logString.Append(" ");                              logString.Append(markerInfo.Name);                                logString.Append(" Avg.:");                              logString.AppendNumber(markerInfo.Logs[i].SnapAvg);                              logString.Append("ms ");                                y -= debugFont.LineSpacing;                          }                      }                  }                    // Compute background size and draw it.                  Vector2 size = debugFont.MeasureString(logString);                  rc = new Rectangle((int)position.X' (int)y' (int)size.X + 12' (int)size.Y);                  spriteBatch.Draw(texture' rc' new Color(0' 0' 0' 128));                    // Draw log string.                  spriteBatch.DrawString(debugFont' logString'                                          new Vector2(position.X + 12' y)' Color.White);                      // Draw log color boxes.                  y += (int)((float)debugFont.LineSpacing * 0.3f);                  rc = new Rectangle((int)position.X + 4' y' 10' 10);                  Rectangle rc2 = new Rectangle((int)position.X + 5' y + 1' 8' 8);                  foreach (MarkerInfo markerInfo in markers)                  {                      for (int i = 0; i < MaxBars; ++i)                      {                          if (markerInfo.Logs[i].Initialized)                          {                              rc.Y = y;                              rc2.Y = y + 1;                              spriteBatch.Draw(texture' rc' Color.White);                              spriteBatch.Draw(texture' rc2' markerInfo.Logs[i].Color);                                y += debugFont.LineSpacing;                          }                      }                  }                  }
Magic Number,Engine.Graphics,Camera,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Camera.cs,RotateCamera,The following statement contains a magic number: this.CurrentRotation -= RotationSpeed*(step/25);
Magic Number,Engine.Graphics,Camera,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Camera.cs,ElevateCamera,The following statement contains a magic number: this.CurrentElevation -= RotationSpeed*(step/25);
Magic Number,Engine.Graphics.Drawing,BasicShapes,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Drawing\BasicShapes.cs,DrawSolidPolygon,The following statement contains a magic number: if (count == 2)              {                  DrawPolygon(primitiveBatch' vertices' count' color);                  return;              }
Magic Number,Engine.Graphics.Drawing,PrimitiveBatch,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Drawing\PrimitiveBatch.cs,PrimitiveBatch,The following statement contains a magic number: _triangleVertices = new VertexPositionColor[bufferSize - bufferSize%3];
Magic Number,Engine.Graphics.Drawing,PrimitiveBatch,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Drawing\PrimitiveBatch.cs,PrimitiveBatch,The following statement contains a magic number: _lineVertices = new VertexPositionColor[bufferSize - bufferSize%2];
Magic Number,Engine.Graphics.Drawing,PrimitiveBatch,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Drawing\PrimitiveBatch.cs,FlushTriangles,The following statement contains a magic number: if (_triangleVertsCount >= 3)              {                  int primitiveCount = _triangleVertsCount/3;                    // submit the draw call to the graphics card                  _device.SamplerStates[0] = SamplerState.AnisotropicClamp;                  _device.DrawUserPrimitives(PrimitiveType.TriangleList' _triangleVertices' 0' primitiveCount);                  _triangleVertsCount -= primitiveCount*3;              }
Magic Number,Engine.Graphics.Drawing,PrimitiveBatch,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Drawing\PrimitiveBatch.cs,FlushTriangles,The following statement contains a magic number: if (_triangleVertsCount >= 3)              {                  int primitiveCount = _triangleVertsCount/3;                    // submit the draw call to the graphics card                  _device.SamplerStates[0] = SamplerState.AnisotropicClamp;                  _device.DrawUserPrimitives(PrimitiveType.TriangleList' _triangleVertices' 0' primitiveCount);                  _triangleVertsCount -= primitiveCount*3;              }
Magic Number,Engine.Graphics.Drawing,PrimitiveBatch,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Drawing\PrimitiveBatch.cs,FlushTriangles,The following statement contains a magic number: if (_triangleVertsCount >= 3)              {                  int primitiveCount = _triangleVertsCount/3;                    // submit the draw call to the graphics card                  _device.SamplerStates[0] = SamplerState.AnisotropicClamp;                  _device.DrawUserPrimitives(PrimitiveType.TriangleList' _triangleVertices' 0' primitiveCount);                  _triangleVertsCount -= primitiveCount*3;              }
Magic Number,Engine.Graphics.Drawing,PrimitiveBatch,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Drawing\PrimitiveBatch.cs,FlushLines,The following statement contains a magic number: if (_lineVertsCount >= 2)              {                  int primitiveCount = _lineVertsCount/2;                    // submit the draw call to the graphics card                  _device.SamplerStates[0] = SamplerState.AnisotropicClamp;                  _device.DrawUserPrimitives(PrimitiveType.LineList' _lineVertices' 0' primitiveCount);                  _lineVertsCount -= primitiveCount*2;              }
Magic Number,Engine.Graphics.Drawing,PrimitiveBatch,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Drawing\PrimitiveBatch.cs,FlushLines,The following statement contains a magic number: if (_lineVertsCount >= 2)              {                  int primitiveCount = _lineVertsCount/2;                    // submit the draw call to the graphics card                  _device.SamplerStates[0] = SamplerState.AnisotropicClamp;                  _device.DrawUserPrimitives(PrimitiveType.LineList' _lineVertices' 0' primitiveCount);                  _lineVertsCount -= primitiveCount*2;              }
Magic Number,Engine.Graphics.Drawing,PrimitiveBatch,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Drawing\PrimitiveBatch.cs,FlushLines,The following statement contains a magic number: if (_lineVertsCount >= 2)              {                  int primitiveCount = _lineVertsCount/2;                    // submit the draw call to the graphics card                  _device.SamplerStates[0] = SamplerState.AnisotropicClamp;                  _device.DrawUserPrimitives(PrimitiveType.LineList' _lineVertices' 0' primitiveCount);                  _lineVertsCount -= primitiveCount*2;              }
Magic Number,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,LoadContent,The following statement contains a magic number: width /= 2;
Magic Number,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,LoadContent,The following statement contains a magic number: height /= 2;
Magic Number,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < sampleCount / 2; i++)              {                  // Store weights for the positive and negative taps.                  float weight = ComputeGaussian(i + 1);                    sampleWeights[i * 2 + 1] = weight;                  sampleWeights[i * 2 + 2] = weight;                    totalWeights += weight * 2;                    // To get the maximum amount of blurring from a limited number of                  // pixel shader samples' we take advantage of the bilinear filtering                  // hardware inside the texture fetch unit. If we position our texture                  // coordinates exactly halfway between two texels' the filtering unit                  // will average them for us' giving two samples for the price of one.                  // This allows us to step in units of two texels per sample' rather                  // than just one at a time. The 1.5 offset kicks things off by                  // positioning us nicely in between two texels.                  float sampleOffset = i * 2 + 1.5f;                    Vector2 delta = new Vector2(dx' dy) * sampleOffset;                    // Store texture coordinate offsets for the positive and negative taps.                  sampleOffsets[i * 2 + 1] = delta;                  sampleOffsets[i * 2 + 2] = -delta;              }
Magic Number,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < sampleCount / 2; i++)              {                  // Store weights for the positive and negative taps.                  float weight = ComputeGaussian(i + 1);                    sampleWeights[i * 2 + 1] = weight;                  sampleWeights[i * 2 + 2] = weight;                    totalWeights += weight * 2;                    // To get the maximum amount of blurring from a limited number of                  // pixel shader samples' we take advantage of the bilinear filtering                  // hardware inside the texture fetch unit. If we position our texture                  // coordinates exactly halfway between two texels' the filtering unit                  // will average them for us' giving two samples for the price of one.                  // This allows us to step in units of two texels per sample' rather                  // than just one at a time. The 1.5 offset kicks things off by                  // positioning us nicely in between two texels.                  float sampleOffset = i * 2 + 1.5f;                    Vector2 delta = new Vector2(dx' dy) * sampleOffset;                    // Store texture coordinate offsets for the positive and negative taps.                  sampleOffsets[i * 2 + 1] = delta;                  sampleOffsets[i * 2 + 2] = -delta;              }
Magic Number,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < sampleCount / 2; i++)              {                  // Store weights for the positive and negative taps.                  float weight = ComputeGaussian(i + 1);                    sampleWeights[i * 2 + 1] = weight;                  sampleWeights[i * 2 + 2] = weight;                    totalWeights += weight * 2;                    // To get the maximum amount of blurring from a limited number of                  // pixel shader samples' we take advantage of the bilinear filtering                  // hardware inside the texture fetch unit. If we position our texture                  // coordinates exactly halfway between two texels' the filtering unit                  // will average them for us' giving two samples for the price of one.                  // This allows us to step in units of two texels per sample' rather                  // than just one at a time. The 1.5 offset kicks things off by                  // positioning us nicely in between two texels.                  float sampleOffset = i * 2 + 1.5f;                    Vector2 delta = new Vector2(dx' dy) * sampleOffset;                    // Store texture coordinate offsets for the positive and negative taps.                  sampleOffsets[i * 2 + 1] = delta;                  sampleOffsets[i * 2 + 2] = -delta;              }
Magic Number,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < sampleCount / 2; i++)              {                  // Store weights for the positive and negative taps.                  float weight = ComputeGaussian(i + 1);                    sampleWeights[i * 2 + 1] = weight;                  sampleWeights[i * 2 + 2] = weight;                    totalWeights += weight * 2;                    // To get the maximum amount of blurring from a limited number of                  // pixel shader samples' we take advantage of the bilinear filtering                  // hardware inside the texture fetch unit. If we position our texture                  // coordinates exactly halfway between two texels' the filtering unit                  // will average them for us' giving two samples for the price of one.                  // This allows us to step in units of two texels per sample' rather                  // than just one at a time. The 1.5 offset kicks things off by                  // positioning us nicely in between two texels.                  float sampleOffset = i * 2 + 1.5f;                    Vector2 delta = new Vector2(dx' dy) * sampleOffset;                    // Store texture coordinate offsets for the positive and negative taps.                  sampleOffsets[i * 2 + 1] = delta;                  sampleOffsets[i * 2 + 2] = -delta;              }
Magic Number,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < sampleCount / 2; i++)              {                  // Store weights for the positive and negative taps.                  float weight = ComputeGaussian(i + 1);                    sampleWeights[i * 2 + 1] = weight;                  sampleWeights[i * 2 + 2] = weight;                    totalWeights += weight * 2;                    // To get the maximum amount of blurring from a limited number of                  // pixel shader samples' we take advantage of the bilinear filtering                  // hardware inside the texture fetch unit. If we position our texture                  // coordinates exactly halfway between two texels' the filtering unit                  // will average them for us' giving two samples for the price of one.                  // This allows us to step in units of two texels per sample' rather                  // than just one at a time. The 1.5 offset kicks things off by                  // positioning us nicely in between two texels.                  float sampleOffset = i * 2 + 1.5f;                    Vector2 delta = new Vector2(dx' dy) * sampleOffset;                    // Store texture coordinate offsets for the positive and negative taps.                  sampleOffsets[i * 2 + 1] = delta;                  sampleOffsets[i * 2 + 2] = -delta;              }
Magic Number,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < sampleCount / 2; i++)              {                  // Store weights for the positive and negative taps.                  float weight = ComputeGaussian(i + 1);                    sampleWeights[i * 2 + 1] = weight;                  sampleWeights[i * 2 + 2] = weight;                    totalWeights += weight * 2;                    // To get the maximum amount of blurring from a limited number of                  // pixel shader samples' we take advantage of the bilinear filtering                  // hardware inside the texture fetch unit. If we position our texture                  // coordinates exactly halfway between two texels' the filtering unit                  // will average them for us' giving two samples for the price of one.                  // This allows us to step in units of two texels per sample' rather                  // than just one at a time. The 1.5 offset kicks things off by                  // positioning us nicely in between two texels.                  float sampleOffset = i * 2 + 1.5f;                    Vector2 delta = new Vector2(dx' dy) * sampleOffset;                    // Store texture coordinate offsets for the positive and negative taps.                  sampleOffsets[i * 2 + 1] = delta;                  sampleOffsets[i * 2 + 2] = -delta;              }
Magic Number,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < sampleCount / 2; i++)              {                  // Store weights for the positive and negative taps.                  float weight = ComputeGaussian(i + 1);                    sampleWeights[i * 2 + 1] = weight;                  sampleWeights[i * 2 + 2] = weight;                    totalWeights += weight * 2;                    // To get the maximum amount of blurring from a limited number of                  // pixel shader samples' we take advantage of the bilinear filtering                  // hardware inside the texture fetch unit. If we position our texture                  // coordinates exactly halfway between two texels' the filtering unit                  // will average them for us' giving two samples for the price of one.                  // This allows us to step in units of two texels per sample' rather                  // than just one at a time. The 1.5 offset kicks things off by                  // positioning us nicely in between two texels.                  float sampleOffset = i * 2 + 1.5f;                    Vector2 delta = new Vector2(dx' dy) * sampleOffset;                    // Store texture coordinate offsets for the positive and negative taps.                  sampleOffsets[i * 2 + 1] = delta;                  sampleOffsets[i * 2 + 2] = -delta;              }
Magic Number,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < sampleCount / 2; i++)              {                  // Store weights for the positive and negative taps.                  float weight = ComputeGaussian(i + 1);                    sampleWeights[i * 2 + 1] = weight;                  sampleWeights[i * 2 + 2] = weight;                    totalWeights += weight * 2;                    // To get the maximum amount of blurring from a limited number of                  // pixel shader samples' we take advantage of the bilinear filtering                  // hardware inside the texture fetch unit. If we position our texture                  // coordinates exactly halfway between two texels' the filtering unit                  // will average them for us' giving two samples for the price of one.                  // This allows us to step in units of two texels per sample' rather                  // than just one at a time. The 1.5 offset kicks things off by                  // positioning us nicely in between two texels.                  float sampleOffset = i * 2 + 1.5f;                    Vector2 delta = new Vector2(dx' dy) * sampleOffset;                    // Store texture coordinate offsets for the positive and negative taps.                  sampleOffsets[i * 2 + 1] = delta;                  sampleOffsets[i * 2 + 2] = -delta;              }
Magic Number,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,SetBlurEffectParameters,The following statement contains a magic number: for (int i = 0; i < sampleCount / 2; i++)              {                  // Store weights for the positive and negative taps.                  float weight = ComputeGaussian(i + 1);                    sampleWeights[i * 2 + 1] = weight;                  sampleWeights[i * 2 + 2] = weight;                    totalWeights += weight * 2;                    // To get the maximum amount of blurring from a limited number of                  // pixel shader samples' we take advantage of the bilinear filtering                  // hardware inside the texture fetch unit. If we position our texture                  // coordinates exactly halfway between two texels' the filtering unit                  // will average them for us' giving two samples for the price of one.                  // This allows us to step in units of two texels per sample' rather                  // than just one at a time. The 1.5 offset kicks things off by                  // positioning us nicely in between two texels.                  float sampleOffset = i * 2 + 1.5f;                    Vector2 delta = new Vector2(dx' dy) * sampleOffset;                    // Store texture coordinate offsets for the positive and negative taps.                  sampleOffsets[i * 2 + 1] = delta;                  sampleOffsets[i * 2 + 2] = -delta;              }
Magic Number,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,ComputeGaussian,The following statement contains a magic number: return (float)((1.0 / Math.Sqrt(2 * Math.PI * theta)) *                             Math.Exp(-(n * n) / (2 * theta * theta)));
Magic Number,Engine.Graphics.Effects.PostProcessing.Bloom,BloomComponent,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Effects\PostProcessing\Bloom\BloomComponent.cs,ComputeGaussian,The following statement contains a magic number: return (float)((1.0 / Math.Sqrt(2 * Math.PI * theta)) *                             Math.Exp(-(n * n) / (2 * theta * theta)));
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,BuildBlockTextureMappings,The following statement contains a magic number: for (int i = 0; i < (int) BlockTexture.Maximum; i++)              {                  BlockTextureMappings.Add((i*6)' GetBlockTextureMapping(i' BlockFaceDirection.XIncreasing)); // build x-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 1' GetBlockTextureMapping(i' BlockFaceDirection.XDecreasing)); // build x-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 2' GetBlockTextureMapping(i' BlockFaceDirection.YIncreasing)); // build y-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 3' GetBlockTextureMapping(i' BlockFaceDirection.YDecreasing)); // build y-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 4' GetBlockTextureMapping(i' BlockFaceDirection.ZIncreasing)); // build z-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 5' GetBlockTextureMapping(i' BlockFaceDirection.ZDecreasing)); // build z-increasing mapping for the texture.                 }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,BuildBlockTextureMappings,The following statement contains a magic number: for (int i = 0; i < (int) BlockTexture.Maximum; i++)              {                  BlockTextureMappings.Add((i*6)' GetBlockTextureMapping(i' BlockFaceDirection.XIncreasing)); // build x-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 1' GetBlockTextureMapping(i' BlockFaceDirection.XDecreasing)); // build x-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 2' GetBlockTextureMapping(i' BlockFaceDirection.YIncreasing)); // build y-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 3' GetBlockTextureMapping(i' BlockFaceDirection.YDecreasing)); // build y-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 4' GetBlockTextureMapping(i' BlockFaceDirection.ZIncreasing)); // build z-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 5' GetBlockTextureMapping(i' BlockFaceDirection.ZDecreasing)); // build z-increasing mapping for the texture.                 }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,BuildBlockTextureMappings,The following statement contains a magic number: for (int i = 0; i < (int) BlockTexture.Maximum; i++)              {                  BlockTextureMappings.Add((i*6)' GetBlockTextureMapping(i' BlockFaceDirection.XIncreasing)); // build x-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 1' GetBlockTextureMapping(i' BlockFaceDirection.XDecreasing)); // build x-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 2' GetBlockTextureMapping(i' BlockFaceDirection.YIncreasing)); // build y-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 3' GetBlockTextureMapping(i' BlockFaceDirection.YDecreasing)); // build y-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 4' GetBlockTextureMapping(i' BlockFaceDirection.ZIncreasing)); // build z-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 5' GetBlockTextureMapping(i' BlockFaceDirection.ZDecreasing)); // build z-increasing mapping for the texture.                 }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,BuildBlockTextureMappings,The following statement contains a magic number: for (int i = 0; i < (int) BlockTexture.Maximum; i++)              {                  BlockTextureMappings.Add((i*6)' GetBlockTextureMapping(i' BlockFaceDirection.XIncreasing)); // build x-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 1' GetBlockTextureMapping(i' BlockFaceDirection.XDecreasing)); // build x-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 2' GetBlockTextureMapping(i' BlockFaceDirection.YIncreasing)); // build y-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 3' GetBlockTextureMapping(i' BlockFaceDirection.YDecreasing)); // build y-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 4' GetBlockTextureMapping(i' BlockFaceDirection.ZIncreasing)); // build z-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 5' GetBlockTextureMapping(i' BlockFaceDirection.ZDecreasing)); // build z-increasing mapping for the texture.                 }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,BuildBlockTextureMappings,The following statement contains a magic number: for (int i = 0; i < (int) BlockTexture.Maximum; i++)              {                  BlockTextureMappings.Add((i*6)' GetBlockTextureMapping(i' BlockFaceDirection.XIncreasing)); // build x-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 1' GetBlockTextureMapping(i' BlockFaceDirection.XDecreasing)); // build x-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 2' GetBlockTextureMapping(i' BlockFaceDirection.YIncreasing)); // build y-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 3' GetBlockTextureMapping(i' BlockFaceDirection.YDecreasing)); // build y-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 4' GetBlockTextureMapping(i' BlockFaceDirection.ZIncreasing)); // build z-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 5' GetBlockTextureMapping(i' BlockFaceDirection.ZDecreasing)); // build z-increasing mapping for the texture.                 }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,BuildBlockTextureMappings,The following statement contains a magic number: for (int i = 0; i < (int) BlockTexture.Maximum; i++)              {                  BlockTextureMappings.Add((i*6)' GetBlockTextureMapping(i' BlockFaceDirection.XIncreasing)); // build x-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 1' GetBlockTextureMapping(i' BlockFaceDirection.XDecreasing)); // build x-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 2' GetBlockTextureMapping(i' BlockFaceDirection.YIncreasing)); // build y-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 3' GetBlockTextureMapping(i' BlockFaceDirection.YDecreasing)); // build y-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 4' GetBlockTextureMapping(i' BlockFaceDirection.ZIncreasing)); // build z-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 5' GetBlockTextureMapping(i' BlockFaceDirection.ZDecreasing)); // build z-increasing mapping for the texture.                 }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,BuildBlockTextureMappings,The following statement contains a magic number: for (int i = 0; i < (int) BlockTexture.Maximum; i++)              {                  BlockTextureMappings.Add((i*6)' GetBlockTextureMapping(i' BlockFaceDirection.XIncreasing)); // build x-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 1' GetBlockTextureMapping(i' BlockFaceDirection.XDecreasing)); // build x-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 2' GetBlockTextureMapping(i' BlockFaceDirection.YIncreasing)); // build y-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 3' GetBlockTextureMapping(i' BlockFaceDirection.YDecreasing)); // build y-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 4' GetBlockTextureMapping(i' BlockFaceDirection.ZIncreasing)); // build z-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 5' GetBlockTextureMapping(i' BlockFaceDirection.ZDecreasing)); // build z-increasing mapping for the texture.                 }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,BuildBlockTextureMappings,The following statement contains a magic number: for (int i = 0; i < (int) BlockTexture.Maximum; i++)              {                  BlockTextureMappings.Add((i*6)' GetBlockTextureMapping(i' BlockFaceDirection.XIncreasing)); // build x-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 1' GetBlockTextureMapping(i' BlockFaceDirection.XDecreasing)); // build x-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 2' GetBlockTextureMapping(i' BlockFaceDirection.YIncreasing)); // build y-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 3' GetBlockTextureMapping(i' BlockFaceDirection.YDecreasing)); // build y-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 4' GetBlockTextureMapping(i' BlockFaceDirection.ZIncreasing)); // build z-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 5' GetBlockTextureMapping(i' BlockFaceDirection.ZDecreasing)); // build z-increasing mapping for the texture.                 }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,BuildBlockTextureMappings,The following statement contains a magic number: for (int i = 0; i < (int) BlockTexture.Maximum; i++)              {                  BlockTextureMappings.Add((i*6)' GetBlockTextureMapping(i' BlockFaceDirection.XIncreasing)); // build x-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 1' GetBlockTextureMapping(i' BlockFaceDirection.XDecreasing)); // build x-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 2' GetBlockTextureMapping(i' BlockFaceDirection.YIncreasing)); // build y-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 3' GetBlockTextureMapping(i' BlockFaceDirection.YDecreasing)); // build y-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 4' GetBlockTextureMapping(i' BlockFaceDirection.ZIncreasing)); // build z-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 5' GetBlockTextureMapping(i' BlockFaceDirection.ZDecreasing)); // build z-increasing mapping for the texture.                 }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,BuildBlockTextureMappings,The following statement contains a magic number: for (int i = 0; i < (int) BlockTexture.Maximum; i++)              {                  BlockTextureMappings.Add((i*6)' GetBlockTextureMapping(i' BlockFaceDirection.XIncreasing)); // build x-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 1' GetBlockTextureMapping(i' BlockFaceDirection.XDecreasing)); // build x-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 2' GetBlockTextureMapping(i' BlockFaceDirection.YIncreasing)); // build y-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 3' GetBlockTextureMapping(i' BlockFaceDirection.YDecreasing)); // build y-decreasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 4' GetBlockTextureMapping(i' BlockFaceDirection.ZIncreasing)); // build z-increasing mapping for the texture.                  BlockTextureMappings.Add((i*6) + 5' GetBlockTextureMapping(i' BlockFaceDirection.ZDecreasing)); // build z-increasing mapping for the texture.                 }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: var mapping = new HalfVector2[6];
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following statement contains a magic number: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Magic Number,Engine.Input,InputManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Input\InputManager.cs,ProcessMouse,The following statement contains a magic number: float rotation = currentState.X - Core.Engine.Instance.Configuration.Graphics.Width / 2;
Magic Number,Engine.Input,InputManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Input\InputManager.cs,ProcessMouse,The following statement contains a magic number: float elevation = currentState.Y - Core.Engine.Instance.Configuration.Graphics.Height / 2;
Magic Number,Engine.Input,InputManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Input\InputManager.cs,CenterCursor,The following statement contains a magic number: Mouse.SetPosition(Game.Window.ClientBounds.Width/2' Game.Window.ClientBounds.Height/2);
Magic Number,Engine.Input,InputManager,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Input\InputManager.cs,CenterCursor,The following statement contains a magic number: Mouse.SetPosition(Game.Window.ClientBounds.Width/2' Game.Window.ClientBounds.Height/2);
Magic Number,Engine.Interface,UserInterface,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Interface\UserInterface.cs,Draw,The following statement contains a magic number: _spriteBatch.Draw(crosshairTexture'                                new Vector2((Game.GraphicsDevice.Viewport.Width/2) - 10'                                            (Game.GraphicsDevice.Viewport.Height/2) - 10)' Color.White);
Magic Number,Engine.Interface,UserInterface,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Interface\UserInterface.cs,Draw,The following statement contains a magic number: _spriteBatch.Draw(crosshairTexture'                                new Vector2((Game.GraphicsDevice.Viewport.Width/2) - 10'                                            (Game.GraphicsDevice.Viewport.Height/2) - 10)' Color.White);
Magic Number,Engine.Interface,UserInterface,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Interface\UserInterface.cs,Draw,The following statement contains a magic number: _spriteBatch.Draw(crosshairTexture'                                new Vector2((Game.GraphicsDevice.Viewport.Width/2) - 10'                                            (Game.GraphicsDevice.Viewport.Height/2) - 10)' Color.White);
Magic Number,Engine.Interface,UserInterface,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Interface\UserInterface.cs,Draw,The following statement contains a magic number: _spriteBatch.Draw(crosshairTexture'                                new Vector2((Game.GraphicsDevice.Viewport.Width/2) - 10'                                            (Game.GraphicsDevice.Viewport.Height/2) - 10)' Color.White);
Magic Number,Engine.Platforms.Android,AndroidPlatform,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Platforms\Android\AndroidPlatform.cs,AndroidPlatform,The following statement contains a magic number: this.Config = new PlatformConfig              {                  Screen =                  {                      Width = 800'                      Height = 480'                      IsFullScreen = true'                      SupportedOrientations = DisplayOrientation.LandscapeLeft | DisplayOrientation.LandscapeRight'                  }'                  Input =                  {                      IsMouseVisible = false'                  }'                  Graphics =                  {                      IsFixedTimeStep = false'                      IsVsyncEnabled = false'                      PostprocessEnabled = false'                      ExtendedEffects = true'                  }'              };
Magic Number,Engine.Platforms.Android,AndroidPlatform,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Platforms\Android\AndroidPlatform.cs,AndroidPlatform,The following statement contains a magic number: this.Config = new PlatformConfig              {                  Screen =                  {                      Width = 800'                      Height = 480'                      IsFullScreen = true'                      SupportedOrientations = DisplayOrientation.LandscapeLeft | DisplayOrientation.LandscapeRight'                  }'                  Input =                  {                      IsMouseVisible = false'                  }'                  Graphics =                  {                      IsFixedTimeStep = false'                      IsVsyncEnabled = false'                      PostprocessEnabled = false'                      ExtendedEffects = true'                  }'              };
Magic Number,Engine.Platforms.IOS,IOSPlatform,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Platforms\IOS\IOSPlatform.cs,IOSPlatform,The following statement contains a magic number: this.Config = new PlatformConfig              {                  Screen =                  {                      Width = 480'                      Height = 800'                      IsFullScreen = true'                      #if IOS                      SupportedOrientations = DisplayOrientation.FaceDown | DisplayOrientation.FaceUp'                      #endif                  }'                  Input =                  {                      IsMouseVisible = false'                  }'                  Graphics =                  {                      IsFixedTimeStep = false'                      IsVsyncEnabled = false'                      PostprocessEnabled = true'                      ExtendedEffects = false'                  }'              };
Magic Number,Engine.Platforms.IOS,IOSPlatform,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Platforms\IOS\IOSPlatform.cs,IOSPlatform,The following statement contains a magic number: this.Config = new PlatformConfig              {                  Screen =                  {                      Width = 480'                      Height = 800'                      IsFullScreen = true'                      #if IOS                      SupportedOrientations = DisplayOrientation.FaceDown | DisplayOrientation.FaceUp'                      #endif                  }'                  Input =                  {                      IsMouseVisible = false'                  }'                  Graphics =                  {                      IsFixedTimeStep = false'                      IsVsyncEnabled = false'                      PostprocessEnabled = true'                      ExtendedEffects = false'                  }'              };
Magic Number,Engine.Platforms.Linux,LinuxPlatform,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Platforms\Linux\LinuxPlatform.cs,LinuxPlatform,The following statement contains a magic number: this.Config = new PlatformConfig              {                  Screen =                  {                      IsFullScreen = false'                      Width = 1280'                      Height = 720'                  }'                  Input =                  {                      IsMouseVisible = true'                  }'                  Graphics =                  {                        IsFixedTimeStep = false'                      IsVsyncEnabled = false'                      PostprocessEnabled = false'                      ExtendedEffects = true'                  }'              };
Magic Number,Engine.Platforms.Linux,LinuxPlatform,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Platforms\Linux\LinuxPlatform.cs,LinuxPlatform,The following statement contains a magic number: this.Config = new PlatformConfig              {                  Screen =                  {                      IsFullScreen = false'                      Width = 1280'                      Height = 720'                  }'                  Input =                  {                      IsMouseVisible = true'                  }'                  Graphics =                  {                        IsFixedTimeStep = false'                      IsVsyncEnabled = false'                      PostprocessEnabled = false'                      ExtendedEffects = true'                  }'              };
Magic Number,Engine.Platforms.MacOS,MacOSPlatform,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Platforms\MacOS\MacOSPlatform.cs,MacOSPlatform,The following statement contains a magic number: this.Config = new PlatformConfig              {                  Screen =                  {                      IsFullScreen = false'                      Width = 1280'                      Height = 720'                  }'                  Input =                  {                      IsMouseVisible = true'                  }'                  Graphics =                  {                        IsFixedTimeStep = false'                      IsVsyncEnabled = false'                      PostprocessEnabled = false'                      ExtendedEffects = true'                  }'              };
Magic Number,Engine.Platforms.MacOS,MacOSPlatform,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Platforms\MacOS\MacOSPlatform.cs,MacOSPlatform,The following statement contains a magic number: this.Config = new PlatformConfig              {                  Screen =                  {                      IsFullScreen = false'                      Width = 1280'                      Height = 720'                  }'                  Input =                  {                      IsMouseVisible = true'                  }'                  Graphics =                  {                        IsFixedTimeStep = false'                      IsVsyncEnabled = false'                      PostprocessEnabled = false'                      ExtendedEffects = true'                  }'              };
Magic Number,Engine.Platforms.Windows,WindowsPlatform,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Platforms\Windows\WindowsPlatform.cs,WindowsPlatform,The following statement contains a magic number: this.Config = new PlatformConfig              {                  Screen =                  {                      IsFullScreen = false'                      Width = 1680'                      Height = 1050'                  }'                  Input =                  {                      IsMouseVisible = true'                  }'                  Graphics =                  {                      IsFixedTimeStep = false'                      IsVsyncEnabled = false'                      PostprocessEnabled = true'                      ExtendedEffects = true'                  }'              };
Magic Number,Engine.Platforms.Windows,WindowsPlatform,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Platforms\Windows\WindowsPlatform.cs,WindowsPlatform,The following statement contains a magic number: this.Config = new PlatformConfig              {                  Screen =                  {                      IsFullScreen = false'                      Width = 1680'                      Height = 1050'                  }'                  Input =                  {                      IsMouseVisible = true'                  }'                  Graphics =                  {                      IsFixedTimeStep = false'                      IsVsyncEnabled = false'                      PostprocessEnabled = true'                      ExtendedEffects = true'                  }'              };
Magic Number,Engine.Platforms.WP7,WindowsPhone7Platform,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Platforms\WP7\WindowsPhone7.cs,Initialize,The following statement contains a magic number: this.Game.TargetElapsedTime = TimeSpan.FromTicks(333333);
Magic Number,Engine.Platforms.WP8,WindowsPhone8Platform,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Platforms\WP8\WindowsPhone8Platform.cs,WindowsPhone8Platform,The following statement contains a magic number: this.Config = new PlatformConfig              {                  Screen =                  {                                          Width = 1280'                      Height = 720'                      IsFullScreen = false'                      SupportedOrientations = DisplayOrientation.LandscapeLeft | DisplayOrientation.LandscapeRight'                  }'                  Input =                  {                      IsMouseVisible = false'                  }'                  Graphics =                  {                        IsFixedTimeStep = false'                      IsVsyncEnabled = false'                      PostprocessEnabled = true'                      ExtendedEffects = true'                  }'              };
Magic Number,Engine.Platforms.WP8,WindowsPhone8Platform,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Platforms\WP8\WindowsPhone8Platform.cs,WindowsPhone8Platform,The following statement contains a magic number: this.Config = new PlatformConfig              {                  Screen =                  {                                          Width = 1280'                      Height = 720'                      IsFullScreen = false'                      SupportedOrientations = DisplayOrientation.LandscapeLeft | DisplayOrientation.LandscapeRight'                  }'                  Input =                  {                      IsMouseVisible = false'                  }'                  Graphics =                  {                        IsFixedTimeStep = false'                      IsVsyncEnabled = false'                      PostprocessEnabled = true'                      ExtendedEffects = true'                  }'              };
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,Draw,The following statement contains a magic number: foreach (var pass in this._blockEffect.CurrentTechnique.Passes)              {                  pass.Apply();                    if (IndexBuffer == null || VertexBuffer == null)                      continue;                    if (VertexBuffer.VertexCount == 0)                      continue;                    if (IndexBuffer.IndexCount == 0)                      continue;                    Game.GraphicsDevice.SetVertexBuffer(VertexBuffer);                  Game.GraphicsDevice.Indices = IndexBuffer;                  Game.GraphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleList' 0' 0' VertexBuffer.VertexCount' 0' IndexBuffer.IndexCount / 3);              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: var textureUVMappings = TextureHelper.BlockTextureMappings[(int)texture * 6 + faceIndex];
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following statement contains a magic number: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,AddVertex,The following statement contains a magic number: VertexList.Add(new BlockVertex(new Vector3(x' 128' z) + addition' textureCoordinate' 1f));
Magic Number,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,AddIndex,The following statement contains a magic number: Index += 4;
Magic Number,Engine.Universe,Player,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Player.cs,TryMove,The following statement contains a magic number: testPosition -= 2*new Vector3(0f' -0.5f' 0f);
Magic Number,Engine.Universe,Player,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Player.cs,SpawnPlayer,The following statement contains a magic number: this.Position = new Vector3(relativePosition.X*Chunk.WidthInBlocks' 150'                                          relativePosition.Z * Chunk.LengthInBlocks);
Magic Number,Engine.Universe,Shovel,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Shovel.cs,DrawInGameDebugVisual,The following statement contains a magic number: spriteBatch.DrawString(spriteFont' text' new Vector2(projected.X - textSize.X/2' projected.Y - textSize.Y/2)' Color.Yellow);
Magic Number,Engine.Universe,Shovel,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Shovel.cs,DrawInGameDebugVisual,The following statement contains a magic number: spriteBatch.DrawString(spriteFont' text' new Vector2(projected.X - textSize.X/2' projected.Y - textSize.Y/2)' Color.Yellow);
Magic Number,Engine.Universe,Sky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Sky.cs,LoadContent,The following statement contains a magic number: this._staticCloudMap = this.CreateStaticCloudMap(32);
Magic Number,Engine.Universe,Sky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Sky.cs,Draw,The following statement contains a magic number: Matrix wStarMatrix = Matrix.CreateTranslation(Vector3.Zero)*Matrix.CreateScale(100)* Matrix.CreateTranslation(new Vector3(this._camera.Position.X' this._camera.Position.Y - 40' this._camera.Position.Z));
Magic Number,Engine.Universe,Sky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Sky.cs,Draw,The following statement contains a magic number: Matrix wStarMatrix = Matrix.CreateTranslation(Vector3.Zero)*Matrix.CreateScale(100)* Matrix.CreateTranslation(new Vector3(this._camera.Position.X' this._camera.Position.Y - 40' this._camera.Position.Z));
Magic Number,Engine.Universe,Sky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Sky.cs,Draw,The following statement contains a magic number: var matrix = Matrix.CreateTranslation(Vector3.Zero)*Matrix.CreateScale(100)* Matrix.CreateTranslation(new Vector3(this._camera.Position.X' this._camera.Position.Y - 40' this._camera.Position.Z));
Magic Number,Engine.Universe,Sky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Sky.cs,Draw,The following statement contains a magic number: var matrix = Matrix.CreateTranslation(Vector3.Zero)*Matrix.CreateScale(100)* Matrix.CreateTranslation(new Vector3(this._camera.Position.X' this._camera.Position.Y - 40' this._camera.Position.Z));
Magic Number,Engine.Universe,Sky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Sky.cs,SetUpFullscreenVertices,The following statement contains a magic number: var vertices = new VertexPositionTexture[4];
Magic Number,Engine.Universe,Sky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Sky.cs,SetUpFullscreenVertices,The following statement contains a magic number: vertices[2] = new VertexPositionTexture(new Vector3(-1' -1' 0f)' new Vector2(0' 0));
Magic Number,Engine.Universe,Sky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Sky.cs,SetUpFullscreenVertices,The following statement contains a magic number: vertices[3] = new VertexPositionTexture(new Vector3(1' -1' 0f)' new Vector2(1' 0));
Magic Number,Engine.Universe,Sky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Sky.cs,CreateStaticCloudMap,The following statement contains a magic number: for (int x = 0; x < resolution; x++)                  for (int y = 0; y < resolution; y++)                      noisyColors[x + y*resolution] = new Color(new Vector3(rand.Next(1000)/1000.0f' 0' 0));
Magic Number,Engine.Universe,Sky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Sky.cs,GeneratePerlinNoise,The following statement contains a magic number: foreach (EffectPass pass in _perlinNoiseEffect.CurrentTechnique.Passes)              {                  pass.Apply();                  GraphicsDevice.DrawUserPrimitives(PrimitiveType.TriangleStrip' _fullScreenVertices' 0' 2);              }
Magic Number,Engine.Universe,Time,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Time.cs,GetRealTimeOfDay,The following statement contains a magic number: return (float) (DateTime.Now.TimeOfDay.TotalSeconds*24)/RealTimeDivisor;
Magic Number,Engine.Universe,Time,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Time.cs,GetGameTimeOfDay,The following statement contains a magic number: return 12;
Missing Default,Engine.Chunks,ChunkCache,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\ChunkCache.cs,GetNeighborChunk,The following switch statement is missing a default case: switch (edge)              {                  case Chunk.Edges.XDecreasing:                      return this.GetChunkByRelativePosition(origin.RelativePosition.X - 1' origin.RelativePosition.Z);                  case Chunk.Edges.XIncreasing:                      return this.GetChunkByRelativePosition(origin.RelativePosition.X + 1' origin.RelativePosition.Z);                  case Chunk.Edges.ZDecreasing:                      return this.GetChunkByRelativePosition(origin.RelativePosition.X' origin.RelativePosition.Z - 1);                  case Chunk.Edges.ZIncreasing:                      return this.GetChunkByRelativePosition(origin.RelativePosition.X' origin.RelativePosition.Z + 1);              }
Missing Default,Engine.Chunks.Processors,VertexBuilder,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Chunks\Processors\VertexBuilder.cs,BuildFaceVertices,The following switch statement is missing a default case: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;                    case BlockFaceDirection.XDecreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.YIncreasing:                  {                      //BL'BR'TR'BL'TR'TL                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 3' 2' 0' 3' 0' 1);                  }                  break;                    case BlockFaceDirection.YDecreasing:                  {                      //TR'BR'TL'TL'BR'BL                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[2]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[4]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 2' 1' 1' 2' 3);                  }                  break;                    case BlockFaceDirection.ZIncreasing:                  {                      //TR'TL'BL'TR'BL'BR                      AddVertex(chunk' position' new Vector3(0' 1' 1)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(1' 1' 1)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(0' 0' 1)' textureUVMappings[5]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(1' 0' 1)' textureUVMappings[2]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 3' 0' 3' 2);                  }                  break;                    case BlockFaceDirection.ZDecreasing:                  {                      //TR'TL'BR'BR'TL'BL                      AddVertex(chunk' position' new Vector3(1' 1' 0)' textureUVMappings[0]' sunLightTR' localLightTR);                      AddVertex(chunk' position' new Vector3(0' 1' 0)' textureUVMappings[1]' sunLightTL' localLightTL);                      AddVertex(chunk' position' new Vector3(1' 0' 0)' textureUVMappings[2]' sunLightBR' localLightBR);                      AddVertex(chunk' position' new Vector3(0' 0' 0)' textureUVMappings[5]' sunLightBL' localLightBL);                      AddIndex(chunk' 0' 1' 2' 2' 1' 3);                  }                  break;              }
Missing Default,Engine.Graphics.Texture,TextureHelper,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Graphics\Texture\TextureHelper.cs,GetBlockTextureMapping,The following switch statement is missing a default case: switch (direction)              {                  case BlockFaceDirection.XIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0 // first triangle.                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1 // second triangle.                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.XDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.YIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[1] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.YDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;                    case BlockFaceDirection.ZIncreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[3] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      mapping[5] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      break;                    case BlockFaceDirection.ZDecreasing:                      mapping[0] = new HalfVector2(xOffset' yOffset); // 0'0                      mapping[1] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[2] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[3] = new HalfVector2(xOffset' yOffset + UnitBlockTextureOffset); // 0'1                      mapping[4] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset); // 1'0                      mapping[5] = new HalfVector2(xOffset + UnitBlockTextureOffset' yOffset + UnitBlockTextureOffset); // 1'1                      break;              }
Missing Default,Engine.Sky,NewSky,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Sky\NewSky.cs,BuildFaceVertices,The following switch statement is missing a default case: switch (faceDir)              {                  case BlockFaceDirection.XIncreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x'z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;                    case BlockFaceDirection.XDecreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.YIncreasing:                      {                          //BL'BR'TR'BL'TR'TL                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[5]);                          AddIndex( 3' 2' 0' 3' 0' 1);                      }                      break;                    case BlockFaceDirection.YDecreasing:                      {                          //TR'BR'TL'TL'BR'BL                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[4]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 2' 1' 1' 2' 3);                      }                      break;                    case BlockFaceDirection.ZIncreasing:                      {                          //TR'TL'BL'TR'BL'BR                          AddVertex(x' z' new Vector3(0' 1' 1)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(1' 1' 1)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(0' 0' 1)' textureUVMappings[5]);                          AddVertex(x' z' new Vector3(1' 0' 1)' textureUVMappings[2]);                          AddIndex( 0' 1' 3' 0' 3' 2);                      }                      break;                    case BlockFaceDirection.ZDecreasing:                      {                          //TR'TL'BR'BR'TL'BL                          AddVertex(x' z' new Vector3(1' 1' 0)' textureUVMappings[0]);                          AddVertex(x' z' new Vector3(0' 1' 0)' textureUVMappings[1]);                          AddVertex(x' z' new Vector3(1' 0' 0)' textureUVMappings[2]);                          AddVertex(x' z' new Vector3(0' 0' 0)' textureUVMappings[5]);                          AddIndex( 0' 1' 2' 2' 1' 3);                      }                      break;              }
Missing Default,Engine.Universe,Player,C:\repos\raistlinthewiz_voxeliq\contrib\old-codebase\src\Engine\Universe\Player.cs,Move,The following switch statement is missing a default case: switch (direction)              {                  case MoveDirection.Forward:                      moveVector.Z--;                      break;                  case MoveDirection.Backward:                      moveVector.Z++;                      break;                  case MoveDirection.Left:                      moveVector.X--;                      break;                  case MoveDirection.Right:                      moveVector.X++;                      break;              }
