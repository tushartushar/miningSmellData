Implementation smell,Namespace,Class,File,Method,Description
Long Method,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The method has 100 lines of code.
Long Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The method has 113 lines of code.
Long Method,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The method has 105 lines of code.
Complex Method,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,Cyclomatic complexity of the method is 34
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,Cyclomatic complexity of the method is 15
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,SpawnPrefabsForChunk,Cyclomatic complexity of the method is 13
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,HideTileMapPrefabs,Cyclomatic complexity of the method is 13
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,Cyclomatic complexity of the method is 15
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,GetLoopOrder,Cyclomatic complexity of the method is 35
Complex Method,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,Build,Cyclomatic complexity of the method is 8
Complex Method,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildForChunk,Cyclomatic complexity of the method is 8
Complex Method,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,Cyclomatic complexity of the method is 13
Complex Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,Build,Cyclomatic complexity of the method is 9
Complex Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildForChunk,Cyclomatic complexity of the method is 13
Complex Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,Cyclomatic complexity of the method is 21
Complex Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,Cyclomatic complexity of the method is 8
Complex Method,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,Cyclomatic complexity of the method is 10
Complex Method,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,Cyclomatic complexity of the method is 20
Complex Method,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,Build,Cyclomatic complexity of the method is 12
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The method has 5 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The method has 8 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The method has 9 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The method has 7 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,SpawnPrefabsForChunk,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,GetLoopOrder,The method has 9 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,ApplySpriteVertexTileFlags,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,ApplySpriteVertexTileFlags,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,Layer,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapChunks.cs,Layer,The method has 5 parameters.
Long Parameter List,tk2dRuntime.TileMap,Layer,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapChunks.cs,Init,The method has 5 parameters.
Long Parameter List,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The method has 7 parameters.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The length of the statement  "			UnityEditor.EditorUtility.DisplayDialog ("tk2dRuntimeSpriteCollection Error"' "The tk2d/BlendVertexColor shader needs to be in a resources folder for this to work.\n\n" + "Create a subdirectory named 'resources' where the shaders are' and move the BlendVertexColor shader into this directory.\n\n" + "eg. TK2DROOT/tk2d/Shaders/Resources/BlendVertexColor\n\n" + "Be sure to do this from within Unity and not from Explorer/Finder."' "Ok"); " is 437.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The length of the statement  "		sc.spriteDefinitions [i] = CreateDefinitionForRegionInTexture (names [i]' textureDimensions' scale' regions [i]' trimRect' anchors [i]' defRotated); " is 148.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The length of the statement  "	Vector2 v0 = new Vector2 ((uvRegion.x + uvOffset.x) / fwidth' 1.0f - (uvRegion.y + uvRegion.height + uvOffset.y) / fheight); " is 124.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The length of the statement  "	Vector2 v1 = new Vector2 ((uvRegion.x + uvRegion.width - uvOffset.x) / fwidth' 1.0f - (uvRegion.y - uvOffset.y) / fheight); " is 123.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The length of the statement  "							entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4])); " is 123.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The length of the statement  "	return CreateFromTexture (texture' spriteCollectionSize' textureDimensions' names.ToArray ()' rects.ToArray ()' trimRects.ToArray ()' anchors.ToArray ()' rotated.ToArray ()); " is 174.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,The length of the statement  "			tileMap.Layers [i] = new Layer (tileMap.data.Layers [i].hash' tileMap.width' tileMap.height' tileMap.partitionSizeX' tileMap.partitionSizeY); " is 141.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,The length of the statement  "				newLayers [i] = new Layer (layerInfo.hash' tileMap.width' tileMap.height' tileMap.partitionSizeX' tileMap.partitionSizeY); " is 122.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,The length of the statement  "		tileMap.ColorChannel = new ColorChannel (tileMap.width' tileMap.height' tileMap.partitionSizeX' tileMap.partitionSizeY); " is 120.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,The length of the statement  "			layer.gameObject.transform.localPosition = new Vector3 (0' 0' tileMap.data.layersFixedZ ? (-layerInfoZ) : accumulatedLayerZ); " is 125.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,The length of the statement  "		BuilderUtil.GetLoopOrder (tileMap.data.sortMethod' layer.numColumns' layer.numRows' out x0' out x1' out dx' out y0' out y1' out dy); " is 132.
Long Statement,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The length of the statement  "					Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90); " is 136.
Long Statement,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The length of the statement  "	BuilderUtil.GetLoopOrder (tileMap.data.sortMethod' tileMap.partitionSizeX' tileMap.partitionSizeY' out x0' out x1' out dx' out y0' out y1' out dy); " is 147.
Long Statement,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The length of the statement  "				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' sprite' sprite.positions [v]' flipH' flipV' rot90); " is 121.
Long Statement,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The length of the statement  "					Color color = Color.Lerp (Color.Lerp (tileColorx0y0' tileColorx1y0' tileColorX)' Color.Lerp (tileColorx0y1' tileColorx1y1' tileColorX)' tileColorY); " is 148.
Complex Conditional,tk2dRuntime.TileMap,ColorChannel,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapChunks.cs,Optimize,The conditional expression  "c.r != clearColor32.r || c.g != clearColor32.g || c.b != clearColor32.b || c.a != clearColor32.a"  is complex.
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.indices = new int[] {  	0'  	3'  	1'  	2'  	3'  	0  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.indices = new int[] {  	0'  	3'  	1'  	2'  	3'  	0  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.indices = new int[] {  	0'  	3'  	1'  	2'  	3'  	0  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.boundsData = new Vector3[2] {  	(boundsMax + boundsMin) / 2.0f'  	(boundsMax - boundsMin)  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.untrimmedBoundsData = new Vector3[2] {  	(boundsMax + boundsMin) / 2.0f'  	(boundsMax - boundsMin)  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'i':  	break;  // ignore version field for now  case 'w':  	textureDimensions.x = Int32.Parse (line.Substring (2));  	break;  case 'h':  	textureDimensions.y = Int32.Parse (line.Substring (2));  	break;  // total number of sprites would be ideal to statically allocate  case '~':  	state++;  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'i':  	break;  // ignore version field for now  case 'w':  	textureDimensions.x = Int32.Parse (line.Substring (2));  	break;  case 'h':  	textureDimensions.y = Int32.Parse (line.Substring (2));  	break;  // total number of sprites would be ideal to statically allocate  case '~':  	state++;  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: textureDimensions.x = Int32.Parse (line.Substring (2));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: textureDimensions.y = Int32.Parse (line.Substring (2));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryName = line.Substring (2);  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRotated = Int32.Parse (line.Substring (2)) == 1;  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildForChunk,The following statement contains a magic number: if (localMeshIndices.Length > 6) {  	// Remove duplicate verts  	localMeshVertices = WeldVertices (localMeshVertices' ref localMeshIndices);  	// Remove duplicate and back-to-back faces  	// Removes inside faces  	localMeshIndices = RemoveDuplicateFaces (localMeshIndices);  	// Merge coplanar faces  	// Optimize (remove unused vertices' reindex)  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [2] = new Vector3 (max.x' min.y' min.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [3] = new Vector3 (max.x' min.y' max.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [4] = new Vector3 (min.x' max.y' min.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [5] = new Vector3 (min.x' max.y' max.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [6] = new Vector3 (max.x' max.y' min.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [7] = new Vector3 (max.x' max.y' max.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {  	Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  	vertexList.Add (flippedPos + currentPos);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,CompareDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {  	int d = indices [face0index + i] - indices [face1index + i];  	if (d != 0)  		return d;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: i += 3
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: sortedFaceIndices [i + 2] = faceIndices [2];  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: sortedFaceIndices [i + 2] = faceIndices [2];  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	sortIndex [i / 3] = i;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	sortIndex [i / 3] = i;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: i += 3
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: sortIndex [i / 3] = i;  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < sortIndex.Length; ++i) {  	if (i != sortIndex.Length - 1 && CompareDuplicateFaces (sortedFaceIndices' sortIndex [i]' sortIndex [i + 1]) == 0) {  		// skip both faces  		// this will fail in the case where there are 3 coplanar faces  		// but that is probably likely user error / intentional  		i++;  		continue;  	}  	for (int j = 0; j < 3; ++j)  		newIndices.Add (indices [sortIndex [i] + j]);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder3D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int j = 0; j < 3; ++j)  	newIndices.Add (indices [sortIndex [i] + j]);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildForChunk,The following statement contains a magic number: if (localIndices.Length > 4) {  	// Remove duplicate verts' reindex  	localVerts = WeldVertices (localVerts' ref localIndices);  	// Remove duplicate and back-to-back edges  	// Removes inside edges  	localIndices = RemoveDuplicateEdges (localIndices);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = verts.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			boxPos [0] = new Vector2 (min.x' min.y);  			boxPos [1] = new Vector2 (max.x' min.y);  			boxPos [2] = new Vector2 (max.x' max.y);  			boxPos [3] = new Vector2 (min.x' max.y);  			for (int i = 0; i < 4; ++i) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  			}  			int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  			for (int i = 0; i < 8; ++i) {  				inds.Add (baseVertexIndex + boxIndices [i]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  				baseVertexIndex = verts.Count;  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts - 1; i > 0; --i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts - 1; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i + 1);  					}  				}  			}  			foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  				baseVertexIndex = verts.Count;  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts; i > 0; --i) {  						inds.Add (baseVertexIndex + (i % numVerts));  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + (i + 1) % numVerts);  					}  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = verts.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			boxPos [0] = new Vector2 (min.x' min.y);  			boxPos [1] = new Vector2 (max.x' min.y);  			boxPos [2] = new Vector2 (max.x' max.y);  			boxPos [3] = new Vector2 (min.x' max.y);  			for (int i = 0; i < 4; ++i) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  			}  			int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  			for (int i = 0; i < 8; ++i) {  				inds.Add (baseVertexIndex + boxIndices [i]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  				baseVertexIndex = verts.Count;  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts - 1; i > 0; --i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts - 1; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i + 1);  					}  				}  			}  			foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  				baseVertexIndex = verts.Count;  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts; i > 0; --i) {  						inds.Add (baseVertexIndex + (i % numVerts));  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + (i + 1) % numVerts);  					}  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = verts.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			boxPos [0] = new Vector2 (min.x' min.y);  			boxPos [1] = new Vector2 (max.x' min.y);  			boxPos [2] = new Vector2 (max.x' max.y);  			boxPos [3] = new Vector2 (min.x' max.y);  			for (int i = 0; i < 4; ++i) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  			}  			int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  			for (int i = 0; i < 8; ++i) {  				inds.Add (baseVertexIndex + boxIndices [i]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  				baseVertexIndex = verts.Count;  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts - 1; i > 0; --i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts - 1; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i + 1);  					}  				}  			}  			foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  				baseVertexIndex = verts.Count;  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts; i > 0; --i) {  						inds.Add (baseVertexIndex + (i % numVerts));  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + (i + 1) % numVerts);  					}  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = verts.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			boxPos [0] = new Vector2 (min.x' min.y);  			boxPos [1] = new Vector2 (max.x' min.y);  			boxPos [2] = new Vector2 (max.x' max.y);  			boxPos [3] = new Vector2 (min.x' max.y);  			for (int i = 0; i < 4; ++i) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  			}  			int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  			for (int i = 0; i < 8; ++i) {  				inds.Add (baseVertexIndex + boxIndices [i]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  				baseVertexIndex = verts.Count;  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts - 1; i > 0; --i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts - 1; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + i + 1);  					}  				}  			}  			foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  				baseVertexIndex = verts.Count;  				foreach (Vector2 pos in dat.points) {  					verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  				}  				int numVerts = dat.points.Length;  				if (reverseIndices) {  					for (int i = numVerts; i > 0; --i) {  						inds.Add (baseVertexIndex + (i % numVerts));  						inds.Add (baseVertexIndex + i - 1);  					}  				}  				else {  					for (int i = 0; i < numVerts; ++i) {  						inds.Add (baseVertexIndex + i);  						inds.Add (baseVertexIndex + (i + 1) % numVerts);  					}  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = verts.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		boxPos [0] = new Vector2 (min.x' min.y);  		boxPos [1] = new Vector2 (max.x' min.y);  		boxPos [2] = new Vector2 (max.x' max.y);  		boxPos [3] = new Vector2 (min.x' max.y);  		for (int i = 0; i < 4; ++i) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  		}  		int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  		for (int i = 0; i < 8; ++i) {  			inds.Add (baseVertexIndex + boxIndices [i]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  			baseVertexIndex = verts.Count;  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts - 1; i > 0; --i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts - 1; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i + 1);  				}  			}  		}  		foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  			baseVertexIndex = verts.Count;  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts; i > 0; --i) {  					inds.Add (baseVertexIndex + (i % numVerts));  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + (i + 1) % numVerts);  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = verts.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		boxPos [0] = new Vector2 (min.x' min.y);  		boxPos [1] = new Vector2 (max.x' min.y);  		boxPos [2] = new Vector2 (max.x' max.y);  		boxPos [3] = new Vector2 (min.x' max.y);  		for (int i = 0; i < 4; ++i) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  		}  		int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  		for (int i = 0; i < 8; ++i) {  			inds.Add (baseVertexIndex + boxIndices [i]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  			baseVertexIndex = verts.Count;  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts - 1; i > 0; --i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts - 1; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i + 1);  				}  			}  		}  		foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  			baseVertexIndex = verts.Count;  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts; i > 0; --i) {  					inds.Add (baseVertexIndex + (i % numVerts));  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + (i + 1) % numVerts);  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = verts.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		boxPos [0] = new Vector2 (min.x' min.y);  		boxPos [1] = new Vector2 (max.x' min.y);  		boxPos [2] = new Vector2 (max.x' max.y);  		boxPos [3] = new Vector2 (min.x' max.y);  		for (int i = 0; i < 4; ++i) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  		}  		int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  		for (int i = 0; i < 8; ++i) {  			inds.Add (baseVertexIndex + boxIndices [i]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  			baseVertexIndex = verts.Count;  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts - 1; i > 0; --i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts - 1; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i + 1);  				}  			}  		}  		foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  			baseVertexIndex = verts.Count;  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts; i > 0; --i) {  					inds.Add (baseVertexIndex + (i % numVerts));  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + (i + 1) % numVerts);  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector2 currentPos = new Vector2 (tileSize.x * (x + xOffset)' tileSize.y * y);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	tk2dSpriteDefinition spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = verts.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		boxPos [0] = new Vector2 (min.x' min.y);  		boxPos [1] = new Vector2 (max.x' min.y);  		boxPos [2] = new Vector2 (max.x' max.y);  		boxPos [3] = new Vector2 (min.x' max.y);  		for (int i = 0; i < 4; ++i) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  		}  		int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  		for (int i = 0; i < 8; ++i) {  			inds.Add (baseVertexIndex + boxIndices [i]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  			baseVertexIndex = verts.Count;  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts - 1; i > 0; --i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts - 1; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + i + 1);  				}  			}  		}  		foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  			baseVertexIndex = verts.Count;  			foreach (Vector2 pos in dat.points) {  				verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  			}  			int numVerts = dat.points.Length;  			if (reverseIndices) {  				for (int i = numVerts; i > 0; --i) {  					inds.Add (baseVertexIndex + (i % numVerts));  					inds.Add (baseVertexIndex + i - 1);  				}  			}  			else {  				for (int i = 0; i < numVerts; ++i) {  					inds.Add (baseVertexIndex + i);  					inds.Add (baseVertexIndex + (i + 1) % numVerts);  				}  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	boxPos [0] = new Vector2 (min.x' min.y);  	boxPos [1] = new Vector2 (max.x' min.y);  	boxPos [2] = new Vector2 (max.x' max.y);  	boxPos [3] = new Vector2 (min.x' max.y);  	for (int i = 0; i < 4; ++i) {  		verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  	}  	int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  	for (int i = 0; i < 8; ++i) {  		inds.Add (baseVertexIndex + boxIndices [i]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  		baseVertexIndex = verts.Count;  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts - 1; i > 0; --i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts - 1; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i + 1);  			}  		}  	}  	foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  		baseVertexIndex = verts.Count;  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts; i > 0; --i) {  				inds.Add (baseVertexIndex + (i % numVerts));  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + (i + 1) % numVerts);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	boxPos [0] = new Vector2 (min.x' min.y);  	boxPos [1] = new Vector2 (max.x' min.y);  	boxPos [2] = new Vector2 (max.x' max.y);  	boxPos [3] = new Vector2 (min.x' max.y);  	for (int i = 0; i < 4; ++i) {  		verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  	}  	int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  	for (int i = 0; i < 8; ++i) {  		inds.Add (baseVertexIndex + boxIndices [i]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  		baseVertexIndex = verts.Count;  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts - 1; i > 0; --i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts - 1; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i + 1);  			}  		}  	}  	foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  		baseVertexIndex = verts.Count;  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts; i > 0; --i) {  				inds.Add (baseVertexIndex + (i % numVerts));  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + (i + 1) % numVerts);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	boxPos [0] = new Vector2 (min.x' min.y);  	boxPos [1] = new Vector2 (max.x' min.y);  	boxPos [2] = new Vector2 (max.x' max.y);  	boxPos [3] = new Vector2 (min.x' max.y);  	for (int i = 0; i < 4; ++i) {  		verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  	}  	int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  	for (int i = 0; i < 8; ++i) {  		inds.Add (baseVertexIndex + boxIndices [i]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  		baseVertexIndex = verts.Count;  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts - 1; i > 0; --i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts - 1; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i + 1);  			}  		}  	}  	foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  		baseVertexIndex = verts.Count;  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts; i > 0; --i) {  				inds.Add (baseVertexIndex + (i % numVerts));  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + (i + 1) % numVerts);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	boxPos [0] = new Vector2 (min.x' min.y);  	boxPos [1] = new Vector2 (max.x' min.y);  	boxPos [2] = new Vector2 (max.x' max.y);  	boxPos [3] = new Vector2 (min.x' max.y);  	for (int i = 0; i < 4; ++i) {  		verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  	}  	int[] boxIndices = reverseIndices ? boxIndsFlipped : boxInds;  	for (int i = 0; i < 8; ++i) {  		inds.Add (baseVertexIndex + boxIndices [i]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	foreach (tk2dCollider2DData dat in spriteData.edgeCollider2D) {  		baseVertexIndex = verts.Count;  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts - 1; i > 0; --i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts - 1; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + i + 1);  			}  		}  	}  	foreach (tk2dCollider2DData dat in spriteData.polygonCollider2D) {  		baseVertexIndex = verts.Count;  		foreach (Vector2 pos in dat.points) {  			verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos' flipH' flipV' rot90) + currentPos);  		}  		int numVerts = dat.points.Length;  		if (reverseIndices) {  			for (int i = numVerts; i > 0; --i) {  				inds.Add (baseVertexIndex + (i % numVerts));  				inds.Add (baseVertexIndex + i - 1);  			}  		}  		else {  			for (int i = 0; i < numVerts; ++i) {  				inds.Add (baseVertexIndex + i);  				inds.Add (baseVertexIndex + (i + 1) % numVerts);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: boxPos [2] = new Vector2 (max.x' max.y);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: boxPos [3] = new Vector2 (min.x' max.y);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int i = 0; i < 4; ++i) {  	verts.Add (BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' boxPos [i]' flipH' flipV' rot90) + currentPos);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {  	inds.Add (baseVertexIndex + boxIndices [i]);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,CompareDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {  	int d = indices [face0index + i] - indices [face1index + i];  	if (d != 0)  		return d;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 2) {  	if (indices [i] > indices [i + 1]) {  		sortedFaceIndices [i] = indices [i + 1];  		sortedFaceIndices [i + 1] = indices [i];  	}  	else {  		sortedFaceIndices [i] = indices [i];  		sortedFaceIndices [i + 1] = indices [i + 1];  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: i += 2
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 2) {  	sortIndex [i / 2] = i;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 2) {  	sortIndex [i / 2] = i;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: i += 2
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: sortIndex [i / 2] = i;  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: for (int i = 0; i < sortIndex.Length; ++i) {  	if (i != sortIndex.Length - 1 && CompareDuplicateFaces (sortedFaceIndices' sortIndex [i]' sortIndex [i + 1]) == 0) {  		// skip both faces  		// this will fail in the case where there are 3 coplanar faces  		// but that is probably likely user error / intentional  		i++;  		continue;  	}  	for (int j = 0; j < 2; ++j)  		newIndices.Add (indices [sortIndex [i] + j]);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,RemoveDuplicateEdges,The following statement contains a magic number: for (int j = 0; j < 2; ++j)  	newIndices.Add (indices [sortIndex [i] + j]);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: while (processedEdge) {  	processedEdge = false;  	for (int i = 0; i < edgeUsed.Length; ++i) {  		if (!edgeUsed [i]) {  			edgeUsed [i] = true;  			int v0 = indices [i * 2 + 0];  			int v1 = indices [i * 2 + 1];  			d0 = (verts [v1] - verts [v0]).normalized;  			edgeIndices.Add (v0);  			edgeIndices.Add (v1);  			// The connecting vertex for this edge list  			for (int k = i + 1; k < edgeUsed.Length; ++k) {  				if (edgeUsed [k]) {  					continue;  				}  				int w0 = indices [k * 2 + 0];  				if (w0 == v1) {  					int w1 = indices [k * 2 + 1];  					d1 = (verts [w1] - verts [w0]).normalized;  					// Same direction?  					if (Vector2.Dot (d1' d0) > 0.999f) {  						edgeIndices.RemoveAt (edgeIndices.Count - 1);  						// remove last  					}  					edgeIndices.Add (w1);  					edgeUsed [k] = true;  					d0 = d1;  					// new normal  					k = i;  					// restart the loop  					v1 = w1;  					// continuing from the end of the loop  					continue;  				}  			}  			processedEdge = true;  			break;  		}  	}  	if (processedEdge) {  		edgeVerts.Clear ();  		edgeVerts.Capacity = Mathf.Max (edgeVerts.Capacity' edgeIndices.Count);  		for (int i = 0; i < edgeIndices.Count; ++i) {  			edgeVerts.Add (verts [edgeIndices [i]]);  		}  		edges.Add (edgeVerts.ToArray ());  		edgeIndices.Clear ();  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: while (processedEdge) {  	processedEdge = false;  	for (int i = 0; i < edgeUsed.Length; ++i) {  		if (!edgeUsed [i]) {  			edgeUsed [i] = true;  			int v0 = indices [i * 2 + 0];  			int v1 = indices [i * 2 + 1];  			d0 = (verts [v1] - verts [v0]).normalized;  			edgeIndices.Add (v0);  			edgeIndices.Add (v1);  			// The connecting vertex for this edge list  			for (int k = i + 1; k < edgeUsed.Length; ++k) {  				if (edgeUsed [k]) {  					continue;  				}  				int w0 = indices [k * 2 + 0];  				if (w0 == v1) {  					int w1 = indices [k * 2 + 1];  					d1 = (verts [w1] - verts [w0]).normalized;  					// Same direction?  					if (Vector2.Dot (d1' d0) > 0.999f) {  						edgeIndices.RemoveAt (edgeIndices.Count - 1);  						// remove last  					}  					edgeIndices.Add (w1);  					edgeUsed [k] = true;  					d0 = d1;  					// new normal  					k = i;  					// restart the loop  					v1 = w1;  					// continuing from the end of the loop  					continue;  				}  			}  			processedEdge = true;  			break;  		}  	}  	if (processedEdge) {  		edgeVerts.Clear ();  		edgeVerts.Capacity = Mathf.Max (edgeVerts.Capacity' edgeIndices.Count);  		for (int i = 0; i < edgeIndices.Count; ++i) {  			edgeVerts.Add (verts [edgeIndices [i]]);  		}  		edges.Add (edgeVerts.ToArray ());  		edgeIndices.Clear ();  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: while (processedEdge) {  	processedEdge = false;  	for (int i = 0; i < edgeUsed.Length; ++i) {  		if (!edgeUsed [i]) {  			edgeUsed [i] = true;  			int v0 = indices [i * 2 + 0];  			int v1 = indices [i * 2 + 1];  			d0 = (verts [v1] - verts [v0]).normalized;  			edgeIndices.Add (v0);  			edgeIndices.Add (v1);  			// The connecting vertex for this edge list  			for (int k = i + 1; k < edgeUsed.Length; ++k) {  				if (edgeUsed [k]) {  					continue;  				}  				int w0 = indices [k * 2 + 0];  				if (w0 == v1) {  					int w1 = indices [k * 2 + 1];  					d1 = (verts [w1] - verts [w0]).normalized;  					// Same direction?  					if (Vector2.Dot (d1' d0) > 0.999f) {  						edgeIndices.RemoveAt (edgeIndices.Count - 1);  						// remove last  					}  					edgeIndices.Add (w1);  					edgeUsed [k] = true;  					d0 = d1;  					// new normal  					k = i;  					// restart the loop  					v1 = w1;  					// continuing from the end of the loop  					continue;  				}  			}  			processedEdge = true;  			break;  		}  	}  	if (processedEdge) {  		edgeVerts.Clear ();  		edgeVerts.Capacity = Mathf.Max (edgeVerts.Capacity' edgeIndices.Count);  		for (int i = 0; i < edgeIndices.Count; ++i) {  			edgeVerts.Add (verts [edgeIndices [i]]);  		}  		edges.Add (edgeVerts.ToArray ());  		edgeIndices.Clear ();  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: while (processedEdge) {  	processedEdge = false;  	for (int i = 0; i < edgeUsed.Length; ++i) {  		if (!edgeUsed [i]) {  			edgeUsed [i] = true;  			int v0 = indices [i * 2 + 0];  			int v1 = indices [i * 2 + 1];  			d0 = (verts [v1] - verts [v0]).normalized;  			edgeIndices.Add (v0);  			edgeIndices.Add (v1);  			// The connecting vertex for this edge list  			for (int k = i + 1; k < edgeUsed.Length; ++k) {  				if (edgeUsed [k]) {  					continue;  				}  				int w0 = indices [k * 2 + 0];  				if (w0 == v1) {  					int w1 = indices [k * 2 + 1];  					d1 = (verts [w1] - verts [w0]).normalized;  					// Same direction?  					if (Vector2.Dot (d1' d0) > 0.999f) {  						edgeIndices.RemoveAt (edgeIndices.Count - 1);  						// remove last  					}  					edgeIndices.Add (w1);  					edgeUsed [k] = true;  					d0 = d1;  					// new normal  					k = i;  					// restart the loop  					v1 = w1;  					// continuing from the end of the loop  					continue;  				}  			}  			processedEdge = true;  			break;  		}  	}  	if (processedEdge) {  		edgeVerts.Clear ();  		edgeVerts.Capacity = Mathf.Max (edgeVerts.Capacity' edgeIndices.Count);  		for (int i = 0; i < edgeIndices.Count; ++i) {  			edgeVerts.Add (verts [edgeIndices [i]]);  		}  		edges.Add (edgeVerts.ToArray ());  		edgeIndices.Clear ();  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int i = 0; i < edgeUsed.Length; ++i) {  	if (!edgeUsed [i]) {  		edgeUsed [i] = true;  		int v0 = indices [i * 2 + 0];  		int v1 = indices [i * 2 + 1];  		d0 = (verts [v1] - verts [v0]).normalized;  		edgeIndices.Add (v0);  		edgeIndices.Add (v1);  		// The connecting vertex for this edge list  		for (int k = i + 1; k < edgeUsed.Length; ++k) {  			if (edgeUsed [k]) {  				continue;  			}  			int w0 = indices [k * 2 + 0];  			if (w0 == v1) {  				int w1 = indices [k * 2 + 1];  				d1 = (verts [w1] - verts [w0]).normalized;  				// Same direction?  				if (Vector2.Dot (d1' d0) > 0.999f) {  					edgeIndices.RemoveAt (edgeIndices.Count - 1);  					// remove last  				}  				edgeIndices.Add (w1);  				edgeUsed [k] = true;  				d0 = d1;  				// new normal  				k = i;  				// restart the loop  				v1 = w1;  				// continuing from the end of the loop  				continue;  			}  		}  		processedEdge = true;  		break;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int i = 0; i < edgeUsed.Length; ++i) {  	if (!edgeUsed [i]) {  		edgeUsed [i] = true;  		int v0 = indices [i * 2 + 0];  		int v1 = indices [i * 2 + 1];  		d0 = (verts [v1] - verts [v0]).normalized;  		edgeIndices.Add (v0);  		edgeIndices.Add (v1);  		// The connecting vertex for this edge list  		for (int k = i + 1; k < edgeUsed.Length; ++k) {  			if (edgeUsed [k]) {  				continue;  			}  			int w0 = indices [k * 2 + 0];  			if (w0 == v1) {  				int w1 = indices [k * 2 + 1];  				d1 = (verts [w1] - verts [w0]).normalized;  				// Same direction?  				if (Vector2.Dot (d1' d0) > 0.999f) {  					edgeIndices.RemoveAt (edgeIndices.Count - 1);  					// remove last  				}  				edgeIndices.Add (w1);  				edgeUsed [k] = true;  				d0 = d1;  				// new normal  				k = i;  				// restart the loop  				v1 = w1;  				// continuing from the end of the loop  				continue;  			}  		}  		processedEdge = true;  		break;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int i = 0; i < edgeUsed.Length; ++i) {  	if (!edgeUsed [i]) {  		edgeUsed [i] = true;  		int v0 = indices [i * 2 + 0];  		int v1 = indices [i * 2 + 1];  		d0 = (verts [v1] - verts [v0]).normalized;  		edgeIndices.Add (v0);  		edgeIndices.Add (v1);  		// The connecting vertex for this edge list  		for (int k = i + 1; k < edgeUsed.Length; ++k) {  			if (edgeUsed [k]) {  				continue;  			}  			int w0 = indices [k * 2 + 0];  			if (w0 == v1) {  				int w1 = indices [k * 2 + 1];  				d1 = (verts [w1] - verts [w0]).normalized;  				// Same direction?  				if (Vector2.Dot (d1' d0) > 0.999f) {  					edgeIndices.RemoveAt (edgeIndices.Count - 1);  					// remove last  				}  				edgeIndices.Add (w1);  				edgeUsed [k] = true;  				d0 = d1;  				// new normal  				k = i;  				// restart the loop  				v1 = w1;  				// continuing from the end of the loop  				continue;  			}  		}  		processedEdge = true;  		break;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int i = 0; i < edgeUsed.Length; ++i) {  	if (!edgeUsed [i]) {  		edgeUsed [i] = true;  		int v0 = indices [i * 2 + 0];  		int v1 = indices [i * 2 + 1];  		d0 = (verts [v1] - verts [v0]).normalized;  		edgeIndices.Add (v0);  		edgeIndices.Add (v1);  		// The connecting vertex for this edge list  		for (int k = i + 1; k < edgeUsed.Length; ++k) {  			if (edgeUsed [k]) {  				continue;  			}  			int w0 = indices [k * 2 + 0];  			if (w0 == v1) {  				int w1 = indices [k * 2 + 1];  				d1 = (verts [w1] - verts [w0]).normalized;  				// Same direction?  				if (Vector2.Dot (d1' d0) > 0.999f) {  					edgeIndices.RemoveAt (edgeIndices.Count - 1);  					// remove last  				}  				edgeIndices.Add (w1);  				edgeUsed [k] = true;  				d0 = d1;  				// new normal  				k = i;  				// restart the loop  				v1 = w1;  				// continuing from the end of the loop  				continue;  			}  		}  		processedEdge = true;  		break;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: if (!edgeUsed [i]) {  	edgeUsed [i] = true;  	int v0 = indices [i * 2 + 0];  	int v1 = indices [i * 2 + 1];  	d0 = (verts [v1] - verts [v0]).normalized;  	edgeIndices.Add (v0);  	edgeIndices.Add (v1);  	// The connecting vertex for this edge list  	for (int k = i + 1; k < edgeUsed.Length; ++k) {  		if (edgeUsed [k]) {  			continue;  		}  		int w0 = indices [k * 2 + 0];  		if (w0 == v1) {  			int w1 = indices [k * 2 + 1];  			d1 = (verts [w1] - verts [w0]).normalized;  			// Same direction?  			if (Vector2.Dot (d1' d0) > 0.999f) {  				edgeIndices.RemoveAt (edgeIndices.Count - 1);  				// remove last  			}  			edgeIndices.Add (w1);  			edgeUsed [k] = true;  			d0 = d1;  			// new normal  			k = i;  			// restart the loop  			v1 = w1;  			// continuing from the end of the loop  			continue;  		}  	}  	processedEdge = true;  	break;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: if (!edgeUsed [i]) {  	edgeUsed [i] = true;  	int v0 = indices [i * 2 + 0];  	int v1 = indices [i * 2 + 1];  	d0 = (verts [v1] - verts [v0]).normalized;  	edgeIndices.Add (v0);  	edgeIndices.Add (v1);  	// The connecting vertex for this edge list  	for (int k = i + 1; k < edgeUsed.Length; ++k) {  		if (edgeUsed [k]) {  			continue;  		}  		int w0 = indices [k * 2 + 0];  		if (w0 == v1) {  			int w1 = indices [k * 2 + 1];  			d1 = (verts [w1] - verts [w0]).normalized;  			// Same direction?  			if (Vector2.Dot (d1' d0) > 0.999f) {  				edgeIndices.RemoveAt (edgeIndices.Count - 1);  				// remove last  			}  			edgeIndices.Add (w1);  			edgeUsed [k] = true;  			d0 = d1;  			// new normal  			k = i;  			// restart the loop  			v1 = w1;  			// continuing from the end of the loop  			continue;  		}  	}  	processedEdge = true;  	break;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: if (!edgeUsed [i]) {  	edgeUsed [i] = true;  	int v0 = indices [i * 2 + 0];  	int v1 = indices [i * 2 + 1];  	d0 = (verts [v1] - verts [v0]).normalized;  	edgeIndices.Add (v0);  	edgeIndices.Add (v1);  	// The connecting vertex for this edge list  	for (int k = i + 1; k < edgeUsed.Length; ++k) {  		if (edgeUsed [k]) {  			continue;  		}  		int w0 = indices [k * 2 + 0];  		if (w0 == v1) {  			int w1 = indices [k * 2 + 1];  			d1 = (verts [w1] - verts [w0]).normalized;  			// Same direction?  			if (Vector2.Dot (d1' d0) > 0.999f) {  				edgeIndices.RemoveAt (edgeIndices.Count - 1);  				// remove last  			}  			edgeIndices.Add (w1);  			edgeUsed [k] = true;  			d0 = d1;  			// new normal  			k = i;  			// restart the loop  			v1 = w1;  			// continuing from the end of the loop  			continue;  		}  	}  	processedEdge = true;  	break;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: if (!edgeUsed [i]) {  	edgeUsed [i] = true;  	int v0 = indices [i * 2 + 0];  	int v1 = indices [i * 2 + 1];  	d0 = (verts [v1] - verts [v0]).normalized;  	edgeIndices.Add (v0);  	edgeIndices.Add (v1);  	// The connecting vertex for this edge list  	for (int k = i + 1; k < edgeUsed.Length; ++k) {  		if (edgeUsed [k]) {  			continue;  		}  		int w0 = indices [k * 2 + 0];  		if (w0 == v1) {  			int w1 = indices [k * 2 + 1];  			d1 = (verts [w1] - verts [w0]).normalized;  			// Same direction?  			if (Vector2.Dot (d1' d0) > 0.999f) {  				edgeIndices.RemoveAt (edgeIndices.Count - 1);  				// remove last  			}  			edgeIndices.Add (w1);  			edgeUsed [k] = true;  			d0 = d1;  			// new normal  			k = i;  			// restart the loop  			v1 = w1;  			// continuing from the end of the loop  			continue;  		}  	}  	processedEdge = true;  	break;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int k = i + 1; k < edgeUsed.Length; ++k) {  	if (edgeUsed [k]) {  		continue;  	}  	int w0 = indices [k * 2 + 0];  	if (w0 == v1) {  		int w1 = indices [k * 2 + 1];  		d1 = (verts [w1] - verts [w0]).normalized;  		// Same direction?  		if (Vector2.Dot (d1' d0) > 0.999f) {  			edgeIndices.RemoveAt (edgeIndices.Count - 1);  			// remove last  		}  		edgeIndices.Add (w1);  		edgeUsed [k] = true;  		d0 = d1;  		// new normal  		k = i;  		// restart the loop  		v1 = w1;  		// continuing from the end of the loop  		continue;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: for (int k = i + 1; k < edgeUsed.Length; ++k) {  	if (edgeUsed [k]) {  		continue;  	}  	int w0 = indices [k * 2 + 0];  	if (w0 == v1) {  		int w1 = indices [k * 2 + 1];  		d1 = (verts [w1] - verts [w0]).normalized;  		// Same direction?  		if (Vector2.Dot (d1' d0) > 0.999f) {  			edgeIndices.RemoveAt (edgeIndices.Count - 1);  			// remove last  		}  		edgeIndices.Add (w1);  		edgeUsed [k] = true;  		d0 = d1;  		// new normal  		k = i;  		// restart the loop  		v1 = w1;  		// continuing from the end of the loop  		continue;  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder2D,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder2D.cs,MergeEdges,The following statement contains a magic number: if (w0 == v1) {  	int w1 = indices [k * 2 + 1];  	d1 = (verts [w1] - verts [w0]).normalized;  	// Same direction?  	if (Vector2.Dot (d1' d0) > 0.999f) {  		edgeIndices.RemoveAt (edgeIndices.Count - 1);  		// remove last  	}  	edgeIndices.Add (w1);  	edgeUsed [k] = true;  	d0 = d1;  	// new normal  	k = i;  	// restart the loop  	v1 = w1;  	// continuing from the end of the loop  	continue;  }  
Missing Default,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following switch statement is missing a default case: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Missing Default,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following switch statement is missing a default case: switch (cmd) {  case 'i':  	break;  // ignore version field for now  case 'w':  	textureDimensions.x = Int32.Parse (line.Substring (2));  	break;  case 'h':  	textureDimensions.y = Int32.Parse (line.Substring (2));  	break;  // total number of sprites would be ideal to statically allocate  case '~':  	state++;  	break;  }  
Missing Default,tk2dRuntime,SpriteCollectionGenerator,C:\repos\pcrouillere_tableauInteractif\Assets\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following switch statement is missing a default case: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
