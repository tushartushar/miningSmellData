Implementation smell,Namespace,Class,File,Method,Description
Long Method,Sparkles,TcpListener,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The method has 100 lines of code.
Complex Method,Sparkles,BaseRepository,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,Cyclomatic complexity of the method is 9
Complex Method,Sparkles,BaseRepository,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,SyncDownBase,Cyclomatic complexity of the method is 10
Long Parameter List,Sparkles,Preset,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\Preset.cs,Create,The method has 6 parameters. Parameters: name' description' address_value' address_example' path_value' path_example
Complex Conditional,Sparkles,BaseRepository,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The conditional expression  "size_buffer.Count >= 4 &&                      size_buffer [0].Equals (size_buffer [1]) &&                      size_buffer [1].Equals (size_buffer [2]) &&                      size_buffer [2].Equals (size_buffer [3])"  is complex.
Complex Conditional,Sparkles,BaseRepository,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,SyncDownBase,The conditional expression  "!pre_sync_revision.Equals (CurrentRevision) &&                      ChangeSets != null && ChangeSets.Count > 0 &&                      !ChangeSets [0].User.Name.Equals (this.local_config.User.Name)"  is complex.
Magic Number,Sparkles,BaseFetcher,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseFetcher.cs,Start,The following statement contains a magic number: thread = new Thread (() => {                  if (Fetch ()) {                      Thread.Sleep (500);                      Logger.LogInfo ("Fetcher"' "Finished");                        IsActive = false;                      Finished (FetchedRepoStorageType' Warnings);                    } else {                      Thread.Sleep (500);                        if (IsActive) {                          Logger.LogInfo ("Fetcher"' "Failed");                          Failed ();                                            } else {                          Logger.LogInfo ("Fetcher"' "Failed: cancelled by user");                      }                        IsActive = false;                  }              });
Magic Number,Sparkles,BaseFetcher,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseFetcher.cs,Start,The following statement contains a magic number: thread = new Thread (() => {                  if (Fetch ()) {                      Thread.Sleep (500);                      Logger.LogInfo ("Fetcher"' "Finished");                        IsActive = false;                      Finished (FetchedRepoStorageType' Warnings);                    } else {                      Thread.Sleep (500);                        if (IsActive) {                          Logger.LogInfo ("Fetcher"' "Failed");                          Failed ();                                            } else {                          Logger.LogInfo ("Fetcher"' "Failed: cancelled by user");                      }                        IsActive = false;                  }              });
Magic Number,Sparkles,BaseFetcher,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseFetcher.cs,GetBackend,The following statement contains a magic number: backend = backend.Substring (4);
Magic Number,Sparkles,BaseRepository,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: size_buffer.Count >= 4
Magic Number,Sparkles,BaseRepository,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: size_buffer.Count >= 4 &&                      size_buffer [0].Equals (size_buffer [1]) &&                      size_buffer [1].Equals (size_buffer [2]) &&                      size_buffer [2].Equals (size_buffer [3])
Magic Number,Sparkles,BaseRepository,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: size_buffer.Count >= 4 &&                      size_buffer [0].Equals (size_buffer [1]) &&                      size_buffer [1].Equals (size_buffer [2]) &&                      size_buffer [2].Equals (size_buffer [3])
Magic Number,Sparkles,BaseRepository,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: size_buffer.Count >= 4 &&                      size_buffer [0].Equals (size_buffer [1]) &&                      size_buffer [1].Equals (size_buffer [2]) &&                      size_buffer [2].Equals (size_buffer [3])
Magic Number,Sparkles,BaseRepository,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: size_buffer.Count >= 4 &&                      size_buffer [0].Equals (size_buffer [1]) &&                      size_buffer [1].Equals (size_buffer [2]) &&                      size_buffer [2].Equals (size_buffer [3])
Magic Number,Sparkles,BaseRepository,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnProgressChanged,The following statement contains a magic number: percentage = 99.0;
Magic Number,Sparkles,BaseRepository,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnProgressChanged,The following statement contains a magic number: percentage == 100.0
Magic Number,Sparkles,BaseRepository,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerDisconnectedDelegate,The following statement contains a magic number: int backoff_time = 2;
Magic Number,Sparkles,BaseRepository,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerDisconnectedDelegate,The following statement contains a magic number: Thread.Sleep (backoff_time * 1000);
Magic Number,Sparkles,BaseRepository,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerDisconnectedDelegate,The following statement contains a magic number: backoff_time *= 2;
Magic Number,Sparkles,BaseRepository,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerAnnouncementReceivedDelegate,The following statement contains a magic number: Thread.Sleep (100);
Magic Number,Sparkles,Configuration,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\Configuration.cs,Configuration,The following statement contains a magic number: file.LastWriteTime < DateTime.Now.AddDays (-7)
Magic Number,Sparkles,Extensions,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESEncrypt,The following statement contains a magic number: byte [] salt_bytes = new Byte [16];
Magic Number,Sparkles,Extensions,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESEncrypt,The following statement contains a magic number: password = (password + salt).SHA256 ().Substring (0' 32);
Magic Number,Sparkles,Extensions,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESEncrypt,The following statement contains a magic number: RijndaelManaged aes = new RijndaelManaged () {                  KeySize = 256'                  BlockSize = 128'                  Mode = CipherMode.CBC'                  Padding = PaddingMode.PKCS7'                  Key = Encoding.UTF8.GetBytes (password)'                  IV = Encoding.UTF8.GetBytes (password.ToCharArray ()' 0' 16)              };
Magic Number,Sparkles,Extensions,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESEncrypt,The following statement contains a magic number: RijndaelManaged aes = new RijndaelManaged () {                  KeySize = 256'                  BlockSize = 128'                  Mode = CipherMode.CBC'                  Padding = PaddingMode.PKCS7'                  Key = Encoding.UTF8.GetBytes (password)'                  IV = Encoding.UTF8.GetBytes (password.ToCharArray ()' 0' 16)              };
Magic Number,Sparkles,Extensions,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESEncrypt,The following statement contains a magic number: RijndaelManaged aes = new RijndaelManaged () {                  KeySize = 256'                  BlockSize = 128'                  Mode = CipherMode.CBC'                  Padding = PaddingMode.PKCS7'                  Key = Encoding.UTF8.GetBytes (password)'                  IV = Encoding.UTF8.GetBytes (password.ToCharArray ()' 0' 16)              };
Magic Number,Sparkles,Extensions,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESDecrypt,The following statement contains a magic number: password = (password + salt).SHA256 ().Substring (0' 32);
Magic Number,Sparkles,Extensions,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESDecrypt,The following statement contains a magic number: RijndaelManaged aes = new RijndaelManaged () {                  KeySize = 256'                  BlockSize = 128'                  Mode = CipherMode.CBC'                  Padding = PaddingMode.PKCS7'                  Key = Encoding.UTF8.GetBytes (password)'                  IV = Encoding.UTF8.GetBytes (password.ToCharArray ()' 0' 16)              };
Magic Number,Sparkles,Extensions,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESDecrypt,The following statement contains a magic number: RijndaelManaged aes = new RijndaelManaged () {                  KeySize = 256'                  BlockSize = 128'                  Mode = CipherMode.CBC'                  Padding = PaddingMode.PKCS7'                  Key = Encoding.UTF8.GetBytes (password)'                  IV = Encoding.UTF8.GetBytes (password.ToCharArray ()' 0' 16)              };
Magic Number,Sparkles,Extensions,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESDecrypt,The following statement contains a magic number: RijndaelManaged aes = new RijndaelManaged () {                  KeySize = 256'                  BlockSize = 128'                  Mode = CipherMode.CBC'                  Padding = PaddingMode.PKCS7'                  Key = Encoding.UTF8.GetBytes (password)'                  IV = Encoding.UTF8.GetBytes (password.ToCharArray ()' 0' 16)              };
Magic Number,Sparkles,Extensions,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));
Magic Number,Sparkles,Extensions,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));
Magic Number,Sparkles,Extensions,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: byte_count >= 1099511627776
Magic Number,Sparkles,Logger,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\Logger.cs,WriteCrashReport,The following statement contains a magic number: int line_count        = 50;
Magic Number,Sparkles,SSHFetcher,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\SSHFetcher.cs,DeriveFingerprint,The following statement contains a magic number: string key = public_key.Split (" ".ToCharArray ()) [2];
Magic Number,Sparkles,TcpListener,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Missing Default,Sparkles,ChangeSet,D:\research\architectureSmells\repos\hbons_SparkleShare\Sparkles\ChangeSet.cs,ToMessage,The following switch statement is missing a default case: switch (Changes [0].Type) {              case ChangeType.Edited:  message = "edited: {0}"; break;              case ChangeType.Deleted: message = "deleted: {0}"; break;              case ChangeType.Moved:   message = "moved: {0}"; break;              }
