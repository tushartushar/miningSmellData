Implementation smell,Namespace,Class,File,Method,Description
Long Method,Sparkles,TcpListener,C:\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The method has 100 lines of code.
Complex Method,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,Cyclomatic complexity of the method is 8
Complex Method,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,SyncDownBase,Cyclomatic complexity of the method is 10
Long Parameter List,Sparkles,Preset,C:\repos\hbons_SparkleShare\Sparkles\Preset.cs,Create,The method has 6 parameters. Parameters: name' description' address_value' address_example' path_value' path_example
Complex Conditional,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The conditional expression  "size_buffer.Count >= 4 &&                      size_buffer [0].Equals (size_buffer [1]) &&                      size_buffer [1].Equals (size_buffer [2]) &&                      size_buffer [2].Equals (size_buffer [3])"  is complex.
Complex Conditional,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,SyncDownBase,The conditional expression  "!pre_sync_revision.Equals (CurrentRevision) &&                      ChangeSets != null && ChangeSets.Count > 0 &&                      !ChangeSets [0].User.Name.Equals (this.local_config.User.Name)"  is complex.
Magic Number,Sparkles,BaseFetcher,C:\repos\hbons_SparkleShare\Sparkles\BaseFetcher.cs,Start,The following statement contains a magic number: thread = new Thread (() => {                  if (Fetch ()) {                      Thread.Sleep (500);                      Logger.LogInfo ("Fetcher"' "Finished");                        IsActive = false;                      Finished (FetchedRepoStorageType' Warnings);                    } else {                      Thread.Sleep (500);                        if (IsActive) {                          Logger.LogInfo ("Fetcher"' "Failed");                          Failed ();                                            } else {                          Logger.LogInfo ("Fetcher"' "Failed: cancelled by user");                      }                        IsActive = false;                  }              });
Magic Number,Sparkles,BaseFetcher,C:\repos\hbons_SparkleShare\Sparkles\BaseFetcher.cs,Start,The following statement contains a magic number: thread = new Thread (() => {                  if (Fetch ()) {                      Thread.Sleep (500);                      Logger.LogInfo ("Fetcher"' "Finished");                        IsActive = false;                      Finished (FetchedRepoStorageType' Warnings);                    } else {                      Thread.Sleep (500);                        if (IsActive) {                          Logger.LogInfo ("Fetcher"' "Failed");                          Failed ();                                            } else {                          Logger.LogInfo ("Fetcher"' "Failed: cancelled by user");                      }                        IsActive = false;                  }              });
Magic Number,Sparkles,BaseFetcher,C:\repos\hbons_SparkleShare\Sparkles\BaseFetcher.cs,GetBackend,The following statement contains a magic number: if (address.StartsWith ("ssh+"' StringComparison.InvariantCultureIgnoreCase)) {                  string backend = address.Substring (0' address.IndexOf ("://"' StringComparison.InvariantCulture));                  backend = backend.Substring (4);                    return char.ToUpper (backend [0]) + backend.Substring (1);              }
Magic Number,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: do {                  if (size_buffer.Count >= 4)                      size_buffer.RemoveAt (0);                    size_buffer.Add (CalculateSize (info));                    if (size_buffer.Count >= 4 &&                      size_buffer [0].Equals (size_buffer [1]) &&                      size_buffer [1].Equals (size_buffer [2]) &&                      size_buffer [2].Equals (size_buffer [3])) {                        Logger.LogInfo ("Local"' Name + " | Activity has settled");                      IsBuffering = false;                        bool first_sync = true;                        if (HasLocalChanges && Status == SyncStatus.Idle) {                          do {                              if (!first_sync)                                  Logger.LogInfo ("Local"' Name + " | More changes found");                                SyncUpBase ();                                if (Error == ErrorStatus.UnreadableFiles)                                  return;                                first_sync = false;                            } while (HasLocalChanges);                      }                         if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {                          Status = SyncStatus.Idle;                          SyncStatusChanged (Status);                      }                    } else {                      Thread.Sleep (500);                  }                } while (IsBuffering);
Magic Number,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: do {                  if (size_buffer.Count >= 4)                      size_buffer.RemoveAt (0);                    size_buffer.Add (CalculateSize (info));                    if (size_buffer.Count >= 4 &&                      size_buffer [0].Equals (size_buffer [1]) &&                      size_buffer [1].Equals (size_buffer [2]) &&                      size_buffer [2].Equals (size_buffer [3])) {                        Logger.LogInfo ("Local"' Name + " | Activity has settled");                      IsBuffering = false;                        bool first_sync = true;                        if (HasLocalChanges && Status == SyncStatus.Idle) {                          do {                              if (!first_sync)                                  Logger.LogInfo ("Local"' Name + " | More changes found");                                SyncUpBase ();                                if (Error == ErrorStatus.UnreadableFiles)                                  return;                                first_sync = false;                            } while (HasLocalChanges);                      }                         if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {                          Status = SyncStatus.Idle;                          SyncStatusChanged (Status);                      }                    } else {                      Thread.Sleep (500);                  }                } while (IsBuffering);
Magic Number,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: do {                  if (size_buffer.Count >= 4)                      size_buffer.RemoveAt (0);                    size_buffer.Add (CalculateSize (info));                    if (size_buffer.Count >= 4 &&                      size_buffer [0].Equals (size_buffer [1]) &&                      size_buffer [1].Equals (size_buffer [2]) &&                      size_buffer [2].Equals (size_buffer [3])) {                        Logger.LogInfo ("Local"' Name + " | Activity has settled");                      IsBuffering = false;                        bool first_sync = true;                        if (HasLocalChanges && Status == SyncStatus.Idle) {                          do {                              if (!first_sync)                                  Logger.LogInfo ("Local"' Name + " | More changes found");                                SyncUpBase ();                                if (Error == ErrorStatus.UnreadableFiles)                                  return;                                first_sync = false;                            } while (HasLocalChanges);                      }                         if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {                          Status = SyncStatus.Idle;                          SyncStatusChanged (Status);                      }                    } else {                      Thread.Sleep (500);                  }                } while (IsBuffering);
Magic Number,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: do {                  if (size_buffer.Count >= 4)                      size_buffer.RemoveAt (0);                    size_buffer.Add (CalculateSize (info));                    if (size_buffer.Count >= 4 &&                      size_buffer [0].Equals (size_buffer [1]) &&                      size_buffer [1].Equals (size_buffer [2]) &&                      size_buffer [2].Equals (size_buffer [3])) {                        Logger.LogInfo ("Local"' Name + " | Activity has settled");                      IsBuffering = false;                        bool first_sync = true;                        if (HasLocalChanges && Status == SyncStatus.Idle) {                          do {                              if (!first_sync)                                  Logger.LogInfo ("Local"' Name + " | More changes found");                                SyncUpBase ();                                if (Error == ErrorStatus.UnreadableFiles)                                  return;                                first_sync = false;                            } while (HasLocalChanges);                      }                         if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {                          Status = SyncStatus.Idle;                          SyncStatusChanged (Status);                      }                    } else {                      Thread.Sleep (500);                  }                } while (IsBuffering);
Magic Number,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: do {                  if (size_buffer.Count >= 4)                      size_buffer.RemoveAt (0);                    size_buffer.Add (CalculateSize (info));                    if (size_buffer.Count >= 4 &&                      size_buffer [0].Equals (size_buffer [1]) &&                      size_buffer [1].Equals (size_buffer [2]) &&                      size_buffer [2].Equals (size_buffer [3])) {                        Logger.LogInfo ("Local"' Name + " | Activity has settled");                      IsBuffering = false;                        bool first_sync = true;                        if (HasLocalChanges && Status == SyncStatus.Idle) {                          do {                              if (!first_sync)                                  Logger.LogInfo ("Local"' Name + " | More changes found");                                SyncUpBase ();                                if (Error == ErrorStatus.UnreadableFiles)                                  return;                                first_sync = false;                            } while (HasLocalChanges);                      }                         if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {                          Status = SyncStatus.Idle;                          SyncStatusChanged (Status);                      }                    } else {                      Thread.Sleep (500);                  }                } while (IsBuffering);
Magic Number,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: do {                  if (size_buffer.Count >= 4)                      size_buffer.RemoveAt (0);                    size_buffer.Add (CalculateSize (info));                    if (size_buffer.Count >= 4 &&                      size_buffer [0].Equals (size_buffer [1]) &&                      size_buffer [1].Equals (size_buffer [2]) &&                      size_buffer [2].Equals (size_buffer [3])) {                        Logger.LogInfo ("Local"' Name + " | Activity has settled");                      IsBuffering = false;                        bool first_sync = true;                        if (HasLocalChanges && Status == SyncStatus.Idle) {                          do {                              if (!first_sync)                                  Logger.LogInfo ("Local"' Name + " | More changes found");                                SyncUpBase ();                                if (Error == ErrorStatus.UnreadableFiles)                                  return;                                first_sync = false;                            } while (HasLocalChanges);                      }                         if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {                          Status = SyncStatus.Idle;                          SyncStatusChanged (Status);                      }                    } else {                      Thread.Sleep (500);                  }                } while (IsBuffering);
Magic Number,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnProgressChanged,The following statement contains a magic number: if (percentage == 100.0)                  percentage = 99.0;
Magic Number,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnProgressChanged,The following statement contains a magic number: if (percentage == 100.0)                  percentage = 99.0;
Magic Number,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerDisconnectedDelegate,The following statement contains a magic number: if (reason == DisconnectReason.SystemSleep) {                  this.remote_timer.Stop ();                    int backoff_time = 2;                    do {                      Logger.LogInfo (Name' "Next reconnect attempt in " + backoff_time + " seconds");                      Thread.Sleep (backoff_time * 1000);                      this.listener.Connect ();                      backoff_time *= 2;                                    } while (backoff_time < 64 && !this.listener.IsConnected);                    this.remote_timer.Start ();              }
Magic Number,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerDisconnectedDelegate,The following statement contains a magic number: if (reason == DisconnectReason.SystemSleep) {                  this.remote_timer.Stop ();                    int backoff_time = 2;                    do {                      Logger.LogInfo (Name' "Next reconnect attempt in " + backoff_time + " seconds");                      Thread.Sleep (backoff_time * 1000);                      this.listener.Connect ();                      backoff_time *= 2;                                    } while (backoff_time < 64 && !this.listener.IsConnected);                    this.remote_timer.Start ();              }
Magic Number,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerDisconnectedDelegate,The following statement contains a magic number: if (reason == DisconnectReason.SystemSleep) {                  this.remote_timer.Stop ();                    int backoff_time = 2;                    do {                      Logger.LogInfo (Name' "Next reconnect attempt in " + backoff_time + " seconds");                      Thread.Sleep (backoff_time * 1000);                      this.listener.Connect ();                      backoff_time *= 2;                                    } while (backoff_time < 64 && !this.listener.IsConnected);                    this.remote_timer.Start ();              }
Magic Number,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerDisconnectedDelegate,The following statement contains a magic number: if (reason == DisconnectReason.SystemSleep) {                  this.remote_timer.Stop ();                    int backoff_time = 2;                    do {                      Logger.LogInfo (Name' "Next reconnect attempt in " + backoff_time + " seconds");                      Thread.Sleep (backoff_time * 1000);                      this.listener.Connect ();                      backoff_time *= 2;                                    } while (backoff_time < 64 && !this.listener.IsConnected);                    this.remote_timer.Start ();              }
Magic Number,Sparkles,BaseRepository,C:\repos\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerAnnouncementReceivedDelegate,The following statement contains a magic number: if (!announcement.Message.Equals (CurrentRevision)) {                  while (this.is_syncing)                      Thread.Sleep (100);                    Logger.LogInfo (Name' "Syncing due to announcement");                    if (Status == SyncStatus.Paused)                      Logger.LogInfo (Name' "We're paused' skipping sync");                  else                      SyncDownBase ();              }
Magic Number,Sparkles,Configuration,C:\repos\hbons_SparkleShare\Sparkles\Configuration.cs,Configuration,The following statement contains a magic number: foreach (FileInfo file in new DirectoryInfo (logs_path).GetFiles ("log*.txt")) {                  if (file.LastWriteTime < DateTime.Now.AddDays (-7))                      file.Delete ();              }
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESEncrypt,The following statement contains a magic number: byte [] salt_bytes = new Byte [16];
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESEncrypt,The following statement contains a magic number: password = (password + salt).SHA256 ().Substring (0' 32);
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESEncrypt,The following statement contains a magic number: RijndaelManaged aes = new RijndaelManaged () {                  KeySize = 256'                  BlockSize = 128'                  Mode = CipherMode.CBC'                  Padding = PaddingMode.PKCS7'                  Key = Encoding.UTF8.GetBytes (password)'                  IV = Encoding.UTF8.GetBytes (password.ToCharArray ()' 0' 16)              };
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESEncrypt,The following statement contains a magic number: RijndaelManaged aes = new RijndaelManaged () {                  KeySize = 256'                  BlockSize = 128'                  Mode = CipherMode.CBC'                  Padding = PaddingMode.PKCS7'                  Key = Encoding.UTF8.GetBytes (password)'                  IV = Encoding.UTF8.GetBytes (password.ToCharArray ()' 0' 16)              };
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESEncrypt,The following statement contains a magic number: RijndaelManaged aes = new RijndaelManaged () {                  KeySize = 256'                  BlockSize = 128'                  Mode = CipherMode.CBC'                  Padding = PaddingMode.PKCS7'                  Key = Encoding.UTF8.GetBytes (password)'                  IV = Encoding.UTF8.GetBytes (password.ToCharArray ()' 0' 16)              };
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESDecrypt,The following statement contains a magic number: password = (password + salt).SHA256 ().Substring (0' 32);
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESDecrypt,The following statement contains a magic number: RijndaelManaged aes = new RijndaelManaged () {                  KeySize = 256'                  BlockSize = 128'                  Mode = CipherMode.CBC'                  Padding = PaddingMode.PKCS7'                  Key = Encoding.UTF8.GetBytes (password)'                  IV = Encoding.UTF8.GetBytes (password.ToCharArray ()' 0' 16)              };
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESDecrypt,The following statement contains a magic number: RijndaelManaged aes = new RijndaelManaged () {                  KeySize = 256'                  BlockSize = 128'                  Mode = CipherMode.CBC'                  Padding = PaddingMode.PKCS7'                  Key = Encoding.UTF8.GetBytes (password)'                  IV = Encoding.UTF8.GetBytes (password.ToCharArray ()' 0' 16)              };
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,AESDecrypt,The following statement contains a magic number: RijndaelManaged aes = new RijndaelManaged () {                  KeySize = 256'                  BlockSize = 128'                  Mode = CipherMode.CBC'                  Padding = PaddingMode.PKCS7'                  Key = Encoding.UTF8.GetBytes (password)'                  IV = Encoding.UTF8.GetBytes (password.ToCharArray ()' 0' 16)              };
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)                  return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));              else if (byte_count >= 1073741824)                  return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));              else if (byte_count >= 1048576)                  return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));              else if (byte_count >= 1024)                  return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));              else                  return byte_count + " ʙ";
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)                  return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));              else if (byte_count >= 1073741824)                  return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));              else if (byte_count >= 1048576)                  return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));              else if (byte_count >= 1024)                  return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));              else                  return byte_count + " ʙ";
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)                  return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));              else if (byte_count >= 1073741824)                  return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));              else if (byte_count >= 1048576)                  return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));              else if (byte_count >= 1024)                  return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));              else                  return byte_count + " ʙ";
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)                  return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));              else if (byte_count >= 1073741824)                  return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));              else if (byte_count >= 1048576)                  return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));              else if (byte_count >= 1024)                  return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));              else                  return byte_count + " ʙ";
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)                  return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));              else if (byte_count >= 1073741824)                  return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));              else if (byte_count >= 1048576)                  return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));              else if (byte_count >= 1024)                  return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));              else                  return byte_count + " ʙ";
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)                  return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));              else if (byte_count >= 1073741824)                  return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));              else if (byte_count >= 1048576)                  return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));              else if (byte_count >= 1024)                  return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));              else                  return byte_count + " ʙ";
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)                  return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));              else if (byte_count >= 1073741824)                  return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));              else if (byte_count >= 1048576)                  return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));              else if (byte_count >= 1024)                  return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));              else                  return byte_count + " ʙ";
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)                  return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));              else if (byte_count >= 1073741824)                  return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));              else if (byte_count >= 1048576)                  return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));              else if (byte_count >= 1024)                  return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));              else                  return byte_count + " ʙ";
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)                  return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));              else if (byte_count >= 1073741824)                  return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));              else if (byte_count >= 1048576)                  return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));              else if (byte_count >= 1024)                  return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));              else                  return byte_count + " ʙ";
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (timestamp >= yesterday && timestamp < DateTime.Today) {                  return "yesterday at " + timestamp.ToString ("HH:mm");                } else if (day_diff == 0) {                  return "today at " + timestamp.ToString ("HH:mm");                            } else if (day_diff < 7) {                  return timestamp.ToString ("dddd");                            } else if (day_diff < 31) {                  if (day_diff < 14)                      return "a week ago";                  else                      return string.Format ("{0} weeks ago"' Math.Ceiling ((double) day_diff / 7));                } else if (day_diff < 62) {                  return "a month ago";                } else {                   return string.Format ("{0} months ago"' Math.Ceiling ((double) day_diff / 31));              }
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (timestamp >= yesterday && timestamp < DateTime.Today) {                  return "yesterday at " + timestamp.ToString ("HH:mm");                } else if (day_diff == 0) {                  return "today at " + timestamp.ToString ("HH:mm");                            } else if (day_diff < 7) {                  return timestamp.ToString ("dddd");                            } else if (day_diff < 31) {                  if (day_diff < 14)                      return "a week ago";                  else                      return string.Format ("{0} weeks ago"' Math.Ceiling ((double) day_diff / 7));                } else if (day_diff < 62) {                  return "a month ago";                } else {                   return string.Format ("{0} months ago"' Math.Ceiling ((double) day_diff / 31));              }
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (timestamp >= yesterday && timestamp < DateTime.Today) {                  return "yesterday at " + timestamp.ToString ("HH:mm");                } else if (day_diff == 0) {                  return "today at " + timestamp.ToString ("HH:mm");                            } else if (day_diff < 7) {                  return timestamp.ToString ("dddd");                            } else if (day_diff < 31) {                  if (day_diff < 14)                      return "a week ago";                  else                      return string.Format ("{0} weeks ago"' Math.Ceiling ((double) day_diff / 7));                } else if (day_diff < 62) {                  return "a month ago";                } else {                   return string.Format ("{0} months ago"' Math.Ceiling ((double) day_diff / 31));              }
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (timestamp >= yesterday && timestamp < DateTime.Today) {                  return "yesterday at " + timestamp.ToString ("HH:mm");                } else if (day_diff == 0) {                  return "today at " + timestamp.ToString ("HH:mm");                            } else if (day_diff < 7) {                  return timestamp.ToString ("dddd");                            } else if (day_diff < 31) {                  if (day_diff < 14)                      return "a week ago";                  else                      return string.Format ("{0} weeks ago"' Math.Ceiling ((double) day_diff / 7));                } else if (day_diff < 62) {                  return "a month ago";                } else {                   return string.Format ("{0} months ago"' Math.Ceiling ((double) day_diff / 31));              }
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (timestamp >= yesterday && timestamp < DateTime.Today) {                  return "yesterday at " + timestamp.ToString ("HH:mm");                } else if (day_diff == 0) {                  return "today at " + timestamp.ToString ("HH:mm");                            } else if (day_diff < 7) {                  return timestamp.ToString ("dddd");                            } else if (day_diff < 31) {                  if (day_diff < 14)                      return "a week ago";                  else                      return string.Format ("{0} weeks ago"' Math.Ceiling ((double) day_diff / 7));                } else if (day_diff < 62) {                  return "a month ago";                } else {                   return string.Format ("{0} months ago"' Math.Ceiling ((double) day_diff / 31));              }
Magic Number,Sparkles,Extensions,C:\repos\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (timestamp >= yesterday && timestamp < DateTime.Today) {                  return "yesterday at " + timestamp.ToString ("HH:mm");                } else if (day_diff == 0) {                  return "today at " + timestamp.ToString ("HH:mm");                            } else if (day_diff < 7) {                  return timestamp.ToString ("dddd");                            } else if (day_diff < 31) {                  if (day_diff < 14)                      return "a week ago";                  else                      return string.Format ("{0} weeks ago"' Math.Ceiling ((double) day_diff / 7));                } else if (day_diff < 62) {                  return "a month ago";                } else {                   return string.Format ("{0} months ago"' Math.Ceiling ((double) day_diff / 31));              }
Magic Number,Sparkles,Logger,C:\repos\hbons_SparkleShare\Sparkles\Logger.cs,LogInfo,The following statement contains a magic number: lock (debug_lock) {                  if (log_size >= 1000) {                      File.WriteAllText (Configuration.DefaultConfiguration.LogFilePath' line + Environment.NewLine);                      log_size = 0;                    } else {                      File.AppendAllText (Configuration.DefaultConfiguration.LogFilePath' line + Environment.NewLine);                      log_size++;                  }              }
Magic Number,Sparkles,Logger,C:\repos\hbons_SparkleShare\Sparkles\Logger.cs,WriteCrashReport,The following statement contains a magic number: if (Configuration.DefaultConfiguration != null && File.Exists (Configuration.DefaultConfiguration.LogFilePath)) {                  string debug_log      = File.ReadAllText (Configuration.DefaultConfiguration.LogFilePath);                  string [] debug_lines = debug_log.Split (Environment.NewLine.ToCharArray ());                   int line_count        = 50;                                        if (debug_lines.Length > line_count)                      crash_report += string.Join (n' debug_lines' (debug_lines.Length - line_count)' line_count) + n;                  else                      crash_report += debug_log + n;              }
Magic Number,Sparkles,InstallationInfo,C:\repos\hbons_SparkleShare\Sparkles\InstallationInfo.Directory.cs,MacOSVersion,The following statement contains a magic number: switch (int.Parse (output)) {              case 7:  release = "Lion"; break;              case 8:  release = "Mountain Lion"; break;              case 9:  release = "Mavericks"; break;              case 10: release = "Yosemite"; break;              case 11: release = "El Capitan"; break;              case 12: release = "Sierra"; break;              case 13: release = "High Sierra"; break;              }
Magic Number,Sparkles,InstallationInfo,C:\repos\hbons_SparkleShare\Sparkles\InstallationInfo.Directory.cs,MacOSVersion,The following statement contains a magic number: switch (int.Parse (output)) {              case 7:  release = "Lion"; break;              case 8:  release = "Mountain Lion"; break;              case 9:  release = "Mavericks"; break;              case 10: release = "Yosemite"; break;              case 11: release = "El Capitan"; break;              case 12: release = "Sierra"; break;              case 13: release = "High Sierra"; break;              }
Magic Number,Sparkles,InstallationInfo,C:\repos\hbons_SparkleShare\Sparkles\InstallationInfo.Directory.cs,MacOSVersion,The following statement contains a magic number: switch (int.Parse (output)) {              case 7:  release = "Lion"; break;              case 8:  release = "Mountain Lion"; break;              case 9:  release = "Mavericks"; break;              case 10: release = "Yosemite"; break;              case 11: release = "El Capitan"; break;              case 12: release = "Sierra"; break;              case 13: release = "High Sierra"; break;              }
Magic Number,Sparkles,InstallationInfo,C:\repos\hbons_SparkleShare\Sparkles\InstallationInfo.Directory.cs,MacOSVersion,The following statement contains a magic number: switch (int.Parse (output)) {              case 7:  release = "Lion"; break;              case 8:  release = "Mountain Lion"; break;              case 9:  release = "Mavericks"; break;              case 10: release = "Yosemite"; break;              case 11: release = "El Capitan"; break;              case 12: release = "Sierra"; break;              case 13: release = "High Sierra"; break;              }
Magic Number,Sparkles,InstallationInfo,C:\repos\hbons_SparkleShare\Sparkles\InstallationInfo.Directory.cs,MacOSVersion,The following statement contains a magic number: switch (int.Parse (output)) {              case 7:  release = "Lion"; break;              case 8:  release = "Mountain Lion"; break;              case 9:  release = "Mavericks"; break;              case 10: release = "Yosemite"; break;              case 11: release = "El Capitan"; break;              case 12: release = "Sierra"; break;              case 13: release = "High Sierra"; break;              }
Magic Number,Sparkles,InstallationInfo,C:\repos\hbons_SparkleShare\Sparkles\InstallationInfo.Directory.cs,MacOSVersion,The following statement contains a magic number: switch (int.Parse (output)) {              case 7:  release = "Lion"; break;              case 8:  release = "Mountain Lion"; break;              case 9:  release = "Mavericks"; break;              case 10: release = "Yosemite"; break;              case 11: release = "El Capitan"; break;              case 12: release = "Sierra"; break;              case 13: release = "High Sierra"; break;              }
Magic Number,Sparkles,InstallationInfo,C:\repos\hbons_SparkleShare\Sparkles\InstallationInfo.Directory.cs,MacOSVersion,The following statement contains a magic number: switch (int.Parse (output)) {              case 7:  release = "Lion"; break;              case 8:  release = "Mountain Lion"; break;              case 9:  release = "Mavericks"; break;              case 10: release = "Yosemite"; break;              case 11: release = "El Capitan"; break;              case 12: release = "Sierra"; break;              case 13: release = "High Sierra"; break;              }
Magic Number,Sparkles,SSHFetcher,C:\repos\hbons_SparkleShare\Sparkles\SSHFetcher.cs,DeriveFingerprint,The following statement contains a magic number: try {                  SHA256 sha256 = new SHA256CryptoServiceProvider ();                  string key = public_key.Split (" ".ToCharArray ()) [2];                    byte [] base64_bytes = Convert.FromBase64String (key);                  byte [] sha256_bytes = sha256.ComputeHash (base64_bytes);                    string fingerprint = BitConverter.ToString (sha256_bytes);                  Console.WriteLine( fingerprint.ToLower ().Replace ("-"' ":"));                  return fingerprint.ToLower ().Replace ("-"' ":");                } catch (Exception e) {                  Logger.LogInfo ("Fetcher"' "Failed to create fingerprint: " + e.Message + " " + e.StackTrace);                  return null;              }
Magic Number,Sparkles,TcpListener,C:\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,C:\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,C:\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,C:\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,C:\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,C:\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,C:\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,C:\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,C:\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,C:\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,C:\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,C:\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Magic Number,Sparkles,TcpListener,C:\repos\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {                  int port = Server.Port;                    if (port < 0)                      port = 443;                    try {                      this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {                          ReceiveTimeout = 5 * 1000'                          SendTimeout    = 5 * 1000                      };                        // Try to connect to the server                      this.socket.Connect (Server.Host' port);                        this.is_connecting = false;                      this.is_connected  = true;                        OnConnected ();                    } catch (Exception e) {                      this.is_connected  = false;                      this.is_connecting = false;                        if (this.socket != null)                          this.socket.Close ();                        OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);                      return;                  }                      byte [] bytes  = new byte [4096];                  int bytes_read = 0;                  this.last_ping = DateTime.Now;                    // Wait for messages                  while (this.is_connected) {                      try {                          int i = 0;                          int timeout = 300;                          DisconnectReason reason = DisconnectReason.TimeOut;                            // This blocks the thread                          while (this.socket.Available < 1) {                              try {                                  // We've timed out' let's ping the server to                                  // see if the connection is still up                                  if (i == timeout) {                                      Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);                                        byte [] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");                                      byte [] pong_bytes = new byte [4096];                                        this.socket.Send (ping_bytes);                                        if (this.socket.Receive (pong_bytes) < 1)                                          // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                        Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);                                        i = 0;                                      this.last_ping = DateTime.Now;                                    } else {                                        // Check when the last ping occured. If it's                                      // significantly longer than our regular interval the                                      // system likely woke up from sleep and we want to                                      // simulate a disconnect                                      int sleepiness = DateTime.Compare (                                          this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)'                                          DateTime.Now                                      );                                        if (sleepiness <= 0) {                                          Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");                                          reason = DisconnectReason.SystemSleep;                                            // 10057 means "Socket is not connected"                                          throw new SocketException (10057);                                      }                                  }                                // The ping failed: disconnect completely                              } catch (SocketException e) {                                  Disconnect(reason' "Ping timeout: " + e.Message);                                  return;                              }                                Thread.Sleep (1000);                              i++;                          }                        } catch (Exception) {                          return;                      }                        try {                          if (this.socket.Available > 0)                              bytes_read = this.socket.Receive (bytes);                            // Parse the received message                          if (bytes_read > 0) {                              string received = Encoding.UTF8.GetString (bytes);                              string line     = received.Substring (0' received.IndexOf ("\n"));                                if (!line.Contains ("!"))                                  continue;                                string folder_identifier = line.Substring (0' line.IndexOf ("!"));                              string message           = CleanMessage (line.Substring (line.IndexOf ("!") + 1));                                // We have a message!                              if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))                                  OnAnnouncement (new Announcement (folder_identifier' message));                          }                        } catch (SocketException e) {                          Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);                          return;                      }                  }              });
Missing Default,Sparkles,ChangeSet,C:\repos\hbons_SparkleShare\Sparkles\ChangeSet.cs,ToMessage,The following switch statement is missing a default case: switch (Changes [0].Type) {              case ChangeType.Edited:  message = "edited: {0}"; break;              case ChangeType.Deleted: message = "deleted: {0}"; break;              case ChangeType.Moved:   message = "moved: {0}"; break;              }
Missing Default,Sparkles,InstallationInfo,C:\repos\hbons_SparkleShare\Sparkles\InstallationInfo.Directory.cs,MacOSVersion,The following switch statement is missing a default case: switch (int.Parse (output)) {              case 7:  release = "Lion"; break;              case 8:  release = "Mountain Lion"; break;              case 9:  release = "Mavericks"; break;              case 10: release = "Yosemite"; break;              case 11: release = "El Capitan"; break;              case 12: release = "Sierra"; break;              case 13: release = "High Sierra"; break;              }
