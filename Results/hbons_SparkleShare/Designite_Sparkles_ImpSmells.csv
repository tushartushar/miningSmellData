Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,Cyclomatic complexity of the method is 13
Complex Method,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,SyncDownBase,Cyclomatic complexity of the method is 10
Complex Method,Sparkles,ChangeSet,F:\newReposMay17\hbons_SparkleShare\Sparkles\ChangeSet.cs,ToMessage,Cyclomatic complexity of the method is 8
Complex Method,Sparkles,Configuration,F:\newReposMay17\hbons_SparkleShare\Sparkles\Configuration.cs,Configuration,Cyclomatic complexity of the method is 10
Long Parameter List,Sparkles,Preset,F:\newReposMay17\hbons_SparkleShare\Sparkles\Preset.cs,Create,The method has 6 parameters.
Long Statement,Sparkles,BaseFetcher,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseFetcher.cs,CreateInitialChangeSet,The length of the statement  "	string text = "Congratulations' you've successfully created a SparkleShare repository!" + n + n + "Any files you add or change in this folder will be automatically synced to " + n + uri_builder.Uri + " and everyone connected to it." + n + n + "SparkleShare is an Open Source software program that helps people collaborate and " + n + "share files. If you like what we do' consider buying us a beer: http://www.sparkleshare.org/" + n + n + "Have fun! :)" + n; " is 458.
Long Statement,Sparkles,BaseListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseListener.cs,Announce,The length of the statement  "			Logger.LogInfo ("Listener"' "Announcing message " + announcement.Message + " to " + announcement.FolderIdentifier + " on " + Server); " is 133.
Long Statement,Sparkles,BaseListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseListener.cs,Announce,The length of the statement  "		Logger.LogInfo ("Listener"' "Already processed message " + announcement.Message + " to " + announcement.FolderIdentifier + " from " + Server); " is 142.
Long Statement,Sparkles,BaseListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseListener.cs,OnAnnouncement,The length of the statement  "	Logger.LogInfo ("Listener"' "Got message " + announcement.Message + " from " + announcement.FolderIdentifier + " on " + Server); " is 128.
Long Statement,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The length of the statement  "		if (size_buffer.Count >= 4 && size_buffer [0].Equals (size_buffer [1]) && size_buffer [1].Equals (size_buffer [2]) && size_buffer [2].Equals (size_buffer [3])) { " is 161.
Long Statement,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,SyncDownBase,The length of the statement  "		if (!pre_sync_revision.Equals (CurrentRevision) && ChangeSets != null && ChangeSets.Count > 0 && !ChangeSets [0].User.Name.Equals (this.local_config.User.Name)) { " is 162.
Long Statement,Sparkles,Configuration,F:\newReposMay17\hbons_SparkleShare\Sparkles\Configuration.cs,CreateInitialConfig,The length of the statement  "	File.WriteAllText (FilePath' "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>" + n + "<sparkleshare>" + n + "  <user>" + n + "    <name>" + user_name + "</name>" + n + "    <email>Unknown</email>" + n + "  </user>" + n + "  <notifications>True</notifications>" + n + "</sparkleshare>"); " is 282.
Long Statement,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ReplaceUnderscoreWithSpace,The length of the statement  "		return s.Substring (0' lead) + s.Substring (lead' len - lead - trail).Replace ("_"' " ") + s.Substring (len - trail' trail); " is 124.
Long Statement,Sparkles,Logger,F:\newReposMay17\hbons_SparkleShare\Sparkles\Logger.cs,WriteCrashReport,The length of the statement  "	string crash_report = "Oops! SparkleShare has crashed... :(" + n + n + "If you want to help fix this crash' please report it at " + n + "https://github.com/hbons/SparkleShare/issues and include the lines below." + n + n + "Remove any sensitive information like file names' IP addresses' domain names' etc. if needed." + n + n + "------" + n + n; " is 345.
Long Statement,Sparkles,SSHAuthenticationInfo,F:\newReposMay17\hbons_SparkleShare\Sparkles\SSHAuthenticationInfo.cs,CreateKeyPair,The length of the statement  "	if (computer_name.EndsWith (".local"' StringComparison.InvariantCultureIgnoreCase) || computer_name.EndsWith (".config"' StringComparison.InvariantCultureIgnoreCase)) " is 166.
Long Statement,Sparkles,Preset,F:\newReposMay17\hbons_SparkleShare\Sparkles\Preset.cs,Create,The length of the statement  "	string preset_xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + "<sparkleshare>" + "  <preset>" + "    <info>" + "        <name>" + name + "</name>" + "        <description>" + description + "</description>" + "        <icon>own-server.png</icon>" + "    </info>" + "    <address>" + "      <value>" + address_value + "</value>" + "      <example>" + address_example + "</example>" + "    </address>" + "    <path>" + "      <value>" + path_value + "</value>" + "      <example>" + path_example + "</example>" + "    </path>" + "  </preset>" + "</sparkleshare>"; " is 565.
Complex Conditional,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The conditional expression  "size_buffer.Count >= 4 && size_buffer [0].Equals (size_buffer [1]) && size_buffer [1].Equals (size_buffer [2]) && size_buffer [2].Equals (size_buffer [3])"  is complex.
Complex Conditional,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,SyncDownBase,The conditional expression  "!pre_sync_revision.Equals (CurrentRevision) && ChangeSets != null && ChangeSets.Count > 0 && !ChangeSets [0].User.Name.Equals (this.local_config.User.Name)"  is complex.
Magic Number,Sparkles,BaseFetcher,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseFetcher.cs,Start,The following statement contains a magic number: thread = new Thread (() => {  	if (Fetch ()) {  		Thread.Sleep (500);  		Logger.LogInfo ("Fetcher"' "Finished");  		IsActive = false;  		Finished (FetchedRepoStorageType' Warnings);  	} else {  		Thread.Sleep (500);  		if (IsActive) {  			Logger.LogInfo ("Fetcher"' "Failed");  			Failed ();  		} else {  			Logger.LogInfo ("Fetcher"' "Failed: cancelled by user");  		}  		IsActive = false;  	}  });  
Magic Number,Sparkles,BaseFetcher,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseFetcher.cs,Start,The following statement contains a magic number: thread = new Thread (() => {  	if (Fetch ()) {  		Thread.Sleep (500);  		Logger.LogInfo ("Fetcher"' "Finished");  		IsActive = false;  		Finished (FetchedRepoStorageType' Warnings);  	} else {  		Thread.Sleep (500);  		if (IsActive) {  			Logger.LogInfo ("Fetcher"' "Failed");  			Failed ();  		} else {  			Logger.LogInfo ("Fetcher"' "Failed: cancelled by user");  		}  		IsActive = false;  	}  });  
Magic Number,Sparkles,BaseFetcher,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseFetcher.cs,Start,The following statement contains a magic number: if (Fetch ()) {  	Thread.Sleep (500);  	Logger.LogInfo ("Fetcher"' "Finished");  	IsActive = false;  	Finished (FetchedRepoStorageType' Warnings);  } else {  	Thread.Sleep (500);  	if (IsActive) {  		Logger.LogInfo ("Fetcher"' "Failed");  		Failed ();  	} else {  		Logger.LogInfo ("Fetcher"' "Failed: cancelled by user");  	}  	IsActive = false;  }  
Magic Number,Sparkles,BaseFetcher,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseFetcher.cs,Start,The following statement contains a magic number: if (Fetch ()) {  	Thread.Sleep (500);  	Logger.LogInfo ("Fetcher"' "Finished");  	IsActive = false;  	Finished (FetchedRepoStorageType' Warnings);  } else {  	Thread.Sleep (500);  	if (IsActive) {  		Logger.LogInfo ("Fetcher"' "Failed");  		Failed ();  	} else {  		Logger.LogInfo ("Fetcher"' "Failed: cancelled by user");  	}  	IsActive = false;  }  
Magic Number,Sparkles,BaseFetcher,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseFetcher.cs,Start,The following statement contains a magic number: Thread.Sleep (500);  
Magic Number,Sparkles,BaseFetcher,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseFetcher.cs,Start,The following statement contains a magic number: Thread.Sleep (500);  
Magic Number,Sparkles,BaseFetcher,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseFetcher.cs,GetBackend,The following statement contains a magic number: if (address.StartsWith ("ssh+"' StringComparison.InvariantCultureIgnoreCase)) {  	string backend = address.Substring (0' address.IndexOf ("://"' StringComparison.InvariantCulture));  	backend = backend.Substring (4);  	return char.ToUpper (backend [0]) + backend.Substring (1);  }  
Magic Number,Sparkles,BaseFetcher,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseFetcher.cs,GetBackend,The following statement contains a magic number: backend = backend.Substring (4);  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: do {  	if (size_buffer.Count >= 4)  		size_buffer.RemoveAt (0);  	size_buffer.Add (CalculateSize (info));  	if (size_buffer.Count >= 4 && size_buffer [0].Equals (size_buffer [1]) && size_buffer [1].Equals (size_buffer [2]) && size_buffer [2].Equals (size_buffer [3])) {  		Logger.LogInfo ("Local"' Name + " | Activity has settled");  		IsBuffering = false;  		bool first_sync = true;  		if (HasLocalChanges && Status == SyncStatus.Idle) {  			do {  				if (!first_sync)  					Logger.LogInfo ("Local"' Name + " | More changes found");  				SyncUpBase ();  				if (Error == ErrorStatus.UnreadableFiles)  					return;  				first_sync = false;  			} while (HasLocalChanges);  		}  		if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {  			Status = SyncStatus.Idle;  			SyncStatusChanged (Status);  		}  	} else {  		Thread.Sleep (500);  	}  } while (IsBuffering);  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: do {  	if (size_buffer.Count >= 4)  		size_buffer.RemoveAt (0);  	size_buffer.Add (CalculateSize (info));  	if (size_buffer.Count >= 4 && size_buffer [0].Equals (size_buffer [1]) && size_buffer [1].Equals (size_buffer [2]) && size_buffer [2].Equals (size_buffer [3])) {  		Logger.LogInfo ("Local"' Name + " | Activity has settled");  		IsBuffering = false;  		bool first_sync = true;  		if (HasLocalChanges && Status == SyncStatus.Idle) {  			do {  				if (!first_sync)  					Logger.LogInfo ("Local"' Name + " | More changes found");  				SyncUpBase ();  				if (Error == ErrorStatus.UnreadableFiles)  					return;  				first_sync = false;  			} while (HasLocalChanges);  		}  		if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {  			Status = SyncStatus.Idle;  			SyncStatusChanged (Status);  		}  	} else {  		Thread.Sleep (500);  	}  } while (IsBuffering);  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: do {  	if (size_buffer.Count >= 4)  		size_buffer.RemoveAt (0);  	size_buffer.Add (CalculateSize (info));  	if (size_buffer.Count >= 4 && size_buffer [0].Equals (size_buffer [1]) && size_buffer [1].Equals (size_buffer [2]) && size_buffer [2].Equals (size_buffer [3])) {  		Logger.LogInfo ("Local"' Name + " | Activity has settled");  		IsBuffering = false;  		bool first_sync = true;  		if (HasLocalChanges && Status == SyncStatus.Idle) {  			do {  				if (!first_sync)  					Logger.LogInfo ("Local"' Name + " | More changes found");  				SyncUpBase ();  				if (Error == ErrorStatus.UnreadableFiles)  					return;  				first_sync = false;  			} while (HasLocalChanges);  		}  		if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {  			Status = SyncStatus.Idle;  			SyncStatusChanged (Status);  		}  	} else {  		Thread.Sleep (500);  	}  } while (IsBuffering);  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: do {  	if (size_buffer.Count >= 4)  		size_buffer.RemoveAt (0);  	size_buffer.Add (CalculateSize (info));  	if (size_buffer.Count >= 4 && size_buffer [0].Equals (size_buffer [1]) && size_buffer [1].Equals (size_buffer [2]) && size_buffer [2].Equals (size_buffer [3])) {  		Logger.LogInfo ("Local"' Name + " | Activity has settled");  		IsBuffering = false;  		bool first_sync = true;  		if (HasLocalChanges && Status == SyncStatus.Idle) {  			do {  				if (!first_sync)  					Logger.LogInfo ("Local"' Name + " | More changes found");  				SyncUpBase ();  				if (Error == ErrorStatus.UnreadableFiles)  					return;  				first_sync = false;  			} while (HasLocalChanges);  		}  		if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {  			Status = SyncStatus.Idle;  			SyncStatusChanged (Status);  		}  	} else {  		Thread.Sleep (500);  	}  } while (IsBuffering);  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: do {  	if (size_buffer.Count >= 4)  		size_buffer.RemoveAt (0);  	size_buffer.Add (CalculateSize (info));  	if (size_buffer.Count >= 4 && size_buffer [0].Equals (size_buffer [1]) && size_buffer [1].Equals (size_buffer [2]) && size_buffer [2].Equals (size_buffer [3])) {  		Logger.LogInfo ("Local"' Name + " | Activity has settled");  		IsBuffering = false;  		bool first_sync = true;  		if (HasLocalChanges && Status == SyncStatus.Idle) {  			do {  				if (!first_sync)  					Logger.LogInfo ("Local"' Name + " | More changes found");  				SyncUpBase ();  				if (Error == ErrorStatus.UnreadableFiles)  					return;  				first_sync = false;  			} while (HasLocalChanges);  		}  		if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {  			Status = SyncStatus.Idle;  			SyncStatusChanged (Status);  		}  	} else {  		Thread.Sleep (500);  	}  } while (IsBuffering);  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: do {  	if (size_buffer.Count >= 4)  		size_buffer.RemoveAt (0);  	size_buffer.Add (CalculateSize (info));  	if (size_buffer.Count >= 4 && size_buffer [0].Equals (size_buffer [1]) && size_buffer [1].Equals (size_buffer [2]) && size_buffer [2].Equals (size_buffer [3])) {  		Logger.LogInfo ("Local"' Name + " | Activity has settled");  		IsBuffering = false;  		bool first_sync = true;  		if (HasLocalChanges && Status == SyncStatus.Idle) {  			do {  				if (!first_sync)  					Logger.LogInfo ("Local"' Name + " | More changes found");  				SyncUpBase ();  				if (Error == ErrorStatus.UnreadableFiles)  					return;  				first_sync = false;  			} while (HasLocalChanges);  		}  		if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {  			Status = SyncStatus.Idle;  			SyncStatusChanged (Status);  		}  	} else {  		Thread.Sleep (500);  	}  } while (IsBuffering);  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: if (size_buffer.Count >= 4)  	size_buffer.RemoveAt (0);  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: if (size_buffer.Count >= 4 && size_buffer [0].Equals (size_buffer [1]) && size_buffer [1].Equals (size_buffer [2]) && size_buffer [2].Equals (size_buffer [3])) {  	Logger.LogInfo ("Local"' Name + " | Activity has settled");  	IsBuffering = false;  	bool first_sync = true;  	if (HasLocalChanges && Status == SyncStatus.Idle) {  		do {  			if (!first_sync)  				Logger.LogInfo ("Local"' Name + " | More changes found");  			SyncUpBase ();  			if (Error == ErrorStatus.UnreadableFiles)  				return;  			first_sync = false;  		} while (HasLocalChanges);  	}  	if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {  		Status = SyncStatus.Idle;  		SyncStatusChanged (Status);  	}  } else {  	Thread.Sleep (500);  }  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: if (size_buffer.Count >= 4 && size_buffer [0].Equals (size_buffer [1]) && size_buffer [1].Equals (size_buffer [2]) && size_buffer [2].Equals (size_buffer [3])) {  	Logger.LogInfo ("Local"' Name + " | Activity has settled");  	IsBuffering = false;  	bool first_sync = true;  	if (HasLocalChanges && Status == SyncStatus.Idle) {  		do {  			if (!first_sync)  				Logger.LogInfo ("Local"' Name + " | More changes found");  			SyncUpBase ();  			if (Error == ErrorStatus.UnreadableFiles)  				return;  			first_sync = false;  		} while (HasLocalChanges);  	}  	if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {  		Status = SyncStatus.Idle;  		SyncStatusChanged (Status);  	}  } else {  	Thread.Sleep (500);  }  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: if (size_buffer.Count >= 4 && size_buffer [0].Equals (size_buffer [1]) && size_buffer [1].Equals (size_buffer [2]) && size_buffer [2].Equals (size_buffer [3])) {  	Logger.LogInfo ("Local"' Name + " | Activity has settled");  	IsBuffering = false;  	bool first_sync = true;  	if (HasLocalChanges && Status == SyncStatus.Idle) {  		do {  			if (!first_sync)  				Logger.LogInfo ("Local"' Name + " | More changes found");  			SyncUpBase ();  			if (Error == ErrorStatus.UnreadableFiles)  				return;  			first_sync = false;  		} while (HasLocalChanges);  	}  	if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {  		Status = SyncStatus.Idle;  		SyncStatusChanged (Status);  	}  } else {  	Thread.Sleep (500);  }  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: if (size_buffer.Count >= 4 && size_buffer [0].Equals (size_buffer [1]) && size_buffer [1].Equals (size_buffer [2]) && size_buffer [2].Equals (size_buffer [3])) {  	Logger.LogInfo ("Local"' Name + " | Activity has settled");  	IsBuffering = false;  	bool first_sync = true;  	if (HasLocalChanges && Status == SyncStatus.Idle) {  		do {  			if (!first_sync)  				Logger.LogInfo ("Local"' Name + " | More changes found");  			SyncUpBase ();  			if (Error == ErrorStatus.UnreadableFiles)  				return;  			first_sync = false;  		} while (HasLocalChanges);  	}  	if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {  		Status = SyncStatus.Idle;  		SyncStatusChanged (Status);  	}  } else {  	Thread.Sleep (500);  }  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: if (size_buffer.Count >= 4 && size_buffer [0].Equals (size_buffer [1]) && size_buffer [1].Equals (size_buffer [2]) && size_buffer [2].Equals (size_buffer [3])) {  	Logger.LogInfo ("Local"' Name + " | Activity has settled");  	IsBuffering = false;  	bool first_sync = true;  	if (HasLocalChanges && Status == SyncStatus.Idle) {  		do {  			if (!first_sync)  				Logger.LogInfo ("Local"' Name + " | More changes found");  			SyncUpBase ();  			if (Error == ErrorStatus.UnreadableFiles)  				return;  			first_sync = false;  		} while (HasLocalChanges);  	}  	if (Status != SyncStatus.Idle && Status != SyncStatus.Error) {  		Status = SyncStatus.Idle;  		SyncStatusChanged (Status);  	}  } else {  	Thread.Sleep (500);  }  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnFileActivity,The following statement contains a magic number: Thread.Sleep (500);  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnProgressChanged,The following statement contains a magic number: if (percentage == 100.0)  	percentage = 99.0;  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnProgressChanged,The following statement contains a magic number: if (percentage == 100.0)  	percentage = 99.0;  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,OnProgressChanged,The following statement contains a magic number: percentage = 99.0;  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerDisconnectedDelegate,The following statement contains a magic number: if (reason == DisconnectReason.SystemSleep) {  	this.remote_timer.Stop ();  	int backoff_time = 2;  	do {  		Logger.LogInfo (Name' "Next reconnect attempt in " + backoff_time + " seconds");  		Thread.Sleep (backoff_time * 1000);  		this.listener.Connect ();  		backoff_time *= 2;  	} while (backoff_time < 64 && !this.listener.IsConnected);  	this.remote_timer.Start ();  }  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerDisconnectedDelegate,The following statement contains a magic number: if (reason == DisconnectReason.SystemSleep) {  	this.remote_timer.Stop ();  	int backoff_time = 2;  	do {  		Logger.LogInfo (Name' "Next reconnect attempt in " + backoff_time + " seconds");  		Thread.Sleep (backoff_time * 1000);  		this.listener.Connect ();  		backoff_time *= 2;  	} while (backoff_time < 64 && !this.listener.IsConnected);  	this.remote_timer.Start ();  }  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerDisconnectedDelegate,The following statement contains a magic number: if (reason == DisconnectReason.SystemSleep) {  	this.remote_timer.Stop ();  	int backoff_time = 2;  	do {  		Logger.LogInfo (Name' "Next reconnect attempt in " + backoff_time + " seconds");  		Thread.Sleep (backoff_time * 1000);  		this.listener.Connect ();  		backoff_time *= 2;  	} while (backoff_time < 64 && !this.listener.IsConnected);  	this.remote_timer.Start ();  }  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerDisconnectedDelegate,The following statement contains a magic number: if (reason == DisconnectReason.SystemSleep) {  	this.remote_timer.Stop ();  	int backoff_time = 2;  	do {  		Logger.LogInfo (Name' "Next reconnect attempt in " + backoff_time + " seconds");  		Thread.Sleep (backoff_time * 1000);  		this.listener.Connect ();  		backoff_time *= 2;  	} while (backoff_time < 64 && !this.listener.IsConnected);  	this.remote_timer.Start ();  }  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerDisconnectedDelegate,The following statement contains a magic number: do {  	Logger.LogInfo (Name' "Next reconnect attempt in " + backoff_time + " seconds");  	Thread.Sleep (backoff_time * 1000);  	this.listener.Connect ();  	backoff_time *= 2;  } while (backoff_time < 64 && !this.listener.IsConnected);  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerDisconnectedDelegate,The following statement contains a magic number: do {  	Logger.LogInfo (Name' "Next reconnect attempt in " + backoff_time + " seconds");  	Thread.Sleep (backoff_time * 1000);  	this.listener.Connect ();  	backoff_time *= 2;  } while (backoff_time < 64 && !this.listener.IsConnected);  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerDisconnectedDelegate,The following statement contains a magic number: do {  	Logger.LogInfo (Name' "Next reconnect attempt in " + backoff_time + " seconds");  	Thread.Sleep (backoff_time * 1000);  	this.listener.Connect ();  	backoff_time *= 2;  } while (backoff_time < 64 && !this.listener.IsConnected);  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerDisconnectedDelegate,The following statement contains a magic number: Thread.Sleep (backoff_time * 1000);  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerDisconnectedDelegate,The following statement contains a magic number: backoff_time *= 2;  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerAnnouncementReceivedDelegate,The following statement contains a magic number: if (!announcement.Message.Equals (CurrentRevision)) {  	while (this.is_syncing)  		Thread.Sleep (100);  	Logger.LogInfo (Name' "Syncing due to announcement");  	if (Status == SyncStatus.Paused)  		Logger.LogInfo (Name' "We're paused' skipping sync");  	else  		SyncDownBase ();  }  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerAnnouncementReceivedDelegate,The following statement contains a magic number: while (this.is_syncing)  	Thread.Sleep (100);  
Magic Number,Sparkles,BaseRepository,F:\newReposMay17\hbons_SparkleShare\Sparkles\BaseRepository.cs,ListenerAnnouncementReceivedDelegate,The following statement contains a magic number: Thread.Sleep (100);  
Magic Number,Sparkles,Configuration,F:\newReposMay17\hbons_SparkleShare\Sparkles\Configuration.cs,Configuration,The following statement contains a magic number: foreach (FileInfo file in new DirectoryInfo (logs_path).GetFiles ("log*.txt")) {  	if (file.LastWriteTime < DateTime.Now.AddDays (-7))  		file.Delete ();  }  
Magic Number,Sparkles,Configuration,F:\newReposMay17\hbons_SparkleShare\Sparkles\Configuration.cs,Configuration,The following statement contains a magic number: if (file.LastWriteTime < DateTime.Now.AddDays (-7))  	file.Delete ();  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,AESEncrypt,The following statement contains a magic number: password = (password + salt).SHA256 ().Substring (0' 32);  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,AESDecrypt,The following statement contains a magic number: password = (password + salt).SHA256 ().Substring (0' 32);  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)  	return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));  else if (byte_count >= 1073741824)  	return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));  else if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)  	return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));  else if (byte_count >= 1073741824)  	return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));  else if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)  	return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));  else if (byte_count >= 1073741824)  	return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));  else if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)  	return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));  else if (byte_count >= 1073741824)  	return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));  else if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)  	return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));  else if (byte_count >= 1073741824)  	return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));  else if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)  	return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));  else if (byte_count >= 1073741824)  	return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));  else if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)  	return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));  else if (byte_count >= 1073741824)  	return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));  else if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)  	return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));  else if (byte_count >= 1073741824)  	return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));  else if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1099511627776)  	return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));  else if (byte_count >= 1073741824)  	return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));  else if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: return string.Format ("{0:##.##} ᴛʙ"' Math.Round (byte_count / 1099511627776' 2));  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1073741824)  	return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));  else if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1073741824)  	return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));  else if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1073741824)  	return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));  else if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1073741824)  	return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));  else if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1073741824)  	return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));  else if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1073741824)  	return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));  else if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: return string.Format ("{0:##.##} ɢʙ"' Math.Round (byte_count / 1073741824' 1));  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1048576)  	return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  else if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: return string.Format ("{0:##.##} ᴍʙ"' Math.Round (byte_count / 1048576' 1));  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: if (byte_count >= 1024)  	return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  else  	return byte_count + " ʙ";  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToSize,The following statement contains a magic number: return string.Format ("{0:##.##} ᴋʙ"' Math.Round (byte_count / 1024' 0));  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (timestamp >= yesterday && timestamp < DateTime.Today) {  	return "yesterday at " + timestamp.ToString ("HH:mm");  } else if (day_diff == 0) {  	return "today at " + timestamp.ToString ("HH:mm");  } else if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (timestamp >= yesterday && timestamp < DateTime.Today) {  	return "yesterday at " + timestamp.ToString ("HH:mm");  } else if (day_diff == 0) {  	return "today at " + timestamp.ToString ("HH:mm");  } else if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (timestamp >= yesterday && timestamp < DateTime.Today) {  	return "yesterday at " + timestamp.ToString ("HH:mm");  } else if (day_diff == 0) {  	return "today at " + timestamp.ToString ("HH:mm");  } else if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (timestamp >= yesterday && timestamp < DateTime.Today) {  	return "yesterday at " + timestamp.ToString ("HH:mm");  } else if (day_diff == 0) {  	return "today at " + timestamp.ToString ("HH:mm");  } else if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (timestamp >= yesterday && timestamp < DateTime.Today) {  	return "yesterday at " + timestamp.ToString ("HH:mm");  } else if (day_diff == 0) {  	return "today at " + timestamp.ToString ("HH:mm");  } else if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (timestamp >= yesterday && timestamp < DateTime.Today) {  	return "yesterday at " + timestamp.ToString ("HH:mm");  } else if (day_diff == 0) {  	return "today at " + timestamp.ToString ("HH:mm");  } else if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff == 0) {  	return "today at " + timestamp.ToString ("HH:mm");  } else if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff == 0) {  	return "today at " + timestamp.ToString ("HH:mm");  } else if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff == 0) {  	return "today at " + timestamp.ToString ("HH:mm");  } else if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff == 0) {  	return "today at " + timestamp.ToString ("HH:mm");  } else if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff == 0) {  	return "today at " + timestamp.ToString ("HH:mm");  } else if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff == 0) {  	return "today at " + timestamp.ToString ("HH:mm");  } else if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff < 7) {  	return timestamp.ToString ("dddd");  } else if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff < 31) {  	if (day_diff < 14)  		return "a week ago";  	else  		return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  } else if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff < 14)  	return "a week ago";  else  	return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff < 14)  	return "a week ago";  else  	return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: return string.Format ("{0} weeks ago"' Math.Ceiling ((double)day_diff / 7));  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: if (day_diff < 62) {  	return "a month ago";  } else {  	return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  }  
Magic Number,Sparkles,Extensions,F:\newReposMay17\hbons_SparkleShare\Sparkles\Extensions.cs,ToPrettyDate,The following statement contains a magic number: return string.Format ("{0} months ago"' Math.Ceiling ((double)day_diff / 31));  
Magic Number,Sparkles,Logger,F:\newReposMay17\hbons_SparkleShare\Sparkles\Logger.cs,LogInfo,The following statement contains a magic number: lock (debug_lock) {  	if (log_size >= 1000) {  		File.WriteAllText (Configuration.DefaultConfiguration.LogFilePath' line + Environment.NewLine);  		log_size = 0;  	} else {  		File.AppendAllText (Configuration.DefaultConfiguration.LogFilePath' line + Environment.NewLine);  		log_size++;  	}  }  
Magic Number,Sparkles,Logger,F:\newReposMay17\hbons_SparkleShare\Sparkles\Logger.cs,LogInfo,The following statement contains a magic number: if (log_size >= 1000) {  	File.WriteAllText (Configuration.DefaultConfiguration.LogFilePath' line + Environment.NewLine);  	log_size = 0;  } else {  	File.AppendAllText (Configuration.DefaultConfiguration.LogFilePath' line + Environment.NewLine);  	log_size++;  }  
Magic Number,Sparkles,Logger,F:\newReposMay17\hbons_SparkleShare\Sparkles\Logger.cs,WriteCrashReport,The following statement contains a magic number: if (Configuration.DefaultConfiguration != null && File.Exists (Configuration.DefaultConfiguration.LogFilePath)) {  	string debug_log = File.ReadAllText (Configuration.DefaultConfiguration.LogFilePath);  	string[] debug_lines = debug_log.Split (Environment.NewLine.ToCharArray ());  	int line_count = 50;  	if (debug_lines.Length > line_count)  		crash_report += string.Join (n' debug_lines' (debug_lines.Length - line_count)' line_count) + n;  	else  		crash_report += debug_log + n;  }  
Magic Number,Sparkles,SSHFetcher,F:\newReposMay17\hbons_SparkleShare\Sparkles\SSHFetcher.cs,DeriveFingerprint,The following statement contains a magic number: try {  	SHA256 sha256 = new SHA256CryptoServiceProvider ();  	string key = public_key.Split (" ".ToCharArray ()) [2];  	byte[] base64_bytes = Convert.FromBase64String (key);  	byte[] sha256_bytes = sha256.ComputeHash (base64_bytes);  	string fingerprint = BitConverter.ToString (sha256_bytes);  	Console.WriteLine (fingerprint.ToLower ().Replace ("-"' ":"));  	return fingerprint.ToLower ().Replace ("-"' ":");  } catch (Exception e) {  	Logger.LogInfo ("Fetcher"' "Failed to create fingerprint: " + e.Message + " " + e.StackTrace);  	return null;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {  	int port = Server.Port;  	if (port < 0)  		port = 443;  	try {  		this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  			ReceiveTimeout = 5 * 1000'  			SendTimeout = 5 * 1000  		};  		// Try to connect to the server  		this.socket.Connect (Server.Host' port);  		this.is_connecting = false;  		this.is_connected = true;  		OnConnected ();  	} catch (Exception e) {  		this.is_connected = false;  		this.is_connecting = false;  		if (this.socket != null)  			this.socket.Close ();  		OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  		return;  	}  	byte[] bytes = new byte[4096];  	int bytes_read = 0;  	this.last_ping = DateTime.Now;  	// Wait for messages  	while (this.is_connected) {  		try {  			int i = 0;  			int timeout = 300;  			DisconnectReason reason = DisconnectReason.TimeOut;  			// This blocks the thread  			while (this.socket.Available < 1) {  				try {  					// We've timed out' let's ping the server to  					// see if the connection is still up  					if (i == timeout) {  						Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  						byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  						byte[] pong_bytes = new byte[4096];  						this.socket.Send (ping_bytes);  						if (this.socket.Receive (pong_bytes) < 1)  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  						i = 0;  						this.last_ping = DateTime.Now;  					} else {  						// Check when the last ping occured. If it's  						// significantly longer than our regular interval the  						// system likely woke up from sleep and we want to  						// simulate a disconnect  						int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  						if (sleepiness <= 0) {  							Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  							reason = DisconnectReason.SystemSleep;  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						}  					}  					// The ping failed: disconnect completely  				} catch (SocketException e) {  					Disconnect (reason' "Ping timeout: " + e.Message);  					return;  				}  				Thread.Sleep (1000);  				i++;  			}  		} catch (Exception) {  			return;  		}  		try {  			if (this.socket.Available > 0)  				bytes_read = this.socket.Receive (bytes);  			// Parse the received message  			if (bytes_read > 0) {  				string received = Encoding.UTF8.GetString (bytes);  				string line = received.Substring (0' received.IndexOf ("\n"));  				if (!line.Contains ("!"))  					continue;  				string folder_identifier = line.Substring (0' line.IndexOf ("!"));  				string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  				// We have a message!  				if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  					OnAnnouncement (new Announcement (folder_identifier' message));  			}  		} catch (SocketException e) {  			Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  			return;  		}  	}  });  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {  	int port = Server.Port;  	if (port < 0)  		port = 443;  	try {  		this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  			ReceiveTimeout = 5 * 1000'  			SendTimeout = 5 * 1000  		};  		// Try to connect to the server  		this.socket.Connect (Server.Host' port);  		this.is_connecting = false;  		this.is_connected = true;  		OnConnected ();  	} catch (Exception e) {  		this.is_connected = false;  		this.is_connecting = false;  		if (this.socket != null)  			this.socket.Close ();  		OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  		return;  	}  	byte[] bytes = new byte[4096];  	int bytes_read = 0;  	this.last_ping = DateTime.Now;  	// Wait for messages  	while (this.is_connected) {  		try {  			int i = 0;  			int timeout = 300;  			DisconnectReason reason = DisconnectReason.TimeOut;  			// This blocks the thread  			while (this.socket.Available < 1) {  				try {  					// We've timed out' let's ping the server to  					// see if the connection is still up  					if (i == timeout) {  						Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  						byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  						byte[] pong_bytes = new byte[4096];  						this.socket.Send (ping_bytes);  						if (this.socket.Receive (pong_bytes) < 1)  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  						i = 0;  						this.last_ping = DateTime.Now;  					} else {  						// Check when the last ping occured. If it's  						// significantly longer than our regular interval the  						// system likely woke up from sleep and we want to  						// simulate a disconnect  						int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  						if (sleepiness <= 0) {  							Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  							reason = DisconnectReason.SystemSleep;  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						}  					}  					// The ping failed: disconnect completely  				} catch (SocketException e) {  					Disconnect (reason' "Ping timeout: " + e.Message);  					return;  				}  				Thread.Sleep (1000);  				i++;  			}  		} catch (Exception) {  			return;  		}  		try {  			if (this.socket.Available > 0)  				bytes_read = this.socket.Receive (bytes);  			// Parse the received message  			if (bytes_read > 0) {  				string received = Encoding.UTF8.GetString (bytes);  				string line = received.Substring (0' received.IndexOf ("\n"));  				if (!line.Contains ("!"))  					continue;  				string folder_identifier = line.Substring (0' line.IndexOf ("!"));  				string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  				// We have a message!  				if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  					OnAnnouncement (new Announcement (folder_identifier' message));  			}  		} catch (SocketException e) {  			Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  			return;  		}  	}  });  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {  	int port = Server.Port;  	if (port < 0)  		port = 443;  	try {  		this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  			ReceiveTimeout = 5 * 1000'  			SendTimeout = 5 * 1000  		};  		// Try to connect to the server  		this.socket.Connect (Server.Host' port);  		this.is_connecting = false;  		this.is_connected = true;  		OnConnected ();  	} catch (Exception e) {  		this.is_connected = false;  		this.is_connecting = false;  		if (this.socket != null)  			this.socket.Close ();  		OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  		return;  	}  	byte[] bytes = new byte[4096];  	int bytes_read = 0;  	this.last_ping = DateTime.Now;  	// Wait for messages  	while (this.is_connected) {  		try {  			int i = 0;  			int timeout = 300;  			DisconnectReason reason = DisconnectReason.TimeOut;  			// This blocks the thread  			while (this.socket.Available < 1) {  				try {  					// We've timed out' let's ping the server to  					// see if the connection is still up  					if (i == timeout) {  						Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  						byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  						byte[] pong_bytes = new byte[4096];  						this.socket.Send (ping_bytes);  						if (this.socket.Receive (pong_bytes) < 1)  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  						i = 0;  						this.last_ping = DateTime.Now;  					} else {  						// Check when the last ping occured. If it's  						// significantly longer than our regular interval the  						// system likely woke up from sleep and we want to  						// simulate a disconnect  						int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  						if (sleepiness <= 0) {  							Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  							reason = DisconnectReason.SystemSleep;  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						}  					}  					// The ping failed: disconnect completely  				} catch (SocketException e) {  					Disconnect (reason' "Ping timeout: " + e.Message);  					return;  				}  				Thread.Sleep (1000);  				i++;  			}  		} catch (Exception) {  			return;  		}  		try {  			if (this.socket.Available > 0)  				bytes_read = this.socket.Receive (bytes);  			// Parse the received message  			if (bytes_read > 0) {  				string received = Encoding.UTF8.GetString (bytes);  				string line = received.Substring (0' received.IndexOf ("\n"));  				if (!line.Contains ("!"))  					continue;  				string folder_identifier = line.Substring (0' line.IndexOf ("!"));  				string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  				// We have a message!  				if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  					OnAnnouncement (new Announcement (folder_identifier' message));  			}  		} catch (SocketException e) {  			Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  			return;  		}  	}  });  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {  	int port = Server.Port;  	if (port < 0)  		port = 443;  	try {  		this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  			ReceiveTimeout = 5 * 1000'  			SendTimeout = 5 * 1000  		};  		// Try to connect to the server  		this.socket.Connect (Server.Host' port);  		this.is_connecting = false;  		this.is_connected = true;  		OnConnected ();  	} catch (Exception e) {  		this.is_connected = false;  		this.is_connecting = false;  		if (this.socket != null)  			this.socket.Close ();  		OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  		return;  	}  	byte[] bytes = new byte[4096];  	int bytes_read = 0;  	this.last_ping = DateTime.Now;  	// Wait for messages  	while (this.is_connected) {  		try {  			int i = 0;  			int timeout = 300;  			DisconnectReason reason = DisconnectReason.TimeOut;  			// This blocks the thread  			while (this.socket.Available < 1) {  				try {  					// We've timed out' let's ping the server to  					// see if the connection is still up  					if (i == timeout) {  						Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  						byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  						byte[] pong_bytes = new byte[4096];  						this.socket.Send (ping_bytes);  						if (this.socket.Receive (pong_bytes) < 1)  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  						i = 0;  						this.last_ping = DateTime.Now;  					} else {  						// Check when the last ping occured. If it's  						// significantly longer than our regular interval the  						// system likely woke up from sleep and we want to  						// simulate a disconnect  						int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  						if (sleepiness <= 0) {  							Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  							reason = DisconnectReason.SystemSleep;  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						}  					}  					// The ping failed: disconnect completely  				} catch (SocketException e) {  					Disconnect (reason' "Ping timeout: " + e.Message);  					return;  				}  				Thread.Sleep (1000);  				i++;  			}  		} catch (Exception) {  			return;  		}  		try {  			if (this.socket.Available > 0)  				bytes_read = this.socket.Receive (bytes);  			// Parse the received message  			if (bytes_read > 0) {  				string received = Encoding.UTF8.GetString (bytes);  				string line = received.Substring (0' received.IndexOf ("\n"));  				if (!line.Contains ("!"))  					continue;  				string folder_identifier = line.Substring (0' line.IndexOf ("!"));  				string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  				// We have a message!  				if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  					OnAnnouncement (new Announcement (folder_identifier' message));  			}  		} catch (SocketException e) {  			Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  			return;  		}  	}  });  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {  	int port = Server.Port;  	if (port < 0)  		port = 443;  	try {  		this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  			ReceiveTimeout = 5 * 1000'  			SendTimeout = 5 * 1000  		};  		// Try to connect to the server  		this.socket.Connect (Server.Host' port);  		this.is_connecting = false;  		this.is_connected = true;  		OnConnected ();  	} catch (Exception e) {  		this.is_connected = false;  		this.is_connecting = false;  		if (this.socket != null)  			this.socket.Close ();  		OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  		return;  	}  	byte[] bytes = new byte[4096];  	int bytes_read = 0;  	this.last_ping = DateTime.Now;  	// Wait for messages  	while (this.is_connected) {  		try {  			int i = 0;  			int timeout = 300;  			DisconnectReason reason = DisconnectReason.TimeOut;  			// This blocks the thread  			while (this.socket.Available < 1) {  				try {  					// We've timed out' let's ping the server to  					// see if the connection is still up  					if (i == timeout) {  						Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  						byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  						byte[] pong_bytes = new byte[4096];  						this.socket.Send (ping_bytes);  						if (this.socket.Receive (pong_bytes) < 1)  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  						i = 0;  						this.last_ping = DateTime.Now;  					} else {  						// Check when the last ping occured. If it's  						// significantly longer than our regular interval the  						// system likely woke up from sleep and we want to  						// simulate a disconnect  						int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  						if (sleepiness <= 0) {  							Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  							reason = DisconnectReason.SystemSleep;  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						}  					}  					// The ping failed: disconnect completely  				} catch (SocketException e) {  					Disconnect (reason' "Ping timeout: " + e.Message);  					return;  				}  				Thread.Sleep (1000);  				i++;  			}  		} catch (Exception) {  			return;  		}  		try {  			if (this.socket.Available > 0)  				bytes_read = this.socket.Receive (bytes);  			// Parse the received message  			if (bytes_read > 0) {  				string received = Encoding.UTF8.GetString (bytes);  				string line = received.Substring (0' received.IndexOf ("\n"));  				if (!line.Contains ("!"))  					continue;  				string folder_identifier = line.Substring (0' line.IndexOf ("!"));  				string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  				// We have a message!  				if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  					OnAnnouncement (new Announcement (folder_identifier' message));  			}  		} catch (SocketException e) {  			Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  			return;  		}  	}  });  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {  	int port = Server.Port;  	if (port < 0)  		port = 443;  	try {  		this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  			ReceiveTimeout = 5 * 1000'  			SendTimeout = 5 * 1000  		};  		// Try to connect to the server  		this.socket.Connect (Server.Host' port);  		this.is_connecting = false;  		this.is_connected = true;  		OnConnected ();  	} catch (Exception e) {  		this.is_connected = false;  		this.is_connecting = false;  		if (this.socket != null)  			this.socket.Close ();  		OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  		return;  	}  	byte[] bytes = new byte[4096];  	int bytes_read = 0;  	this.last_ping = DateTime.Now;  	// Wait for messages  	while (this.is_connected) {  		try {  			int i = 0;  			int timeout = 300;  			DisconnectReason reason = DisconnectReason.TimeOut;  			// This blocks the thread  			while (this.socket.Available < 1) {  				try {  					// We've timed out' let's ping the server to  					// see if the connection is still up  					if (i == timeout) {  						Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  						byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  						byte[] pong_bytes = new byte[4096];  						this.socket.Send (ping_bytes);  						if (this.socket.Receive (pong_bytes) < 1)  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  						i = 0;  						this.last_ping = DateTime.Now;  					} else {  						// Check when the last ping occured. If it's  						// significantly longer than our regular interval the  						// system likely woke up from sleep and we want to  						// simulate a disconnect  						int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  						if (sleepiness <= 0) {  							Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  							reason = DisconnectReason.SystemSleep;  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						}  					}  					// The ping failed: disconnect completely  				} catch (SocketException e) {  					Disconnect (reason' "Ping timeout: " + e.Message);  					return;  				}  				Thread.Sleep (1000);  				i++;  			}  		} catch (Exception) {  			return;  		}  		try {  			if (this.socket.Available > 0)  				bytes_read = this.socket.Receive (bytes);  			// Parse the received message  			if (bytes_read > 0) {  				string received = Encoding.UTF8.GetString (bytes);  				string line = received.Substring (0' received.IndexOf ("\n"));  				if (!line.Contains ("!"))  					continue;  				string folder_identifier = line.Substring (0' line.IndexOf ("!"));  				string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  				// We have a message!  				if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  					OnAnnouncement (new Announcement (folder_identifier' message));  			}  		} catch (SocketException e) {  			Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  			return;  		}  	}  });  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {  	int port = Server.Port;  	if (port < 0)  		port = 443;  	try {  		this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  			ReceiveTimeout = 5 * 1000'  			SendTimeout = 5 * 1000  		};  		// Try to connect to the server  		this.socket.Connect (Server.Host' port);  		this.is_connecting = false;  		this.is_connected = true;  		OnConnected ();  	} catch (Exception e) {  		this.is_connected = false;  		this.is_connecting = false;  		if (this.socket != null)  			this.socket.Close ();  		OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  		return;  	}  	byte[] bytes = new byte[4096];  	int bytes_read = 0;  	this.last_ping = DateTime.Now;  	// Wait for messages  	while (this.is_connected) {  		try {  			int i = 0;  			int timeout = 300;  			DisconnectReason reason = DisconnectReason.TimeOut;  			// This blocks the thread  			while (this.socket.Available < 1) {  				try {  					// We've timed out' let's ping the server to  					// see if the connection is still up  					if (i == timeout) {  						Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  						byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  						byte[] pong_bytes = new byte[4096];  						this.socket.Send (ping_bytes);  						if (this.socket.Receive (pong_bytes) < 1)  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  						i = 0;  						this.last_ping = DateTime.Now;  					} else {  						// Check when the last ping occured. If it's  						// significantly longer than our regular interval the  						// system likely woke up from sleep and we want to  						// simulate a disconnect  						int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  						if (sleepiness <= 0) {  							Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  							reason = DisconnectReason.SystemSleep;  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						}  					}  					// The ping failed: disconnect completely  				} catch (SocketException e) {  					Disconnect (reason' "Ping timeout: " + e.Message);  					return;  				}  				Thread.Sleep (1000);  				i++;  			}  		} catch (Exception) {  			return;  		}  		try {  			if (this.socket.Available > 0)  				bytes_read = this.socket.Receive (bytes);  			// Parse the received message  			if (bytes_read > 0) {  				string received = Encoding.UTF8.GetString (bytes);  				string line = received.Substring (0' received.IndexOf ("\n"));  				if (!line.Contains ("!"))  					continue;  				string folder_identifier = line.Substring (0' line.IndexOf ("!"));  				string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  				// We have a message!  				if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  					OnAnnouncement (new Announcement (folder_identifier' message));  			}  		} catch (SocketException e) {  			Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  			return;  		}  	}  });  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {  	int port = Server.Port;  	if (port < 0)  		port = 443;  	try {  		this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  			ReceiveTimeout = 5 * 1000'  			SendTimeout = 5 * 1000  		};  		// Try to connect to the server  		this.socket.Connect (Server.Host' port);  		this.is_connecting = false;  		this.is_connected = true;  		OnConnected ();  	} catch (Exception e) {  		this.is_connected = false;  		this.is_connecting = false;  		if (this.socket != null)  			this.socket.Close ();  		OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  		return;  	}  	byte[] bytes = new byte[4096];  	int bytes_read = 0;  	this.last_ping = DateTime.Now;  	// Wait for messages  	while (this.is_connected) {  		try {  			int i = 0;  			int timeout = 300;  			DisconnectReason reason = DisconnectReason.TimeOut;  			// This blocks the thread  			while (this.socket.Available < 1) {  				try {  					// We've timed out' let's ping the server to  					// see if the connection is still up  					if (i == timeout) {  						Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  						byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  						byte[] pong_bytes = new byte[4096];  						this.socket.Send (ping_bytes);  						if (this.socket.Receive (pong_bytes) < 1)  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  						i = 0;  						this.last_ping = DateTime.Now;  					} else {  						// Check when the last ping occured. If it's  						// significantly longer than our regular interval the  						// system likely woke up from sleep and we want to  						// simulate a disconnect  						int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  						if (sleepiness <= 0) {  							Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  							reason = DisconnectReason.SystemSleep;  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						}  					}  					// The ping failed: disconnect completely  				} catch (SocketException e) {  					Disconnect (reason' "Ping timeout: " + e.Message);  					return;  				}  				Thread.Sleep (1000);  				i++;  			}  		} catch (Exception) {  			return;  		}  		try {  			if (this.socket.Available > 0)  				bytes_read = this.socket.Receive (bytes);  			// Parse the received message  			if (bytes_read > 0) {  				string received = Encoding.UTF8.GetString (bytes);  				string line = received.Substring (0' received.IndexOf ("\n"));  				if (!line.Contains ("!"))  					continue;  				string folder_identifier = line.Substring (0' line.IndexOf ("!"));  				string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  				// We have a message!  				if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  					OnAnnouncement (new Announcement (folder_identifier' message));  			}  		} catch (SocketException e) {  			Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  			return;  		}  	}  });  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {  	int port = Server.Port;  	if (port < 0)  		port = 443;  	try {  		this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  			ReceiveTimeout = 5 * 1000'  			SendTimeout = 5 * 1000  		};  		// Try to connect to the server  		this.socket.Connect (Server.Host' port);  		this.is_connecting = false;  		this.is_connected = true;  		OnConnected ();  	} catch (Exception e) {  		this.is_connected = false;  		this.is_connecting = false;  		if (this.socket != null)  			this.socket.Close ();  		OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  		return;  	}  	byte[] bytes = new byte[4096];  	int bytes_read = 0;  	this.last_ping = DateTime.Now;  	// Wait for messages  	while (this.is_connected) {  		try {  			int i = 0;  			int timeout = 300;  			DisconnectReason reason = DisconnectReason.TimeOut;  			// This blocks the thread  			while (this.socket.Available < 1) {  				try {  					// We've timed out' let's ping the server to  					// see if the connection is still up  					if (i == timeout) {  						Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  						byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  						byte[] pong_bytes = new byte[4096];  						this.socket.Send (ping_bytes);  						if (this.socket.Receive (pong_bytes) < 1)  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  						i = 0;  						this.last_ping = DateTime.Now;  					} else {  						// Check when the last ping occured. If it's  						// significantly longer than our regular interval the  						// system likely woke up from sleep and we want to  						// simulate a disconnect  						int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  						if (sleepiness <= 0) {  							Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  							reason = DisconnectReason.SystemSleep;  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						}  					}  					// The ping failed: disconnect completely  				} catch (SocketException e) {  					Disconnect (reason' "Ping timeout: " + e.Message);  					return;  				}  				Thread.Sleep (1000);  				i++;  			}  		} catch (Exception) {  			return;  		}  		try {  			if (this.socket.Available > 0)  				bytes_read = this.socket.Receive (bytes);  			// Parse the received message  			if (bytes_read > 0) {  				string received = Encoding.UTF8.GetString (bytes);  				string line = received.Substring (0' received.IndexOf ("\n"));  				if (!line.Contains ("!"))  					continue;  				string folder_identifier = line.Substring (0' line.IndexOf ("!"));  				string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  				// We have a message!  				if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  					OnAnnouncement (new Announcement (folder_identifier' message));  			}  		} catch (SocketException e) {  			Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  			return;  		}  	}  });  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {  	int port = Server.Port;  	if (port < 0)  		port = 443;  	try {  		this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  			ReceiveTimeout = 5 * 1000'  			SendTimeout = 5 * 1000  		};  		// Try to connect to the server  		this.socket.Connect (Server.Host' port);  		this.is_connecting = false;  		this.is_connected = true;  		OnConnected ();  	} catch (Exception e) {  		this.is_connected = false;  		this.is_connecting = false;  		if (this.socket != null)  			this.socket.Close ();  		OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  		return;  	}  	byte[] bytes = new byte[4096];  	int bytes_read = 0;  	this.last_ping = DateTime.Now;  	// Wait for messages  	while (this.is_connected) {  		try {  			int i = 0;  			int timeout = 300;  			DisconnectReason reason = DisconnectReason.TimeOut;  			// This blocks the thread  			while (this.socket.Available < 1) {  				try {  					// We've timed out' let's ping the server to  					// see if the connection is still up  					if (i == timeout) {  						Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  						byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  						byte[] pong_bytes = new byte[4096];  						this.socket.Send (ping_bytes);  						if (this.socket.Receive (pong_bytes) < 1)  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  						i = 0;  						this.last_ping = DateTime.Now;  					} else {  						// Check when the last ping occured. If it's  						// significantly longer than our regular interval the  						// system likely woke up from sleep and we want to  						// simulate a disconnect  						int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  						if (sleepiness <= 0) {  							Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  							reason = DisconnectReason.SystemSleep;  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						}  					}  					// The ping failed: disconnect completely  				} catch (SocketException e) {  					Disconnect (reason' "Ping timeout: " + e.Message);  					return;  				}  				Thread.Sleep (1000);  				i++;  			}  		} catch (Exception) {  			return;  		}  		try {  			if (this.socket.Available > 0)  				bytes_read = this.socket.Receive (bytes);  			// Parse the received message  			if (bytes_read > 0) {  				string received = Encoding.UTF8.GetString (bytes);  				string line = received.Substring (0' received.IndexOf ("\n"));  				if (!line.Contains ("!"))  					continue;  				string folder_identifier = line.Substring (0' line.IndexOf ("!"));  				string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  				// We have a message!  				if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  					OnAnnouncement (new Announcement (folder_identifier' message));  			}  		} catch (SocketException e) {  			Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  			return;  		}  	}  });  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {  	int port = Server.Port;  	if (port < 0)  		port = 443;  	try {  		this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  			ReceiveTimeout = 5 * 1000'  			SendTimeout = 5 * 1000  		};  		// Try to connect to the server  		this.socket.Connect (Server.Host' port);  		this.is_connecting = false;  		this.is_connected = true;  		OnConnected ();  	} catch (Exception e) {  		this.is_connected = false;  		this.is_connecting = false;  		if (this.socket != null)  			this.socket.Close ();  		OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  		return;  	}  	byte[] bytes = new byte[4096];  	int bytes_read = 0;  	this.last_ping = DateTime.Now;  	// Wait for messages  	while (this.is_connected) {  		try {  			int i = 0;  			int timeout = 300;  			DisconnectReason reason = DisconnectReason.TimeOut;  			// This blocks the thread  			while (this.socket.Available < 1) {  				try {  					// We've timed out' let's ping the server to  					// see if the connection is still up  					if (i == timeout) {  						Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  						byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  						byte[] pong_bytes = new byte[4096];  						this.socket.Send (ping_bytes);  						if (this.socket.Receive (pong_bytes) < 1)  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  						i = 0;  						this.last_ping = DateTime.Now;  					} else {  						// Check when the last ping occured. If it's  						// significantly longer than our regular interval the  						// system likely woke up from sleep and we want to  						// simulate a disconnect  						int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  						if (sleepiness <= 0) {  							Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  							reason = DisconnectReason.SystemSleep;  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						}  					}  					// The ping failed: disconnect completely  				} catch (SocketException e) {  					Disconnect (reason' "Ping timeout: " + e.Message);  					return;  				}  				Thread.Sleep (1000);  				i++;  			}  		} catch (Exception) {  			return;  		}  		try {  			if (this.socket.Available > 0)  				bytes_read = this.socket.Receive (bytes);  			// Parse the received message  			if (bytes_read > 0) {  				string received = Encoding.UTF8.GetString (bytes);  				string line = received.Substring (0' received.IndexOf ("\n"));  				if (!line.Contains ("!"))  					continue;  				string folder_identifier = line.Substring (0' line.IndexOf ("!"));  				string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  				// We have a message!  				if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  					OnAnnouncement (new Announcement (folder_identifier' message));  			}  		} catch (SocketException e) {  			Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  			return;  		}  	}  });  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {  	int port = Server.Port;  	if (port < 0)  		port = 443;  	try {  		this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  			ReceiveTimeout = 5 * 1000'  			SendTimeout = 5 * 1000  		};  		// Try to connect to the server  		this.socket.Connect (Server.Host' port);  		this.is_connecting = false;  		this.is_connected = true;  		OnConnected ();  	} catch (Exception e) {  		this.is_connected = false;  		this.is_connecting = false;  		if (this.socket != null)  			this.socket.Close ();  		OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  		return;  	}  	byte[] bytes = new byte[4096];  	int bytes_read = 0;  	this.last_ping = DateTime.Now;  	// Wait for messages  	while (this.is_connected) {  		try {  			int i = 0;  			int timeout = 300;  			DisconnectReason reason = DisconnectReason.TimeOut;  			// This blocks the thread  			while (this.socket.Available < 1) {  				try {  					// We've timed out' let's ping the server to  					// see if the connection is still up  					if (i == timeout) {  						Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  						byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  						byte[] pong_bytes = new byte[4096];  						this.socket.Send (ping_bytes);  						if (this.socket.Receive (pong_bytes) < 1)  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  						i = 0;  						this.last_ping = DateTime.Now;  					} else {  						// Check when the last ping occured. If it's  						// significantly longer than our regular interval the  						// system likely woke up from sleep and we want to  						// simulate a disconnect  						int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  						if (sleepiness <= 0) {  							Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  							reason = DisconnectReason.SystemSleep;  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						}  					}  					// The ping failed: disconnect completely  				} catch (SocketException e) {  					Disconnect (reason' "Ping timeout: " + e.Message);  					return;  				}  				Thread.Sleep (1000);  				i++;  			}  		} catch (Exception) {  			return;  		}  		try {  			if (this.socket.Available > 0)  				bytes_read = this.socket.Receive (bytes);  			// Parse the received message  			if (bytes_read > 0) {  				string received = Encoding.UTF8.GetString (bytes);  				string line = received.Substring (0' received.IndexOf ("\n"));  				if (!line.Contains ("!"))  					continue;  				string folder_identifier = line.Substring (0' line.IndexOf ("!"));  				string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  				// We have a message!  				if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  					OnAnnouncement (new Announcement (folder_identifier' message));  			}  		} catch (SocketException e) {  			Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  			return;  		}  	}  });  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.thread = new Thread (() => {  	int port = Server.Port;  	if (port < 0)  		port = 443;  	try {  		this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  			ReceiveTimeout = 5 * 1000'  			SendTimeout = 5 * 1000  		};  		// Try to connect to the server  		this.socket.Connect (Server.Host' port);  		this.is_connecting = false;  		this.is_connected = true;  		OnConnected ();  	} catch (Exception e) {  		this.is_connected = false;  		this.is_connecting = false;  		if (this.socket != null)  			this.socket.Close ();  		OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  		return;  	}  	byte[] bytes = new byte[4096];  	int bytes_read = 0;  	this.last_ping = DateTime.Now;  	// Wait for messages  	while (this.is_connected) {  		try {  			int i = 0;  			int timeout = 300;  			DisconnectReason reason = DisconnectReason.TimeOut;  			// This blocks the thread  			while (this.socket.Available < 1) {  				try {  					// We've timed out' let's ping the server to  					// see if the connection is still up  					if (i == timeout) {  						Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  						byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  						byte[] pong_bytes = new byte[4096];  						this.socket.Send (ping_bytes);  						if (this.socket.Receive (pong_bytes) < 1)  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  						i = 0;  						this.last_ping = DateTime.Now;  					} else {  						// Check when the last ping occured. If it's  						// significantly longer than our regular interval the  						// system likely woke up from sleep and we want to  						// simulate a disconnect  						int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  						if (sleepiness <= 0) {  							Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  							reason = DisconnectReason.SystemSleep;  							// 10057 means "Socket is not connected"  							throw new SocketException (10057);  						}  					}  					// The ping failed: disconnect completely  				} catch (SocketException e) {  					Disconnect (reason' "Ping timeout: " + e.Message);  					return;  				}  				Thread.Sleep (1000);  				i++;  			}  		} catch (Exception) {  			return;  		}  		try {  			if (this.socket.Available > 0)  				bytes_read = this.socket.Receive (bytes);  			// Parse the received message  			if (bytes_read > 0) {  				string received = Encoding.UTF8.GetString (bytes);  				string line = received.Substring (0' received.IndexOf ("\n"));  				if (!line.Contains ("!"))  					continue;  				string folder_identifier = line.Substring (0' line.IndexOf ("!"));  				string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  				// We have a message!  				if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  					OnAnnouncement (new Announcement (folder_identifier' message));  			}  		} catch (SocketException e) {  			Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  			return;  		}  	}  });  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: if (port < 0)  	port = 443;  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: port = 443;  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: try {  	this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  		ReceiveTimeout = 5 * 1000'  		SendTimeout = 5 * 1000  	};  	// Try to connect to the server  	this.socket.Connect (Server.Host' port);  	this.is_connecting = false;  	this.is_connected = true;  	OnConnected ();  } catch (Exception e) {  	this.is_connected = false;  	this.is_connecting = false;  	if (this.socket != null)  		this.socket.Close ();  	OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  	return;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: try {  	this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  		ReceiveTimeout = 5 * 1000'  		SendTimeout = 5 * 1000  	};  	// Try to connect to the server  	this.socket.Connect (Server.Host' port);  	this.is_connecting = false;  	this.is_connected = true;  	OnConnected ();  } catch (Exception e) {  	this.is_connected = false;  	this.is_connecting = false;  	if (this.socket != null)  		this.socket.Close ();  	OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  	return;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: try {  	this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  		ReceiveTimeout = 5 * 1000'  		SendTimeout = 5 * 1000  	};  	// Try to connect to the server  	this.socket.Connect (Server.Host' port);  	this.is_connecting = false;  	this.is_connected = true;  	OnConnected ();  } catch (Exception e) {  	this.is_connected = false;  	this.is_connecting = false;  	if (this.socket != null)  		this.socket.Close ();  	OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  	return;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: try {  	this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  		ReceiveTimeout = 5 * 1000'  		SendTimeout = 5 * 1000  	};  	// Try to connect to the server  	this.socket.Connect (Server.Host' port);  	this.is_connecting = false;  	this.is_connected = true;  	OnConnected ();  } catch (Exception e) {  	this.is_connected = false;  	this.is_connecting = false;  	if (this.socket != null)  		this.socket.Close ();  	OnDisconnected (Sparkles.DisconnectReason.TimeOut' e.Message);  	return;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  	ReceiveTimeout = 5 * 1000'  	SendTimeout = 5 * 1000  };  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  	ReceiveTimeout = 5 * 1000'  	SendTimeout = 5 * 1000  };  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  	ReceiveTimeout = 5 * 1000'  	SendTimeout = 5 * 1000  };  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: this.socket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp) {  	ReceiveTimeout = 5 * 1000'  	SendTimeout = 5 * 1000  };  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: while (this.is_connected) {  	try {  		int i = 0;  		int timeout = 300;  		DisconnectReason reason = DisconnectReason.TimeOut;  		// This blocks the thread  		while (this.socket.Available < 1) {  			try {  				// We've timed out' let's ping the server to  				// see if the connection is still up  				if (i == timeout) {  					Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  					byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  					byte[] pong_bytes = new byte[4096];  					this.socket.Send (ping_bytes);  					if (this.socket.Receive (pong_bytes) < 1)  						// 10057 means "Socket is not connected"  						throw new SocketException (10057);  					Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  					i = 0;  					this.last_ping = DateTime.Now;  				} else {  					// Check when the last ping occured. If it's  					// significantly longer than our regular interval the  					// system likely woke up from sleep and we want to  					// simulate a disconnect  					int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  					if (sleepiness <= 0) {  						Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  						reason = DisconnectReason.SystemSleep;  						// 10057 means "Socket is not connected"  						throw new SocketException (10057);  					}  				}  				// The ping failed: disconnect completely  			} catch (SocketException e) {  				Disconnect (reason' "Ping timeout: " + e.Message);  				return;  			}  			Thread.Sleep (1000);  			i++;  		}  	} catch (Exception) {  		return;  	}  	try {  		if (this.socket.Available > 0)  			bytes_read = this.socket.Receive (bytes);  		// Parse the received message  		if (bytes_read > 0) {  			string received = Encoding.UTF8.GetString (bytes);  			string line = received.Substring (0' received.IndexOf ("\n"));  			if (!line.Contains ("!"))  				continue;  			string folder_identifier = line.Substring (0' line.IndexOf ("!"));  			string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  			// We have a message!  			if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  				OnAnnouncement (new Announcement (folder_identifier' message));  		}  	} catch (SocketException e) {  		Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  		return;  	}  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: while (this.is_connected) {  	try {  		int i = 0;  		int timeout = 300;  		DisconnectReason reason = DisconnectReason.TimeOut;  		// This blocks the thread  		while (this.socket.Available < 1) {  			try {  				// We've timed out' let's ping the server to  				// see if the connection is still up  				if (i == timeout) {  					Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  					byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  					byte[] pong_bytes = new byte[4096];  					this.socket.Send (ping_bytes);  					if (this.socket.Receive (pong_bytes) < 1)  						// 10057 means "Socket is not connected"  						throw new SocketException (10057);  					Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  					i = 0;  					this.last_ping = DateTime.Now;  				} else {  					// Check when the last ping occured. If it's  					// significantly longer than our regular interval the  					// system likely woke up from sleep and we want to  					// simulate a disconnect  					int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  					if (sleepiness <= 0) {  						Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  						reason = DisconnectReason.SystemSleep;  						// 10057 means "Socket is not connected"  						throw new SocketException (10057);  					}  				}  				// The ping failed: disconnect completely  			} catch (SocketException e) {  				Disconnect (reason' "Ping timeout: " + e.Message);  				return;  			}  			Thread.Sleep (1000);  			i++;  		}  	} catch (Exception) {  		return;  	}  	try {  		if (this.socket.Available > 0)  			bytes_read = this.socket.Receive (bytes);  		// Parse the received message  		if (bytes_read > 0) {  			string received = Encoding.UTF8.GetString (bytes);  			string line = received.Substring (0' received.IndexOf ("\n"));  			if (!line.Contains ("!"))  				continue;  			string folder_identifier = line.Substring (0' line.IndexOf ("!"));  			string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  			// We have a message!  			if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  				OnAnnouncement (new Announcement (folder_identifier' message));  		}  	} catch (SocketException e) {  		Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  		return;  	}  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: while (this.is_connected) {  	try {  		int i = 0;  		int timeout = 300;  		DisconnectReason reason = DisconnectReason.TimeOut;  		// This blocks the thread  		while (this.socket.Available < 1) {  			try {  				// We've timed out' let's ping the server to  				// see if the connection is still up  				if (i == timeout) {  					Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  					byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  					byte[] pong_bytes = new byte[4096];  					this.socket.Send (ping_bytes);  					if (this.socket.Receive (pong_bytes) < 1)  						// 10057 means "Socket is not connected"  						throw new SocketException (10057);  					Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  					i = 0;  					this.last_ping = DateTime.Now;  				} else {  					// Check when the last ping occured. If it's  					// significantly longer than our regular interval the  					// system likely woke up from sleep and we want to  					// simulate a disconnect  					int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  					if (sleepiness <= 0) {  						Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  						reason = DisconnectReason.SystemSleep;  						// 10057 means "Socket is not connected"  						throw new SocketException (10057);  					}  				}  				// The ping failed: disconnect completely  			} catch (SocketException e) {  				Disconnect (reason' "Ping timeout: " + e.Message);  				return;  			}  			Thread.Sleep (1000);  			i++;  		}  	} catch (Exception) {  		return;  	}  	try {  		if (this.socket.Available > 0)  			bytes_read = this.socket.Receive (bytes);  		// Parse the received message  		if (bytes_read > 0) {  			string received = Encoding.UTF8.GetString (bytes);  			string line = received.Substring (0' received.IndexOf ("\n"));  			if (!line.Contains ("!"))  				continue;  			string folder_identifier = line.Substring (0' line.IndexOf ("!"));  			string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  			// We have a message!  			if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  				OnAnnouncement (new Announcement (folder_identifier' message));  		}  	} catch (SocketException e) {  		Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  		return;  	}  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: while (this.is_connected) {  	try {  		int i = 0;  		int timeout = 300;  		DisconnectReason reason = DisconnectReason.TimeOut;  		// This blocks the thread  		while (this.socket.Available < 1) {  			try {  				// We've timed out' let's ping the server to  				// see if the connection is still up  				if (i == timeout) {  					Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  					byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  					byte[] pong_bytes = new byte[4096];  					this.socket.Send (ping_bytes);  					if (this.socket.Receive (pong_bytes) < 1)  						// 10057 means "Socket is not connected"  						throw new SocketException (10057);  					Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  					i = 0;  					this.last_ping = DateTime.Now;  				} else {  					// Check when the last ping occured. If it's  					// significantly longer than our regular interval the  					// system likely woke up from sleep and we want to  					// simulate a disconnect  					int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  					if (sleepiness <= 0) {  						Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  						reason = DisconnectReason.SystemSleep;  						// 10057 means "Socket is not connected"  						throw new SocketException (10057);  					}  				}  				// The ping failed: disconnect completely  			} catch (SocketException e) {  				Disconnect (reason' "Ping timeout: " + e.Message);  				return;  			}  			Thread.Sleep (1000);  			i++;  		}  	} catch (Exception) {  		return;  	}  	try {  		if (this.socket.Available > 0)  			bytes_read = this.socket.Receive (bytes);  		// Parse the received message  		if (bytes_read > 0) {  			string received = Encoding.UTF8.GetString (bytes);  			string line = received.Substring (0' received.IndexOf ("\n"));  			if (!line.Contains ("!"))  				continue;  			string folder_identifier = line.Substring (0' line.IndexOf ("!"));  			string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  			// We have a message!  			if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  				OnAnnouncement (new Announcement (folder_identifier' message));  		}  	} catch (SocketException e) {  		Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  		return;  	}  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: while (this.is_connected) {  	try {  		int i = 0;  		int timeout = 300;  		DisconnectReason reason = DisconnectReason.TimeOut;  		// This blocks the thread  		while (this.socket.Available < 1) {  			try {  				// We've timed out' let's ping the server to  				// see if the connection is still up  				if (i == timeout) {  					Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  					byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  					byte[] pong_bytes = new byte[4096];  					this.socket.Send (ping_bytes);  					if (this.socket.Receive (pong_bytes) < 1)  						// 10057 means "Socket is not connected"  						throw new SocketException (10057);  					Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  					i = 0;  					this.last_ping = DateTime.Now;  				} else {  					// Check when the last ping occured. If it's  					// significantly longer than our regular interval the  					// system likely woke up from sleep and we want to  					// simulate a disconnect  					int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  					if (sleepiness <= 0) {  						Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  						reason = DisconnectReason.SystemSleep;  						// 10057 means "Socket is not connected"  						throw new SocketException (10057);  					}  				}  				// The ping failed: disconnect completely  			} catch (SocketException e) {  				Disconnect (reason' "Ping timeout: " + e.Message);  				return;  			}  			Thread.Sleep (1000);  			i++;  		}  	} catch (Exception) {  		return;  	}  	try {  		if (this.socket.Available > 0)  			bytes_read = this.socket.Receive (bytes);  		// Parse the received message  		if (bytes_read > 0) {  			string received = Encoding.UTF8.GetString (bytes);  			string line = received.Substring (0' received.IndexOf ("\n"));  			if (!line.Contains ("!"))  				continue;  			string folder_identifier = line.Substring (0' line.IndexOf ("!"));  			string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  			// We have a message!  			if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  				OnAnnouncement (new Announcement (folder_identifier' message));  		}  	} catch (SocketException e) {  		Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  		return;  	}  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: while (this.is_connected) {  	try {  		int i = 0;  		int timeout = 300;  		DisconnectReason reason = DisconnectReason.TimeOut;  		// This blocks the thread  		while (this.socket.Available < 1) {  			try {  				// We've timed out' let's ping the server to  				// see if the connection is still up  				if (i == timeout) {  					Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  					byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  					byte[] pong_bytes = new byte[4096];  					this.socket.Send (ping_bytes);  					if (this.socket.Receive (pong_bytes) < 1)  						// 10057 means "Socket is not connected"  						throw new SocketException (10057);  					Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  					i = 0;  					this.last_ping = DateTime.Now;  				} else {  					// Check when the last ping occured. If it's  					// significantly longer than our regular interval the  					// system likely woke up from sleep and we want to  					// simulate a disconnect  					int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  					if (sleepiness <= 0) {  						Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  						reason = DisconnectReason.SystemSleep;  						// 10057 means "Socket is not connected"  						throw new SocketException (10057);  					}  				}  				// The ping failed: disconnect completely  			} catch (SocketException e) {  				Disconnect (reason' "Ping timeout: " + e.Message);  				return;  			}  			Thread.Sleep (1000);  			i++;  		}  	} catch (Exception) {  		return;  	}  	try {  		if (this.socket.Available > 0)  			bytes_read = this.socket.Receive (bytes);  		// Parse the received message  		if (bytes_read > 0) {  			string received = Encoding.UTF8.GetString (bytes);  			string line = received.Substring (0' received.IndexOf ("\n"));  			if (!line.Contains ("!"))  				continue;  			string folder_identifier = line.Substring (0' line.IndexOf ("!"));  			string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  			// We have a message!  			if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  				OnAnnouncement (new Announcement (folder_identifier' message));  		}  	} catch (SocketException e) {  		Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  		return;  	}  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: while (this.is_connected) {  	try {  		int i = 0;  		int timeout = 300;  		DisconnectReason reason = DisconnectReason.TimeOut;  		// This blocks the thread  		while (this.socket.Available < 1) {  			try {  				// We've timed out' let's ping the server to  				// see if the connection is still up  				if (i == timeout) {  					Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  					byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  					byte[] pong_bytes = new byte[4096];  					this.socket.Send (ping_bytes);  					if (this.socket.Receive (pong_bytes) < 1)  						// 10057 means "Socket is not connected"  						throw new SocketException (10057);  					Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  					i = 0;  					this.last_ping = DateTime.Now;  				} else {  					// Check when the last ping occured. If it's  					// significantly longer than our regular interval the  					// system likely woke up from sleep and we want to  					// simulate a disconnect  					int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  					if (sleepiness <= 0) {  						Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  						reason = DisconnectReason.SystemSleep;  						// 10057 means "Socket is not connected"  						throw new SocketException (10057);  					}  				}  				// The ping failed: disconnect completely  			} catch (SocketException e) {  				Disconnect (reason' "Ping timeout: " + e.Message);  				return;  			}  			Thread.Sleep (1000);  			i++;  		}  	} catch (Exception) {  		return;  	}  	try {  		if (this.socket.Available > 0)  			bytes_read = this.socket.Receive (bytes);  		// Parse the received message  		if (bytes_read > 0) {  			string received = Encoding.UTF8.GetString (bytes);  			string line = received.Substring (0' received.IndexOf ("\n"));  			if (!line.Contains ("!"))  				continue;  			string folder_identifier = line.Substring (0' line.IndexOf ("!"));  			string message = CleanMessage (line.Substring (line.IndexOf ("!") + 1));  			// We have a message!  			if (!folder_identifier.Equals ("debug") && !string.IsNullOrEmpty (message))  				OnAnnouncement (new Announcement (folder_identifier' message));  		}  	} catch (SocketException e) {  		Disconnect (DisconnectReason.TimeOut' "Timeout during receiving: " + e.Message);  		return;  	}  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: try {  	int i = 0;  	int timeout = 300;  	DisconnectReason reason = DisconnectReason.TimeOut;  	// This blocks the thread  	while (this.socket.Available < 1) {  		try {  			// We've timed out' let's ping the server to  			// see if the connection is still up  			if (i == timeout) {  				Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  				byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  				byte[] pong_bytes = new byte[4096];  				this.socket.Send (ping_bytes);  				if (this.socket.Receive (pong_bytes) < 1)  					// 10057 means "Socket is not connected"  					throw new SocketException (10057);  				Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  				i = 0;  				this.last_ping = DateTime.Now;  			} else {  				// Check when the last ping occured. If it's  				// significantly longer than our regular interval the  				// system likely woke up from sleep and we want to  				// simulate a disconnect  				int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  				if (sleepiness <= 0) {  					Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  					reason = DisconnectReason.SystemSleep;  					// 10057 means "Socket is not connected"  					throw new SocketException (10057);  				}  			}  			// The ping failed: disconnect completely  		} catch (SocketException e) {  			Disconnect (reason' "Ping timeout: " + e.Message);  			return;  		}  		Thread.Sleep (1000);  		i++;  	}  } catch (Exception) {  	return;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: try {  	int i = 0;  	int timeout = 300;  	DisconnectReason reason = DisconnectReason.TimeOut;  	// This blocks the thread  	while (this.socket.Available < 1) {  		try {  			// We've timed out' let's ping the server to  			// see if the connection is still up  			if (i == timeout) {  				Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  				byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  				byte[] pong_bytes = new byte[4096];  				this.socket.Send (ping_bytes);  				if (this.socket.Receive (pong_bytes) < 1)  					// 10057 means "Socket is not connected"  					throw new SocketException (10057);  				Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  				i = 0;  				this.last_ping = DateTime.Now;  			} else {  				// Check when the last ping occured. If it's  				// significantly longer than our regular interval the  				// system likely woke up from sleep and we want to  				// simulate a disconnect  				int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  				if (sleepiness <= 0) {  					Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  					reason = DisconnectReason.SystemSleep;  					// 10057 means "Socket is not connected"  					throw new SocketException (10057);  				}  			}  			// The ping failed: disconnect completely  		} catch (SocketException e) {  			Disconnect (reason' "Ping timeout: " + e.Message);  			return;  		}  		Thread.Sleep (1000);  		i++;  	}  } catch (Exception) {  	return;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: try {  	int i = 0;  	int timeout = 300;  	DisconnectReason reason = DisconnectReason.TimeOut;  	// This blocks the thread  	while (this.socket.Available < 1) {  		try {  			// We've timed out' let's ping the server to  			// see if the connection is still up  			if (i == timeout) {  				Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  				byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  				byte[] pong_bytes = new byte[4096];  				this.socket.Send (ping_bytes);  				if (this.socket.Receive (pong_bytes) < 1)  					// 10057 means "Socket is not connected"  					throw new SocketException (10057);  				Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  				i = 0;  				this.last_ping = DateTime.Now;  			} else {  				// Check when the last ping occured. If it's  				// significantly longer than our regular interval the  				// system likely woke up from sleep and we want to  				// simulate a disconnect  				int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  				if (sleepiness <= 0) {  					Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  					reason = DisconnectReason.SystemSleep;  					// 10057 means "Socket is not connected"  					throw new SocketException (10057);  				}  			}  			// The ping failed: disconnect completely  		} catch (SocketException e) {  			Disconnect (reason' "Ping timeout: " + e.Message);  			return;  		}  		Thread.Sleep (1000);  		i++;  	}  } catch (Exception) {  	return;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: try {  	int i = 0;  	int timeout = 300;  	DisconnectReason reason = DisconnectReason.TimeOut;  	// This blocks the thread  	while (this.socket.Available < 1) {  		try {  			// We've timed out' let's ping the server to  			// see if the connection is still up  			if (i == timeout) {  				Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  				byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  				byte[] pong_bytes = new byte[4096];  				this.socket.Send (ping_bytes);  				if (this.socket.Receive (pong_bytes) < 1)  					// 10057 means "Socket is not connected"  					throw new SocketException (10057);  				Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  				i = 0;  				this.last_ping = DateTime.Now;  			} else {  				// Check when the last ping occured. If it's  				// significantly longer than our regular interval the  				// system likely woke up from sleep and we want to  				// simulate a disconnect  				int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  				if (sleepiness <= 0) {  					Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  					reason = DisconnectReason.SystemSleep;  					// 10057 means "Socket is not connected"  					throw new SocketException (10057);  				}  			}  			// The ping failed: disconnect completely  		} catch (SocketException e) {  			Disconnect (reason' "Ping timeout: " + e.Message);  			return;  		}  		Thread.Sleep (1000);  		i++;  	}  } catch (Exception) {  	return;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: try {  	int i = 0;  	int timeout = 300;  	DisconnectReason reason = DisconnectReason.TimeOut;  	// This blocks the thread  	while (this.socket.Available < 1) {  		try {  			// We've timed out' let's ping the server to  			// see if the connection is still up  			if (i == timeout) {  				Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  				byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  				byte[] pong_bytes = new byte[4096];  				this.socket.Send (ping_bytes);  				if (this.socket.Receive (pong_bytes) < 1)  					// 10057 means "Socket is not connected"  					throw new SocketException (10057);  				Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  				i = 0;  				this.last_ping = DateTime.Now;  			} else {  				// Check when the last ping occured. If it's  				// significantly longer than our regular interval the  				// system likely woke up from sleep and we want to  				// simulate a disconnect  				int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  				if (sleepiness <= 0) {  					Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  					reason = DisconnectReason.SystemSleep;  					// 10057 means "Socket is not connected"  					throw new SocketException (10057);  				}  			}  			// The ping failed: disconnect completely  		} catch (SocketException e) {  			Disconnect (reason' "Ping timeout: " + e.Message);  			return;  		}  		Thread.Sleep (1000);  		i++;  	}  } catch (Exception) {  	return;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: try {  	int i = 0;  	int timeout = 300;  	DisconnectReason reason = DisconnectReason.TimeOut;  	// This blocks the thread  	while (this.socket.Available < 1) {  		try {  			// We've timed out' let's ping the server to  			// see if the connection is still up  			if (i == timeout) {  				Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  				byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  				byte[] pong_bytes = new byte[4096];  				this.socket.Send (ping_bytes);  				if (this.socket.Receive (pong_bytes) < 1)  					// 10057 means "Socket is not connected"  					throw new SocketException (10057);  				Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  				i = 0;  				this.last_ping = DateTime.Now;  			} else {  				// Check when the last ping occured. If it's  				// significantly longer than our regular interval the  				// system likely woke up from sleep and we want to  				// simulate a disconnect  				int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  				if (sleepiness <= 0) {  					Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  					reason = DisconnectReason.SystemSleep;  					// 10057 means "Socket is not connected"  					throw new SocketException (10057);  				}  			}  			// The ping failed: disconnect completely  		} catch (SocketException e) {  			Disconnect (reason' "Ping timeout: " + e.Message);  			return;  		}  		Thread.Sleep (1000);  		i++;  	}  } catch (Exception) {  	return;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: try {  	int i = 0;  	int timeout = 300;  	DisconnectReason reason = DisconnectReason.TimeOut;  	// This blocks the thread  	while (this.socket.Available < 1) {  		try {  			// We've timed out' let's ping the server to  			// see if the connection is still up  			if (i == timeout) {  				Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  				byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  				byte[] pong_bytes = new byte[4096];  				this.socket.Send (ping_bytes);  				if (this.socket.Receive (pong_bytes) < 1)  					// 10057 means "Socket is not connected"  					throw new SocketException (10057);  				Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  				i = 0;  				this.last_ping = DateTime.Now;  			} else {  				// Check when the last ping occured. If it's  				// significantly longer than our regular interval the  				// system likely woke up from sleep and we want to  				// simulate a disconnect  				int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  				if (sleepiness <= 0) {  					Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  					reason = DisconnectReason.SystemSleep;  					// 10057 means "Socket is not connected"  					throw new SocketException (10057);  				}  			}  			// The ping failed: disconnect completely  		} catch (SocketException e) {  			Disconnect (reason' "Ping timeout: " + e.Message);  			return;  		}  		Thread.Sleep (1000);  		i++;  	}  } catch (Exception) {  	return;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: while (this.socket.Available < 1) {  	try {  		// We've timed out' let's ping the server to  		// see if the connection is still up  		if (i == timeout) {  			Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  			byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  			byte[] pong_bytes = new byte[4096];  			this.socket.Send (ping_bytes);  			if (this.socket.Receive (pong_bytes) < 1)  				// 10057 means "Socket is not connected"  				throw new SocketException (10057);  			Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  			i = 0;  			this.last_ping = DateTime.Now;  		} else {  			// Check when the last ping occured. If it's  			// significantly longer than our regular interval the  			// system likely woke up from sleep and we want to  			// simulate a disconnect  			int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  			if (sleepiness <= 0) {  				Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  				reason = DisconnectReason.SystemSleep;  				// 10057 means "Socket is not connected"  				throw new SocketException (10057);  			}  		}  		// The ping failed: disconnect completely  	} catch (SocketException e) {  		Disconnect (reason' "Ping timeout: " + e.Message);  		return;  	}  	Thread.Sleep (1000);  	i++;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: while (this.socket.Available < 1) {  	try {  		// We've timed out' let's ping the server to  		// see if the connection is still up  		if (i == timeout) {  			Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  			byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  			byte[] pong_bytes = new byte[4096];  			this.socket.Send (ping_bytes);  			if (this.socket.Receive (pong_bytes) < 1)  				// 10057 means "Socket is not connected"  				throw new SocketException (10057);  			Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  			i = 0;  			this.last_ping = DateTime.Now;  		} else {  			// Check when the last ping occured. If it's  			// significantly longer than our regular interval the  			// system likely woke up from sleep and we want to  			// simulate a disconnect  			int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  			if (sleepiness <= 0) {  				Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  				reason = DisconnectReason.SystemSleep;  				// 10057 means "Socket is not connected"  				throw new SocketException (10057);  			}  		}  		// The ping failed: disconnect completely  	} catch (SocketException e) {  		Disconnect (reason' "Ping timeout: " + e.Message);  		return;  	}  	Thread.Sleep (1000);  	i++;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: while (this.socket.Available < 1) {  	try {  		// We've timed out' let's ping the server to  		// see if the connection is still up  		if (i == timeout) {  			Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  			byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  			byte[] pong_bytes = new byte[4096];  			this.socket.Send (ping_bytes);  			if (this.socket.Receive (pong_bytes) < 1)  				// 10057 means "Socket is not connected"  				throw new SocketException (10057);  			Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  			i = 0;  			this.last_ping = DateTime.Now;  		} else {  			// Check when the last ping occured. If it's  			// significantly longer than our regular interval the  			// system likely woke up from sleep and we want to  			// simulate a disconnect  			int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  			if (sleepiness <= 0) {  				Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  				reason = DisconnectReason.SystemSleep;  				// 10057 means "Socket is not connected"  				throw new SocketException (10057);  			}  		}  		// The ping failed: disconnect completely  	} catch (SocketException e) {  		Disconnect (reason' "Ping timeout: " + e.Message);  		return;  	}  	Thread.Sleep (1000);  	i++;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: while (this.socket.Available < 1) {  	try {  		// We've timed out' let's ping the server to  		// see if the connection is still up  		if (i == timeout) {  			Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  			byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  			byte[] pong_bytes = new byte[4096];  			this.socket.Send (ping_bytes);  			if (this.socket.Receive (pong_bytes) < 1)  				// 10057 means "Socket is not connected"  				throw new SocketException (10057);  			Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  			i = 0;  			this.last_ping = DateTime.Now;  		} else {  			// Check when the last ping occured. If it's  			// significantly longer than our regular interval the  			// system likely woke up from sleep and we want to  			// simulate a disconnect  			int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  			if (sleepiness <= 0) {  				Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  				reason = DisconnectReason.SystemSleep;  				// 10057 means "Socket is not connected"  				throw new SocketException (10057);  			}  		}  		// The ping failed: disconnect completely  	} catch (SocketException e) {  		Disconnect (reason' "Ping timeout: " + e.Message);  		return;  	}  	Thread.Sleep (1000);  	i++;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: while (this.socket.Available < 1) {  	try {  		// We've timed out' let's ping the server to  		// see if the connection is still up  		if (i == timeout) {  			Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  			byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  			byte[] pong_bytes = new byte[4096];  			this.socket.Send (ping_bytes);  			if (this.socket.Receive (pong_bytes) < 1)  				// 10057 means "Socket is not connected"  				throw new SocketException (10057);  			Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  			i = 0;  			this.last_ping = DateTime.Now;  		} else {  			// Check when the last ping occured. If it's  			// significantly longer than our regular interval the  			// system likely woke up from sleep and we want to  			// simulate a disconnect  			int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  			if (sleepiness <= 0) {  				Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  				reason = DisconnectReason.SystemSleep;  				// 10057 means "Socket is not connected"  				throw new SocketException (10057);  			}  		}  		// The ping failed: disconnect completely  	} catch (SocketException e) {  		Disconnect (reason' "Ping timeout: " + e.Message);  		return;  	}  	Thread.Sleep (1000);  	i++;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: while (this.socket.Available < 1) {  	try {  		// We've timed out' let's ping the server to  		// see if the connection is still up  		if (i == timeout) {  			Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  			byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  			byte[] pong_bytes = new byte[4096];  			this.socket.Send (ping_bytes);  			if (this.socket.Receive (pong_bytes) < 1)  				// 10057 means "Socket is not connected"  				throw new SocketException (10057);  			Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  			i = 0;  			this.last_ping = DateTime.Now;  		} else {  			// Check when the last ping occured. If it's  			// significantly longer than our regular interval the  			// system likely woke up from sleep and we want to  			// simulate a disconnect  			int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  			if (sleepiness <= 0) {  				Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  				reason = DisconnectReason.SystemSleep;  				// 10057 means "Socket is not connected"  				throw new SocketException (10057);  			}  		}  		// The ping failed: disconnect completely  	} catch (SocketException e) {  		Disconnect (reason' "Ping timeout: " + e.Message);  		return;  	}  	Thread.Sleep (1000);  	i++;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: try {  	// We've timed out' let's ping the server to  	// see if the connection is still up  	if (i == timeout) {  		Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  		byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  		byte[] pong_bytes = new byte[4096];  		this.socket.Send (ping_bytes);  		if (this.socket.Receive (pong_bytes) < 1)  			// 10057 means "Socket is not connected"  			throw new SocketException (10057);  		Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  		i = 0;  		this.last_ping = DateTime.Now;  	} else {  		// Check when the last ping occured. If it's  		// significantly longer than our regular interval the  		// system likely woke up from sleep and we want to  		// simulate a disconnect  		int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  		if (sleepiness <= 0) {  			Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  			reason = DisconnectReason.SystemSleep;  			// 10057 means "Socket is not connected"  			throw new SocketException (10057);  		}  	}  	// The ping failed: disconnect completely  } catch (SocketException e) {  	Disconnect (reason' "Ping timeout: " + e.Message);  	return;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: try {  	// We've timed out' let's ping the server to  	// see if the connection is still up  	if (i == timeout) {  		Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  		byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  		byte[] pong_bytes = new byte[4096];  		this.socket.Send (ping_bytes);  		if (this.socket.Receive (pong_bytes) < 1)  			// 10057 means "Socket is not connected"  			throw new SocketException (10057);  		Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  		i = 0;  		this.last_ping = DateTime.Now;  	} else {  		// Check when the last ping occured. If it's  		// significantly longer than our regular interval the  		// system likely woke up from sleep and we want to  		// simulate a disconnect  		int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  		if (sleepiness <= 0) {  			Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  			reason = DisconnectReason.SystemSleep;  			// 10057 means "Socket is not connected"  			throw new SocketException (10057);  		}  	}  	// The ping failed: disconnect completely  } catch (SocketException e) {  	Disconnect (reason' "Ping timeout: " + e.Message);  	return;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: try {  	// We've timed out' let's ping the server to  	// see if the connection is still up  	if (i == timeout) {  		Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  		byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  		byte[] pong_bytes = new byte[4096];  		this.socket.Send (ping_bytes);  		if (this.socket.Receive (pong_bytes) < 1)  			// 10057 means "Socket is not connected"  			throw new SocketException (10057);  		Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  		i = 0;  		this.last_ping = DateTime.Now;  	} else {  		// Check when the last ping occured. If it's  		// significantly longer than our regular interval the  		// system likely woke up from sleep and we want to  		// simulate a disconnect  		int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  		if (sleepiness <= 0) {  			Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  			reason = DisconnectReason.SystemSleep;  			// 10057 means "Socket is not connected"  			throw new SocketException (10057);  		}  	}  	// The ping failed: disconnect completely  } catch (SocketException e) {  	Disconnect (reason' "Ping timeout: " + e.Message);  	return;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: try {  	// We've timed out' let's ping the server to  	// see if the connection is still up  	if (i == timeout) {  		Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  		byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  		byte[] pong_bytes = new byte[4096];  		this.socket.Send (ping_bytes);  		if (this.socket.Receive (pong_bytes) < 1)  			// 10057 means "Socket is not connected"  			throw new SocketException (10057);  		Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  		i = 0;  		this.last_ping = DateTime.Now;  	} else {  		// Check when the last ping occured. If it's  		// significantly longer than our regular interval the  		// system likely woke up from sleep and we want to  		// simulate a disconnect  		int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  		if (sleepiness <= 0) {  			Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  			reason = DisconnectReason.SystemSleep;  			// 10057 means "Socket is not connected"  			throw new SocketException (10057);  		}  	}  	// The ping failed: disconnect completely  } catch (SocketException e) {  	Disconnect (reason' "Ping timeout: " + e.Message);  	return;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: try {  	// We've timed out' let's ping the server to  	// see if the connection is still up  	if (i == timeout) {  		Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  		byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  		byte[] pong_bytes = new byte[4096];  		this.socket.Send (ping_bytes);  		if (this.socket.Receive (pong_bytes) < 1)  			// 10057 means "Socket is not connected"  			throw new SocketException (10057);  		Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  		i = 0;  		this.last_ping = DateTime.Now;  	} else {  		// Check when the last ping occured. If it's  		// significantly longer than our regular interval the  		// system likely woke up from sleep and we want to  		// simulate a disconnect  		int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  		if (sleepiness <= 0) {  			Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  			reason = DisconnectReason.SystemSleep;  			// 10057 means "Socket is not connected"  			throw new SocketException (10057);  		}  	}  	// The ping failed: disconnect completely  } catch (SocketException e) {  	Disconnect (reason' "Ping timeout: " + e.Message);  	return;  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: if (i == timeout) {  	Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  	byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  	byte[] pong_bytes = new byte[4096];  	this.socket.Send (ping_bytes);  	if (this.socket.Receive (pong_bytes) < 1)  		// 10057 means "Socket is not connected"  		throw new SocketException (10057);  	Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  	i = 0;  	this.last_ping = DateTime.Now;  } else {  	// Check when the last ping occured. If it's  	// significantly longer than our regular interval the  	// system likely woke up from sleep and we want to  	// simulate a disconnect  	int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  	if (sleepiness <= 0) {  		Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  		reason = DisconnectReason.SystemSleep;  		// 10057 means "Socket is not connected"  		throw new SocketException (10057);  	}  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: if (i == timeout) {  	Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  	byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  	byte[] pong_bytes = new byte[4096];  	this.socket.Send (ping_bytes);  	if (this.socket.Receive (pong_bytes) < 1)  		// 10057 means "Socket is not connected"  		throw new SocketException (10057);  	Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  	i = 0;  	this.last_ping = DateTime.Now;  } else {  	// Check when the last ping occured. If it's  	// significantly longer than our regular interval the  	// system likely woke up from sleep and we want to  	// simulate a disconnect  	int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  	if (sleepiness <= 0) {  		Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  		reason = DisconnectReason.SystemSleep;  		// 10057 means "Socket is not connected"  		throw new SocketException (10057);  	}  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: if (i == timeout) {  	Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  	byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  	byte[] pong_bytes = new byte[4096];  	this.socket.Send (ping_bytes);  	if (this.socket.Receive (pong_bytes) < 1)  		// 10057 means "Socket is not connected"  		throw new SocketException (10057);  	Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  	i = 0;  	this.last_ping = DateTime.Now;  } else {  	// Check when the last ping occured. If it's  	// significantly longer than our regular interval the  	// system likely woke up from sleep and we want to  	// simulate a disconnect  	int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  	if (sleepiness <= 0) {  		Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  		reason = DisconnectReason.SystemSleep;  		// 10057 means "Socket is not connected"  		throw new SocketException (10057);  	}  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: if (i == timeout) {  	Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  	byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  	byte[] pong_bytes = new byte[4096];  	this.socket.Send (ping_bytes);  	if (this.socket.Receive (pong_bytes) < 1)  		// 10057 means "Socket is not connected"  		throw new SocketException (10057);  	Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  	i = 0;  	this.last_ping = DateTime.Now;  } else {  	// Check when the last ping occured. If it's  	// significantly longer than our regular interval the  	// system likely woke up from sleep and we want to  	// simulate a disconnect  	int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  	if (sleepiness <= 0) {  		Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  		reason = DisconnectReason.SystemSleep;  		// 10057 means "Socket is not connected"  		throw new SocketException (10057);  	}  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: if (i == timeout) {  	Logger.LogInfo ("ListenerTcp"' "Pinging " + Server);  	byte[] ping_bytes = Encoding.UTF8.GetBytes ("ping\n");  	byte[] pong_bytes = new byte[4096];  	this.socket.Send (ping_bytes);  	if (this.socket.Receive (pong_bytes) < 1)  		// 10057 means "Socket is not connected"  		throw new SocketException (10057);  	Logger.LogInfo ("ListenerTcp"' "Received pong from " + Server);  	i = 0;  	this.last_ping = DateTime.Now;  } else {  	// Check when the last ping occured. If it's  	// significantly longer than our regular interval the  	// system likely woke up from sleep and we want to  	// simulate a disconnect  	int sleepiness = DateTime.Compare (this.last_ping.AddMilliseconds (timeout * 1000 * 1.2)' DateTime.Now);  	if (sleepiness <= 0) {  		Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  		reason = DisconnectReason.SystemSleep;  		// 10057 means "Socket is not connected"  		throw new SocketException (10057);  	}  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: if (this.socket.Receive (pong_bytes) < 1)  	// 10057 means "Socket is not connected"  	throw new SocketException (10057);  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: throw new SocketException (10057);  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: if (sleepiness <= 0) {  	Logger.LogInfo ("ListenerTcp"' "System woke up from sleep");  	reason = DisconnectReason.SystemSleep;  	// 10057 means "Socket is not connected"  	throw new SocketException (10057);  }  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: throw new SocketException (10057);  
Magic Number,Sparkles,TcpListener,F:\newReposMay17\hbons_SparkleShare\Sparkles\TcpListener.cs,Connect,The following statement contains a magic number: Thread.Sleep (1000);  
Missing Default,Sparkles,ChangeSet,F:\newReposMay17\hbons_SparkleShare\Sparkles\ChangeSet.cs,ToMessage,The following switch statement is missing a default case: switch (Changes [0].Type) {  case ChangeType.Edited:  	message = "edited: {0}";  	break;  case ChangeType.Deleted:  	message = "deleted: {0}";  	break;  case ChangeType.Moved:  	message = "moved: {0}";  	break;  }  
