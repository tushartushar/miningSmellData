Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,OnDataReceived,Cyclomatic complexity of the method is 10
Complex Method,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,OnDataReceived_LoopTest,Cyclomatic complexity of the method is 9
Complex Method,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,Cyclomatic complexity of the method is 10
Long Statement,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,The length of the statement  "			if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x00' out writeInterfaceInfo' out mWriteEndpointInfo)) { " is 121.
Long Statement,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,The length of the statement  "			if (((mWriteEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous) || ((mReadEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous)) { " is 172.
Long Statement,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,The length of the statement  "			mEP1Reader = mUsbDevice.OpenEndpointReader ((ReadEndpointID)mReadEndpointInfo.Descriptor.EndpointID' mBenchMarkParameters.BufferSize' (EndpointType)(mReadEndpointInfo.Descriptor.Attributes & 3)); " is 195.
Long Statement,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,The length of the statement  "			mEP1Writer = mUsbDevice.OpenEndpointWriter ((WriteEndpointID)mWriteEndpointInfo.Descriptor.EndpointID' (EndpointType)(mWriteEndpointInfo.Descriptor.Attributes & 3)); " is 165.
Long Statement,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,cboDevice_DropDown,The length of the statement  "			sCboText = string.Format ("Vid:{0} Pid:{1} {2}"' symVidPid.Vid.ToString ("X4")' symVidPid.Pid.ToString ("X4")' usbRegistry.FullName); " is 133.
Empty Catch Block,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,Form1_FormClosing,The method has an empty catch block.
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,OnDataReceived,The following statement contains a magic number: if (mUsbTestType == UsbTestType.Loop) {  	OnDataReceived_LoopTest (sender' e);  }  else {  	for (int i = 0; i < e.Count; i++) {  		if (mbInLoopTestError) {  			if (e.Buffer [i] == 0) {  				mReadTestPID = e.Buffer [i + 1];  				mbInLoopTestError = false;  			}  			else  				continue;  		}  		if (e.Buffer [i] == 0) {  			mLoopTestCompletedPackets++;  			if (e.Buffer [i + 1] == mReadTestPID) {  				i++;  				mReadTestPID++;  				bValidatePosEP1 = 2;  			}  			else {  				mbInLoopTestError = true;  				if (mLoopTestCompletedPackets > 1) {  					mEndPointStopWatch.PacketErrorCount++;  					SetStatus (string.Format ("Data validation mismatch at position:{0}/{1}."' i' loopTestBytes.Length)' true);  				}  				break;  			}  		}  		else if (e.Buffer [i] == bValidatePosEP1) {  			bValidatePosEP1++;  		}  	}  	if (mLoopTestCompletedPackets < 2)  		return;  	if (!mEndPointStopWatch.IsStarted) {  		mEndPointStopWatch.DiffWithNow ();  		return;  	}  	UpdateDataRate (e.Count);  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,OnDataReceived,The following statement contains a magic number: if (mUsbTestType == UsbTestType.Loop) {  	OnDataReceived_LoopTest (sender' e);  }  else {  	for (int i = 0; i < e.Count; i++) {  		if (mbInLoopTestError) {  			if (e.Buffer [i] == 0) {  				mReadTestPID = e.Buffer [i + 1];  				mbInLoopTestError = false;  			}  			else  				continue;  		}  		if (e.Buffer [i] == 0) {  			mLoopTestCompletedPackets++;  			if (e.Buffer [i + 1] == mReadTestPID) {  				i++;  				mReadTestPID++;  				bValidatePosEP1 = 2;  			}  			else {  				mbInLoopTestError = true;  				if (mLoopTestCompletedPackets > 1) {  					mEndPointStopWatch.PacketErrorCount++;  					SetStatus (string.Format ("Data validation mismatch at position:{0}/{1}."' i' loopTestBytes.Length)' true);  				}  				break;  			}  		}  		else if (e.Buffer [i] == bValidatePosEP1) {  			bValidatePosEP1++;  		}  	}  	if (mLoopTestCompletedPackets < 2)  		return;  	if (!mEndPointStopWatch.IsStarted) {  		mEndPointStopWatch.DiffWithNow ();  		return;  	}  	UpdateDataRate (e.Count);  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,OnDataReceived,The following statement contains a magic number: for (int i = 0; i < e.Count; i++) {  	if (mbInLoopTestError) {  		if (e.Buffer [i] == 0) {  			mReadTestPID = e.Buffer [i + 1];  			mbInLoopTestError = false;  		}  		else  			continue;  	}  	if (e.Buffer [i] == 0) {  		mLoopTestCompletedPackets++;  		if (e.Buffer [i + 1] == mReadTestPID) {  			i++;  			mReadTestPID++;  			bValidatePosEP1 = 2;  		}  		else {  			mbInLoopTestError = true;  			if (mLoopTestCompletedPackets > 1) {  				mEndPointStopWatch.PacketErrorCount++;  				SetStatus (string.Format ("Data validation mismatch at position:{0}/{1}."' i' loopTestBytes.Length)' true);  			}  			break;  		}  	}  	else if (e.Buffer [i] == bValidatePosEP1) {  		bValidatePosEP1++;  	}  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,OnDataReceived,The following statement contains a magic number: if (e.Buffer [i] == 0) {  	mLoopTestCompletedPackets++;  	if (e.Buffer [i + 1] == mReadTestPID) {  		i++;  		mReadTestPID++;  		bValidatePosEP1 = 2;  	}  	else {  		mbInLoopTestError = true;  		if (mLoopTestCompletedPackets > 1) {  			mEndPointStopWatch.PacketErrorCount++;  			SetStatus (string.Format ("Data validation mismatch at position:{0}/{1}."' i' loopTestBytes.Length)' true);  		}  		break;  	}  }  else if (e.Buffer [i] == bValidatePosEP1) {  	bValidatePosEP1++;  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,OnDataReceived,The following statement contains a magic number: if (e.Buffer [i + 1] == mReadTestPID) {  	i++;  	mReadTestPID++;  	bValidatePosEP1 = 2;  }  else {  	mbInLoopTestError = true;  	if (mLoopTestCompletedPackets > 1) {  		mEndPointStopWatch.PacketErrorCount++;  		SetStatus (string.Format ("Data validation mismatch at position:{0}/{1}."' i' loopTestBytes.Length)' true);  	}  	break;  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,OnDataReceived,The following statement contains a magic number: bValidatePosEP1 = 2;  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,OnDataReceived,The following statement contains a magic number: if (mLoopTestCompletedPackets < 2)  	return;  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,The following statement contains a magic number: try {  	if (usbRegistry.Open (out mUsbDevice)) {  		UsbInterfaceInfo readInterfaceInfo;  		UsbInterfaceInfo writeInterfaceInfo;  		UsbDevice.UsbErrorEvent += OnUsbError;  		if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x80' out readInterfaceInfo' out mReadEndpointInfo)) {  			throw new Exception ("failed locating read endpoint.");  		}  		mBenchMarkParameters.BufferSize -= (mBenchMarkParameters.BufferSize % (mReadEndpointInfo.Descriptor.MaxPacketSize));  		if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x00' out writeInterfaceInfo' out mWriteEndpointInfo)) {  			throw new Exception ("failed locating write endpoint.");  		}  		if (((mWriteEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous) || ((mReadEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous)) {  			throw new Exception ("buenchmark GUI application does not support ISO endpoints. Use BenchmarkCon instead.");  		}  		mBenchMarkParameters.BufferSize -= (mBenchMarkParameters.BufferSize % (mWriteEndpointInfo.Descriptor.MaxPacketSize));  		if (writeInterfaceInfo.Descriptor.InterfaceID != readInterfaceInfo.Descriptor.InterfaceID)  			throw new Exception ("read/write endpoints must be on the same interface.");  		mEP1Reader = mUsbDevice.OpenEndpointReader ((ReadEndpointID)mReadEndpointInfo.Descriptor.EndpointID' mBenchMarkParameters.BufferSize' (EndpointType)(mReadEndpointInfo.Descriptor.Attributes & 3));  		mEP1Writer = mUsbDevice.OpenEndpointWriter ((WriteEndpointID)mWriteEndpointInfo.Descriptor.EndpointID' (EndpointType)(mWriteEndpointInfo.Descriptor.Attributes & 3));  		mInterfaceInfo = writeInterfaceInfo;  		mEP1Reader.ReadThreadPriority = mBenchMarkParameters.Priority;  		mEP1Reader.DataReceived += OnDataReceived;  		makeTestBytes (out loopTestBytes' mBenchMarkParameters.BufferSize);  		// If this is a "whole" usb device (libusb-win32' linux libusb)  		// it will have an IUsbDevice interface. If not (WinUSB) the   		// variable will be null indicating this is an interface of a   		// device.  		IUsbDevice wholeUsbDevice = mUsbDevice as IUsbDevice;  		if (!ReferenceEquals (wholeUsbDevice' null)) {  			// This is a "whole" USB device. Before it can be used'   			// the desired configuration and interface must be selected.  			// Select config #1  			wholeUsbDevice.SetConfiguration (1);  			// Claim interface #0.  			wholeUsbDevice.ClaimInterface (mInterfaceInfo.Descriptor.InterfaceID);  		}  		return true;  	}  }  catch (Exception ex) {  	SetStatus (ex.Message' true);  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,The following statement contains a magic number: try {  	if (usbRegistry.Open (out mUsbDevice)) {  		UsbInterfaceInfo readInterfaceInfo;  		UsbInterfaceInfo writeInterfaceInfo;  		UsbDevice.UsbErrorEvent += OnUsbError;  		if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x80' out readInterfaceInfo' out mReadEndpointInfo)) {  			throw new Exception ("failed locating read endpoint.");  		}  		mBenchMarkParameters.BufferSize -= (mBenchMarkParameters.BufferSize % (mReadEndpointInfo.Descriptor.MaxPacketSize));  		if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x00' out writeInterfaceInfo' out mWriteEndpointInfo)) {  			throw new Exception ("failed locating write endpoint.");  		}  		if (((mWriteEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous) || ((mReadEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous)) {  			throw new Exception ("buenchmark GUI application does not support ISO endpoints. Use BenchmarkCon instead.");  		}  		mBenchMarkParameters.BufferSize -= (mBenchMarkParameters.BufferSize % (mWriteEndpointInfo.Descriptor.MaxPacketSize));  		if (writeInterfaceInfo.Descriptor.InterfaceID != readInterfaceInfo.Descriptor.InterfaceID)  			throw new Exception ("read/write endpoints must be on the same interface.");  		mEP1Reader = mUsbDevice.OpenEndpointReader ((ReadEndpointID)mReadEndpointInfo.Descriptor.EndpointID' mBenchMarkParameters.BufferSize' (EndpointType)(mReadEndpointInfo.Descriptor.Attributes & 3));  		mEP1Writer = mUsbDevice.OpenEndpointWriter ((WriteEndpointID)mWriteEndpointInfo.Descriptor.EndpointID' (EndpointType)(mWriteEndpointInfo.Descriptor.Attributes & 3));  		mInterfaceInfo = writeInterfaceInfo;  		mEP1Reader.ReadThreadPriority = mBenchMarkParameters.Priority;  		mEP1Reader.DataReceived += OnDataReceived;  		makeTestBytes (out loopTestBytes' mBenchMarkParameters.BufferSize);  		// If this is a "whole" usb device (libusb-win32' linux libusb)  		// it will have an IUsbDevice interface. If not (WinUSB) the   		// variable will be null indicating this is an interface of a   		// device.  		IUsbDevice wholeUsbDevice = mUsbDevice as IUsbDevice;  		if (!ReferenceEquals (wholeUsbDevice' null)) {  			// This is a "whole" USB device. Before it can be used'   			// the desired configuration and interface must be selected.  			// Select config #1  			wholeUsbDevice.SetConfiguration (1);  			// Claim interface #0.  			wholeUsbDevice.ClaimInterface (mInterfaceInfo.Descriptor.InterfaceID);  		}  		return true;  	}  }  catch (Exception ex) {  	SetStatus (ex.Message' true);  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,The following statement contains a magic number: try {  	if (usbRegistry.Open (out mUsbDevice)) {  		UsbInterfaceInfo readInterfaceInfo;  		UsbInterfaceInfo writeInterfaceInfo;  		UsbDevice.UsbErrorEvent += OnUsbError;  		if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x80' out readInterfaceInfo' out mReadEndpointInfo)) {  			throw new Exception ("failed locating read endpoint.");  		}  		mBenchMarkParameters.BufferSize -= (mBenchMarkParameters.BufferSize % (mReadEndpointInfo.Descriptor.MaxPacketSize));  		if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x00' out writeInterfaceInfo' out mWriteEndpointInfo)) {  			throw new Exception ("failed locating write endpoint.");  		}  		if (((mWriteEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous) || ((mReadEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous)) {  			throw new Exception ("buenchmark GUI application does not support ISO endpoints. Use BenchmarkCon instead.");  		}  		mBenchMarkParameters.BufferSize -= (mBenchMarkParameters.BufferSize % (mWriteEndpointInfo.Descriptor.MaxPacketSize));  		if (writeInterfaceInfo.Descriptor.InterfaceID != readInterfaceInfo.Descriptor.InterfaceID)  			throw new Exception ("read/write endpoints must be on the same interface.");  		mEP1Reader = mUsbDevice.OpenEndpointReader ((ReadEndpointID)mReadEndpointInfo.Descriptor.EndpointID' mBenchMarkParameters.BufferSize' (EndpointType)(mReadEndpointInfo.Descriptor.Attributes & 3));  		mEP1Writer = mUsbDevice.OpenEndpointWriter ((WriteEndpointID)mWriteEndpointInfo.Descriptor.EndpointID' (EndpointType)(mWriteEndpointInfo.Descriptor.Attributes & 3));  		mInterfaceInfo = writeInterfaceInfo;  		mEP1Reader.ReadThreadPriority = mBenchMarkParameters.Priority;  		mEP1Reader.DataReceived += OnDataReceived;  		makeTestBytes (out loopTestBytes' mBenchMarkParameters.BufferSize);  		// If this is a "whole" usb device (libusb-win32' linux libusb)  		// it will have an IUsbDevice interface. If not (WinUSB) the   		// variable will be null indicating this is an interface of a   		// device.  		IUsbDevice wholeUsbDevice = mUsbDevice as IUsbDevice;  		if (!ReferenceEquals (wholeUsbDevice' null)) {  			// This is a "whole" USB device. Before it can be used'   			// the desired configuration and interface must be selected.  			// Select config #1  			wholeUsbDevice.SetConfiguration (1);  			// Claim interface #0.  			wholeUsbDevice.ClaimInterface (mInterfaceInfo.Descriptor.InterfaceID);  		}  		return true;  	}  }  catch (Exception ex) {  	SetStatus (ex.Message' true);  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,The following statement contains a magic number: try {  	if (usbRegistry.Open (out mUsbDevice)) {  		UsbInterfaceInfo readInterfaceInfo;  		UsbInterfaceInfo writeInterfaceInfo;  		UsbDevice.UsbErrorEvent += OnUsbError;  		if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x80' out readInterfaceInfo' out mReadEndpointInfo)) {  			throw new Exception ("failed locating read endpoint.");  		}  		mBenchMarkParameters.BufferSize -= (mBenchMarkParameters.BufferSize % (mReadEndpointInfo.Descriptor.MaxPacketSize));  		if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x00' out writeInterfaceInfo' out mWriteEndpointInfo)) {  			throw new Exception ("failed locating write endpoint.");  		}  		if (((mWriteEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous) || ((mReadEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous)) {  			throw new Exception ("buenchmark GUI application does not support ISO endpoints. Use BenchmarkCon instead.");  		}  		mBenchMarkParameters.BufferSize -= (mBenchMarkParameters.BufferSize % (mWriteEndpointInfo.Descriptor.MaxPacketSize));  		if (writeInterfaceInfo.Descriptor.InterfaceID != readInterfaceInfo.Descriptor.InterfaceID)  			throw new Exception ("read/write endpoints must be on the same interface.");  		mEP1Reader = mUsbDevice.OpenEndpointReader ((ReadEndpointID)mReadEndpointInfo.Descriptor.EndpointID' mBenchMarkParameters.BufferSize' (EndpointType)(mReadEndpointInfo.Descriptor.Attributes & 3));  		mEP1Writer = mUsbDevice.OpenEndpointWriter ((WriteEndpointID)mWriteEndpointInfo.Descriptor.EndpointID' (EndpointType)(mWriteEndpointInfo.Descriptor.Attributes & 3));  		mInterfaceInfo = writeInterfaceInfo;  		mEP1Reader.ReadThreadPriority = mBenchMarkParameters.Priority;  		mEP1Reader.DataReceived += OnDataReceived;  		makeTestBytes (out loopTestBytes' mBenchMarkParameters.BufferSize);  		// If this is a "whole" usb device (libusb-win32' linux libusb)  		// it will have an IUsbDevice interface. If not (WinUSB) the   		// variable will be null indicating this is an interface of a   		// device.  		IUsbDevice wholeUsbDevice = mUsbDevice as IUsbDevice;  		if (!ReferenceEquals (wholeUsbDevice' null)) {  			// This is a "whole" USB device. Before it can be used'   			// the desired configuration and interface must be selected.  			// Select config #1  			wholeUsbDevice.SetConfiguration (1);  			// Claim interface #0.  			wholeUsbDevice.ClaimInterface (mInterfaceInfo.Descriptor.InterfaceID);  		}  		return true;  	}  }  catch (Exception ex) {  	SetStatus (ex.Message' true);  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,The following statement contains a magic number: if (usbRegistry.Open (out mUsbDevice)) {  	UsbInterfaceInfo readInterfaceInfo;  	UsbInterfaceInfo writeInterfaceInfo;  	UsbDevice.UsbErrorEvent += OnUsbError;  	if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x80' out readInterfaceInfo' out mReadEndpointInfo)) {  		throw new Exception ("failed locating read endpoint.");  	}  	mBenchMarkParameters.BufferSize -= (mBenchMarkParameters.BufferSize % (mReadEndpointInfo.Descriptor.MaxPacketSize));  	if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x00' out writeInterfaceInfo' out mWriteEndpointInfo)) {  		throw new Exception ("failed locating write endpoint.");  	}  	if (((mWriteEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous) || ((mReadEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous)) {  		throw new Exception ("buenchmark GUI application does not support ISO endpoints. Use BenchmarkCon instead.");  	}  	mBenchMarkParameters.BufferSize -= (mBenchMarkParameters.BufferSize % (mWriteEndpointInfo.Descriptor.MaxPacketSize));  	if (writeInterfaceInfo.Descriptor.InterfaceID != readInterfaceInfo.Descriptor.InterfaceID)  		throw new Exception ("read/write endpoints must be on the same interface.");  	mEP1Reader = mUsbDevice.OpenEndpointReader ((ReadEndpointID)mReadEndpointInfo.Descriptor.EndpointID' mBenchMarkParameters.BufferSize' (EndpointType)(mReadEndpointInfo.Descriptor.Attributes & 3));  	mEP1Writer = mUsbDevice.OpenEndpointWriter ((WriteEndpointID)mWriteEndpointInfo.Descriptor.EndpointID' (EndpointType)(mWriteEndpointInfo.Descriptor.Attributes & 3));  	mInterfaceInfo = writeInterfaceInfo;  	mEP1Reader.ReadThreadPriority = mBenchMarkParameters.Priority;  	mEP1Reader.DataReceived += OnDataReceived;  	makeTestBytes (out loopTestBytes' mBenchMarkParameters.BufferSize);  	// If this is a "whole" usb device (libusb-win32' linux libusb)  	// it will have an IUsbDevice interface. If not (WinUSB) the   	// variable will be null indicating this is an interface of a   	// device.  	IUsbDevice wholeUsbDevice = mUsbDevice as IUsbDevice;  	if (!ReferenceEquals (wholeUsbDevice' null)) {  		// This is a "whole" USB device. Before it can be used'   		// the desired configuration and interface must be selected.  		// Select config #1  		wholeUsbDevice.SetConfiguration (1);  		// Claim interface #0.  		wholeUsbDevice.ClaimInterface (mInterfaceInfo.Descriptor.InterfaceID);  	}  	return true;  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,The following statement contains a magic number: if (usbRegistry.Open (out mUsbDevice)) {  	UsbInterfaceInfo readInterfaceInfo;  	UsbInterfaceInfo writeInterfaceInfo;  	UsbDevice.UsbErrorEvent += OnUsbError;  	if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x80' out readInterfaceInfo' out mReadEndpointInfo)) {  		throw new Exception ("failed locating read endpoint.");  	}  	mBenchMarkParameters.BufferSize -= (mBenchMarkParameters.BufferSize % (mReadEndpointInfo.Descriptor.MaxPacketSize));  	if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x00' out writeInterfaceInfo' out mWriteEndpointInfo)) {  		throw new Exception ("failed locating write endpoint.");  	}  	if (((mWriteEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous) || ((mReadEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous)) {  		throw new Exception ("buenchmark GUI application does not support ISO endpoints. Use BenchmarkCon instead.");  	}  	mBenchMarkParameters.BufferSize -= (mBenchMarkParameters.BufferSize % (mWriteEndpointInfo.Descriptor.MaxPacketSize));  	if (writeInterfaceInfo.Descriptor.InterfaceID != readInterfaceInfo.Descriptor.InterfaceID)  		throw new Exception ("read/write endpoints must be on the same interface.");  	mEP1Reader = mUsbDevice.OpenEndpointReader ((ReadEndpointID)mReadEndpointInfo.Descriptor.EndpointID' mBenchMarkParameters.BufferSize' (EndpointType)(mReadEndpointInfo.Descriptor.Attributes & 3));  	mEP1Writer = mUsbDevice.OpenEndpointWriter ((WriteEndpointID)mWriteEndpointInfo.Descriptor.EndpointID' (EndpointType)(mWriteEndpointInfo.Descriptor.Attributes & 3));  	mInterfaceInfo = writeInterfaceInfo;  	mEP1Reader.ReadThreadPriority = mBenchMarkParameters.Priority;  	mEP1Reader.DataReceived += OnDataReceived;  	makeTestBytes (out loopTestBytes' mBenchMarkParameters.BufferSize);  	// If this is a "whole" usb device (libusb-win32' linux libusb)  	// it will have an IUsbDevice interface. If not (WinUSB) the   	// variable will be null indicating this is an interface of a   	// device.  	IUsbDevice wholeUsbDevice = mUsbDevice as IUsbDevice;  	if (!ReferenceEquals (wholeUsbDevice' null)) {  		// This is a "whole" USB device. Before it can be used'   		// the desired configuration and interface must be selected.  		// Select config #1  		wholeUsbDevice.SetConfiguration (1);  		// Claim interface #0.  		wholeUsbDevice.ClaimInterface (mInterfaceInfo.Descriptor.InterfaceID);  	}  	return true;  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,The following statement contains a magic number: if (usbRegistry.Open (out mUsbDevice)) {  	UsbInterfaceInfo readInterfaceInfo;  	UsbInterfaceInfo writeInterfaceInfo;  	UsbDevice.UsbErrorEvent += OnUsbError;  	if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x80' out readInterfaceInfo' out mReadEndpointInfo)) {  		throw new Exception ("failed locating read endpoint.");  	}  	mBenchMarkParameters.BufferSize -= (mBenchMarkParameters.BufferSize % (mReadEndpointInfo.Descriptor.MaxPacketSize));  	if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x00' out writeInterfaceInfo' out mWriteEndpointInfo)) {  		throw new Exception ("failed locating write endpoint.");  	}  	if (((mWriteEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous) || ((mReadEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous)) {  		throw new Exception ("buenchmark GUI application does not support ISO endpoints. Use BenchmarkCon instead.");  	}  	mBenchMarkParameters.BufferSize -= (mBenchMarkParameters.BufferSize % (mWriteEndpointInfo.Descriptor.MaxPacketSize));  	if (writeInterfaceInfo.Descriptor.InterfaceID != readInterfaceInfo.Descriptor.InterfaceID)  		throw new Exception ("read/write endpoints must be on the same interface.");  	mEP1Reader = mUsbDevice.OpenEndpointReader ((ReadEndpointID)mReadEndpointInfo.Descriptor.EndpointID' mBenchMarkParameters.BufferSize' (EndpointType)(mReadEndpointInfo.Descriptor.Attributes & 3));  	mEP1Writer = mUsbDevice.OpenEndpointWriter ((WriteEndpointID)mWriteEndpointInfo.Descriptor.EndpointID' (EndpointType)(mWriteEndpointInfo.Descriptor.Attributes & 3));  	mInterfaceInfo = writeInterfaceInfo;  	mEP1Reader.ReadThreadPriority = mBenchMarkParameters.Priority;  	mEP1Reader.DataReceived += OnDataReceived;  	makeTestBytes (out loopTestBytes' mBenchMarkParameters.BufferSize);  	// If this is a "whole" usb device (libusb-win32' linux libusb)  	// it will have an IUsbDevice interface. If not (WinUSB) the   	// variable will be null indicating this is an interface of a   	// device.  	IUsbDevice wholeUsbDevice = mUsbDevice as IUsbDevice;  	if (!ReferenceEquals (wholeUsbDevice' null)) {  		// This is a "whole" USB device. Before it can be used'   		// the desired configuration and interface must be selected.  		// Select config #1  		wholeUsbDevice.SetConfiguration (1);  		// Claim interface #0.  		wholeUsbDevice.ClaimInterface (mInterfaceInfo.Descriptor.InterfaceID);  	}  	return true;  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,The following statement contains a magic number: if (usbRegistry.Open (out mUsbDevice)) {  	UsbInterfaceInfo readInterfaceInfo;  	UsbInterfaceInfo writeInterfaceInfo;  	UsbDevice.UsbErrorEvent += OnUsbError;  	if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x80' out readInterfaceInfo' out mReadEndpointInfo)) {  		throw new Exception ("failed locating read endpoint.");  	}  	mBenchMarkParameters.BufferSize -= (mBenchMarkParameters.BufferSize % (mReadEndpointInfo.Descriptor.MaxPacketSize));  	if (!UsbEndpointBase.LookupEndpointInfo (mUsbDevice.Configs [0]' 0x00' out writeInterfaceInfo' out mWriteEndpointInfo)) {  		throw new Exception ("failed locating write endpoint.");  	}  	if (((mWriteEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous) || ((mReadEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous)) {  		throw new Exception ("buenchmark GUI application does not support ISO endpoints. Use BenchmarkCon instead.");  	}  	mBenchMarkParameters.BufferSize -= (mBenchMarkParameters.BufferSize % (mWriteEndpointInfo.Descriptor.MaxPacketSize));  	if (writeInterfaceInfo.Descriptor.InterfaceID != readInterfaceInfo.Descriptor.InterfaceID)  		throw new Exception ("read/write endpoints must be on the same interface.");  	mEP1Reader = mUsbDevice.OpenEndpointReader ((ReadEndpointID)mReadEndpointInfo.Descriptor.EndpointID' mBenchMarkParameters.BufferSize' (EndpointType)(mReadEndpointInfo.Descriptor.Attributes & 3));  	mEP1Writer = mUsbDevice.OpenEndpointWriter ((WriteEndpointID)mWriteEndpointInfo.Descriptor.EndpointID' (EndpointType)(mWriteEndpointInfo.Descriptor.Attributes & 3));  	mInterfaceInfo = writeInterfaceInfo;  	mEP1Reader.ReadThreadPriority = mBenchMarkParameters.Priority;  	mEP1Reader.DataReceived += OnDataReceived;  	makeTestBytes (out loopTestBytes' mBenchMarkParameters.BufferSize);  	// If this is a "whole" usb device (libusb-win32' linux libusb)  	// it will have an IUsbDevice interface. If not (WinUSB) the   	// variable will be null indicating this is an interface of a   	// device.  	IUsbDevice wholeUsbDevice = mUsbDevice as IUsbDevice;  	if (!ReferenceEquals (wholeUsbDevice' null)) {  		// This is a "whole" USB device. Before it can be used'   		// the desired configuration and interface must be selected.  		// Select config #1  		wholeUsbDevice.SetConfiguration (1);  		// Claim interface #0.  		wholeUsbDevice.ClaimInterface (mInterfaceInfo.Descriptor.InterfaceID);  	}  	return true;  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,The following statement contains a magic number: if (((mWriteEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous) || ((mReadEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous)) {  	throw new Exception ("buenchmark GUI application does not support ISO endpoints. Use BenchmarkCon instead.");  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,The following statement contains a magic number: if (((mWriteEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous) || ((mReadEndpointInfo.Descriptor.Attributes & 3) == (int)EndpointType.Isochronous)) {  	throw new Exception ("buenchmark GUI application does not support ISO endpoints. Use BenchmarkCon instead.");  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,The following statement contains a magic number: mEP1Reader = mUsbDevice.OpenEndpointReader ((ReadEndpointID)mReadEndpointInfo.Descriptor.EndpointID' mBenchMarkParameters.BufferSize' (EndpointType)(mReadEndpointInfo.Descriptor.Attributes & 3));  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,openAsTestDevice,The following statement contains a magic number: mEP1Writer = mUsbDevice.OpenEndpointWriter ((WriteEndpointID)mWriteEndpointInfo.Descriptor.EndpointID' (EndpointType)(mWriteEndpointInfo.Descriptor.Attributes & 3));  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,stopReadWrite,The following statement contains a magic number: if (mthWriteThreadEP1 != null && bWriteThreadEP1Enabled) {  	bWriteThreadEP1Enabled = false;  	mEP1Writer.Abort ();  	DateTime dtStart = DateTime.Now;  	while (mthWriteThreadEP1.IsAlive) {  		Application.DoEvents ();  		Thread.Sleep (10);  		if ((DateTime.Now - dtStart).TotalMilliseconds > 1000) {  			System.Diagnostics.Debug.Print ("[CRITICAL ERROR] Benchmark write thread dead-locked! Terminating thread..");  			mthWriteThreadEP1.Abort ();  			break;  		}  	}  	mthWriteThreadEP1 = null;  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,stopReadWrite,The following statement contains a magic number: if (mthWriteThreadEP1 != null && bWriteThreadEP1Enabled) {  	bWriteThreadEP1Enabled = false;  	mEP1Writer.Abort ();  	DateTime dtStart = DateTime.Now;  	while (mthWriteThreadEP1.IsAlive) {  		Application.DoEvents ();  		Thread.Sleep (10);  		if ((DateTime.Now - dtStart).TotalMilliseconds > 1000) {  			System.Diagnostics.Debug.Print ("[CRITICAL ERROR] Benchmark write thread dead-locked! Terminating thread..");  			mthWriteThreadEP1.Abort ();  			break;  		}  	}  	mthWriteThreadEP1 = null;  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,stopReadWrite,The following statement contains a magic number: while (mthWriteThreadEP1.IsAlive) {  	Application.DoEvents ();  	Thread.Sleep (10);  	if ((DateTime.Now - dtStart).TotalMilliseconds > 1000) {  		System.Diagnostics.Debug.Print ("[CRITICAL ERROR] Benchmark write thread dead-locked! Terminating thread..");  		mthWriteThreadEP1.Abort ();  		break;  	}  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,stopReadWrite,The following statement contains a magic number: while (mthWriteThreadEP1.IsAlive) {  	Application.DoEvents ();  	Thread.Sleep (10);  	if ((DateTime.Now - dtStart).TotalMilliseconds > 1000) {  		System.Diagnostics.Debug.Print ("[CRITICAL ERROR] Benchmark write thread dead-locked! Terminating thread..");  		mthWriteThreadEP1.Abort ();  		break;  	}  }  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,stopReadWrite,The following statement contains a magic number: Thread.Sleep (10);  
Magic Number,Benchmark,fBenchmark,C:\repos\johannes85_bloenk-software\Libraries\LibUsbDotNet\Benchmark\fBenchmark.cs,stopReadWrite,The following statement contains a magic number: if ((DateTime.Now - dtStart).TotalMilliseconds > 1000) {  	System.Diagnostics.Debug.Print ("[CRITICAL ERROR] Benchmark write thread dead-locked! Terminating thread..");  	mthWriteThreadEP1.Abort ();  	break;  }  
