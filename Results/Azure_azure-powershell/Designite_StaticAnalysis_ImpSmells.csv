Implementation smell,Namespace,Class,File,Method,Description
Long Method,StaticAnalysis.BreakingChangeAnalyzer,CmdletBreakingChangeLoader,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\CmdletBreakingChangeLoader.cs,GetModuleMetadata,The method has 131 lines of code.
Long Method,StaticAnalysis.BreakingChangeAnalyzer,ParameterSetMetadataHelper,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\ParameterSetMetadataHelper.cs,CompareParameterSetMetadata,The method has 122 lines of code.
Long Method,StaticAnalysis.SignatureVerifier,SignatureVerifier,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\SignatureVerifier.cs,Analyze,The method has 156 lines of code.
Complex Method,StaticAnalysis,Program,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\Program.cs,Main,Cyclomatic complexity of the method is 9
Complex Method,StaticAnalysis.BreakingChangeAnalyzer,BreakingChangeAnalyzer,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\BreakingChangeAnalyzer.cs,Analyze,Cyclomatic complexity of the method is 10
Complex Method,StaticAnalysis.BreakingChangeAnalyzer,CmdletBreakingChangeLoader,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\CmdletBreakingChangeLoader.cs,GetModuleMetadata,Cyclomatic complexity of the method is 18
Complex Method,StaticAnalysis.BreakingChangeAnalyzer,ParameterSetMetadataHelper,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\ParameterSetMetadataHelper.cs,CompareParameterSetMetadata,Cyclomatic complexity of the method is 14
Complex Method,StaticAnalysis.BreakingChangeAnalyzer,TypeMetadata,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\TypeMetadata.cs,TypeMetadata,Cyclomatic complexity of the method is 10
Complex Method,StaticAnalysis.HelpAnalyzer,HelpAnalyzer,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\HelpAnalyzer\HelpAnalyzer.cs,AnalyzeMarkdownHelp,Cyclomatic complexity of the method is 8
Complex Method,StaticAnalysis.SignatureVerifier,SignatureVerifier,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\SignatureVerifier.cs,Analyze,Cyclomatic complexity of the method is 17
Long Parameter List,StaticAnalysis.BreakingChangeAnalyzer,LogExtensions,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\BreakingChangeAnalyzer.cs,LogBreakingChangeIssue,The method has 6 parameters. Parameters: issueLogger' cmdlet' description' remediation' severity' problemId
Long Parameter List,StaticAnalysis.BreakingChangeAnalyzer,TypeMetadataHelper,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\TypeMetadataHelper.cs,CheckParameterType,The method has 5 parameters. Parameters: cmdlet' parameter' oldTypeMetadata' newTypeMetadata' issueLogger
Long Parameter List,StaticAnalysis.BreakingChangeAnalyzer,TypeMetadataHelper,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\TypeMetadataHelper.cs,IsElementType,The method has 7 parameters. Parameters: cmdlet' oldTypeMetadata' newTypeMetadata' problemId' description' remediation' issueLogger
Long Parameter List,StaticAnalysis.BreakingChangeAnalyzer,TypeMetadataHelper,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\TypeMetadataHelper.cs,IsGenericType,The method has 5 parameters. Parameters: cmdlet' oldTypeMetadata' newTypeMetadata' target' issueLogger
Long Parameter List,StaticAnalysis.BreakingChangeAnalyzer,TypeMetadataHelper,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\TypeMetadataHelper.cs,HasSameGenericType,The method has 5 parameters. Parameters: cmdlet' oldTypeMetadata' newTypeMetadata' target' issueLogger
Long Parameter List,StaticAnalysis.BreakingChangeAnalyzer,TypeMetadataHelper,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\TypeMetadataHelper.cs,HasSameGenericArgumentSize,The method has 5 parameters. Parameters: cmdlet' oldTypeMetadata' newTypeMetadata' target' issueLogger
Long Parameter List,StaticAnalysis.BreakingChangeAnalyzer,TypeMetadataHelper,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\TypeMetadataHelper.cs,CheckGenericTypeArguments,The method has 5 parameters. Parameters: cmdlet' oldArgument' newArgument' target' issueLogger
Long Parameter List,StaticAnalysis.SignatureVerifier,LogExtensions,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\SignatureVerifier.cs,LogSignatureIssue,The method has 6 parameters. Parameters: issueLogger' cmdlet' description' remediation' severity' problemId
Long Identifier,StaticAnalysis.DependencyAnalyzer,DependencyAnalyzer,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\DependencyAnalyzer.cs,,The length of the parameter ReferenceDoesNotMatchAssemblyVersion is 36.
Long Identifier,StaticAnalysis.DependencyAnalyzer,DependencyAnalyzer,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\DependencyAnalyzer.cs,,The length of the parameter AssemblyVersionFileVersionMismatch is 34.
Long Identifier,StaticAnalysis.ProblemIds,SignatureProblemId,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\ProblemIds.cs,,The length of the parameter ForceWithoutShouldProcessAttribute is 34.
Long Identifier,StaticAnalysis.ProblemIds,SignatureProblemId,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\ProblemIds.cs,,The length of the parameter ConfirmLeveleWithNoShouldProcess is 32.
Long Identifier,StaticAnalysis.ProblemIds,SignatureProblemId,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\ProblemIds.cs,,The length of the parameter CmdletWithDestructiveVerbNoForce is 32.
Long Identifier,StaticAnalysis.ProblemIds,DependencyProblemId,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\ProblemIds.cs,,The length of the parameter ReferenceDoesNotMatchAssemblyVersion is 36.
Long Identifier,StaticAnalysis.ProblemIds,DependencyProblemId,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\ProblemIds.cs,,The length of the parameter AssemblyVersionFileVersionMismatch is 34.
Long Identifier,StaticAnalysis.ProblemIds,BreakingChangeProblemId,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\ProblemIds.cs,,The length of the parameter ChangedOutputGenericTypeArgument is 32.
Long Identifier,StaticAnalysis.ProblemIds,BreakingChangeProblemId,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\ProblemIds.cs,,The length of the parameter DifferentOutputGenericTypeArgumentSize is 38.
Long Identifier,StaticAnalysis.ProblemIds,BreakingChangeProblemId,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\ProblemIds.cs,,The length of the parameter ValueFromPipelineByPropertyName is 31.
Long Identifier,StaticAnalysis.ProblemIds,BreakingChangeProblemId,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\ProblemIds.cs,,The length of the parameter RemovedParameterFromParameterSet is 32.
Long Identifier,StaticAnalysis.ProblemIds,BreakingChangeProblemId,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\ProblemIds.cs,,The length of the parameter ChangedParameterGenericTypeArgument is 35.
Long Identifier,StaticAnalysis.ProblemIds,BreakingChangeProblemId,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\ProblemIds.cs,,The length of the parameter DifferentParameterGenericTypeArgumentSize is 41.
Long Identifier,StaticAnalysis.ProblemIds,BreakingChangeProblemId,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\ProblemIds.cs,,The length of the parameter DifferentGenericTypeArgumentSize is 32.
Long Identifier,StaticAnalysis.SignatureVerifier,SignatureVerifier,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\SignatureVerifier.cs,,The length of the parameter signatureIssueReportLoggerName is 30.
Long Statement,StaticAnalysis,AnalysisLogger,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\Loggers\AnalysisLogger.cs,GetReportLogger,The length of the statement  "            return Loggers.Where<ReportLogger>((log) => Path.GetFileName(log.FileName).Equals(loggerFileName' StringComparison.OrdinalIgnoreCase)).SingleOrDefault<ReportLogger>(); " is 167.
Long Statement,StaticAnalysis.BreakingChangeAnalyzer,CmdletBreakingChangeLoader,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\CmdletBreakingChangeLoader.cs,GetModuleMetadata,The length of the statement  "                            var parameterSetMetadata = cmdletMetadata.ParameterSets.FirstOrDefault(s => s.Name.Equals(parameterSet.ParameterSetName)); " is 122.
Long Statement,StaticAnalysis.BreakingChangeAnalyzer,CmdletBreakingChangeLoader,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\CmdletBreakingChangeLoader.cs,GetModuleMetadata,The length of the statement  "                            var param = parameterSet.Parameters.FirstOrDefault(p => p.ParameterMetadata.Name.Equals(parameter.ParameterMetadata.Name)); " is 123.
Long Statement,StaticAnalysis.BreakingChangeAnalyzer,CmdletMetadataHelper,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\CmdletMetadataHelper.cs,CompareCmdletMetadata,The length of the statement  "                    _parameterSetMetadataHelper.CompareParameterSetMetadata(oldCmdlet' oldCmdlet.ParameterSets' newCmdlet.ParameterSets' issueLogger); " is 130.
Long Statement,StaticAnalysis.DependencyAnalyzer,AssemblyVersionConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\AssemblyVersionConflict.cs,Parse,The length of the statement  "            var matcher = "\"([^\"]+)\"'\"([^\"]+)\"'\"([^\"]+)\"'\"([^\"]+)\"'\"([^\"]+)\"'\"([^\"]+)\"'\"([^\"]+)\"'\"([^\"]+)\"'\"([^\"]+)\""; " is 133.
Long Statement,StaticAnalysis.DependencyAnalyzer,MissingAssembly,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\MissingAssembly.cs,Parse,The length of the statement  "            var matcher = "\"([^\"]+)\"'\"([^\"]+)\"'\"([^\"]+)\"'\"([^\"]+)\"'\"([^\"]+)\"'\"([^\"]+)\"'\"([^\"]+)\"'\"([^\"]+)\""; " is 120.
Long Statement,StaticAnalysis.SignatureVerifier,SignatureVerifier,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\SignatureVerifier.cs,Analyze,The length of the statement  "            foreach (var baseDirectory in cmdletProbingDirs.Where(s => !s.Contains("ServiceManagement") && Directory.Exists(Path.GetFullPath(s)))) " is 134.
Long Statement,StaticAnalysis.SignatureVerifier,SignatureVerifier,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\SignatureVerifier.cs,Analyze,The length of the statement  "                                    cmdlets = cmdlets.Where<CmdletSignatureMetadata>((cmdlet) => cmdletFilter(cmdlet.Name)).ToList<CmdletSignatureMetadata>(); " is 122.
Complex Conditional,StaticAnalysis.DependencyAnalyzer,DependencyAnalyzer,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\DependencyAnalyzer.cs,FindExtraAssemblies,The conditional expression  "_assemblies.Values.Any(a => !IsCommandAssembly(a) && (a.ReferencingAssembly == null                  || a.ReferencingAssembly.Count == 0 || !a.GetAncestors().Any(IsCommandAssembly)))"  is complex.
Empty Catch Block,StaticAnalysis.DependencyAnalyzer,AssemblyLoader,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\AssemblyLoader.cs,GetReflectedAssemblyInfo,The method has an empty catch block.
Empty Catch Block,StaticAnalysis.DependencyAnalyzer,AssemblyLoader,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\AssemblyLoader.cs,GetReflectedAssemblyFromFile,The method has an empty catch block.
Empty Catch Block,StaticAnalysis.HelpAnalyzer,CmdletLoader,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\HelpAnalyzer\CmdletLoader.cs,GetCmdlets,The method has an empty catch block.
Empty Catch Block,StaticAnalysis.SignatureVerifier,CmdletSignatureLoader,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\CmdletSignatureLoader.cs,GetCmdlets,The method has an empty catch block.
Magic Number,StaticAnalysis,Program,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\Program.cs,Main,The following statement contains a magic number: try              {                  if (args == null || args.Length < 1)                  {                      throw new InvalidOperationException("Please pass a valid directory name as the first parameter");                  }                    var installDir = args[0];                  if (!Directory.Exists(installDir))                  {                      throw new InvalidOperationException("You must pass a valid directory as the first parameter");                  }                    var directories = new List<string>              {                  Path.Combine(installDir' @"ResourceManager\AzureResourceManager\")'                  Path.Combine(installDir' @"ServiceManagement\Azure\")'                  Path.Combine(installDir' @"Storage\")             }.Where((d) => Directory.Exists(d)).ToList<string>();                    var reportsDirectory = Directory.GetCurrentDirectory();                  bool logReportsDirectoryWarning = true;                  if (args.Length > 1 && Directory.Exists(args[1]))                  {                      reportsDirectory = args[1];                      logReportsDirectoryWarning = false;                  }                    var exceptionsDirectory = Path.Combine(reportsDirectory' "Exceptions");                  bool useExceptions = true;                  if (args.Length > 2)                  {                      bool.TryParse(args[2]' out useExceptions);                  }                    bool skipHelp = true;                  if (args.Length > 3)                  {                      bool.TryParse(args[3]' out skipHelp);                  }                    if (skipHelp)                  {                      Analyzers = Analyzers.Where((a) => !(a is HelpAnalyzer.HelpAnalyzer)).ToList();                  }                                    analysisLogger = useExceptions ? new AnalysisLogger(reportsDirectory' exceptionsDirectory) :                      new AnalysisLogger(reportsDirectory);                  if (logReportsDirectoryWarning)                  {                      analysisLogger.WriteWarning("No logger specified in the second parameter' writing reports to {0}"'                          reportsDirectory);                  }                    foreach (var analyzer in Analyzers)                  {                      analyzer.Logger = analysisLogger;                      analysisLogger.WriteMessage("Executing analyzer: {0}"' analyzer.Name);                      analyzer.Analyze(directories);                      analysisLogger.WriteMessage("Processing complete for analyzer: {0}"' analyzer.Name);                  }                    analysisLogger.WriteReports();                  analysisLogger.CheckForIssues(2);              }              catch(Exception ex)              {                  analysisLogger.WriteError(ex.ToString());                  throw ex;              }
Magic Number,StaticAnalysis,Program,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\Program.cs,Main,The following statement contains a magic number: try              {                  if (args == null || args.Length < 1)                  {                      throw new InvalidOperationException("Please pass a valid directory name as the first parameter");                  }                    var installDir = args[0];                  if (!Directory.Exists(installDir))                  {                      throw new InvalidOperationException("You must pass a valid directory as the first parameter");                  }                    var directories = new List<string>              {                  Path.Combine(installDir' @"ResourceManager\AzureResourceManager\")'                  Path.Combine(installDir' @"ServiceManagement\Azure\")'                  Path.Combine(installDir' @"Storage\")             }.Where((d) => Directory.Exists(d)).ToList<string>();                    var reportsDirectory = Directory.GetCurrentDirectory();                  bool logReportsDirectoryWarning = true;                  if (args.Length > 1 && Directory.Exists(args[1]))                  {                      reportsDirectory = args[1];                      logReportsDirectoryWarning = false;                  }                    var exceptionsDirectory = Path.Combine(reportsDirectory' "Exceptions");                  bool useExceptions = true;                  if (args.Length > 2)                  {                      bool.TryParse(args[2]' out useExceptions);                  }                    bool skipHelp = true;                  if (args.Length > 3)                  {                      bool.TryParse(args[3]' out skipHelp);                  }                    if (skipHelp)                  {                      Analyzers = Analyzers.Where((a) => !(a is HelpAnalyzer.HelpAnalyzer)).ToList();                  }                                    analysisLogger = useExceptions ? new AnalysisLogger(reportsDirectory' exceptionsDirectory) :                      new AnalysisLogger(reportsDirectory);                  if (logReportsDirectoryWarning)                  {                      analysisLogger.WriteWarning("No logger specified in the second parameter' writing reports to {0}"'                          reportsDirectory);                  }                    foreach (var analyzer in Analyzers)                  {                      analyzer.Logger = analysisLogger;                      analysisLogger.WriteMessage("Executing analyzer: {0}"' analyzer.Name);                      analyzer.Analyze(directories);                      analysisLogger.WriteMessage("Processing complete for analyzer: {0}"' analyzer.Name);                  }                    analysisLogger.WriteReports();                  analysisLogger.CheckForIssues(2);              }              catch(Exception ex)              {                  analysisLogger.WriteError(ex.ToString());                  throw ex;              }
Magic Number,StaticAnalysis,Program,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\Program.cs,Main,The following statement contains a magic number: try              {                  if (args == null || args.Length < 1)                  {                      throw new InvalidOperationException("Please pass a valid directory name as the first parameter");                  }                    var installDir = args[0];                  if (!Directory.Exists(installDir))                  {                      throw new InvalidOperationException("You must pass a valid directory as the first parameter");                  }                    var directories = new List<string>              {                  Path.Combine(installDir' @"ResourceManager\AzureResourceManager\")'                  Path.Combine(installDir' @"ServiceManagement\Azure\")'                  Path.Combine(installDir' @"Storage\")             }.Where((d) => Directory.Exists(d)).ToList<string>();                    var reportsDirectory = Directory.GetCurrentDirectory();                  bool logReportsDirectoryWarning = true;                  if (args.Length > 1 && Directory.Exists(args[1]))                  {                      reportsDirectory = args[1];                      logReportsDirectoryWarning = false;                  }                    var exceptionsDirectory = Path.Combine(reportsDirectory' "Exceptions");                  bool useExceptions = true;                  if (args.Length > 2)                  {                      bool.TryParse(args[2]' out useExceptions);                  }                    bool skipHelp = true;                  if (args.Length > 3)                  {                      bool.TryParse(args[3]' out skipHelp);                  }                    if (skipHelp)                  {                      Analyzers = Analyzers.Where((a) => !(a is HelpAnalyzer.HelpAnalyzer)).ToList();                  }                                    analysisLogger = useExceptions ? new AnalysisLogger(reportsDirectory' exceptionsDirectory) :                      new AnalysisLogger(reportsDirectory);                  if (logReportsDirectoryWarning)                  {                      analysisLogger.WriteWarning("No logger specified in the second parameter' writing reports to {0}"'                          reportsDirectory);                  }                    foreach (var analyzer in Analyzers)                  {                      analyzer.Logger = analysisLogger;                      analysisLogger.WriteMessage("Executing analyzer: {0}"' analyzer.Name);                      analyzer.Analyze(directories);                      analysisLogger.WriteMessage("Processing complete for analyzer: {0}"' analyzer.Name);                  }                    analysisLogger.WriteReports();                  analysisLogger.CheckForIssues(2);              }              catch(Exception ex)              {                  analysisLogger.WriteError(ex.ToString());                  throw ex;              }
Magic Number,StaticAnalysis,Program,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\Program.cs,Main,The following statement contains a magic number: try              {                  if (args == null || args.Length < 1)                  {                      throw new InvalidOperationException("Please pass a valid directory name as the first parameter");                  }                    var installDir = args[0];                  if (!Directory.Exists(installDir))                  {                      throw new InvalidOperationException("You must pass a valid directory as the first parameter");                  }                    var directories = new List<string>              {                  Path.Combine(installDir' @"ResourceManager\AzureResourceManager\")'                  Path.Combine(installDir' @"ServiceManagement\Azure\")'                  Path.Combine(installDir' @"Storage\")             }.Where((d) => Directory.Exists(d)).ToList<string>();                    var reportsDirectory = Directory.GetCurrentDirectory();                  bool logReportsDirectoryWarning = true;                  if (args.Length > 1 && Directory.Exists(args[1]))                  {                      reportsDirectory = args[1];                      logReportsDirectoryWarning = false;                  }                    var exceptionsDirectory = Path.Combine(reportsDirectory' "Exceptions");                  bool useExceptions = true;                  if (args.Length > 2)                  {                      bool.TryParse(args[2]' out useExceptions);                  }                    bool skipHelp = true;                  if (args.Length > 3)                  {                      bool.TryParse(args[3]' out skipHelp);                  }                    if (skipHelp)                  {                      Analyzers = Analyzers.Where((a) => !(a is HelpAnalyzer.HelpAnalyzer)).ToList();                  }                                    analysisLogger = useExceptions ? new AnalysisLogger(reportsDirectory' exceptionsDirectory) :                      new AnalysisLogger(reportsDirectory);                  if (logReportsDirectoryWarning)                  {                      analysisLogger.WriteWarning("No logger specified in the second parameter' writing reports to {0}"'                          reportsDirectory);                  }                    foreach (var analyzer in Analyzers)                  {                      analyzer.Logger = analysisLogger;                      analysisLogger.WriteMessage("Executing analyzer: {0}"' analyzer.Name);                      analyzer.Analyze(directories);                      analysisLogger.WriteMessage("Processing complete for analyzer: {0}"' analyzer.Name);                  }                    analysisLogger.WriteReports();                  analysisLogger.CheckForIssues(2);              }              catch(Exception ex)              {                  analysisLogger.WriteError(ex.ToString());                  throw ex;              }
Magic Number,StaticAnalysis,Program,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\Program.cs,Main,The following statement contains a magic number: try              {                  if (args == null || args.Length < 1)                  {                      throw new InvalidOperationException("Please pass a valid directory name as the first parameter");                  }                    var installDir = args[0];                  if (!Directory.Exists(installDir))                  {                      throw new InvalidOperationException("You must pass a valid directory as the first parameter");                  }                    var directories = new List<string>              {                  Path.Combine(installDir' @"ResourceManager\AzureResourceManager\")'                  Path.Combine(installDir' @"ServiceManagement\Azure\")'                  Path.Combine(installDir' @"Storage\")             }.Where((d) => Directory.Exists(d)).ToList<string>();                    var reportsDirectory = Directory.GetCurrentDirectory();                  bool logReportsDirectoryWarning = true;                  if (args.Length > 1 && Directory.Exists(args[1]))                  {                      reportsDirectory = args[1];                      logReportsDirectoryWarning = false;                  }                    var exceptionsDirectory = Path.Combine(reportsDirectory' "Exceptions");                  bool useExceptions = true;                  if (args.Length > 2)                  {                      bool.TryParse(args[2]' out useExceptions);                  }                    bool skipHelp = true;                  if (args.Length > 3)                  {                      bool.TryParse(args[3]' out skipHelp);                  }                    if (skipHelp)                  {                      Analyzers = Analyzers.Where((a) => !(a is HelpAnalyzer.HelpAnalyzer)).ToList();                  }                                    analysisLogger = useExceptions ? new AnalysisLogger(reportsDirectory' exceptionsDirectory) :                      new AnalysisLogger(reportsDirectory);                  if (logReportsDirectoryWarning)                  {                      analysisLogger.WriteWarning("No logger specified in the second parameter' writing reports to {0}"'                          reportsDirectory);                  }                    foreach (var analyzer in Analyzers)                  {                      analyzer.Logger = analysisLogger;                      analysisLogger.WriteMessage("Executing analyzer: {0}"' analyzer.Name);                      analyzer.Analyze(directories);                      analysisLogger.WriteMessage("Processing complete for analyzer: {0}"' analyzer.Name);                  }                    analysisLogger.WriteReports();                  analysisLogger.CheckForIssues(2);              }              catch(Exception ex)              {                  analysisLogger.WriteError(ex.ToString());                  throw ex;              }
Magic Number,StaticAnalysis.BreakingChangeAnalyzer,BreakingChangeAnalyzer,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\BreakingChangeAnalyzer.cs,Analyze,The following statement contains a magic number: foreach (var baseDirectory in cmdletProbingDirs.Where(s => !s.Contains("ServiceManagement") &&                                                                           !s.Contains("Stack") && Directory.Exists(Path.GetFullPath(s))))              {                  List<string> probingDirectories = new List<string>();                    // Add current directory for probing                  probingDirectories.Add(baseDirectory);                  probingDirectories.AddRange(Directory.EnumerateDirectories(Path.GetFullPath(baseDirectory)));                    foreach (var directory in probingDirectories)                  {                      var service = Path.GetFileName(directory);                        var manifestFiles = Directory.EnumerateFiles(directory' "*.psd1").ToList();                        if (manifestFiles.Count > 1)                      {                          manifestFiles = manifestFiles.Where(f => Path.GetFileName(f).IndexOf(service) >= 0).ToList();                      }                        if (manifestFiles.Count == 0)                      {                          continue;                      }                        var psd1 = manifestFiles.FirstOrDefault();                        var parentDirectory = Directory.GetParent(psd1);                      var psd1FileName = Path.GetFileName(psd1);                        PowerShell powershell = PowerShell.Create();                      powershell.AddScript("Import-LocalizedData -BaseDirectory " + parentDirectory +                                           " -FileName " + psd1FileName +                                           " -BindingVariable ModuleMetadata; $ModuleMetadata.NestedModules");                        var cmdletResult = powershell.Invoke();                      var cmdletFiles = cmdletResult.Select(c => c.ToString().Substring(2));                        if (cmdletFiles.Any())                      {                          foreach (var cmdletFileName in cmdletFiles)                          {                              var cmdletFileFullPath = Path.Combine(directory' Path.GetFileName(cmdletFileName));                                                            if (File.Exists(cmdletFileFullPath))                              {                                  issueLogger.Decorator.AddDecorator(a => a.AssemblyFileName = cmdletFileFullPath' "AssemblyFileName");                                  processedHelpFiles.Add(cmdletFileName);                                  var proxy =                                       EnvironmentHelpers.CreateProxy<CmdletBreakingChangeLoader>(directory' out _appDomain);                                  var newModuleMetadata = proxy.GetModuleMetadata(cmdletFileFullPath);                                    string fileName = cmdletFileName + ".json";                                  string executingPath =                                       Path.GetDirectoryName(new Uri(Assembly.GetExecutingAssembly().CodeBase).AbsolutePath);                                    string filePath = executingPath + "\\SerializedCmdlets\\" + fileName;                                  bool serialize = false;                                    if (serialize)                                  {                                      SerializeCmdlets(filePath' newModuleMetadata);                                  }                                  else                                  {                                      if (!File.Exists(filePath))                                      {                                          continue;                                      }                                        var oldModuleMetadata = DeserializeCmdlets(filePath);                                        if (cmdletFilter != null)                                      {                                          string output = string.Format("Before filter\nOld module cmdlet count: {0}\nNew module cmdlet count: {1}"'                                              oldModuleMetadata.Cmdlets.Count' newModuleMetadata.Cmdlets.Count);                                            output += string.Format("\nCmdlet file: {0}"' cmdletFileFullPath);                                            oldModuleMetadata.FilterCmdlets(cmdletFilter);                                          newModuleMetadata.FilterCmdlets(cmdletFilter);                                            output += string.Format("After filter\nOld module cmdlet count: {0}\nNew module cmdlet count: {1}"'                                              oldModuleMetadata.Cmdlets.Count' newModuleMetadata.Cmdlets.Count);                                            foreach (var cmdlet in oldModuleMetadata.Cmdlets)                                          {                                              output += string.Format("\n\tOld cmdlet - {0}"' cmdlet.Name);                                          }                                            foreach (var cmdlet in newModuleMetadata.Cmdlets)                                          {                                              output += string.Format("\n\tNew cmdlet - {0}"' cmdlet.Name);                                          }                                            issueLogger.WriteMessage(output + Environment.NewLine);                                      }                                        RunBreakingChangeChecks(oldModuleMetadata' newModuleMetadata' issueLogger);                                  }                              }                          }                      }                  }              }
Magic Number,StaticAnalysis.BreakingChangeAnalyzer,BreakingChangeIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\BreakingChangeIssue.cs,Parse,The following statement contains a magic number: if (!match.Success || match.Groups.Count < 8)              {                  throw new InvalidOperationException(string.Format("Could not parse '{0}' as HelpIssue record"' line));              }
Magic Number,StaticAnalysis.BreakingChangeAnalyzer,BreakingChangeIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\BreakingChangeIssue.cs,Parse,The following statement contains a magic number: ClassName = match.Groups[2].Value;
Magic Number,StaticAnalysis.BreakingChangeAnalyzer,BreakingChangeIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\BreakingChangeIssue.cs,Parse,The following statement contains a magic number: Target = match.Groups[3].Value;
Magic Number,StaticAnalysis.BreakingChangeAnalyzer,BreakingChangeIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\BreakingChangeIssue.cs,Parse,The following statement contains a magic number: Severity = int.Parse(match.Groups[4].Value);
Magic Number,StaticAnalysis.BreakingChangeAnalyzer,BreakingChangeIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\BreakingChangeIssue.cs,Parse,The following statement contains a magic number: ProblemId = int.Parse(match.Groups[5].Value);
Magic Number,StaticAnalysis.BreakingChangeAnalyzer,BreakingChangeIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\BreakingChangeIssue.cs,Parse,The following statement contains a magic number: Description = match.Groups[6].Value;
Magic Number,StaticAnalysis.BreakingChangeAnalyzer,BreakingChangeIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\BreakingChangeAnalyzer\BreakingChangeIssue.cs,Parse,The following statement contains a magic number: Remediation = match.Groups[7].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,DependencyMap,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\DependencyMap.cs,Parse,The following statement contains a magic number: if (!match.Success || match.Groups.Count < 7)              {                  throw new InvalidOperationException(string.Format("Could not parse '{0}' as ExtraAssembly record"' line));              }
Magic Number,StaticAnalysis.DependencyAnalyzer,DependencyMap,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\DependencyMap.cs,Parse,The following statement contains a magic number: AssemblyName = match.Groups[2].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,DependencyMap,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\DependencyMap.cs,Parse,The following statement contains a magic number: Severity = int.Parse(match.Groups[3].Value);
Magic Number,StaticAnalysis.DependencyAnalyzer,DependencyMap,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\DependencyMap.cs,Parse,The following statement contains a magic number: ProblemId = int.Parse(match.Groups[4].Value);
Magic Number,StaticAnalysis.DependencyAnalyzer,DependencyMap,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\DependencyMap.cs,Parse,The following statement contains a magic number: Description = match.Groups[5].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,DependencyMap,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\DependencyMap.cs,Parse,The following statement contains a magic number: Remediation = match.Groups[6].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,AssemblyVersionConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\AssemblyVersionConflict.cs,Parse,The following statement contains a magic number: if (!match.Success || match.Groups.Count < 10)              {                  throw new InvalidOperationException(string.Format("Could not parse '{0}' as AssemblyVersionConflict record"' line));              }
Magic Number,StaticAnalysis.DependencyAnalyzer,AssemblyVersionConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\AssemblyVersionConflict.cs,Parse,The following statement contains a magic number: AssemblyName = match.Groups[2].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,AssemblyVersionConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\AssemblyVersionConflict.cs,Parse,The following statement contains a magic number: ExpectedVersion = Version.Parse(match.Groups[3].Value);
Magic Number,StaticAnalysis.DependencyAnalyzer,AssemblyVersionConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\AssemblyVersionConflict.cs,Parse,The following statement contains a magic number: ActualVersion = Version.Parse(match.Groups[4].Value);
Magic Number,StaticAnalysis.DependencyAnalyzer,AssemblyVersionConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\AssemblyVersionConflict.cs,Parse,The following statement contains a magic number: ParentAssembly = match.Groups[5].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,AssemblyVersionConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\AssemblyVersionConflict.cs,Parse,The following statement contains a magic number: Severity = int.Parse(match.Groups[6].Value);
Magic Number,StaticAnalysis.DependencyAnalyzer,AssemblyVersionConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\AssemblyVersionConflict.cs,Parse,The following statement contains a magic number: ProblemId = int.Parse(match.Groups[7].Value);
Magic Number,StaticAnalysis.DependencyAnalyzer,AssemblyVersionConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\AssemblyVersionConflict.cs,Parse,The following statement contains a magic number: Description = match.Groups[8].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,AssemblyVersionConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\AssemblyVersionConflict.cs,Parse,The following statement contains a magic number: Remediation = match.Groups[9].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,DependencyAnalyzer,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\DependencyAnalyzer.cs,AddSharedAssembly,The following statement contains a magic number: if (_sharedAssemblyReferences.ContainsKey(assembly.AssemblyName))              {                  var stored = _sharedAssemblyReferences[assembly.AssemblyName];                  if (!assembly.Equals(stored) && !(IsFrameworkAssembly(assembly.AssemblyName) && assembly.Version.Major <= 4))                  {                      _sharedConflictLogger.LogRecord(new SharedAssemblyConflict                      {                          AssemblyName = assembly.Name'                          AssemblyPathsAndFileVersions = new List<Tuple<string' Version>>()                          {                              new Tuple<string' Version>(assembly.Location' new Version(assembly.AssemblyFileMajorVersion'                                  assembly.AssemblyFileMinorVersion))'                              new Tuple<string' Version>(stored.Location' new Version(stored.AssemblyFileMajorVersion'                                  stored.AssemblyFileMinorVersion))                            }'                          AssemblyVersion = assembly.Version'                          Severity = 0'                          ProblemId = AssemblyVersionFileVersionMismatch'                          Description = "Shared assembly conflict' shared assemblies with the same assembly " +                                        "version have differing file versions"'                          Remediation = string.Format("Update the assembly reference for {0} in one of the " +                                                      "referring assemblies"' assembly.Name)                      });                        return false;                  }              }              else              {                  _sharedAssemblyReferences[assembly.AssemblyName] = assembly;              }
Magic Number,StaticAnalysis.DependencyAnalyzer,DependencyAnalyzer,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\DependencyAnalyzer.cs,ProcessDirectory,The following statement contains a magic number: foreach (var assembly in _assemblies.Values)              {                  foreach (var parent in assembly.ReferencingAssembly)                  {                      _dependencyMapLogger.LogRecord(                          new DependencyMap                          {                              AssemblyName = assembly.Name'                              AssemblyVersion = assembly.Version.ToString()'                              ReferencingAssembly = parent.Name'                              ReferencingAssemblyVersion = parent.Version.ToString()'                              Severity = 3                          });                  }                }
Magic Number,StaticAnalysis.DependencyAnalyzer,DependencyAnalyzer,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\DependencyAnalyzer.cs,FindExtraAssemblies,The following statement contains a magic number: if (_assemblies.Values.Any(a => !IsCommandAssembly(a) && (a.ReferencingAssembly == null                  || a.ReferencingAssembly.Count == 0 || !a.GetAncestors().Any(IsCommandAssembly))))              {                  foreach (                      var assembly in                          _assemblies.Values.Where(a => !IsCommandAssembly(a) && (a.ReferencingAssembly == null ||                              a.ReferencingAssembly.Count == 0 || !a.GetAncestors().Any(IsCommandAssembly))))                  {                      _extraAssemblyLogger.LogRecord(new ExtraAssembly                      {                          AssemblyName = assembly.Name'                          Severity = 2'                          ProblemId = ExtraAssemblyRecord'                          Description = string.Format("Assembly {0} is not referenced from any cmdlets assembly"'                          assembly.Name)'                          Remediation = string.Format("Remove assembly {0} from the project and regenerate the Wix " +                                                      "file"' assembly.Name)                      });                  }              }
Magic Number,StaticAnalysis.DependencyAnalyzer,DependencyAnalyzer,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\DependencyAnalyzer.cs,CheckAssemblyReference,The following statement contains a magic number: if (_assemblies.ContainsKey(reference.Name))              {                  var stored = _assemblies[reference.Name];                  if (stored.Equals(reference))                  {                      stored.ReferencingAssembly.Add(parent);                  }                  else if (reference.Version.Major == 0 && reference.Version.Minor == 0)                  {                      Logger.WriteWarning("{0}.dll has reference to assembly {1} without any version specification."'                          parent.Name' reference.Name);                      _versionConflictLogger.LogRecord(new AssemblyVersionConflict()                      {                          AssemblyName = reference.Name'                          ActualVersion = stored.Version'                          ExpectedVersion = reference.Version'                          ParentAssembly = parent.Name'                          ProblemId = NoAssemblyVersionEvidence'                          Severity = 2'                          Description = string.Format("Assembly {0} referenced from {1}.dll does not specify any " +                                                     "assembly version evidence.  The assembly will use version " +                                                     "{2} from disk."' reference.Name' parent.Name' stored.Version)'                          Remediation = string.Format("Update the reference to assembly {0} from {1} so that " +                                                     "assembly version evidence is supplied"' reference.Name'                                                     parent.Name)                      });                  }                  else                  {                      var minVersion = (stored.Version < reference.Version) ? stored.Version : reference.Version;                      _versionConflictLogger.LogRecord(new AssemblyVersionConflict()                      {                          AssemblyName = reference.Name'                          ActualVersion = stored.Version'                          ExpectedVersion = reference.Version'                          ParentAssembly = parent.Name'                          ProblemId = ReferenceDoesNotMatchAssemblyVersion'                          Severity = 1'                          Description = string.Format("Assembly {0} version {1} referenced from {2}.dll does " +                                                      "not match assembly version on disk: {3}"'                                                      reference.Name' reference.Version' parent.Name' stored.Version)'                          Remediation = string.Format("Update any references to version {0} of assembly {1}"'                          minVersion' reference.Name)                      });                  }              }              else if (!IsFrameworkAssembly(reference))              {                  _missingAssemblyLogger.LogRecord(new MissingAssembly                  {                      AssemblyName = reference.Name'                      AssemblyVersion = reference.Version.ToString()'                      ReferencingAssembly = parent.Name'                      Severity = 0'                      ProblemId = MissingAssemblyRecord'                      Description = string.Format("Missing assembly {0} referenced from {1}"' reference.Name'                      parent.Name)'                      Remediation = "Ensure that the assembly is included in the Wix file or directory"                  });              }
Magic Number,StaticAnalysis.DependencyAnalyzer,MissingAssembly,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\MissingAssembly.cs,Parse,The following statement contains a magic number: if (!match.Success || match.Groups.Count < 9)              {                  throw new InvalidOperationException(string.Format("Could not parse '{0}' as MissingAssembly record"' line));              }
Magic Number,StaticAnalysis.DependencyAnalyzer,MissingAssembly,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\MissingAssembly.cs,Parse,The following statement contains a magic number: AssemblyName = match.Groups[2].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,MissingAssembly,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\MissingAssembly.cs,Parse,The following statement contains a magic number: AssemblyVersion = match.Groups[3].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,MissingAssembly,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\MissingAssembly.cs,Parse,The following statement contains a magic number: ReferencingAssembly = match.Groups[4].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,MissingAssembly,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\MissingAssembly.cs,Parse,The following statement contains a magic number: Severity = int.Parse(match.Groups[5].Value);
Magic Number,StaticAnalysis.DependencyAnalyzer,MissingAssembly,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\MissingAssembly.cs,Parse,The following statement contains a magic number: ProblemId = int.Parse(match.Groups[6].Value);
Magic Number,StaticAnalysis.DependencyAnalyzer,MissingAssembly,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\MissingAssembly.cs,Parse,The following statement contains a magic number: Description = match.Groups[7].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,MissingAssembly,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\MissingAssembly.cs,Parse,The following statement contains a magic number: Remediation = match.Groups[8].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,ExtraAssembly,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\ExtraAssembly.cs,Parse,The following statement contains a magic number: if (!match.Success || match.Groups.Count < 7)              {                  throw new InvalidOperationException(string.Format("Could not parse '{0}' as ExtraAssembly record"' line));              }
Magic Number,StaticAnalysis.DependencyAnalyzer,ExtraAssembly,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\ExtraAssembly.cs,Parse,The following statement contains a magic number: AssemblyName = match.Groups[2].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,ExtraAssembly,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\ExtraAssembly.cs,Parse,The following statement contains a magic number: Severity = int.Parse(match.Groups[3].Value);
Magic Number,StaticAnalysis.DependencyAnalyzer,ExtraAssembly,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\ExtraAssembly.cs,Parse,The following statement contains a magic number: ProblemId = int.Parse(match.Groups[4].Value);
Magic Number,StaticAnalysis.DependencyAnalyzer,ExtraAssembly,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\ExtraAssembly.cs,Parse,The following statement contains a magic number: Description = match.Groups[5].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,ExtraAssembly,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\ExtraAssembly.cs,Parse,The following statement contains a magic number: Remediation = match.Groups[6].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,SharedAssemblyConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\SharedAssemblyConflict.cs,Parse,The following statement contains a magic number: if (!match.Success || match.Groups.Count < 8)              {                  throw new InvalidOperationException(string.Format("Could not parse '{0}' as SharedAssemblyConflict record"' line));              }
Magic Number,StaticAnalysis.DependencyAnalyzer,SharedAssemblyConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\SharedAssemblyConflict.cs,Parse,The following statement contains a magic number: AssemblyName = match.Groups[2].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,SharedAssemblyConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\SharedAssemblyConflict.cs,Parse,The following statement contains a magic number: AssemblyVersion = Version.Parse(match.Groups[3].Value);
Magic Number,StaticAnalysis.DependencyAnalyzer,SharedAssemblyConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\SharedAssemblyConflict.cs,Parse,The following statement contains a magic number: Severity = int.Parse(match.Groups[4].Value);
Magic Number,StaticAnalysis.DependencyAnalyzer,SharedAssemblyConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\SharedAssemblyConflict.cs,Parse,The following statement contains a magic number: ProblemId = int.Parse(match.Groups[5].Value);
Magic Number,StaticAnalysis.DependencyAnalyzer,SharedAssemblyConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\SharedAssemblyConflict.cs,Parse,The following statement contains a magic number: Description = match.Groups[6].Value;
Magic Number,StaticAnalysis.DependencyAnalyzer,SharedAssemblyConflict,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\DependencyAnalyzer\SharedAssemblyConflict.cs,Parse,The following statement contains a magic number: Remediation = match.Groups[7].Value;
Magic Number,StaticAnalysis.HelpAnalyzer,HelpAnalyzer,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\HelpAnalyzer\HelpAnalyzer.cs,AnalyzeMarkdownHelp,The following statement contains a magic number: if (helpFiles.Any())              {                  Directory.SetCurrentDirectory(directory);                  var manifestFiles = Directory.EnumerateFiles(directory' "*.psd1").ToList();                  if (manifestFiles.Count > 1)                  {                      manifestFiles = manifestFiles.Where(f => Path.GetFileName(f).IndexOf(service) >= 0).ToList();                  }                    if (manifestFiles.Count == 0)                  {                      return;                  }                    var psd1 = manifestFiles.FirstOrDefault();                  var parentDirectory = Directory.GetParent(psd1);                  var psd1FileName = Path.GetFileName(psd1);                    PowerShell powershell = PowerShell.Create();                  powershell.AddScript("Import-LocalizedData -BaseDirectory " + parentDirectory +                                      " -FileName " + psd1FileName +                                      " -BindingVariable ModuleMetadata; $ModuleMetadata.NestedModules");                  var cmdletResult = powershell.Invoke();                  var cmdletFiles = cmdletResult.Select(c => c.ToString().Substring(2));                  if (cmdletFiles.Any())                  {                      List<CmdletHelpMetadata> allCmdlets = new List<CmdletHelpMetadata>();                      foreach (var cmdletFileName in cmdletFiles)                      {                          var cmdletFileFullPath = Path.Combine(directory' Path.GetFileName(cmdletFileName));                          if (File.Exists(cmdletFileFullPath))                          {                              helpLogger.Decorator.AddDecorator((h) =>                              {                                  h.HelpFile = cmdletFileFullPath;                                  h.Assembly = cmdletFileFullPath;                              }' "Cmdlet");                              processedHelpFiles.Add(cmdletFileName);                              var proxy =                                  EnvironmentHelpers.CreateProxy<CmdletLoader>(directory' out _appDomain);                              var cmdlets = proxy.GetCmdlets(cmdletFileFullPath);                              allCmdlets.AddRange(cmdlets);                              helpLogger.Decorator.Remove("Cmdlet");                              AppDomain.Unload(_appDomain);                          }                      }                        ValidateHelpRecords(allCmdlets' helpFiles' helpLogger);                  }                    Directory.SetCurrentDirectory(savedDirectory);              }
Magic Number,StaticAnalysis.HelpAnalyzer,HelpIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\HelpAnalyzer\HelpIssue.cs,Parse,The following statement contains a magic number: if (!match.Success || match.Groups.Count < 8)              {                  throw new InvalidOperationException(string.Format("Could not parse '{0}' as HelpIssue record"' line));              }
Magic Number,StaticAnalysis.HelpAnalyzer,HelpIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\HelpAnalyzer\HelpIssue.cs,Parse,The following statement contains a magic number: HelpFile = match.Groups[2].Value;
Magic Number,StaticAnalysis.HelpAnalyzer,HelpIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\HelpAnalyzer\HelpIssue.cs,Parse,The following statement contains a magic number: Target = match.Groups[3].Value;
Magic Number,StaticAnalysis.HelpAnalyzer,HelpIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\HelpAnalyzer\HelpIssue.cs,Parse,The following statement contains a magic number: Severity = int.Parse(match.Groups[4].Value);
Magic Number,StaticAnalysis.HelpAnalyzer,HelpIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\HelpAnalyzer\HelpIssue.cs,Parse,The following statement contains a magic number: ProblemId = int.Parse(match.Groups[5].Value);
Magic Number,StaticAnalysis.HelpAnalyzer,HelpIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\HelpAnalyzer\HelpIssue.cs,Parse,The following statement contains a magic number: Description = match.Groups[6].Value;
Magic Number,StaticAnalysis.HelpAnalyzer,HelpIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\HelpAnalyzer\HelpIssue.cs,Parse,The following statement contains a magic number: Remediation = match.Groups[7].Value;
Magic Number,StaticAnalysis.SignatureVerifier,SignatureIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\SignatureIssue.cs,Parse,The following statement contains a magic number: if (!match.Success || match.Groups.Count < 8)              {                  throw new InvalidOperationException(string.Format("Could not parse '{0}' as HelpIssue record"' line));              }
Magic Number,StaticAnalysis.SignatureVerifier,SignatureIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\SignatureIssue.cs,Parse,The following statement contains a magic number: ClassName = match.Groups[2].Value;
Magic Number,StaticAnalysis.SignatureVerifier,SignatureIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\SignatureIssue.cs,Parse,The following statement contains a magic number: Target = match.Groups[3].Value;
Magic Number,StaticAnalysis.SignatureVerifier,SignatureIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\SignatureIssue.cs,Parse,The following statement contains a magic number: Severity = int.Parse(match.Groups[4].Value);
Magic Number,StaticAnalysis.SignatureVerifier,SignatureIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\SignatureIssue.cs,Parse,The following statement contains a magic number: ProblemId = int.Parse(match.Groups[5].Value);
Magic Number,StaticAnalysis.SignatureVerifier,SignatureIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\SignatureIssue.cs,Parse,The following statement contains a magic number: Description = match.Groups[6].Value;
Magic Number,StaticAnalysis.SignatureVerifier,SignatureIssue,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\SignatureIssue.cs,Parse,The following statement contains a magic number: Remediation = match.Groups[7].Value;
Magic Number,StaticAnalysis.SignatureVerifier,SignatureVerifier,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\SignatureVerifier.cs,Analyze,The following statement contains a magic number: foreach (var baseDirectory in cmdletProbingDirs.Where(s => !s.Contains("ServiceManagement") && Directory.Exists(Path.GetFullPath(s))))              {                  //Add current directory for probing                  probingDirectories.Add(baseDirectory);                  probingDirectories.AddRange(Directory.EnumerateDirectories(Path.GetFullPath(baseDirectory)));                    foreach(var directory in probingDirectories)                  {                      var helpFiles = Directory.EnumerateFiles(directory' "*.dll-Help.xml")                          .Where(f => !processedHelpFiles.Contains(Path.GetFileName(f)'                              StringComparer.OrdinalIgnoreCase)).ToList();                      if (helpFiles.Any())                      {                          Directory.SetCurrentDirectory(directory);                          foreach (var helpFile in helpFiles)                          {                              var cmdletFile = helpFile.Substring(0' helpFile.Length - "-Help.xml".Length);                              var helpFileName = Path.GetFileName(helpFile);                              var cmdletFileName = Path.GetFileName(cmdletFile);                              if (File.Exists(cmdletFile))                              {                                  issueLogger.Decorator.AddDecorator(a => a.AssemblyFileName = cmdletFileName' "AssemblyFileName");                                  processedHelpFiles.Add(helpFileName);                                  var proxy = EnvironmentHelpers.CreateProxy<CmdletSignatureLoader>(directory' out _appDomain);                                  var cmdlets = proxy.GetCmdlets(cmdletFile);                                    if (cmdletFilter != null)                                  {                                      cmdlets = cmdlets.Where<CmdletSignatureMetadata>((cmdlet) => cmdletFilter(cmdlet.Name)).ToList<CmdletSignatureMetadata>();                                  }                                    foreach (var cmdlet in cmdlets)                                  {                                      Logger.WriteMessage("Processing cmdlet '{0}'"' cmdlet.ClassName);                                      string defaultRemediation = "Determine if the cmdlet should implement ShouldProcess and " +                                                            "if so determine if it should implement Force / ShouldContinue";                                      if (!cmdlet.SupportsShouldProcess && cmdlet.HasForceSwitch)                                      {                                          issueLogger.LogSignatureIssue(                                             cmdlet: cmdlet'                                             severity: 0'                                          problemId: SignatureProblemId.ForceWithoutShouldProcessAttribute'                                          description: string.Format("{0} Has  -Force parameter but does not set the SupportsShouldProcess " +                                                                      "property to true in the Cmdlet attribute."' cmdlet.Name)'                                          remediation: defaultRemediation);                                      }                                      if (!cmdlet.SupportsShouldProcess && cmdlet.ConfirmImpact != ConfirmImpact.Medium)                                      {                                          issueLogger.LogSignatureIssue(                                             cmdlet: cmdlet'                                             severity: 2'                                          problemId: SignatureProblemId.ConfirmLeveleWithNoShouldProcess'                                          description:                                              string.Format("{0} Changes the ConfirmImpact but does not set the " +                                                  "SupportsShouldProcess property to true in the cmdlet attribute."'                                                  cmdlet.Name)'                                          remediation: defaultRemediation);                                      }                                      if (!cmdlet.SupportsShouldProcess && cmdlet.IsShouldProcessVerb)                                      {                                          issueLogger.LogSignatureIssue(                                              cmdlet: cmdlet'                                              severity: 1'                                              problemId: SignatureProblemId.ActionIndicatesShouldProcess'                                              description:                                                  string.Format(                                                      "{0} Does not support ShouldProcess but the cmdlet verb {1} indicates that it should."'                                                      cmdlet.Name' cmdlet.VerbName)'                                              remediation: defaultRemediation);                                      }                                      if (cmdlet.ConfirmImpact != ConfirmImpact.Medium)                                      {                                          issueLogger.LogSignatureIssue(                                             cmdlet: cmdlet'                                             severity: 2'                                          problemId: SignatureProblemId.ConfirmLevelChange'                                          description:                                          string.Format("{0} changes the confirm impact.  Please ensure that the " +                                              "change in ConfirmImpact is justified"' cmdlet.Name)'                                          remediation:                                              "Verify that ConfirmImpact is changed appropriately by the cmdlet. " +                                              "It is very rare for a cmdlet to change the ConfirmImpact.");                                      }                                      if (cmdlet.IsShouldContinueVerb && !cmdlet.HasForceSwitch)                                      {                                          issueLogger.LogSignatureIssue(                                             cmdlet: cmdlet'                                             severity: 2'                                          problemId: SignatureProblemId.CmdletWithDestructiveVerbNoForce'                                          description:                                              string.Format(                                                  "{0} does not have a Force parameter but the cmdlet verb '{1}' " +                                                  "indicates that it may perform destructive actions under certain " +                                                  "circumstances. Consider whether the cmdlet should have a Force " +                                                  "parameter anduse ShouldContinue under some circumstances. "'                                                  cmdlet.Name' cmdlet.VerbName)'                                          remediation: "Consider wether the cmdlet should have a Force " +                                                        "parameter and use ShouldContinue under some circumstances. ");                                      }                                        if (!cmdlet.IsApprovedVerb)                                      {                                          issueLogger.LogSignatureIssue(                                              cmdlet: cmdlet'                                              severity: 1'                                          problemId: SignatureProblemId.CmdletWithUnapprovedVerb'                                          description:                                              string.Format(                                                  "{0} uses the verb '{1}'' which is not on the list of approved " +                                                  "verbs for PowerShell commands. Use the cmdlet 'Get-Verb' to see " +                                                  "the full list of approved verbs and consider renaming the cmdlet."'                                                  cmdlet.Name' cmdlet.VerbName)'                                          remediation: "Consider renaming the cmdlet to use an approved verb for PowerShell.");                                      }                                        if (!cmdlet.HasSingularNoun)                                      {                                          issueLogger.LogSignatureIssue(                                              cmdlet: cmdlet'                                              severity: 1'                                          problemId: SignatureProblemId.CmdletWithPluralNoun'                                          description:                                              string.Format(                                                  "{0} uses the noun '{1}'' which does not follow the enforced " +                                                  "naming convention of using a singular noun for a cmdlet name."'                                                  cmdlet.Name' cmdlet.NounName)'                                          remediation: "Consider using a singular noun for the cmdlet name.");                                      }                                        foreach (var parameter in cmdlet.GetParametersWithPluralNoun())                                      {                                          issueLogger.LogSignatureIssue(                                              cmdlet: cmdlet'                                              severity: 1'                                          problemId: SignatureProblemId.ParameterWithPluralNoun'                                          description:                                              string.Format(                                                  "Parameter {0} of cmdlet {1} does not follow the enforced " +                                                  "naming convention of using a singular noun for a parameter name."'                                                  parameter.Name' cmdlet.Name)'                                          remediation: "Consider using a singular noun for the parameter name.");                                      }                                  }                                    AppDomain.Unload(_appDomain);                                  issueLogger.Decorator.Remove("AssemblyFileName");                              }                          }                          Directory.SetCurrentDirectory(savedDirectory);                      }                  }              }
Magic Number,StaticAnalysis.SignatureVerifier,SignatureVerifier,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\SignatureVerifier.cs,Analyze,The following statement contains a magic number: foreach (var baseDirectory in cmdletProbingDirs.Where(s => !s.Contains("ServiceManagement") && Directory.Exists(Path.GetFullPath(s))))              {                  //Add current directory for probing                  probingDirectories.Add(baseDirectory);                  probingDirectories.AddRange(Directory.EnumerateDirectories(Path.GetFullPath(baseDirectory)));                    foreach(var directory in probingDirectories)                  {                      var helpFiles = Directory.EnumerateFiles(directory' "*.dll-Help.xml")                          .Where(f => !processedHelpFiles.Contains(Path.GetFileName(f)'                              StringComparer.OrdinalIgnoreCase)).ToList();                      if (helpFiles.Any())                      {                          Directory.SetCurrentDirectory(directory);                          foreach (var helpFile in helpFiles)                          {                              var cmdletFile = helpFile.Substring(0' helpFile.Length - "-Help.xml".Length);                              var helpFileName = Path.GetFileName(helpFile);                              var cmdletFileName = Path.GetFileName(cmdletFile);                              if (File.Exists(cmdletFile))                              {                                  issueLogger.Decorator.AddDecorator(a => a.AssemblyFileName = cmdletFileName' "AssemblyFileName");                                  processedHelpFiles.Add(helpFileName);                                  var proxy = EnvironmentHelpers.CreateProxy<CmdletSignatureLoader>(directory' out _appDomain);                                  var cmdlets = proxy.GetCmdlets(cmdletFile);                                    if (cmdletFilter != null)                                  {                                      cmdlets = cmdlets.Where<CmdletSignatureMetadata>((cmdlet) => cmdletFilter(cmdlet.Name)).ToList<CmdletSignatureMetadata>();                                  }                                    foreach (var cmdlet in cmdlets)                                  {                                      Logger.WriteMessage("Processing cmdlet '{0}'"' cmdlet.ClassName);                                      string defaultRemediation = "Determine if the cmdlet should implement ShouldProcess and " +                                                            "if so determine if it should implement Force / ShouldContinue";                                      if (!cmdlet.SupportsShouldProcess && cmdlet.HasForceSwitch)                                      {                                          issueLogger.LogSignatureIssue(                                             cmdlet: cmdlet'                                             severity: 0'                                          problemId: SignatureProblemId.ForceWithoutShouldProcessAttribute'                                          description: string.Format("{0} Has  -Force parameter but does not set the SupportsShouldProcess " +                                                                      "property to true in the Cmdlet attribute."' cmdlet.Name)'                                          remediation: defaultRemediation);                                      }                                      if (!cmdlet.SupportsShouldProcess && cmdlet.ConfirmImpact != ConfirmImpact.Medium)                                      {                                          issueLogger.LogSignatureIssue(                                             cmdlet: cmdlet'                                             severity: 2'                                          problemId: SignatureProblemId.ConfirmLeveleWithNoShouldProcess'                                          description:                                              string.Format("{0} Changes the ConfirmImpact but does not set the " +                                                  "SupportsShouldProcess property to true in the cmdlet attribute."'                                                  cmdlet.Name)'                                          remediation: defaultRemediation);                                      }                                      if (!cmdlet.SupportsShouldProcess && cmdlet.IsShouldProcessVerb)                                      {                                          issueLogger.LogSignatureIssue(                                              cmdlet: cmdlet'                                              severity: 1'                                              problemId: SignatureProblemId.ActionIndicatesShouldProcess'                                              description:                                                  string.Format(                                                      "{0} Does not support ShouldProcess but the cmdlet verb {1} indicates that it should."'                                                      cmdlet.Name' cmdlet.VerbName)'                                              remediation: defaultRemediation);                                      }                                      if (cmdlet.ConfirmImpact != ConfirmImpact.Medium)                                      {                                          issueLogger.LogSignatureIssue(                                             cmdlet: cmdlet'                                             severity: 2'                                          problemId: SignatureProblemId.ConfirmLevelChange'                                          description:                                          string.Format("{0} changes the confirm impact.  Please ensure that the " +                                              "change in ConfirmImpact is justified"' cmdlet.Name)'                                          remediation:                                              "Verify that ConfirmImpact is changed appropriately by the cmdlet. " +                                              "It is very rare for a cmdlet to change the ConfirmImpact.");                                      }                                      if (cmdlet.IsShouldContinueVerb && !cmdlet.HasForceSwitch)                                      {                                          issueLogger.LogSignatureIssue(                                             cmdlet: cmdlet'                                             severity: 2'                                          problemId: SignatureProblemId.CmdletWithDestructiveVerbNoForce'                                          description:                                              string.Format(                                                  "{0} does not have a Force parameter but the cmdlet verb '{1}' " +                                                  "indicates that it may perform destructive actions under certain " +                                                  "circumstances. Consider whether the cmdlet should have a Force " +                                                  "parameter anduse ShouldContinue under some circumstances. "'                                                  cmdlet.Name' cmdlet.VerbName)'                                          remediation: "Consider wether the cmdlet should have a Force " +                                                        "parameter and use ShouldContinue under some circumstances. ");                                      }                                        if (!cmdlet.IsApprovedVerb)                                      {                                          issueLogger.LogSignatureIssue(                                              cmdlet: cmdlet'                                              severity: 1'                                          problemId: SignatureProblemId.CmdletWithUnapprovedVerb'                                          description:                                              string.Format(                                                  "{0} uses the verb '{1}'' which is not on the list of approved " +                                                  "verbs for PowerShell commands. Use the cmdlet 'Get-Verb' to see " +                                                  "the full list of approved verbs and consider renaming the cmdlet."'                                                  cmdlet.Name' cmdlet.VerbName)'                                          remediation: "Consider renaming the cmdlet to use an approved verb for PowerShell.");                                      }                                        if (!cmdlet.HasSingularNoun)                                      {                                          issueLogger.LogSignatureIssue(                                              cmdlet: cmdlet'                                              severity: 1'                                          problemId: SignatureProblemId.CmdletWithPluralNoun'                                          description:                                              string.Format(                                                  "{0} uses the noun '{1}'' which does not follow the enforced " +                                                  "naming convention of using a singular noun for a cmdlet name."'                                                  cmdlet.Name' cmdlet.NounName)'                                          remediation: "Consider using a singular noun for the cmdlet name.");                                      }                                        foreach (var parameter in cmdlet.GetParametersWithPluralNoun())                                      {                                          issueLogger.LogSignatureIssue(                                              cmdlet: cmdlet'                                              severity: 1'                                          problemId: SignatureProblemId.ParameterWithPluralNoun'                                          description:                                              string.Format(                                                  "Parameter {0} of cmdlet {1} does not follow the enforced " +                                                  "naming convention of using a singular noun for a parameter name."'                                                  parameter.Name' cmdlet.Name)'                                          remediation: "Consider using a singular noun for the parameter name.");                                      }                                  }                                    AppDomain.Unload(_appDomain);                                  issueLogger.Decorator.Remove("AssemblyFileName");                              }                          }                          Directory.SetCurrentDirectory(savedDirectory);                      }                  }              }
Magic Number,StaticAnalysis.SignatureVerifier,SignatureVerifier,C:\repos\Azure_azure-powershell\tools\StaticAnalysis\SignatureVerifier\SignatureVerifier.cs,Analyze,The following statement contains a magic number: foreach (var baseDirectory in cmdletProbingDirs.Where(s => !s.Contains("ServiceManagement") && Directory.Exists(Path.GetFullPath(s))))              {                  //Add current directory for probing                  probingDirectories.Add(baseDirectory);                  probingDirectories.AddRange(Directory.EnumerateDirectories(Path.GetFullPath(baseDirectory)));                    foreach(var directory in probingDirectories)                  {                      var helpFiles = Directory.EnumerateFiles(directory' "*.dll-Help.xml")                          .Where(f => !processedHelpFiles.Contains(Path.GetFileName(f)'                              StringComparer.OrdinalIgnoreCase)).ToList();                      if (helpFiles.Any())                      {                          Directory.SetCurrentDirectory(directory);                          foreach (var helpFile in helpFiles)                          {                              var cmdletFile = helpFile.Substring(0' helpFile.Length - "-Help.xml".Length);                              var helpFileName = Path.GetFileName(helpFile);                              var cmdletFileName = Path.GetFileName(cmdletFile);                              if (File.Exists(cmdletFile))                              {                                  issueLogger.Decorator.AddDecorator(a => a.AssemblyFileName = cmdletFileName' "AssemblyFileName");                                  processedHelpFiles.Add(helpFileName);                                  var proxy = EnvironmentHelpers.CreateProxy<CmdletSignatureLoader>(directory' out _appDomain);                                  var cmdlets = proxy.GetCmdlets(cmdletFile);                                    if (cmdletFilter != null)                                  {                                      cmdlets = cmdlets.Where<CmdletSignatureMetadata>((cmdlet) => cmdletFilter(cmdlet.Name)).ToList<CmdletSignatureMetadata>();                                  }                                    foreach (var cmdlet in cmdlets)                                  {                                      Logger.WriteMessage("Processing cmdlet '{0}'"' cmdlet.ClassName);                                      string defaultRemediation = "Determine if the cmdlet should implement ShouldProcess and " +                                                            "if so determine if it should implement Force / ShouldContinue";                                      if (!cmdlet.SupportsShouldProcess && cmdlet.HasForceSwitch)                                      {                                          issueLogger.LogSignatureIssue(                                             cmdlet: cmdlet'                                             severity: 0'                                          problemId: SignatureProblemId.ForceWithoutShouldProcessAttribute'                                          description: string.Format("{0} Has  -Force parameter but does not set the SupportsShouldProcess " +                                                                      "property to true in the Cmdlet attribute."' cmdlet.Name)'                                          remediation: defaultRemediation);                                      }                                      if (!cmdlet.SupportsShouldProcess && cmdlet.ConfirmImpact != ConfirmImpact.Medium)                                      {                                          issueLogger.LogSignatureIssue(                                             cmdlet: cmdlet'                                             severity: 2'                                          problemId: SignatureProblemId.ConfirmLeveleWithNoShouldProcess'                                          description:                                              string.Format("{0} Changes the ConfirmImpact but does not set the " +                                                  "SupportsShouldProcess property to true in the cmdlet attribute."'                                                  cmdlet.Name)'                                          remediation: defaultRemediation);                                      }                                      if (!cmdlet.SupportsShouldProcess && cmdlet.IsShouldProcessVerb)                                      {                                          issueLogger.LogSignatureIssue(                                              cmdlet: cmdlet'                                              severity: 1'                                              problemId: SignatureProblemId.ActionIndicatesShouldProcess'                                              description:                                                  string.Format(                                                      "{0} Does not support ShouldProcess but the cmdlet verb {1} indicates that it should."'                                                      cmdlet.Name' cmdlet.VerbName)'                                              remediation: defaultRemediation);                                      }                                      if (cmdlet.ConfirmImpact != ConfirmImpact.Medium)                                      {                                          issueLogger.LogSignatureIssue(                                             cmdlet: cmdlet'                                             severity: 2'                                          problemId: SignatureProblemId.ConfirmLevelChange'                                          description:                                          string.Format("{0} changes the confirm impact.  Please ensure that the " +                                              "change in ConfirmImpact is justified"' cmdlet.Name)'                                          remediation:                                              "Verify that ConfirmImpact is changed appropriately by the cmdlet. " +                                              "It is very rare for a cmdlet to change the ConfirmImpact.");                                      }                                      if (cmdlet.IsShouldContinueVerb && !cmdlet.HasForceSwitch)                                      {                                          issueLogger.LogSignatureIssue(                                             cmdlet: cmdlet'                                             severity: 2'                                          problemId: SignatureProblemId.CmdletWithDestructiveVerbNoForce'                                          description:                                              string.Format(                                                  "{0} does not have a Force parameter but the cmdlet verb '{1}' " +                                                  "indicates that it may perform destructive actions under certain " +                                                  "circumstances. Consider whether the cmdlet should have a Force " +                                                  "parameter anduse ShouldContinue under some circumstances. "'                                                  cmdlet.Name' cmdlet.VerbName)'                                          remediation: "Consider wether the cmdlet should have a Force " +                                                        "parameter and use ShouldContinue under some circumstances. ");                                      }                                        if (!cmdlet.IsApprovedVerb)                                      {                                          issueLogger.LogSignatureIssue(                                              cmdlet: cmdlet'                                              severity: 1'                                          problemId: SignatureProblemId.CmdletWithUnapprovedVerb'                                          description:                                              string.Format(                                                  "{0} uses the verb '{1}'' which is not on the list of approved " +                                                  "verbs for PowerShell commands. Use the cmdlet 'Get-Verb' to see " +                                                  "the full list of approved verbs and consider renaming the cmdlet."'                                                  cmdlet.Name' cmdlet.VerbName)'                                          remediation: "Consider renaming the cmdlet to use an approved verb for PowerShell.");                                      }                                        if (!cmdlet.HasSingularNoun)                                      {                                          issueLogger.LogSignatureIssue(                                              cmdlet: cmdlet'                                              severity: 1'                                          problemId: SignatureProblemId.CmdletWithPluralNoun'                                          description:                                              string.Format(                                                  "{0} uses the noun '{1}'' which does not follow the enforced " +                                                  "naming convention of using a singular noun for a cmdlet name."'                                                  cmdlet.Name' cmdlet.NounName)'                                          remediation: "Consider using a singular noun for the cmdlet name.");                                      }                                        foreach (var parameter in cmdlet.GetParametersWithPluralNoun())                                      {                                          issueLogger.LogSignatureIssue(                                              cmdlet: cmdlet'                                              severity: 1'                                          problemId: SignatureProblemId.ParameterWithPluralNoun'                                          description:                                              string.Format(                                                  "Parameter {0} of cmdlet {1} does not follow the enforced " +                                                  "naming convention of using a singular noun for a parameter name."'                                                  parameter.Name' cmdlet.Name)'                                          remediation: "Consider using a singular noun for the parameter name.");                                      }                                  }                                    AppDomain.Unload(_appDomain);                                  issueLogger.Decorator.Remove("AssemblyFileName");                              }                          }                          Directory.SetCurrentDirectory(savedDirectory);                      }                  }              }
