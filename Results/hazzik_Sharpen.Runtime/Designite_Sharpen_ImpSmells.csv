Implementation smell,Namespace,Class,File,Method,Description
Long Method,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The method has 140 lines of code.
Long Method,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The method has 223 lines of code.
Complex Method,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,Cyclomatic complexity of the method is 83
Complex Method,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,Cyclomatic complexity of the method is 105
Complex Method,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,GetTimeZone,Cyclomatic complexity of the method is 9
Complex Method,Sharpen,MessageFormat,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\MessageFormat.cs,Format,Cyclomatic complexity of the method is 9
Complex Method,Sharpen,HttpURLConnection,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\HttpURLConnection.cs,SetRequestProperty,Cyclomatic complexity of the method is 24
Complex Method,Sharpen,JavaCalendar,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\JavaCalendar.cs,Add,Cyclomatic complexity of the method is 23
Complex Method,Sharpen,JavaCalendar,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\JavaCalendar.cs,Set,Cyclomatic complexity of the method is 20
Long Parameter List,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,RegionMatches,The method has 6 parameters.
Long Statement,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,GetTime,The length of the statement  "	return new DateTimeOffset (DateTime.SpecifyKind (dateTime' DateTimeKind.Utc)' TimeSpan.Zero).ToMillisecondsSinceEpoch (); " is 121.
Long Statement,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,ToMillisecondsSinceEpoch,The length of the statement  "	return new DateTimeOffset (DateTime.SpecifyKind (dateTime' DateTimeKind.Utc)' TimeSpan.Zero).ToMillisecondsSinceEpoch (); " is 121.
Long Statement,Sharpen,SimpleDateFormat,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\SimpleDateFormat.cs,Format,The length of the statement  "	return Extensions.MillisToDateTimeOffset (date' (int)GetTimeZone ().BaseUtcOffset.TotalMinutes).DateTime.ToString (format); " is 123.
Long Statement,Sharpen,ResourceBundle,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\ResourceBundle.cs,GetBundle,The length of the statement  "	manifestResourceStream = asm.GetManifestResourceStream (bundleClass + "_" + culture.ToString ().Replace ('-'' '_') + ".properties"); " is 132.
Long Statement,Sharpen,ResourceBundle,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\ResourceBundle.cs,GetBundle,The length of the statement  "		manifestResourceStream = asm.GetManifestResourceStream (bundleClass + "_" + culture.TwoLetterISOLanguageName + ".properties"); " is 126.
Long Statement,Sharpen,ScheduledThreadPoolExecutor,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\ScheduledThreadPoolExecutor.cs,Shutdown,The length of the statement  "			Scheduler.Instance.Shutdown (this' continueExistingPeriodicTasksAfterShutdownPolicy' executeExistingDelayedTasksAfterShutdownPolicy); " is 133.
Complex Conditional,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The conditional expression  "buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0"  is complex.
Complex Conditional,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,RegionMatches,The conditional expression  "toOffset < 0 || ooffset < 0 || toOffset + len > str.Length || ooffset + len > other.Length"  is complex.
Empty Catch Block,Sharpen,TaskFuture,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Executors.cs,Cancel,The method has an empty catch block.
Empty Catch Block,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,GetTimeZone,The method has an empty catch block.
Empty Catch Block,Sharpen,ThreadPoolExecutor,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\ThreadPoolExecutor.cs,RunPoolThread,The method has an empty catch block.
Empty Catch Block,Sharpen,ThreadPoolExecutor,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\ThreadPoolExecutor.cs,ShutdownNow,The method has an empty catch block.
Empty Catch Block,Sharpen,SystemProcess,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Process.cs,Destroy,The method has an empty catch block.
Empty Catch Block,Sharpen,FileHelper,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\FileHelper.cs,SetLastModified,The method has an empty catch block.
Magic Number,Sharpen,CRC32,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\CRC32.cs,Update,The following statement contains a magic number: this._value = (this._value >> 8) ^ CrcTable [(int)((IntPtr)((this._value & 0xff) ^ value))];  
Magic Number,Sharpen,CRC32,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\CRC32.cs,Update,The following statement contains a magic number: this._value = CrcTable [(int)((IntPtr)((this._value ^ value) & 0xff))] ^ (this._value >> 8);  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: for (j = b.i + 1; j < b.description.Length; j++) {  	if (b.description [j] == ']')  		break;  	n = ((short)b.description [j]) - ((short)'0');  	if (n >= 0 && n <= 9) {  		if (count == -1)  			count = n;  		else  			count = count * 10 + n;  	}  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: for (j = b.i + 1; j < b.description.Length; j++) {  	if (b.description [j] == ']')  		break;  	n = ((short)b.description [j]) - ((short)'0');  	if (n >= 0 && n <= 9) {  		if (count == -1)  			count = n;  		else  			count = count * 10 + n;  	}  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: if (n >= 0 && n <= 9) {  	if (count == -1)  		count = n;  	else  		count = count * 10 + n;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: if (n >= 0 && n <= 9) {  	if (count == -1)  		count = n;  	else  		count = count * 10 + n;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: if (count == -1)  	count = n;  else  	count = count * 10 + n;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: count = count * 10 + n;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: n = 2;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: n = 2;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: e = Encoding.GetEncoding (12000);  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: n = 4;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: e = Encoding.GetEncoding (12001);  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: n = 4;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: if (b.align == -1)  	b.align = 4;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: b.align = 4;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetInt32 (buffer' idx));  	idx += 4;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetInt32 (buffer' idx));  	idx += 4;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx += 4;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetUInt32 (buffer' idx));  	idx += 4;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetUInt32 (buffer' idx));  	idx += 4;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx += 4;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 2' ref align)) {  	result.Add (conv.GetInt16 (buffer' idx));  	idx += 2;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 2' ref align)) {  	result.Add (conv.GetInt16 (buffer' idx));  	idx += 2;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx += 2;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 2' ref align)) {  	result.Add (conv.GetUInt16 (buffer' idx));  	idx += 2;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 2' ref align)) {  	result.Add (conv.GetUInt16 (buffer' idx));  	idx += 2;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx += 2;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetInt64 (buffer' idx));  	idx += 8;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetInt64 (buffer' idx));  	idx += 8;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx += 8;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetUInt64 (buffer' idx));  	idx += 8;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetUInt64 (buffer' idx));  	idx += 8;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx += 8;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetDouble (buffer' idx));  	idx += 4;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetDouble (buffer' idx));  	idx += 4;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx += 4;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetDouble (buffer' idx));  	idx += 8;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetDouble (buffer' idx));  	idx += 8;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx += 8;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (j = i + 1; j < description.Length; j++) {  	if (description [j] == ']')  		break;  	n = ((short)description [j]) - ((short)'0');  	if (n >= 0 && n <= 9) {  		if (count == -1)  			count = n;  		else  			count = count * 10 + n;  	}  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (j = i + 1; j < description.Length; j++) {  	if (description [j] == ']')  		break;  	n = ((short)description [j]) - ((short)'0');  	if (n >= 0 && n <= 9) {  		if (count == -1)  			count = n;  		else  			count = count * 10 + n;  	}  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (n >= 0 && n <= 9) {  	if (count == -1)  		count = n;  	else  		count = count * 10 + n;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (n >= 0 && n <= 9) {  	if (count == -1)  		count = n;  	else  		count = count * 10 + n;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (count == -1)  	count = n;  else  	count = count * 10 + n;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: count = count * 10 + n;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (align) {  	idx = Align (idx' 4);  	align = false;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx = Align (idx' 4);  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: n = 2;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: n = 2;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: e = Encoding.GetEncoding (12000);  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: n = 4;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: e = Encoding.GetEncoding (12001);  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: n = 4;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (k == buffer.Length)  	idx = k;  else  	idx = k + 2;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx = k + 2;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (; k < buffer.Length; k++) {  	if (k + 3 >= buffer.Length) {  		k = buffer.Length;  		break;  	}  	if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  		break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (; k < buffer.Length; k++) {  	if (k + 3 >= buffer.Length) {  		k = buffer.Length;  		break;  	}  	if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  		break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (; k < buffer.Length; k++) {  	if (k + 3 >= buffer.Length) {  		k = buffer.Length;  		break;  	}  	if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  		break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (k + 3 >= buffer.Length) {  	k = buffer.Length;  	break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  	break;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  	break;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (k == buffer.Length)  	idx = k;  else  	idx = k + 4;  
Magic Number,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx = k + 4;  
Magic Number,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,BitCount,The following statement contains a magic number: for (int i = 0; i < 32; i++) {  	if ((num & 1) != 0) {  		count++;  	}  	num >>= 1;  }  
Magic Number,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: if (tzone.Length <= 4) {  	foreach (var timezone in TimeZoneInfo.GetSystemTimeZones ()) {  		var parts = timezone.Id.Split (new[] {  			' '  		}' StringSplitOptions.RemoveEmptyEntries);  		if (parts.Length == tzone.Length) {  			bool found = true;  			for (int i = 0; i < parts.Length; i++)  				found &= parts [i] [0] == tzone [i];  			if (found)  				return timezone;  		}  	}  }  
Magic Number,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: if (strArray.Length == 1 && strArray [0].Length > 2) {  	hours = int.Parse (strArray [0].Substring (0' 2));  	minutes = int.Parse (strArray [0].Substring (2));  }  else {  	hours = int.Parse (strArray [0]);  	minutes = (strArray.Length <= 1) ? 0 : int.Parse (strArray [1]);  }  
Magic Number,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: if (strArray.Length == 1 && strArray [0].Length > 2) {  	hours = int.Parse (strArray [0].Substring (0' 2));  	minutes = int.Parse (strArray [0].Substring (2));  }  else {  	hours = int.Parse (strArray [0]);  	minutes = (strArray.Length <= 1) ? 0 : int.Parse (strArray [1]);  }  
Magic Number,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: if (strArray.Length == 1 && strArray [0].Length > 2) {  	hours = int.Parse (strArray [0].Substring (0' 2));  	minutes = int.Parse (strArray [0].Substring (2));  }  else {  	hours = int.Parse (strArray [0]);  	minutes = (strArray.Length <= 1) ? 0 : int.Parse (strArray [1]);  }  
Magic Number,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: hours = int.Parse (strArray [0].Substring (0' 2));  
Magic Number,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: minutes = int.Parse (strArray [0].Substring (2));  
Magic Number,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: if (tzone [3] == '-')  	t = -t;  
Magic Number,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,ToOctalString,The following statement contains a magic number: return Convert.ToString (val' 8);  
Magic Number,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,ToHexString,The following statement contains a magic number: return Convert.ToString (val' 16);  
Magic Number,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,GetTotalInFixed,The following statement contains a magic number: if (inf.TotalIn > 0)  	return Convert.ToInt32 (inf.TotalIn) + 4;  else  	return 0;  
Magic Number,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,GetTotalInFixed,The following statement contains a magic number: return Convert.ToInt32 (inf.TotalIn) + 4;  
Magic Number,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,GetRemainingInputFixed,The following statement contains a magic number: if (inf.RemainingInput >= 4)  	return inf.RemainingInput - 4;  else  	return 0;  
Magic Number,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,GetRemainingInputFixed,The following statement contains a magic number: if (inf.RemainingInput >= 4)  	return inf.RemainingInput - 4;  else  	return 0;  
Magic Number,Sharpen,Extensions,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Extensions.cs,GetRemainingInputFixed,The following statement contains a magic number: return inf.RemainingInput - 4;  
Magic Number,Sharpen,FileChannel,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\FileChannel.cs,TransferFrom,The following statement contains a magic number: if (buffer == null)  	buffer = new byte[8092];  
Magic Number,Sharpen,FileChannel,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\FileChannel.cs,TransferFrom,The following statement contains a magic number: buffer = new byte[8092];  
Magic Number,Sharpen,MessageFormat,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\MessageFormat.cs,AddFormatted,The following statement contains a magic number: if (placeholderArgs.Count > 3)  	throw new ArgumentException ("Invalid format pattern: {" + string.Join ("'"' placeholderArgs.ToArray ()) + "}");  
Magic Number,Sharpen,Pattern,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Pattern.cs,Compile,The following statement contains a magic number: if ((flags & 2) != DOTALL) {  	compiled |= RegexOptions.Singleline;  }  
Magic Number,Sharpen,Pattern,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Pattern.cs,Compile,The following statement contains a magic number: if ((flags & 4) != MULTILINE) {  	compiled |= RegexOptions.Multiline;  }  
Magic Number,Sharpen,RandomAccessFile,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\RandomAccessFile.cs,Write,The following statement contains a magic number: stream.Write (BitConverter.GetBytes (value)' 0' 4);  
Magic Number,Sharpen,Runtime,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Runtime.cs,NanoTime,The following statement contains a magic number: return Environment.TickCount * 1000 * 1000;  
Magic Number,Sharpen,Runtime,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\Runtime.cs,NanoTime,The following statement contains a magic number: return Environment.TickCount * 1000 * 1000;  
Magic Number,Sharpen,ByteBuffer,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\ByteBuffer.cs,GetInt,The following statement contains a magic number: CheckGetLimit (4);  
Magic Number,Sharpen,ByteBuffer,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\ByteBuffer.cs,GetInt,The following statement contains a magic number: index += 4;  
Magic Number,Sharpen,ByteBuffer,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\ByteBuffer.cs,GetShort,The following statement contains a magic number: CheckGetLimit (2);  
Magic Number,Sharpen,ByteBuffer,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\ByteBuffer.cs,GetShort,The following statement contains a magic number: index += 2;  
Magic Number,Sharpen,FilePath,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\FilePath.cs,CreateTempFile,The following statement contains a magic number: if (prefix.Length < 3) {  	throw new ArgumentException ("prefix must have at least 3 characters");  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value);  	break;  case 1:  	Time.AddMinutes (value);  	break;  case 2:  	Time.AddSeconds (value);  	break;  case 3:  	Time.AddMilliseconds (value);  	break;  case 5:  	Time.AddYears (value);  	break;  case 6:  	Time.AddMonths (value);  	break;  case 7:  	Time.AddDays (7 * value);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value);  	break;  case 1:  	Time.AddMinutes (value);  	break;  case 2:  	Time.AddSeconds (value);  	break;  case 3:  	Time.AddMilliseconds (value);  	break;  case 5:  	Time.AddYears (value);  	break;  case 6:  	Time.AddMonths (value);  	break;  case 7:  	Time.AddDays (7 * value);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value);  	break;  case 1:  	Time.AddMinutes (value);  	break;  case 2:  	Time.AddSeconds (value);  	break;  case 3:  	Time.AddMilliseconds (value);  	break;  case 5:  	Time.AddYears (value);  	break;  case 6:  	Time.AddMonths (value);  	break;  case 7:  	Time.AddDays (7 * value);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value);  	break;  case 1:  	Time.AddMinutes (value);  	break;  case 2:  	Time.AddSeconds (value);  	break;  case 3:  	Time.AddMilliseconds (value);  	break;  case 5:  	Time.AddYears (value);  	break;  case 6:  	Time.AddMonths (value);  	break;  case 7:  	Time.AddDays (7 * value);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value);  	break;  case 1:  	Time.AddMinutes (value);  	break;  case 2:  	Time.AddSeconds (value);  	break;  case 3:  	Time.AddMilliseconds (value);  	break;  case 5:  	Time.AddYears (value);  	break;  case 6:  	Time.AddMonths (value);  	break;  case 7:  	Time.AddDays (7 * value);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value);  	break;  case 1:  	Time.AddMinutes (value);  	break;  case 2:  	Time.AddSeconds (value);  	break;  case 3:  	Time.AddMilliseconds (value);  	break;  case 5:  	Time.AddYears (value);  	break;  case 6:  	Time.AddMonths (value);  	break;  case 7:  	Time.AddDays (7 * value);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: Time.AddDays (7 * value);  
Magic Number,Sharpen,JavaCalendar,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\JavaCalendar.cs,Set,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value - Time.Hour);  	break;  case 1:  	Time.AddMinutes (value - Time.Minute);  	break;  case 2:  	Time.AddSeconds (value - Time.Second);  	break;  case 3:  	Time.AddMilliseconds (value - Time.Millisecond);  	break;  case 5:  	Time.AddYears (value - Time.Year);  	break;  case 6:  	Time.AddMonths (value - Time.Month);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\JavaCalendar.cs,Set,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value - Time.Hour);  	break;  case 1:  	Time.AddMinutes (value - Time.Minute);  	break;  case 2:  	Time.AddSeconds (value - Time.Second);  	break;  case 3:  	Time.AddMilliseconds (value - Time.Millisecond);  	break;  case 5:  	Time.AddYears (value - Time.Year);  	break;  case 6:  	Time.AddMonths (value - Time.Month);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\JavaCalendar.cs,Set,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value - Time.Hour);  	break;  case 1:  	Time.AddMinutes (value - Time.Minute);  	break;  case 2:  	Time.AddSeconds (value - Time.Second);  	break;  case 3:  	Time.AddMilliseconds (value - Time.Millisecond);  	break;  case 5:  	Time.AddYears (value - Time.Year);  	break;  case 6:  	Time.AddMonths (value - Time.Month);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\JavaCalendar.cs,Set,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value - Time.Hour);  	break;  case 1:  	Time.AddMinutes (value - Time.Minute);  	break;  case 2:  	Time.AddSeconds (value - Time.Second);  	break;  case 3:  	Time.AddMilliseconds (value - Time.Millisecond);  	break;  case 5:  	Time.AddYears (value - Time.Year);  	break;  case 6:  	Time.AddMonths (value - Time.Month);  	break;  default:  	throw new NotSupportedException ();  }  
Missing Default,Sharpen,DataConverter,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\DataConverter.cs,Unpack,The following switch statement is missing a default case: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Missing Default,Sharpen,MessageDigest,C:\repos\hazzik_Sharpen.Runtime\Sharpen\Sharpen\MessageDigest.cs,GetInstance,The following switch statement is missing a default case: switch (algorithm.ToLower ()) {  case "sha-1":  	return new MessageDigest<SHA1Managed> ();  case "md5":  	return new MessageDigest<MD5CryptoServiceProvider> ();  }  
