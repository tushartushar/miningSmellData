Implementation smell,Namespace,Class,File,Method,Description
Long Method,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The method has 182 lines of code.
Complex Method,JRayXLib.Math.intersections,RayCube,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\RayCube.cs,GetDistanceToBorderPlane,Cyclomatic complexity of the method is 13
Complex Method,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,Cyclomatic complexity of the method is 78
Complex Method,JRayXLib.Struct,Octree,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree.cs,BuildTree,Cyclomatic complexity of the method is 9
Complex Method,JRayXLib.Model,TriangleMeshModel,C:\repos\FrankyBoy_JRayX\JRayXLib\Model\TriangleMeshModel.cs,TriangleMeshModel,Cyclomatic complexity of the method is 12
Long Parameter List,JRayXLib.Math.intersections,AreaCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\AreaCone.cs,IsAreaIntersectingCone,The method has 7 parameters.
Long Parameter List,JRayXLib.Math.intersections,CubeCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\CubeCone.cs,IsCubeEnclosingCone,The method has 6 parameters.
Long Parameter List,JRayXLib.Math.intersections,CubeCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\CubeCone.cs,IsCubeIntersectingCone,The method has 6 parameters.
Long Parameter List,JRayXLib.Math.intersections,PlaneCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\PlaneCone.cs,IsPlaneIntersectingCone,The method has 6 parameters.
Long Parameter List,JRayXLib.Math.intersections,RayCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\RayCone.cs,GetRayConeIntersectionDistance,The method has 6 parameters.
Long Parameter List,JRayXLib.Math.intersections,RayTriangle,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\RayTriangle.cs,GetHitPointRayTriangleDistance,The method has 5 parameters.
Long Parameter List,JRayXLib.Scene,Camera,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Camera.cs,Camera,The method has 6 parameters.
Long Parameter List,JRayXLib.Scene,Camera,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Camera.cs,CreateCamera,The method has 5 parameters.
Long Parameter List,JRayXLib.Scene,OctreeScene,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\OctreeScene.cs,UpdateObjects,The method has 8 parameters.
Long Parameter List,JRayXLib.Shapes,Sphere,C:\repos\FrankyBoy_JRayX\JRayXLib\Shapes\Sphere.cs,Sphere,The method has 5 parameters.
Long Parameter List,JRayXLib.Shapes,TexturedSphere,C:\repos\FrankyBoy_JRayX\JRayXLib\Shapes\TexturedSphere.cs,TexturedSphere,The method has 6 parameters.
Long Parameter List,JRayXLib.Shapes,TexturedSphere,C:\repos\FrankyBoy_JRayX\JRayXLib\Shapes\TexturedSphere.cs,TexturedSphere,The method has 6 parameters.
Long Parameter List,JRayXLib.Shapes,TexturedTriangle,C:\repos\FrankyBoy_JRayX\JRayXLib\Shapes\TexturedTriangle.cs,TexturedTriangle,The method has 7 parameters.
Long Parameter List,JRayXLib.Struct,Octree2,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree2.cs,GetFirstCollisionInternal,The method has 5 parameters.
Long Parameter List,JRayXLib.Math,Vect3Extensions,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Vect3Extensions.cs,InterpolateTriangle,The method has 7 parameters.
Long Statement,JRayXLib.Math.intersections,AreaCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\AreaCone.cs,IsAreaIntersectingCone,The length of the statement  "		return System.Math.Abs (p.X - planePoint.X) < areaWidthHalf * 2 && System.Math.Abs (p.Y - planePoint.Y) < areaWidthHalf * 2 && System.Math.Abs (p.Z - planePoint.Z) < areaWidthHalf * 2; " is 184.
Long Statement,JRayXLib.Math.intersections,CubeCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\CubeCone.cs,IsCubeEnclosingCone,The length of the statement  "	return PointCube.Encloses (cubeCenter' cubeWidthHalf' conePosition) && !IsCubeIntersectingCone (cubeCenter' cubeWidthHalf' conePosition' coneAxis' coneAxisLength' coneCosPhi); " is 175.
Long Statement,JRayXLib.Math.intersections,CubeCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\CubeCone.cs,IsCubeIntersectingCone,The length of the statement  "	if (AreaCone.IsAreaIntersectingCone (planeNormal' planePoint' cubeWidthHalf' conePosition' coneAxis' coneAxisLength' coneCosPhi)) " is 129.
Long Statement,JRayXLib.Math.intersections,CubeCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\CubeCone.cs,IsCubeIntersectingCone,The length of the statement  "	if (AreaCone.IsAreaIntersectingCone (planeNormal' planePoint' cubeWidthHalf' conePosition' coneAxis' coneAxisLength' coneCosPhi)) " is 129.
Long Statement,JRayXLib.Math.intersections,CubeCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\CubeCone.cs,IsCubeIntersectingCone,The length of the statement  "	if (AreaCone.IsAreaIntersectingCone (planeNormal' planePoint' cubeWidthHalf' conePosition' coneAxis' coneAxisLength' coneCosPhi)) " is 129.
Long Statement,JRayXLib.Math.intersections,CubeCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\CubeCone.cs,IsCubeIntersectingCone,The length of the statement  "	if (AreaCone.IsAreaIntersectingCone (planeNormal' planePoint' cubeWidthHalf' conePosition' coneAxis' coneAxisLength' coneCosPhi)) " is 129.
Long Statement,JRayXLib.Math.intersections,CubeCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\CubeCone.cs,IsCubeIntersectingCone,The length of the statement  "	if (AreaCone.IsAreaIntersectingCone (planeNormal' planePoint' cubeWidthHalf' conePosition' coneAxis' coneAxisLength' coneCosPhi)) " is 129.
Long Statement,JRayXLib.Math.intersections,CubeCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\CubeCone.cs,IsCubeIntersectingCone,The length of the statement  "	if (AreaCone.IsAreaIntersectingCone (planeNormal' planePoint' cubeWidthHalf' conePosition' coneAxis' coneAxisLength' coneCosPhi)) " is 129.
Long Statement,JRayXLib.Math.intersections,CubeSphere,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\CubeSphere.cs,IsSphereEnclosedByCube,The length of the statement  "	return System.Math.Abs (cCenter.X - sCenter.X) < cWidthHalf - sRadius && System.Math.Abs (cCenter.Y - sCenter.Y) < cWidthHalf - sRadius && System.Math.Abs (cCenter.Z - sCenter.Z) < cWidthHalf - sRadius; " is 202.
Long Statement,JRayXLib.Math.intersections,CubeSphere,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\CubeSphere.cs,IsSphereIntersectingCube,The length of the statement  "	return System.Math.Abs (cCenter.X - sphere.Position.X) < cWidthHalf + sphere.Radius && System.Math.Abs (cCenter.Y - sphere.Position.Y) < cWidthHalf + sphere.Radius && System.Math.Abs (cCenter.Z - sphere.Position.Z) < cWidthHalf + sphere.Radius; " is 244.
Long Statement,JRayXLib.Math.intersections,PointCube,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\PointCube.cs,Encloses,The length of the statement  "	return System.Math.Abs (cubeCenter.X - point.X) < cubeWidthHalf && System.Math.Abs (cubeCenter.Y - point.Y) < cubeWidthHalf && System.Math.Abs (cubeCenter.Z - point.Z) < cubeWidthHalf; " is 184.
Long Statement,JRayXLib.Shapes,Matrix4,C:\repos\FrankyBoy_JRayX\JRayXLib\Shapes\Matrix4.cs,Equals,The length of the statement  "	return System.Math.Abs (A0 - other.A0) < Constants.EPS && System.Math.Abs (A1 - other.A1) < Constants.EPS && System.Math.Abs (A2 - other.A2) < Constants.EPS && System.Math.Abs (A3 - other.A3) < Constants.EPS && System.Math.Abs (B0 - other.B0) < Constants.EPS && System.Math.Abs (B1 - other.B1) < Constants.EPS && System.Math.Abs (B2 - other.B2) < Constants.EPS && System.Math.Abs (B3 - other.B3) < Constants.EPS && System.Math.Abs (C0 - other.C0) < Constants.EPS && System.Math.Abs (C1 - other.C1) < Constants.EPS && System.Math.Abs (C2 - other.C2) < Constants.EPS && System.Math.Abs (C3 - other.C3) < Constants.EPS && System.Math.Abs (D0 - other.D0) < Constants.EPS && System.Math.Abs (D1 - other.D1) < Constants.EPS && System.Math.Abs (D2 - other.D2) < Constants.EPS && System.Math.Abs (D3 - other.D3) < Constants.EPS; " is 820.
Long Statement,JRayXLib.Shapes,Texture,C:\repos\FrankyBoy_JRayX\JRayXLib\Shapes\Texture.cs,ToBitmap,The length of the statement  "			System.Drawing.Color sysColor = System.Drawing.Color.FromArgb (_data [i' j].A' _data [i' j].R' _data [i' j].G' _data [i' j].B); " is 127.
Long Statement,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The length of the statement  "		if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) { " is 128.
Long Statement,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The length of the statement  "			if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s)) " is 225.
Long Statement,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The length of the statement  "		if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) { " is 128.
Long Statement,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The length of the statement  "			bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s); " is 700.
Long Statement,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The length of the statement  "			bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s); " is 700.
Long Statement,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The length of the statement  "		if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) { " is 135.
Long Statement,JRayXLib.Struct,Octree,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree.cs,BuildTree,The length of the statement  "	Log.Debug (string.Format (" - contains {0} of {1} elements ({2:0.##}%)"' t.GetRoot ().GetSize ()' objects.Count' t.GetRoot ().GetSize () / (float)objects.Count * 100)); " is 168.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "	double detA = m.A0 * (m.B1 * m.C2 * m.D3 + m.B2 * m.C3 * m.D1 + m.B3 * m.C1 * m.D2) + m.A1 * (m.B0 * m.C3 * m.D2 + m.B2 * m.C0 * m.D3 + m.B3 * m.C2 * m.D0) + m.A2 * (m.B0 * m.C1 * m.D3 + m.B1 * m.C3 * m.D0 + m.B3 * m.C0 * m.D1) + m.A3 * (m.B0 * m.C2 * m.D1 + m.B1 * m.C0 * m.D2 + m.B2 * m.C1 * m.D0) - m.A0 * (m.B1 * m.C3 * m.D2 + m.B2 * m.C1 * m.D3 + m.B3 * m.C2 * m.D1) - m.A1 * (m.B0 * m.C2 * m.D3 + m.B2 * m.C3 * m.D0 + m.B3 * m.C0 * m.D2) - m.A2 * (m.B0 * m.C3 * m.D1 + m.B1 * m.C0 * m.D3 + m.B3 * m.C1 * m.D0) - m.A3 * (m.B0 * m.C1 * m.D2 + m.B1 * m.C2 * m.D0 + m.B2 * m.C0 * m.D1); " is 588.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "		A0 = (m.B1 * m.C2 * m.D3 + m.B2 * m.C3 * m.D1 + m.B3 * m.C1 * m.D2 - m.B1 * m.C3 * m.D2 - m.B2 * m.C1 * m.D3 - m.B3 * m.C2 * m.D1) * detA' " is 138.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "		A1 = (m.A1 * m.C3 * m.D2 + m.A2 * m.C1 * m.D3 + m.A3 * m.C2 * m.D1 - m.A1 * m.C2 * m.D3 - m.A2 * m.C3 * m.D1 - m.A3 * m.C1 * m.D2) * detA' " is 138.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "		A2 = (m.A1 * m.B2 * m.D3 + m.A2 * m.B3 * m.D1 + m.A3 * m.B1 * m.D2 - m.A1 * m.B3 * m.D2 - m.A2 * m.B1 * m.D3 - m.A3 * m.B2 * m.D1) * detA' " is 138.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "		A3 = (m.A1 * m.B3 * m.C2 + m.A2 * m.B1 * m.C3 + m.A3 * m.B2 * m.C1 - m.A1 * m.B2 * m.C3 - m.A2 * m.B3 * m.C1 - m.A3 * m.B1 * m.C2) * detA' " is 138.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "		B0 = (m.B0 * m.C3 * m.D2 + m.B2 * m.C0 * m.D3 + m.B3 * m.C2 * m.D0 - m.B0 * m.C2 * m.D3 - m.B2 * m.C3 * m.D0 - m.B3 * m.C0 * m.D2) * detA' " is 138.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "		B1 = (m.A0 * m.C2 * m.D3 + m.A2 * m.C3 * m.D0 + m.A3 * m.C0 * m.D2 - m.A0 * m.C3 * m.D2 - m.A2 * m.C0 * m.D3 - m.A3 * m.C2 * m.D0) * detA' " is 138.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "		B2 = (m.A0 * m.B3 * m.D2 + m.A2 * m.B0 * m.D3 + m.A3 * m.B2 * m.D0 - m.A0 * m.B2 * m.D3 - m.A2 * m.B3 * m.D0 - m.A3 * m.B0 * m.D2) * detA' " is 138.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "		B3 = (m.A0 * m.B2 * m.C3 + m.A2 * m.B3 * m.C0 + m.A3 * m.B0 * m.C2 - m.A0 * m.B3 * m.C2 - m.A2 * m.B0 * m.C3 - m.A3 * m.B2 * m.C0) * detA' " is 138.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "		C0 = (m.B0 * m.C1 * m.D3 + m.B1 * m.C3 * m.D0 + m.B3 * m.C0 * m.D1 - m.B0 * m.C3 * m.D1 - m.B1 * m.C0 * m.D3 - m.B3 * m.C1 * m.D0) * detA' " is 138.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "		C1 = (m.A0 * m.C3 * m.D1 + m.A1 * m.C0 * m.D3 + m.A3 * m.C1 * m.D0 - m.A0 * m.C1 * m.D3 - m.A1 * m.C3 * m.D0 - m.A3 * m.C0 * m.D1) * detA' " is 138.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "		C2 = (m.A0 * m.B1 * m.D3 + m.A1 * m.B3 * m.D0 + m.A3 * m.B0 * m.D1 - m.A0 * m.B3 * m.D1 - m.A1 * m.B0 * m.D3 - m.A3 * m.B1 * m.D0) * detA' " is 138.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "		C3 = (m.A0 * m.B3 * m.C1 + m.A1 * m.B0 * m.C3 + m.A3 * m.B1 * m.C0 - m.A0 * m.B1 * m.C3 - m.A1 * m.B3 * m.C0 - m.A3 * m.B0 * m.C1) * detA' " is 138.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "		D0 = (m.B0 * m.C2 * m.D1 + m.B1 * m.C0 * m.D2 + m.B2 * m.C1 * m.D0 - m.B0 * m.C1 * m.D2 - m.B1 * m.C2 * m.D0 - m.B2 * m.C0 * m.D1) * detA' " is 138.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "		D1 = (m.A0 * m.C1 * m.D2 + m.A1 * m.C2 * m.D0 + m.A2 * m.C0 * m.D1 - m.A0 * m.C2 * m.D1 - m.A1 * m.C0 * m.D2 - m.A2 * m.C1 * m.D0) * detA' " is 138.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "		D2 = (m.A0 * m.B2 * m.D1 + m.A1 * m.B0 * m.D2 + m.A2 * m.B1 * m.D0 - m.A0 * m.B1 * m.D2 - m.A1 * m.B2 * m.D0 - m.A2 * m.B0 * m.D1) * detA' " is 138.
Long Statement,JRayXLib.Math,Matrix,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Matrix.cs,Invert,The length of the statement  "		D3 = (m.A0 * m.B1 * m.C2 + m.A1 * m.B2 * m.C0 + m.A2 * m.B0 * m.C1 - m.A0 * m.B2 * m.C1 - m.A1 * m.B0 * m.C2 - m.A2 * m.B1 * m.C0) * detA " is 137.
Long Statement,JRayXLib.Math,Triangle,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Triangle.cs,GetCircumScribedCircleCenter,The length of the statement  "	if (System.Math.Abs (dac.X) > Constants.EPS && System.Math.Abs (dac.Y) > Constants.EPS && System.Math.Abs (dab.X / dac.X - dab.Y / dac.Y) > Constants.EPS) { " is 156.
Long Statement,JRayXLib.Math,Triangle,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Triangle.cs,GetCircumScribedCircleCenter,The length of the statement  "	if (System.Math.Abs (dac.X) > Constants.EPS && System.Math.Abs (dac.Z) > Constants.EPS && System.Math.Abs (dab.Z / dac.Z - dab.X / dac.X) > Constants.EPS) { " is 156.
Long Statement,JRayXLib.Math,Triangle,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Triangle.cs,GetCircumScribedCircleCenter,The length of the statement  "	if (System.Math.Abs (dac.Y) > Constants.EPS && System.Math.Abs (dac.Z) > Constants.EPS && System.Math.Abs (dab.Y / dac.Y - dab.Z / dac.Z) > Constants.EPS) { " is 156.
Long Statement,JRayXLib.Math,Triangle,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Triangle.cs,GetCircumScribedCircleCenter,The length of the statement  "	if (System.Math.Abs (dab.Y) > Constants.EPS && System.Math.Abs (dab.X) > Constants.EPS && System.Math.Abs (dac.X / dab.X - dac.Y / dab.Y) > Constants.EPS) { " is 156.
Long Statement,JRayXLib.Math,Triangle,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Triangle.cs,GetCircumScribedCircleCenter,The length of the statement  "	if (System.Math.Abs (dab.Z) > Constants.EPS && System.Math.Abs (dab.X) > Constants.EPS && System.Math.Abs (dac.Z / dab.Z - dac.X / dab.X) > Constants.EPS) { " is 156.
Long Statement,JRayXLib.Math,Triangle,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Triangle.cs,GetCircumScribedCircleCenter,The length of the statement  "	if (System.Math.Abs (dab.Z) > Constants.EPS && System.Math.Abs (dab.Y) > Constants.EPS && System.Math.Abs (dac.Y / dab.Y - dac.Z / dab.Z) > Constants.EPS) { " is 156.
Complex Conditional,JRayXLib.Shapes,Texture,C:\repos\FrankyBoy_JRayX\JRayXLib\Shapes\Texture.cs,GetColorAt,The conditional expression  "tx < -1 || tx > 2 || ty < -1 || ty > 2"  is complex.
Complex Conditional,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The conditional expression  "_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s)"  is complex.
Magic Number,JRayXLib.Math.intersections,AreaCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\AreaCone.cs,IsAreaIntersectingCone,The following statement contains a magic number: if (d < len) {  	//check if Hitpoint is in the +/-width/2 - area of the plane  	p = conePosition + p * d;  	return System.Math.Abs (p.X - planePoint.X) < areaWidthHalf * 2 && System.Math.Abs (p.Y - planePoint.Y) < areaWidthHalf * 2 && System.Math.Abs (p.Z - planePoint.Z) < areaWidthHalf * 2;  }  
Magic Number,JRayXLib.Math.intersections,AreaCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\AreaCone.cs,IsAreaIntersectingCone,The following statement contains a magic number: if (d < len) {  	//check if Hitpoint is in the +/-width/2 - area of the plane  	p = conePosition + p * d;  	return System.Math.Abs (p.X - planePoint.X) < areaWidthHalf * 2 && System.Math.Abs (p.Y - planePoint.Y) < areaWidthHalf * 2 && System.Math.Abs (p.Z - planePoint.Z) < areaWidthHalf * 2;  }  
Magic Number,JRayXLib.Math.intersections,AreaCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\AreaCone.cs,IsAreaIntersectingCone,The following statement contains a magic number: if (d < len) {  	//check if Hitpoint is in the +/-width/2 - area of the plane  	p = conePosition + p * d;  	return System.Math.Abs (p.X - planePoint.X) < areaWidthHalf * 2 && System.Math.Abs (p.Y - planePoint.Y) < areaWidthHalf * 2 && System.Math.Abs (p.Z - planePoint.Z) < areaWidthHalf * 2;  }  
Magic Number,JRayXLib.Math.intersections,AreaCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\AreaCone.cs,IsAreaIntersectingCone,The following statement contains a magic number: return System.Math.Abs (p.X - planePoint.X) < areaWidthHalf * 2 && System.Math.Abs (p.Y - planePoint.Y) < areaWidthHalf * 2 && System.Math.Abs (p.Z - planePoint.Z) < areaWidthHalf * 2;  
Magic Number,JRayXLib.Math.intersections,AreaCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\AreaCone.cs,IsAreaIntersectingCone,The following statement contains a magic number: return System.Math.Abs (p.X - planePoint.X) < areaWidthHalf * 2 && System.Math.Abs (p.Y - planePoint.Y) < areaWidthHalf * 2 && System.Math.Abs (p.Z - planePoint.Z) < areaWidthHalf * 2;  
Magic Number,JRayXLib.Math.intersections,AreaCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\AreaCone.cs,IsAreaIntersectingCone,The following statement contains a magic number: return System.Math.Abs (p.X - planePoint.X) < areaWidthHalf * 2 && System.Math.Abs (p.Y - planePoint.Y) < areaWidthHalf * 2 && System.Math.Abs (p.Z - planePoint.Z) < areaWidthHalf * 2;  
Magic Number,JRayXLib.Math.intersections,CubeCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\CubeCone.cs,IsCubeIntersectingCone,The following statement contains a magic number: planePoint.X += 2 * cubeWidthHalf;  
Magic Number,JRayXLib.Math.intersections,CubeCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\CubeCone.cs,IsCubeIntersectingCone,The following statement contains a magic number: planePoint.Y += 2 * cubeWidthHalf;  
Magic Number,JRayXLib.Math.intersections,CubeCone,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\intersections\CubeCone.cs,IsCubeIntersectingCone,The following statement contains a magic number: planePoint.Z += 2 * cubeWidthHalf;  
Magic Number,JRayXLib.Colors,ColorExtensions,C:\repos\FrankyBoy_JRayX\JRayXLib\Colors\Color.cs,MixSurfaceLight,The following statement contains a magic number: return new Color {  	A = surfaceColor.A'  	R = (byte)(surfaceColor.R * lightColor.R / 256)'  	G = (byte)(surfaceColor.G * lightColor.G / 256)'  	B = (byte)(surfaceColor.B * lightColor.B / 256)  };  
Magic Number,JRayXLib.Colors,ColorExtensions,C:\repos\FrankyBoy_JRayX\JRayXLib\Colors\Color.cs,MixSurfaceLight,The following statement contains a magic number: return new Color {  	A = surfaceColor.A'  	R = (byte)(surfaceColor.R * lightColor.R / 256)'  	G = (byte)(surfaceColor.G * lightColor.G / 256)'  	B = (byte)(surfaceColor.B * lightColor.B / 256)  };  
Magic Number,JRayXLib.Colors,ColorExtensions,C:\repos\FrankyBoy_JRayX\JRayXLib\Colors\Color.cs,MixSurfaceLight,The following statement contains a magic number: return new Color {  	A = surfaceColor.A'  	R = (byte)(surfaceColor.R * lightColor.R / 256)'  	G = (byte)(surfaceColor.G * lightColor.G / 256)'  	B = (byte)(surfaceColor.B * lightColor.B / 256)  };  
Magic Number,JRayXLib.Colors,WideColorExtensions,C:\repos\FrankyBoy_JRayX\JRayXLib\Colors\WideColor.cs,MixSurfaceLight,The following statement contains a magic number: return new WideColor {  	A = surfaceColor.A'  	R = (ushort)(surfaceColor.R * lightColor.R / 256)'  	G = (ushort)(surfaceColor.G * lightColor.G / 256)'  	B = (ushort)(surfaceColor.B * lightColor.B / 256)  };  
Magic Number,JRayXLib.Colors,WideColorExtensions,C:\repos\FrankyBoy_JRayX\JRayXLib\Colors\WideColor.cs,MixSurfaceLight,The following statement contains a magic number: return new WideColor {  	A = surfaceColor.A'  	R = (ushort)(surfaceColor.R * lightColor.R / 256)'  	G = (ushort)(surfaceColor.G * lightColor.G / 256)'  	B = (ushort)(surfaceColor.B * lightColor.B / 256)  };  
Magic Number,JRayXLib.Colors,WideColorExtensions,C:\repos\FrankyBoy_JRayX\JRayXLib\Colors\WideColor.cs,MixSurfaceLight,The following statement contains a magic number: return new WideColor {  	A = surfaceColor.A'  	R = (ushort)(surfaceColor.R * lightColor.R / 256)'  	G = (ushort)(surfaceColor.G * lightColor.G / 256)'  	B = (ushort)(surfaceColor.B * lightColor.B / 256)  };  
Magic Number,JRayXLib,Renderer,C:\repos\FrankyBoy_JRayX\JRayXLib\Renderer.cs,Renderer,The following statement contains a magic number: SplitMultiplier = 4;  
Magic Number,JRayXLib,Renderer,C:\repos\FrankyBoy_JRayX\JRayXLib\Renderer.cs,RenderImage,The following statement contains a magic number: try {  	if (_lbuf == null || _widthPx != image.Width || _heightPx != image.Height) {  		_lbuf = new WideColor[image.Height' image.Width];  		_widthPx = image.Width;  		_heightPx = image.Height;  		_scene.Camera.SetScreenDimensions (_widthPx' _heightPx);  	}  	int max = ExecuteTasks ();  	double scale = 255.0 / max * BrigthnessScale;  	for (int i = 0; i < _heightPx; i++) {  		for (int j = 0; j < _widthPx; j++) {  			WideColor color = _lbuf [i' j];  			image [i' j] = (color * scale).To8Bit ();  		}  	}  }  catch (Exception e) {  	Log.Info ("Exception in renderImage:");  	Log.Info (e);  	Shutdown = true;  }  
Magic Number,JRayXLib.Scene,Camera,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Camera.cs,CreateCamera,The following statement contains a magic number: temp1 = temp1 / 2;  
Magic Number,JRayXLib.Scene,Camera,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Camera.cs,CreateCamera,The following statement contains a magic number: temp1 = temp1 / 2;  
Magic Number,JRayXLib.Scene,Camera,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Camera.cs,SetScreenDimensions,The following statement contains a magic number: ViewPaneWidthVector /= 2;  
Magic Number,JRayXLib.Scene,Camera,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Camera.cs,SetScreenDimensions,The following statement contains a magic number: ViewPaneWidthVector *= 2;  
Magic Number,JRayXLib.Scene,Scene,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Scene.cs,Scene,The following statement contains a magic number: AmbientLightDirection = new Vect3 {  	X = 0'  	Y = -1'  	Z = .5  }.Normalize ();  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,BinarySTLLoader,The following statement contains a magic number: if (cam != null)  	_cam = cam;  else {  	const double camheight = 50;  	_cam = new Camera (new Vect3 {  		Y = camheight * 2'  		Z = camheight  	}' new Vect3 {  		Y = camheight * 2 - 1'  		Z = camheight - 1  	}' new Vect3 {  		Y = Constants.InvSqurtTwo'  		Z = -Constants.InvSqurtTwo  	}' 1' 1' 1);  }  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,BinarySTLLoader,The following statement contains a magic number: if (cam != null)  	_cam = cam;  else {  	const double camheight = 50;  	_cam = new Camera (new Vect3 {  		Y = camheight * 2'  		Z = camheight  	}' new Vect3 {  		Y = camheight * 2 - 1'  		Z = camheight - 1  	}' new Vect3 {  		Y = Constants.InvSqurtTwo'  		Z = -Constants.InvSqurtTwo  	}' 1' 1' 1);  }  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,BinarySTLLoader,The following statement contains a magic number: if (cam != null)  	_cam = cam;  else {  	const double camheight = 50;  	_cam = new Camera (new Vect3 {  		Y = camheight * 2'  		Z = camheight  	}' new Vect3 {  		Y = camheight * 2 - 1'  		Z = camheight - 1  	}' new Vect3 {  		Y = Constants.InvSqurtTwo'  		Z = -Constants.InvSqurtTwo  	}' 1' 1' 1);  }  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,BinarySTLLoader,The following statement contains a magic number: _cam = new Camera (new Vect3 {  	Y = camheight * 2'  	Z = camheight  }' new Vect3 {  	Y = camheight * 2 - 1'  	Z = camheight - 1  }' new Vect3 {  	Y = Constants.InvSqurtTwo'  	Z = -Constants.InvSqurtTwo  }' 1' 1' 1);  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,BinarySTLLoader,The following statement contains a magic number: _cam = new Camera (new Vect3 {  	Y = camheight * 2'  	Z = camheight  }' new Vect3 {  	Y = camheight * 2 - 1'  	Z = camheight - 1  }' new Vect3 {  	Y = Constants.InvSqurtTwo'  	Z = -Constants.InvSqurtTwo  }' 1' 1' 1);  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,LoadScene,The following statement contains a magic number: for (int i = -nx; i <= nx; i++)  	for (int j = -ny; j <= ny; j++)  		objects.Add (new ModelInstance (new Vect3 {  			X = i * 15 + (j % 2) * 7'  			Z = (j + 4) * -15  		}' model));  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,LoadScene,The following statement contains a magic number: for (int i = -nx; i <= nx; i++)  	for (int j = -ny; j <= ny; j++)  		objects.Add (new ModelInstance (new Vect3 {  			X = i * 15 + (j % 2) * 7'  			Z = (j + 4) * -15  		}' model));  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,LoadScene,The following statement contains a magic number: for (int i = -nx; i <= nx; i++)  	for (int j = -ny; j <= ny; j++)  		objects.Add (new ModelInstance (new Vect3 {  			X = i * 15 + (j % 2) * 7'  			Z = (j + 4) * -15  		}' model));  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,LoadScene,The following statement contains a magic number: for (int i = -nx; i <= nx; i++)  	for (int j = -ny; j <= ny; j++)  		objects.Add (new ModelInstance (new Vect3 {  			X = i * 15 + (j % 2) * 7'  			Z = (j + 4) * -15  		}' model));  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,LoadScene,The following statement contains a magic number: for (int i = -nx; i <= nx; i++)  	for (int j = -ny; j <= ny; j++)  		objects.Add (new ModelInstance (new Vect3 {  			X = i * 15 + (j % 2) * 7'  			Z = (j + 4) * -15  		}' model));  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,LoadScene,The following statement contains a magic number: for (int j = -ny; j <= ny; j++)  	objects.Add (new ModelInstance (new Vect3 {  		X = i * 15 + (j % 2) * 7'  		Z = (j + 4) * -15  	}' model));  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,LoadScene,The following statement contains a magic number: for (int j = -ny; j <= ny; j++)  	objects.Add (new ModelInstance (new Vect3 {  		X = i * 15 + (j % 2) * 7'  		Z = (j + 4) * -15  	}' model));  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,LoadScene,The following statement contains a magic number: for (int j = -ny; j <= ny; j++)  	objects.Add (new ModelInstance (new Vect3 {  		X = i * 15 + (j % 2) * 7'  		Z = (j + 4) * -15  	}' model));  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,LoadScene,The following statement contains a magic number: for (int j = -ny; j <= ny; j++)  	objects.Add (new ModelInstance (new Vect3 {  		X = i * 15 + (j % 2) * 7'  		Z = (j + 4) * -15  	}' model));  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,LoadScene,The following statement contains a magic number: for (int j = -ny; j <= ny; j++)  	objects.Add (new ModelInstance (new Vect3 {  		X = i * 15 + (j % 2) * 7'  		Z = (j + 4) * -15  	}' model));  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,LoadScene,The following statement contains a magic number: objects.Add (new ModelInstance (new Vect3 {  	X = i * 15 + (j % 2) * 7'  	Z = (j + 4) * -15  }' model));  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,LoadScene,The following statement contains a magic number: objects.Add (new ModelInstance (new Vect3 {  	X = i * 15 + (j % 2) * 7'  	Z = (j + 4) * -15  }' model));  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,LoadScene,The following statement contains a magic number: objects.Add (new ModelInstance (new Vect3 {  	X = i * 15 + (j % 2) * 7'  	Z = (j + 4) * -15  }' model));  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,LoadScene,The following statement contains a magic number: objects.Add (new ModelInstance (new Vect3 {  	X = i * 15 + (j % 2) * 7'  	Z = (j + 4) * -15  }' model));  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,LoadScene,The following statement contains a magic number: objects.Add (new ModelInstance (new Vect3 {  	X = i * 15 + (j % 2) * 7'  	Z = (j + 4) * -15  }' model));  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,Parse,The following statement contains a magic number: using (var reader = new BinaryReader (new FileStream (f' FileMode.Open' FileAccess.Read))) {  	reader.ReadBytes (80);  	// skipping header  	int triangleCount = reader.ReadInt32 ();  	var triangleEdgeData = new List<I3DObject> (triangleCount);  	for (int i = 0; i < triangleCount; i++) {  		triangleEdgeData [i] = new MinimalTriangle (new Vect3 {  			X = reader.ReadSingle ()'  			Y = reader.ReadSingle ()'  			Z = reader.ReadSingle ()  		}' new Vect3 {  			X = reader.ReadSingle ()'  			Y = reader.ReadSingle ()'  			Z = reader.ReadSingle ()  		}' new Vect3 {  			X = reader.ReadSingle ()'  			Y = reader.ReadSingle ()'  			Z = reader.ReadSingle ()  		}' new Vect3 {  			X = reader.ReadSingle ()'  			Y = reader.ReadSingle ()'  			Z = reader.ReadSingle ()  		});  		reader.ReadUInt16 ();  		// skip the 2 attribute bytes  	}  	return new TriangleMeshModel (triangleEdgeData);  }  
Magic Number,JRayXLib.Scene.Loaders,BinarySTLLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\BinarySTLLoader.cs,Parse,The following statement contains a magic number: reader.ReadBytes (80);  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,LoadScene,The following statement contains a magic number: for (double x = 1; x < camheight * 3; x += h)  	for (double z = -camheight; z < camheight; z += h)  		AddTree (x + Rd.NextDouble () * dist - dist / 2' -2' z + Rd.NextDouble () * dist - dist / 2' objects);  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,LoadScene,The following statement contains a magic number: for (double x = 1; x < camheight * 3; x += h)  	for (double z = -camheight; z < camheight; z += h)  		AddTree (x + Rd.NextDouble () * dist - dist / 2' -2' z + Rd.NextDouble () * dist - dist / 2' objects);  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,LoadScene,The following statement contains a magic number: for (double x = 1; x < camheight * 3; x += h)  	for (double z = -camheight; z < camheight; z += h)  		AddTree (x + Rd.NextDouble () * dist - dist / 2' -2' z + Rd.NextDouble () * dist - dist / 2' objects);  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,LoadScene,The following statement contains a magic number: for (double x = 1; x < camheight * 3; x += h)  	for (double z = -camheight; z < camheight; z += h)  		AddTree (x + Rd.NextDouble () * dist - dist / 2' -2' z + Rd.NextDouble () * dist - dist / 2' objects);  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,LoadScene,The following statement contains a magic number: for (double z = -camheight; z < camheight; z += h)  	AddTree (x + Rd.NextDouble () * dist - dist / 2' -2' z + Rd.NextDouble () * dist - dist / 2' objects);  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,LoadScene,The following statement contains a magic number: for (double z = -camheight; z < camheight; z += h)  	AddTree (x + Rd.NextDouble () * dist - dist / 2' -2' z + Rd.NextDouble () * dist - dist / 2' objects);  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,LoadScene,The following statement contains a magic number: for (double z = -camheight; z < camheight; z += h)  	AddTree (x + Rd.NextDouble () * dist - dist / 2' -2' z + Rd.NextDouble () * dist - dist / 2' objects);  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,LoadScene,The following statement contains a magic number: AddTree (x + Rd.NextDouble () * dist - dist / 2' -2' z + Rd.NextDouble () * dist - dist / 2' objects);  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,LoadScene,The following statement contains a magic number: AddTree (x + Rd.NextDouble () * dist - dist / 2' -2' z + Rd.NextDouble () * dist - dist / 2' objects);  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,LoadScene,The following statement contains a magic number: AddTree (x + Rd.NextDouble () * dist - dist / 2' -2' z + Rd.NextDouble () * dist - dist / 2' objects);  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: if (Rd.NextDouble () < 0.5) {  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0'  		Y = -1.6'  		Z = t1  	}' 10' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -2'  		Z = t1 * 2  	}' 1' @base));  }  else {  	objects.Add (new Sphere (new Vect3 {  		X = x'  		Y = y + 1.5 - ld / 2'  		Z = z  	}' ld' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 1.5'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -1.5'  		Z = t1 * 2  	}' 1' @base));  }  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: if (Rd.NextDouble () < 0.5) {  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0'  		Y = -1.6'  		Z = t1  	}' 10' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -2'  		Z = t1 * 2  	}' 1' @base));  }  else {  	objects.Add (new Sphere (new Vect3 {  		X = x'  		Y = y + 1.5 - ld / 2'  		Z = z  	}' ld' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 1.5'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -1.5'  		Z = t1 * 2  	}' 1' @base));  }  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: if (Rd.NextDouble () < 0.5) {  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0'  		Y = -1.6'  		Z = t1  	}' 10' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -2'  		Z = t1 * 2  	}' 1' @base));  }  else {  	objects.Add (new Sphere (new Vect3 {  		X = x'  		Y = y + 1.5 - ld / 2'  		Z = z  	}' ld' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 1.5'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -1.5'  		Z = t1 * 2  	}' 1' @base));  }  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: if (Rd.NextDouble () < 0.5) {  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0'  		Y = -1.6'  		Z = t1  	}' 10' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -2'  		Z = t1 * 2  	}' 1' @base));  }  else {  	objects.Add (new Sphere (new Vect3 {  		X = x'  		Y = y + 1.5 - ld / 2'  		Z = z  	}' ld' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 1.5'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -1.5'  		Z = t1 * 2  	}' 1' @base));  }  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: if (Rd.NextDouble () < 0.5) {  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0'  		Y = -1.6'  		Z = t1  	}' 10' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -2'  		Z = t1 * 2  	}' 1' @base));  }  else {  	objects.Add (new Sphere (new Vect3 {  		X = x'  		Y = y + 1.5 - ld / 2'  		Z = z  	}' ld' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 1.5'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -1.5'  		Z = t1 * 2  	}' 1' @base));  }  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: if (Rd.NextDouble () < 0.5) {  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0'  		Y = -1.6'  		Z = t1  	}' 10' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -2'  		Z = t1 * 2  	}' 1' @base));  }  else {  	objects.Add (new Sphere (new Vect3 {  		X = x'  		Y = y + 1.5 - ld / 2'  		Z = z  	}' ld' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 1.5'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -1.5'  		Z = t1 * 2  	}' 1' @base));  }  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: if (Rd.NextDouble () < 0.5) {  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0'  		Y = -1.6'  		Z = t1  	}' 10' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -2'  		Z = t1 * 2  	}' 1' @base));  }  else {  	objects.Add (new Sphere (new Vect3 {  		X = x'  		Y = y + 1.5 - ld / 2'  		Z = z  	}' ld' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 1.5'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -1.5'  		Z = t1 * 2  	}' 1' @base));  }  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: if (Rd.NextDouble () < 0.5) {  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0'  		Y = -1.6'  		Z = t1  	}' 10' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -2'  		Z = t1 * 2  	}' 1' @base));  }  else {  	objects.Add (new Sphere (new Vect3 {  		X = x'  		Y = y + 1.5 - ld / 2'  		Z = z  	}' ld' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 1.5'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -1.5'  		Z = t1 * 2  	}' 1' @base));  }  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: if (Rd.NextDouble () < 0.5) {  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0'  		Y = -1.6'  		Z = t1  	}' 10' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -2'  		Z = t1 * 2  	}' 1' @base));  }  else {  	objects.Add (new Sphere (new Vect3 {  		X = x'  		Y = y + 1.5 - ld / 2'  		Z = z  	}' ld' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 1.5'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -1.5'  		Z = t1 * 2  	}' 1' @base));  }  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: if (Rd.NextDouble () < 0.5) {  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0'  		Y = -1.6'  		Z = t1  	}' 10' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -2'  		Z = t1 * 2  	}' 1' @base));  }  else {  	objects.Add (new Sphere (new Vect3 {  		X = x'  		Y = y + 1.5 - ld / 2'  		Z = z  	}' ld' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 1.5'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -1.5'  		Z = t1 * 2  	}' 1' @base));  }  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: if (Rd.NextDouble () < 0.5) {  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0'  		Y = -1.6'  		Z = t1  	}' 10' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -2'  		Z = t1 * 2  	}' 1' @base));  }  else {  	objects.Add (new Sphere (new Vect3 {  		X = x'  		Y = y + 1.5 - ld / 2'  		Z = z  	}' ld' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 1.5'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -1.5'  		Z = t1 * 2  	}' 1' @base));  }  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: if (Rd.NextDouble () < 0.5) {  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0'  		Y = -1.6'  		Z = t1  	}' 10' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -2'  		Z = t1 * 2  	}' 1' @base));  }  else {  	objects.Add (new Sphere (new Vect3 {  		X = x'  		Y = y + 1.5 - ld / 2'  		Z = z  	}' ld' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 1.5'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -1.5'  		Z = t1 * 2  	}' 1' @base));  }  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: if (Rd.NextDouble () < 0.5) {  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0'  		Y = -1.6'  		Z = t1  	}' 10' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -2'  		Z = t1 * 2  	}' 1' @base));  }  else {  	objects.Add (new Sphere (new Vect3 {  		X = x'  		Y = y + 1.5 - ld / 2'  		Z = z  	}' ld' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 1.5'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -1.5'  		Z = t1 * 2  	}' 1' @base));  }  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: if (Rd.NextDouble () < 0.5) {  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0'  		Y = -1.6'  		Z = t1  	}' 10' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 2'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -2'  		Z = t1 * 2  	}' 1' @base));  }  else {  	objects.Add (new Sphere (new Vect3 {  		X = x'  		Y = y + 1.5 - ld / 2'  		Z = z  	}' ld' leafColor));  	objects.Add (new Cone (new Vect3 {  		X = x'  		Y = y + 1.5'  		Z = z  	}' new Vect3 {  		X = t0 * 2'  		Y = -1.5'  		Z = t1 * 2  	}' 1' @base));  }  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: objects.Add (new Cone (new Vect3 {  	X = x'  	Y = y + 2'  	Z = z  }' new Vect3 {  	X = t0'  	Y = -1.6'  	Z = t1  }' 10' leafColor));  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: objects.Add (new Cone (new Vect3 {  	X = x'  	Y = y + 2'  	Z = z  }' new Vect3 {  	X = t0'  	Y = -1.6'  	Z = t1  }' 10' leafColor));  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: objects.Add (new Cone (new Vect3 {  	X = x'  	Y = y + 2'  	Z = z  }' new Vect3 {  	X = t0'  	Y = -1.6'  	Z = t1  }' 10' leafColor));  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: objects.Add (new Cone (new Vect3 {  	X = x'  	Y = y + 2'  	Z = z  }' new Vect3 {  	X = t0 * 2'  	Y = -2'  	Z = t1 * 2  }' 1' @base));  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: objects.Add (new Cone (new Vect3 {  	X = x'  	Y = y + 2'  	Z = z  }' new Vect3 {  	X = t0 * 2'  	Y = -2'  	Z = t1 * 2  }' 1' @base));  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: objects.Add (new Cone (new Vect3 {  	X = x'  	Y = y + 2'  	Z = z  }' new Vect3 {  	X = t0 * 2'  	Y = -2'  	Z = t1 * 2  }' 1' @base));  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: objects.Add (new Cone (new Vect3 {  	X = x'  	Y = y + 2'  	Z = z  }' new Vect3 {  	X = t0 * 2'  	Y = -2'  	Z = t1 * 2  }' 1' @base));  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: objects.Add (new Sphere (new Vect3 {  	X = x'  	Y = y + 1.5 - ld / 2'  	Z = z  }' ld' leafColor));  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: objects.Add (new Sphere (new Vect3 {  	X = x'  	Y = y + 1.5 - ld / 2'  	Z = z  }' ld' leafColor));  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: objects.Add (new Cone (new Vect3 {  	X = x'  	Y = y + 1.5'  	Z = z  }' new Vect3 {  	X = t0 * 2'  	Y = -1.5'  	Z = t1 * 2  }' 1' @base));  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: objects.Add (new Cone (new Vect3 {  	X = x'  	Y = y + 1.5'  	Z = z  }' new Vect3 {  	X = t0 * 2'  	Y = -1.5'  	Z = t1 * 2  }' 1' @base));  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: objects.Add (new Cone (new Vect3 {  	X = x'  	Y = y + 1.5'  	Z = z  }' new Vect3 {  	X = t0 * 2'  	Y = -1.5'  	Z = t1 * 2  }' 1' @base));  
Magic Number,JRayXLib.Scene.Loaders,RandomForrestLoader,C:\repos\FrankyBoy_JRayX\JRayXLib\Scene\Loaders\RandomForrestLoader.cs,AddTree,The following statement contains a magic number: objects.Add (new Cone (new Vect3 {  	X = x'  	Y = y + 1.5'  	Z = z  }' new Vect3 {  	X = t0 * 2'  	Y = -1.5'  	Z = t1 * 2  }' 1' @base));  
Magic Number,JRayXLib.Shapes,Basic3DObject,C:\repos\FrankyBoy_JRayX\JRayXLib\Shapes\Basic3DObject.cs,GetRefractionIndex,The following statement contains a magic number: return 1.03;  
Magic Number,JRayXLib.Shapes,Texture,C:\repos\FrankyBoy_JRayX\JRayXLib\Shapes\Texture.cs,GetColorAt,The following statement contains a magic number: if (tx < -1 || tx > 2 || ty < -1 || ty > 2) {  	throw new Exception ("This texcoord is far beyond every numerical tolerance: " + new Vect3 {  		X = tx'  		Y = ty  	});  }  
Magic Number,JRayXLib.Shapes,Texture,C:\repos\FrankyBoy_JRayX\JRayXLib\Shapes\Texture.cs,GetColorAt,The following statement contains a magic number: if (tx < -1 || tx > 2 || ty < -1 || ty > 2) {  	throw new Exception ("This texcoord is far beyond every numerical tolerance: " + new Vect3 {  		X = tx'  		Y = ty  	});  }  
Magic Number,JRayXLib.Shapes,TexturedSphere,C:\repos\FrankyBoy_JRayX\JRayXLib\Shapes\TexturedSphere.cs,GetTextureColorAt,The following statement contains a magic number: if (tmp * LookAt < 0) {  	x = 0.5 + x;  }  else {  	x = 0.5 - x;  }  
Magic Number,JRayXLib.Shapes,TexturedSphere,C:\repos\FrankyBoy_JRayX\JRayXLib\Shapes\TexturedSphere.cs,GetTextureColorAt,The following statement contains a magic number: if (tmp * LookAt < 0) {  	x = 0.5 + x;  }  else {  	x = 0.5 - x;  }  
Magic Number,JRayXLib.Shapes,TexturedSphere,C:\repos\FrankyBoy_JRayX\JRayXLib\Shapes\TexturedSphere.cs,GetTextureColorAt,The following statement contains a magic number: x = 0.5 + x;  
Magic Number,JRayXLib.Shapes,TexturedSphere,C:\repos\FrankyBoy_JRayX\JRayXLib\Shapes\TexturedSphere.cs,GetTextureColorAt,The following statement contains a magic number: x = 0.5 - x;  
Magic Number,JRayXLib.Struct,Octree2,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree2.cs,GetLocation,The following statement contains a magic number: if (boundingSphere.Radius < _halfWidth / 2) {  	return ObjectLocation.Child;  }  
Magic Number,JRayXLib.Struct,Octree2,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree2.cs,CreateChildren,The following statement contains a magic number: for (int counter = 0; counter < 8; counter++)  	result [counter] = new Octree2 (new Vect3 {  		X = counter % 2 < 1 ? _center.X - qwidth : _center.X + qwidth'  		Y = counter % 4 < 2 ? _center.Y - qwidth : _center.Y + qwidth'  		Z = counter < 4 ? _center.Z - qwidth : _center.Z + qwidth'  	}' qwidth);  
Magic Number,JRayXLib.Struct,Octree2,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree2.cs,CreateChildren,The following statement contains a magic number: for (int counter = 0; counter < 8; counter++)  	result [counter] = new Octree2 (new Vect3 {  		X = counter % 2 < 1 ? _center.X - qwidth : _center.X + qwidth'  		Y = counter % 4 < 2 ? _center.Y - qwidth : _center.Y + qwidth'  		Z = counter < 4 ? _center.Z - qwidth : _center.Z + qwidth'  	}' qwidth);  
Magic Number,JRayXLib.Struct,Octree2,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree2.cs,CreateChildren,The following statement contains a magic number: for (int counter = 0; counter < 8; counter++)  	result [counter] = new Octree2 (new Vect3 {  		X = counter % 2 < 1 ? _center.X - qwidth : _center.X + qwidth'  		Y = counter % 4 < 2 ? _center.Y - qwidth : _center.Y + qwidth'  		Z = counter < 4 ? _center.Z - qwidth : _center.Z + qwidth'  	}' qwidth);  
Magic Number,JRayXLib.Struct,Octree2,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree2.cs,CreateChildren,The following statement contains a magic number: for (int counter = 0; counter < 8; counter++)  	result [counter] = new Octree2 (new Vect3 {  		X = counter % 2 < 1 ? _center.X - qwidth : _center.X + qwidth'  		Y = counter % 4 < 2 ? _center.Y - qwidth : _center.Y + qwidth'  		Z = counter < 4 ? _center.Z - qwidth : _center.Z + qwidth'  	}' qwidth);  
Magic Number,JRayXLib.Struct,Octree2,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree2.cs,CreateChildren,The following statement contains a magic number: for (int counter = 0; counter < 8; counter++)  	result [counter] = new Octree2 (new Vect3 {  		X = counter % 2 < 1 ? _center.X - qwidth : _center.X + qwidth'  		Y = counter % 4 < 2 ? _center.Y - qwidth : _center.Y + qwidth'  		Z = counter < 4 ? _center.Z - qwidth : _center.Z + qwidth'  	}' qwidth);  
Magic Number,JRayXLib.Struct,Octree2,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree2.cs,CreateChildren,The following statement contains a magic number: result [counter] = new Octree2 (new Vect3 {  	X = counter % 2 < 1 ? _center.X - qwidth : _center.X + qwidth'  	Y = counter % 4 < 2 ? _center.Y - qwidth : _center.Y + qwidth'  	Z = counter < 4 ? _center.Z - qwidth : _center.Z + qwidth'  }' qwidth);  
Magic Number,JRayXLib.Struct,Octree2,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree2.cs,CreateChildren,The following statement contains a magic number: result [counter] = new Octree2 (new Vect3 {  	X = counter % 2 < 1 ? _center.X - qwidth : _center.X + qwidth'  	Y = counter % 4 < 2 ? _center.Y - qwidth : _center.Y + qwidth'  	Z = counter < 4 ? _center.Z - qwidth : _center.Z + qwidth'  }' qwidth);  
Magic Number,JRayXLib.Struct,Octree2,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree2.cs,CreateChildren,The following statement contains a magic number: result [counter] = new Octree2 (new Vect3 {  	X = counter % 2 < 1 ? _center.X - qwidth : _center.X + qwidth'  	Y = counter % 4 < 2 ? _center.Y - qwidth : _center.Y + qwidth'  	Z = counter < 4 ? _center.Z - qwidth : _center.Z + qwidth'  }' qwidth);  
Magic Number,JRayXLib.Struct,Octree2,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree2.cs,CreateChildren,The following statement contains a magic number: result [counter] = new Octree2 (new Vect3 {  	X = counter % 2 < 1 ? _center.X - qwidth : _center.X + qwidth'  	Y = counter % 4 < 2 ? _center.Y - qwidth : _center.Y + qwidth'  	Z = counter < 4 ? _center.Z - qwidth : _center.Z + qwidth'  }' qwidth);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Encloses,The following statement contains a magic number: return PointCube.Encloses (Center' Width / 2 + Constants.EPS' v);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: switch (Strategy) {  case TreeInsertStrategy.LeafOnly:  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	if (_child != null) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FitIntoBox:  	if (!o.IsEnclosedByCube (Center' Width / 2))  		return false;  	if (_child != null) {  		if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  			return true;  	}  	Content.Add (o);  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.MinWidth) {  		Split ();  	}  	return true;  case TreeInsertStrategy.Dynamic:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  	}  	//if object is very small (in relation to the box) - duplicate it to child nodes  	//add it to this node otherwise  	if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  		_child [0].Insert (o' s);  		_child [1].Insert (o' s);  		_child [2].Insert (o' s);  		_child [3].Insert (o' s);  		_child [4].Insert (o' s);  		_child [5].Insert (o' s);  		_child [6].Insert (o' s);  		_child [7].Insert (o' s);  	}  	else {  		Content.Add (o);  	}  	//if node too full split it  	if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  		Split ();  	}  	return true;  case TreeInsertStrategy.DynamicTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		foreach (Node n in _child) {  			if (o.IsEnclosedByCube (n.Center' n.Width / 2))  				return n.Insert (o' s);  		}  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > 2) {  		Split ();  	}  	return true;  case TreeInsertStrategy.FastBuildTest:  	//if sphere is not touching cube -> error  	if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  		return false;  	}  	//if object is enclosed by any child' add it there  	if (_child != null) {  		bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  		int intersectionCount = 0;  		if (i0)  			intersectionCount++;  		if (i1)  			intersectionCount++;  		if (i2)  			intersectionCount++;  		if (i3)  			intersectionCount++;  		if (i4)  			intersectionCount++;  		if (i5)  			intersectionCount++;  		if (i6)  			intersectionCount++;  		if (i7)  			intersectionCount++;  		if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  			if (i0)  				_child [0].Insert (o' s);  			if (i1)  				_child [1].Insert (o' s);  			if (i2)  				_child [2].Insert (o' s);  			if (i3)  				_child [3].Insert (o' s);  			if (i4)  				_child [4].Insert (o' s);  			if (i5)  				_child [5].Insert (o' s);  			if (i6)  				_child [6].Insert (o' s);  			if (i7)  				_child [7].Insert (o' s);  			return true;  		}  	}  	Content.Add (o);  	//if node too full split it  	if (_child == null && Content.Count > TreeInsertStrategyConstants.MaxElements && Width > TreeInsertStrategyConstants.DynamicMinWidth) {  		Split ();  	}  	return true;  default:  	throw new Exception ("Mode not implemented: " + Strategy);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  	return false;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	_child [0].Insert (o' s);  	_child [1].Insert (o' s);  	_child [2].Insert (o' s);  	_child [3].Insert (o' s);  	_child [4].Insert (o' s);  	_child [5].Insert (o' s);  	_child [6].Insert (o' s);  	_child [7].Insert (o' s);  }  else {  	Content.Add (o);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	_child [0].Insert (o' s);  	_child [1].Insert (o' s);  	_child [2].Insert (o' s);  	_child [3].Insert (o' s);  	_child [4].Insert (o' s);  	_child [5].Insert (o' s);  	_child [6].Insert (o' s);  	_child [7].Insert (o' s);  }  else {  	Content.Add (o);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	_child [0].Insert (o' s);  	_child [1].Insert (o' s);  	_child [2].Insert (o' s);  	_child [3].Insert (o' s);  	_child [4].Insert (o' s);  	_child [5].Insert (o' s);  	_child [6].Insert (o' s);  	_child [7].Insert (o' s);  }  else {  	Content.Add (o);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	_child [0].Insert (o' s);  	_child [1].Insert (o' s);  	_child [2].Insert (o' s);  	_child [3].Insert (o' s);  	_child [4].Insert (o' s);  	_child [5].Insert (o' s);  	_child [6].Insert (o' s);  	_child [7].Insert (o' s);  }  else {  	Content.Add (o);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	_child [0].Insert (o' s);  	_child [1].Insert (o' s);  	_child [2].Insert (o' s);  	_child [3].Insert (o' s);  	_child [4].Insert (o' s);  	_child [5].Insert (o' s);  	_child [6].Insert (o' s);  	_child [7].Insert (o' s);  }  else {  	Content.Add (o);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	_child [0].Insert (o' s);  	_child [1].Insert (o' s);  	_child [2].Insert (o' s);  	_child [3].Insert (o' s);  	_child [4].Insert (o' s);  	_child [5].Insert (o' s);  	_child [6].Insert (o' s);  	_child [7].Insert (o' s);  }  else {  	Content.Add (o);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [2].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [3].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [4].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [5].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [6].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [7].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (!o.IsEnclosedByCube (Center' Width / 2))  	return false;  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  		return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  		return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  		return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  		return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  		return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  		return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  	return true;  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  	return true;  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  	return true;  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  	return true;  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  	return true;  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child [0].Insert (o' s) || _child [1].Insert (o' s) || _child [2].Insert (o' s) || _child [3].Insert (o' s) || _child [4].Insert (o' s) || _child [5].Insert (o' s) || _child [6].Insert (o' s) || _child [7].Insert (o' s))  	return true;  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  	return false;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: foreach (Node n in _child) {  	if (o.IsEnclosedByCube (n.Center' n.Width / 2))  		return n.Insert (o' s);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (o.IsEnclosedByCube (n.Center' n.Width / 2))  	return n.Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  	_child [0].Insert (o' s);  	_child [1].Insert (o' s);  	_child [2].Insert (o' s);  	_child [3].Insert (o' s);  	_child [4].Insert (o' s);  	_child [5].Insert (o' s);  	_child [6].Insert (o' s);  	_child [7].Insert (o' s);  }  else {  	Content.Add (o);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  	_child [0].Insert (o' s);  	_child [1].Insert (o' s);  	_child [2].Insert (o' s);  	_child [3].Insert (o' s);  	_child [4].Insert (o' s);  	_child [5].Insert (o' s);  	_child [6].Insert (o' s);  	_child [7].Insert (o' s);  }  else {  	Content.Add (o);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  	_child [0].Insert (o' s);  	_child [1].Insert (o' s);  	_child [2].Insert (o' s);  	_child [3].Insert (o' s);  	_child [4].Insert (o' s);  	_child [5].Insert (o' s);  	_child [6].Insert (o' s);  	_child [7].Insert (o' s);  }  else {  	Content.Add (o);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  	_child [0].Insert (o' s);  	_child [1].Insert (o' s);  	_child [2].Insert (o' s);  	_child [3].Insert (o' s);  	_child [4].Insert (o' s);  	_child [5].Insert (o' s);  	_child [6].Insert (o' s);  	_child [7].Insert (o' s);  }  else {  	Content.Add (o);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  	_child [0].Insert (o' s);  	_child [1].Insert (o' s);  	_child [2].Insert (o' s);  	_child [3].Insert (o' s);  	_child [4].Insert (o' s);  	_child [5].Insert (o' s);  	_child [6].Insert (o' s);  	_child [7].Insert (o' s);  }  else {  	Content.Add (o);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null && s.Radius / Width < TreeInsertStrategyConstants.DynamicDuplicateMaxSizeRatio) {  	_child [0].Insert (o' s);  	_child [1].Insert (o' s);  	_child [2].Insert (o' s);  	_child [3].Insert (o' s);  	_child [4].Insert (o' s);  	_child [5].Insert (o' s);  	_child [6].Insert (o' s);  	_child [7].Insert (o' s);  }  else {  	Content.Add (o);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [2].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [3].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [4].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [5].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [6].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [7].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child == null && Content.Count > 2/*&&width>TreeInsertStrategy.DYNAMIC_MIN_WIDTH*/) {  	Split ();  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  	return false;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	foreach (Node n in _child) {  		if (o.IsEnclosedByCube (n.Center' n.Width / 2))  			return n.Insert (o' s);  	}  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: foreach (Node n in _child) {  	if (o.IsEnclosedByCube (n.Center' n.Width / 2))  		return n.Insert (o' s);  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (o.IsEnclosedByCube (n.Center' n.Width / 2))  	return n.Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  	if (i0)  		_child [0].Insert (o' s);  	if (i1)  		_child [1].Insert (o' s);  	if (i2)  		_child [2].Insert (o' s);  	if (i3)  		_child [3].Insert (o' s);  	if (i4)  		_child [4].Insert (o' s);  	if (i5)  		_child [5].Insert (o' s);  	if (i6)  		_child [6].Insert (o' s);  	if (i7)  		_child [7].Insert (o' s);  	return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  	if (i0)  		_child [0].Insert (o' s);  	if (i1)  		_child [1].Insert (o' s);  	if (i2)  		_child [2].Insert (o' s);  	if (i3)  		_child [3].Insert (o' s);  	if (i4)  		_child [4].Insert (o' s);  	if (i5)  		_child [5].Insert (o' s);  	if (i6)  		_child [6].Insert (o' s);  	if (i7)  		_child [7].Insert (o' s);  	return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  	if (i0)  		_child [0].Insert (o' s);  	if (i1)  		_child [1].Insert (o' s);  	if (i2)  		_child [2].Insert (o' s);  	if (i3)  		_child [3].Insert (o' s);  	if (i4)  		_child [4].Insert (o' s);  	if (i5)  		_child [5].Insert (o' s);  	if (i6)  		_child [6].Insert (o' s);  	if (i7)  		_child [7].Insert (o' s);  	return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  	if (i0)  		_child [0].Insert (o' s);  	if (i1)  		_child [1].Insert (o' s);  	if (i2)  		_child [2].Insert (o' s);  	if (i3)  		_child [3].Insert (o' s);  	if (i4)  		_child [4].Insert (o' s);  	if (i5)  		_child [5].Insert (o' s);  	if (i6)  		_child [6].Insert (o' s);  	if (i7)  		_child [7].Insert (o' s);  	return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  	if (i0)  		_child [0].Insert (o' s);  	if (i1)  		_child [1].Insert (o' s);  	if (i2)  		_child [2].Insert (o' s);  	if (i3)  		_child [3].Insert (o' s);  	if (i4)  		_child [4].Insert (o' s);  	if (i5)  		_child [5].Insert (o' s);  	if (i6)  		_child [6].Insert (o' s);  	if (i7)  		_child [7].Insert (o' s);  	return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  	if (i0)  		_child [0].Insert (o' s);  	if (i1)  		_child [1].Insert (o' s);  	if (i2)  		_child [2].Insert (o' s);  	if (i3)  		_child [3].Insert (o' s);  	if (i4)  		_child [4].Insert (o' s);  	if (i5)  		_child [5].Insert (o' s);  	if (i6)  		_child [6].Insert (o' s);  	if (i7)  		_child [7].Insert (o' s);  	return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.35) {  	if (i0)  		_child [0].Insert (o' s);  	if (i1)  		_child [1].Insert (o' s);  	if (i2)  		_child [2].Insert (o' s);  	if (i3)  		_child [3].Insert (o' s);  	if (i4)  		_child [4].Insert (o' s);  	if (i5)  		_child [5].Insert (o' s);  	if (i6)  		_child [6].Insert (o' s);  	if (i7)  		_child [7].Insert (o' s);  	return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (i2)  	_child [2].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [2].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (i3)  	_child [3].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [3].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (i4)  	_child [4].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [4].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (i5)  	_child [5].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [5].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (i6)  	_child [6].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [6].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (i7)  	_child [7].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [7].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child == null && Content.Count > 2) {  	Split ();  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (!CubeSphere.IsSphereIntersectingCube (Center' Width / 2' s)) {  	return false;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (_child != null) {  	bool i0 = CubeSphere.IsSphereIntersectingCube (_child [0].Center' _child [0].Width / 2' s)' i1 = CubeSphere.IsSphereIntersectingCube (_child [1].Center' _child [1].Width / 2' s)' i2 = CubeSphere.IsSphereIntersectingCube (_child [2].Center' _child [2].Width / 2' s)' i3 = CubeSphere.IsSphereIntersectingCube (_child [3].Center' _child [3].Width / 2' s)' i4 = CubeSphere.IsSphereIntersectingCube (_child [4].Center' _child [4].Width / 2' s)' i5 = CubeSphere.IsSphereIntersectingCube (_child [5].Center' _child [5].Width / 2' s)' i6 = CubeSphere.IsSphereIntersectingCube (_child [6].Center' _child [6].Width / 2' s)' i7 = CubeSphere.IsSphereIntersectingCube (_child [7].Center' _child [7].Width / 2' s);  	int intersectionCount = 0;  	if (i0)  		intersectionCount++;  	if (i1)  		intersectionCount++;  	if (i2)  		intersectionCount++;  	if (i3)  		intersectionCount++;  	if (i4)  		intersectionCount++;  	if (i5)  		intersectionCount++;  	if (i6)  		intersectionCount++;  	if (i7)  		intersectionCount++;  	if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  		if (i0)  			_child [0].Insert (o' s);  		if (i1)  			_child [1].Insert (o' s);  		if (i2)  			_child [2].Insert (o' s);  		if (i3)  			_child [3].Insert (o' s);  		if (i4)  			_child [4].Insert (o' s);  		if (i5)  			_child [5].Insert (o' s);  		if (i6)  			_child [6].Insert (o' s);  		if (i7)  			_child [7].Insert (o' s);  		return true;  	}  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  	if (i0)  		_child [0].Insert (o' s);  	if (i1)  		_child [1].Insert (o' s);  	if (i2)  		_child [2].Insert (o' s);  	if (i3)  		_child [3].Insert (o' s);  	if (i4)  		_child [4].Insert (o' s);  	if (i5)  		_child [5].Insert (o' s);  	if (i6)  		_child [6].Insert (o' s);  	if (i7)  		_child [7].Insert (o' s);  	return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  	if (i0)  		_child [0].Insert (o' s);  	if (i1)  		_child [1].Insert (o' s);  	if (i2)  		_child [2].Insert (o' s);  	if (i3)  		_child [3].Insert (o' s);  	if (i4)  		_child [4].Insert (o' s);  	if (i5)  		_child [5].Insert (o' s);  	if (i6)  		_child [6].Insert (o' s);  	if (i7)  		_child [7].Insert (o' s);  	return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  	if (i0)  		_child [0].Insert (o' s);  	if (i1)  		_child [1].Insert (o' s);  	if (i2)  		_child [2].Insert (o' s);  	if (i3)  		_child [3].Insert (o' s);  	if (i4)  		_child [4].Insert (o' s);  	if (i5)  		_child [5].Insert (o' s);  	if (i6)  		_child [6].Insert (o' s);  	if (i7)  		_child [7].Insert (o' s);  	return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  	if (i0)  		_child [0].Insert (o' s);  	if (i1)  		_child [1].Insert (o' s);  	if (i2)  		_child [2].Insert (o' s);  	if (i3)  		_child [3].Insert (o' s);  	if (i4)  		_child [4].Insert (o' s);  	if (i5)  		_child [5].Insert (o' s);  	if (i6)  		_child [6].Insert (o' s);  	if (i7)  		_child [7].Insert (o' s);  	return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  	if (i0)  		_child [0].Insert (o' s);  	if (i1)  		_child [1].Insert (o' s);  	if (i2)  		_child [2].Insert (o' s);  	if (i3)  		_child [3].Insert (o' s);  	if (i4)  		_child [4].Insert (o' s);  	if (i5)  		_child [5].Insert (o' s);  	if (i6)  		_child [6].Insert (o' s);  	if (i7)  		_child [7].Insert (o' s);  	return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  	if (i0)  		_child [0].Insert (o' s);  	if (i1)  		_child [1].Insert (o' s);  	if (i2)  		_child [2].Insert (o' s);  	if (i3)  		_child [3].Insert (o' s);  	if (i4)  		_child [4].Insert (o' s);  	if (i5)  		_child [5].Insert (o' s);  	if (i6)  		_child [6].Insert (o' s);  	if (i7)  		_child [7].Insert (o' s);  	return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (intersectionCount == 1 || intersectionCount * s.Radius / Width < 0.5) {  	if (i0)  		_child [0].Insert (o' s);  	if (i1)  		_child [1].Insert (o' s);  	if (i2)  		_child [2].Insert (o' s);  	if (i3)  		_child [3].Insert (o' s);  	if (i4)  		_child [4].Insert (o' s);  	if (i5)  		_child [5].Insert (o' s);  	if (i6)  		_child [6].Insert (o' s);  	if (i7)  		_child [7].Insert (o' s);  	return true;  }  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (i2)  	_child [2].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [2].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (i3)  	_child [3].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [3].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (i4)  	_child [4].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [4].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (i5)  	_child [5].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [5].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (i6)  	_child [6].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [6].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: if (i7)  	_child [7].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The following statement contains a magic number: _child [7].Insert (o' s);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Split,The following statement contains a magic number: _child = new Node[8];  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Split,The following statement contains a magic number: _child [2] = new Node (new Vect3 {  	X = Center.X + w4'  	Y = Center.Y - w4'  	Z = Center.Z + w4  }' this' w2);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Split,The following statement contains a magic number: _child [3] = new Node (new Vect3 {  	X = Center.X + w4'  	Y = Center.Y - w4'  	Z = Center.Z - w4  }' this' w2);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Split,The following statement contains a magic number: _child [4] = new Node (new Vect3 {  	X = Center.X - w4'  	Y = Center.Y + w4'  	Z = Center.Z + w4  }' this' w2);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Split,The following statement contains a magic number: _child [5] = new Node (new Vect3 {  	X = Center.X - w4'  	Y = Center.Y + w4'  	Z = Center.Z - w4  }' this' w2);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Split,The following statement contains a magic number: _child [6] = new Node (new Vect3 {  	X = Center.X - w4'  	Y = Center.Y - w4'  	Z = Center.Z + w4  }' this' w2);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Split,The following statement contains a magic number: _child [7] = new Node (new Vect3 {  	X = Center.X - w4'  	Y = Center.Y - w4'  	Z = Center.Z - w4  }' this' w2);  
Magic Number,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,ToString,The following statement contains a magic number: return Center + "+/-" + Width / 2;  
Magic Number,JRayXLib.Struct,Octree,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree.cs,BuildTree,The following statement contains a magic number: while (true) {  	t = new Octree (center' sizeHint);  	foreach (I3DObject o in objects) {  		if (!t.Root.Insert (o' o.GetBoundingSphere ())) {  			sizeHint *= 2;  			Log.Warn ("Warning - resize needed!");  			goto cont;  		}  	}  	break;  	cont:  	{  	}  }  
Magic Number,JRayXLib.Struct,Octree,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree.cs,BuildTree,The following statement contains a magic number: foreach (I3DObject o in objects) {  	if (!t.Root.Insert (o' o.GetBoundingSphere ())) {  		sizeHint *= 2;  		Log.Warn ("Warning - resize needed!");  		goto cont;  	}  }  
Magic Number,JRayXLib.Struct,Octree,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree.cs,BuildTree,The following statement contains a magic number: if (!t.Root.Insert (o' o.GetBoundingSphere ())) {  	sizeHint *= 2;  	Log.Warn ("Warning - resize needed!");  	goto cont;  }  
Magic Number,JRayXLib.Struct,Octree,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree.cs,BuildTree,The following statement contains a magic number: sizeHint *= 2;  
Magic Number,JRayXLib.Struct,Octree,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree.cs,BuildTree,The following statement contains a magic number: Log.Debug (string.Format (" - contains {0} of {1} elements ({2:0.##}%)"' t.GetRoot ().GetSize ()' objects.Count' t.GetRoot ().GetSize () / (float)objects.Count * 100));  
Magic Number,JRayXLib.Struct,RayPath,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\RayPath.cs,GetFirstCollision,The following statement contains a magic number: do {  	//March to the leaf containing "pos" and check collisions  	n = n.MarchToCheckingCollisions (pos' c' r);  	//No leaf is containing "pos" -> left tree -> stop searching  	if (n == null)  		break;  	//march out of current node  	double d = RayCube.GetDistanceToBorderPlane (pos' r.Direction' n.Center' n.Width / 2) + Constants.EPS * 1e4;  	//distance traveled since the ray's origin  	pos = pos + r.Direction * d;  	distanceTravelled += d;  	//in case eps was not enough  	while (n.Encloses (pos)) {  		d = Constants.EPS * 1e4;  		pos = pos + r.Direction * d;  		distanceTravelled += d;  	}  	/**              * When passing a box-border' all intersection tests between the ray's origin and the              * box-border-intersection-point must have taken place (and some beyond the box-border too).              * Therefore' if an intersection located between the ray's origin and the box-border has been found' this              * must be the nearest intersection and the search may stop.              */}  while (c.Distance > distanceTravelled);  
Magic Number,JRayXLib.Struct,RayPath,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\RayPath.cs,GetFirstCollision,The following statement contains a magic number: do {  	//March to the leaf containing "pos" and check collisions  	n = n.MarchToCheckingCollisions (pos' c' r);  	//No leaf is containing "pos" -> left tree -> stop searching  	if (n == null)  		break;  	//march out of current node  	double d = RayCube.GetDistanceToBorderPlane (pos' r.Direction' n.Center' n.Width / 2) + Constants.EPS * 1e4;  	//distance traveled since the ray's origin  	pos = pos + r.Direction * d;  	distanceTravelled += d;  	//in case eps was not enough  	while (n.Encloses (pos)) {  		d = Constants.EPS * 1e4;  		pos = pos + r.Direction * d;  		distanceTravelled += d;  	}  	/**              * When passing a box-border' all intersection tests between the ray's origin and the              * box-border-intersection-point must have taken place (and some beyond the box-border too).              * Therefore' if an intersection located between the ray's origin and the box-border has been found' this              * must be the nearest intersection and the search may stop.              */}  while (c.Distance > distanceTravelled);  
Magic Number,JRayXLib.Struct,RayPath,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\RayPath.cs,GetFirstCollision,The following statement contains a magic number: do {  	//March to the leaf containing "pos" and check collisions  	n = n.MarchToCheckingCollisions (pos' c' r);  	//No leaf is containing "pos" -> left tree -> stop searching  	if (n == null)  		break;  	//march out of current node  	double d = RayCube.GetDistanceToBorderPlane (pos' r.Direction' n.Center' n.Width / 2) + Constants.EPS * 1e4;  	//distance traveled since the ray's origin  	pos = pos + r.Direction * d;  	distanceTravelled += d;  	//in case eps was not enough  	while (n.Encloses (pos)) {  		d = Constants.EPS * 1e4;  		pos = pos + r.Direction * d;  		distanceTravelled += d;  	}  	/**              * When passing a box-border' all intersection tests between the ray's origin and the              * box-border-intersection-point must have taken place (and some beyond the box-border too).              * Therefore' if an intersection located between the ray's origin and the box-border has been found' this              * must be the nearest intersection and the search may stop.              */}  while (c.Distance > distanceTravelled);  
Magic Number,JRayXLib.Struct,RayPath,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\RayPath.cs,GetFirstCollision,The following statement contains a magic number: while (n.Encloses (pos)) {  	d = Constants.EPS * 1e4;  	pos = pos + r.Direction * d;  	distanceTravelled += d;  }  
Magic Number,JRayXLib.Struct,RayPath,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\RayPath.cs,GetFirstCollision,The following statement contains a magic number: d = Constants.EPS * 1e4;  
Magic Number,JRayXLib.Util,MathHelper,C:\repos\FrankyBoy_JRayX\JRayXLib\Util\MathHelper.cs,ToRadians,The following statement contains a magic number: return (System.Math.PI / 180) * angle;  
Magic Number,JRayXLib.Math,Triangle,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Triangle.cs,GetCircumScribedCircleCenter,The following statement contains a magic number: mab = a + mab / 2;  
Magic Number,JRayXLib.Math,Triangle,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Triangle.cs,GetCircumScribedCircleCenter,The following statement contains a magic number: mac = a + mac / 2;  
Magic Number,JRayXLib.Math,Vect3Extensions,C:\repos\FrankyBoy_JRayX\JRayXLib\Math\Vect3Extensions.cs,ReflectOn,The following statement contains a magic number: result = result * -2;  
Magic Number,JRayXLib.Model,TriangleMeshModel,C:\repos\FrankyBoy_JRayX\JRayXLib\Model\TriangleMeshModel.cs,TriangleMeshModel,The following statement contains a magic number: max = (max + min) / 2;  
Magic Number,JRayXLib.Ray.Scenes,KugelTest,C:\repos\FrankyBoy_JRayX\JRayXLib\Ray\Scenes\KugelTest.cs,KugelTest,The following statement contains a magic number: Camera = new Camera (new Vect3 {  	Z = -10  }' new Vect3 {  	Z = -8  }' new Vect3 {  	Y = 1  });  
Magic Number,JRayXLib.Ray.Scenes,KugelTest,C:\repos\FrankyBoy_JRayX\JRayXLib\Ray\Scenes\KugelTest.cs,KugelTest,The following statement contains a magic number: Camera = new Camera (new Vect3 {  	Z = -10  }' new Vect3 {  	Z = -8  }' new Vect3 {  	Y = 1  });  
Duplicate Code,JRayXLib.Struct,Node,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Node.cs,Insert,The method contains a code clone-set at the following line numbers (starting from the method definition): ((103' 123)' (154' 174))
Missing Default,JRayXLib.Struct,Octree2,C:\repos\FrankyBoy_JRayX\JRayXLib\Struct\Octree2.cs,Insert,The following switch statement is missing a default case: switch (location) {  case ObjectLocation.None:  	return false;  case ObjectLocation.Child:  	if (_children == null)  		_children = CreateChildren ();  	return _children.Select (x => x.Insert (obj)).Aggregate ((a' b) => a || b);  case ObjectLocation.Self:  	var tmpList = new List<I3DObject> (_objects) {  		obj  	};  	_objects = tmpList.ToArray ();  	return true;  }  
