Implementation smell,Namespace,Class,File,Method,Description
Long Method,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The method has 114 lines of code.
Complex Method,ChromeTabs,ChromeTabControl,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,SetSelectedContent,Cyclomatic complexity of the method is 9
Long Identifier,ChromeTabs,ChromeTabControl,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,,The length of the parameter AddTabCommandParameterProperty is 30.
Long Identifier,ChromeTabs,ChromeTabControl,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,,The length of the parameter ContainerItemPreparedForOverrideEvent is 37.
Long Identifier,ChromeTabs,ChromeTabControl,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,,The length of the parameter CloseTabWhenDraggedOutsideBondsProperty is 39.
Long Identifier,ChromeTabs,ChromeTabControl,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,,The length of the parameter AddButtonMouseDownBrushProperty is 31.
Long Identifier,ChromeTabs,ChromeTabControl,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,,The length of the parameter AddButtonMouseOverBrushProperty is 31.
Long Identifier,ChromeTabs,ChromeTabControl,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,,The length of the parameter AddButtonDisabledBrushProperty is 30.
Long Identifier,ChromeTabs,ChromeTabControl,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,,The length of the parameter TabTearTriggerDistanceProperty is 30.
Long Statement,ChromeTabs,TabShape,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\TabShape.cs,GetGeometry,The length of the statement  "            return Geometry.Parse(String.Format(CultureInfo.InvariantCulture' "M0'{5} C2.5'{5} 5'0 10'0 15'0 {0}'0 {1}'0 {2}'0 {3}'{5} {4}'{5}"' x1' x2' x3' x4' x5' height)); " is 162.
Long Statement,ChromeTabs,ChromeTabControl,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,PrepareContainerForItemOverride,The length of the statement  "            RaiseEvent(new ContainerOverrideEventArgs(ChromeTabControl.ContainerItemPreparedForOverrideEvent' this' item' AsTabItem(element))); " is 131.
Long Statement,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ArrangeOverride,The length of the statement  "                this.addButtonRect = new Rect(new Point(offset + Overlap' (finalSize.Height - this.addButtonSize.Height) / 2)' this.addButtonSize); " is 131.
Long Statement,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,CalculateTabWidth,The length of the statement  "            double activeWidth = double.IsPositiveInfinity(availableSize.Width) ? 500 : availableSize.Width - this.leftMargin - this.rightMargin; " is 133.
Long Statement,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,CalculateTabWidth,The length of the statement  "            return Math.Min(Math.Max(totalNonPinnedTabsWidth / (this.Children.Count - numberOfPinnedTabs)' this.MinTabWidth)' this.MaxTabWidth); " is 132.
Long Statement,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The length of the statement  "                        var bound = Math.Min(1' Math.Abs(diff)) * ((sign * GetWidthForTabItem(tab) * tabWidthSlidePercent) + ((Math.Abs(diff) < 2) ? 0 : (diff - sign) * (GetWidthForTabItem(tab) - this.Overlap))); " is 188.
Long Statement,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,OnPreviewMouseMove,The length of the statement  "                RaiseEvent(new TabDragEventArgs(ChromeTabControl.TabDraggedOutsideBondsEvent' this' viewmodel' this.PointToScreen(e.GetPosition(this)))); " is 137.
Long Statement,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,OnPreviewMouseMove,The length of the statement  "                OnTabRelease(e.GetPosition(this)' ParentTabControl.CloseTabWhenDraggedOutsideBonds' 0.01);//If we set it to 0 the completed event never fires' so we set it to a small decimal. " is 175.
Long Statement,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,OnTabRelease,The length of the statement  "                            offset = this.slideIntervals[this.slideIndex + 1] - GetWidthForTabItem(this.draggedTab) * (1 - tabWidthSlidePercent) + this.Overlap; " is 132.
Long Statement,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,OnTabRelease,The length of the statement  "                            offset = this.slideIntervals[this.slideIndex - 1] + GetWidthForTabItem(this.draggedTab) * (1 - tabWidthSlidePercent) - this.Overlap; " is 132.
Long Statement,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,Reanimate,The length of the statement  "            ThicknessAnimation moveBackAnimation = new ThicknessAnimation(tab.Margin' offset' new Duration(TimeSpan.FromSeconds(duration))); " is 128.
Long Statement,XamlGeneratedNamespace,GeneratedInternalTypeHelper,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\obj\Debug\GeneratedInternalTypeHelper.g.cs,CreateInstance,The length of the statement  "            return System.Activator.CreateInstance(type' ((System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic)  " is 128.
Complex Conditional,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,StartTabDrag,The conditional expression  "this.Children.Count == 1                      && ParentTabControl.DragWindowWithOneTab                      && Mouse.LeftButton == MouseButtonState.Pressed                      && !isTabGrab"  is complex.
Complex Conditional,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The conditional expression  "!shiftedTab.Equals(this.draggedTab)                                  && ((shiftedTab.IsPinned && draggedTab.IsPinned) || (!shiftedTab.IsPinned && !draggedTab.IsPinned))"  is complex.
Magic Number,ChromeTabs,TabShape,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\TabShape.cs,GetGeometry,The following statement contains a magic number: double height = 25;
Magic Number,ChromeTabs,TabShape,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\TabShape.cs,GetGeometry,The following statement contains a magic number: double x1 = width - 15;
Magic Number,ChromeTabs,TabShape,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\TabShape.cs,GetGeometry,The following statement contains a magic number: double x2 = width - 10;
Magic Number,ChromeTabs,TabShape,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\TabShape.cs,GetGeometry,The following statement contains a magic number: double x3 = width - 5;
Magic Number,ChromeTabs,TabShape,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\TabShape.cs,GetGeometry,The following statement contains a magic number: double x4 = width - 2.5;
Magic Number,ChromeTabs,ChromeTabControl,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,ChangeSelectedItem,The following statement contains a magic number: if (index != this.SelectedIndex)              {                  if (index > -1)                  {                      if (this.SelectedItem != null)                      {                          Canvas.SetZIndex(this.AsTabItem(this.SelectedItem)' 0);                      }                      this.SelectedIndex = index;                      Canvas.SetZIndex(item' 1001);                  }              }
Magic Number,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ChromeTabPanel,The following statement contains a magic number: this.rightMargin = 25.0;
Magic Number,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ChromeTabPanel,The following statement contains a magic number: this.defaultMeasureHeight = 30.0;
Magic Number,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ChromeTabPanel,The following statement contains a magic number: this.addButtonSize = new Size(20' 12);
Magic Number,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ChromeTabPanel,The following statement contains a magic number: this.addButtonSize = new Size(20' 12);
Magic Number,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ArrangeOverride,The following statement contains a magic number: this.rightMargin = ParentTabControl.IsAddButtonVisible ? 25 : 0;
Magic Number,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ArrangeOverride,The following statement contains a magic number: if (ParentTabControl.IsAddButtonVisible)              {                  this.addButtonRect = new Rect(new Point(offset + Overlap' (finalSize.Height - this.addButtonSize.Height) / 2)' this.addButtonSize);                  this.addButton.Arrange(this.addButtonRect);              }
Magic Number,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,CalculateTabWidth,The following statement contains a magic number: double activeWidth = double.IsPositiveInfinity(availableSize.Width) ? 500 : availableSize.Width - this.leftMargin - this.rightMargin;
Magic Number,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,StartTabDrag,The following statement contains a magic number: if (tab != null)              {                  this.UpdateLayout();                  double totalWidth = 0;                  for (int i = 0; i < tab.Index; i++)                  {                      totalWidth += GetWidthForTabItem(Children[i] as ChromeTabItem) - Overlap;                  }                  double xPos = totalWidth + ((GetWidthForTabItem(tab) / 2));                  this.downPoint = new Point(xPos' downPoint.Y);              }              else                  this.downPoint = downPoint;
Magic Number,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,StartTabDrag,The following statement contains a magic number: if (this.draggedTab != null)              {                  if (this.Children.Count == 1                      && ParentTabControl.DragWindowWithOneTab                      && Mouse.LeftButton == MouseButtonState.Pressed                      && !isTabGrab)                  {                      this.draggedTab = null;                      Window.GetWindow(this).DragMove();                  }                  else                  {                      this.downTabBoundsPoint = MouseUtilities.CorrectGetPosition(this.draggedTab);                      Canvas.SetZIndex(this.draggedTab' 1000);                      ParentTabControl.ChangeSelectedItem(this.draggedTab);                      if (isTabGrab)                      {                          for (int i = 0; i < this.Children.Count; i++)                          {                              ProcessMouseMove(new Point(p.X + 0.1' p.Y));                          }                      }                  }              }
Magic Number,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,StartTabDrag,The following statement contains a magic number: if (this.draggedTab != null)              {                  if (this.Children.Count == 1                      && ParentTabControl.DragWindowWithOneTab                      && Mouse.LeftButton == MouseButtonState.Pressed                      && !isTabGrab)                  {                      this.draggedTab = null;                      Window.GetWindow(this).DragMove();                  }                  else                  {                      this.downTabBoundsPoint = MouseUtilities.CorrectGetPosition(this.draggedTab);                      Canvas.SetZIndex(this.draggedTab' 1000);                      ParentTabControl.ChangeSelectedItem(this.draggedTab);                      if (isTabGrab)                      {                          for (int i = 0; i < this.Children.Count; i++)                          {                              ProcessMouseMove(new Point(p.X + 0.1' p.Y));                          }                      }                  }              }
Magic Number,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: if (margin.Left != 0)              {                  int guardValue = Interlocked.Increment(ref this.captureGuard);                  if (guardValue == 1)                  {                      this.draggedTab.Margin = margin;                        //we capture the mouse and start tab movement                      this.originalIndex = this.draggedTab.Index;                      this.slideIndex = this.originalIndex + 1;                      //Add slide intervals' the positions  where the tab slides over the next.                      this.slideIntervals = new List<double>();                      this.slideIntervals.Add(double.NegativeInfinity);                        for (int i = 1; i <= this.Children.Count; i += 1)                      {                          var tab = this.Children[i - 1] as ChromeTabItem;                          var diff = i - this.slideIndex;                          var sign = diff == 0 ? 0 : diff / Math.Abs(diff);                          var bound = Math.Min(1' Math.Abs(diff)) * ((sign * GetWidthForTabItem(tab) * tabWidthSlidePercent) + ((Math.Abs(diff) < 2) ? 0 : (diff - sign) * (GetWidthForTabItem(tab) - this.Overlap)));                          this.slideIntervals.Add(bound);                      }                      this.slideIntervals.Add(double.PositiveInfinity);                      this.Dispatcher.BeginInvoke(new Action(() =>                          {                              if (this.CaptureMouse())                              {                                  Debug.WriteLine("has mouse capture=true");                              }                              else                                  Debug.WriteLine("has mouse capture=false");                          }));                  }                  else if (this.slideIntervals != null)                  {                        if (insideTabPoint.X > 0 && (nowPoint.X + (this.draggedTab.ActualWidth - insideTabPoint.X)) >= this.ActualWidth)                      {                          return;                      }                      else if (insideTabPoint.X < this.downTabBoundsPoint.X && (nowPoint.X - insideTabPoint.X) <= 0)                      {                          return;                      }                      this.draggedTab.Margin = margin;                      //We return on small marging changes to avoid the tabs jumping around when quickly clicking between tabs.                      if (Math.Abs(this.draggedTab.Margin.Left) < 10)                          return;                      this.addButton.Visibility = System.Windows.Visibility.Hidden;                      hideAddButton = true;                        int changed = 0;                      int localSlideIndex = this.slideIndex;                      if (localSlideIndex - 1 >= 0                           && localSlideIndex - 1 < this.slideIntervals.Count                          && margin.Left < this.slideIntervals[localSlideIndex - 1])                      {                          SwapSlideInterval(localSlideIndex - 1);                          localSlideIndex -= 1;                          changed = 1;                      }                      else if (localSlideIndex + 1 >= 0                          && localSlideIndex + 1 < this.slideIntervals.Count                          && margin.Left > this.slideIntervals[localSlideIndex + 1])                      {                          SwapSlideInterval(localSlideIndex + 1);                          localSlideIndex += 1;                          changed = -1;                      }                      if (changed != 0)                      {                          var rightedOriginalIndex = this.originalIndex + 1;                          var diff = 1;                          if (changed > 0 && localSlideIndex >= rightedOriginalIndex)                          {                              changed = 0;                              diff = 0;                          }                          else if (changed < 0 && localSlideIndex <= rightedOriginalIndex)                          {                              changed = 0;                              diff = 2;                          }                            int index = localSlideIndex - diff;                          if (index >= 0 && index < this.Children.Count)                          {                              ChromeTabItem shiftedTab = this.Children[index] as ChromeTabItem;                                if (!shiftedTab.Equals(this.draggedTab)                                  && ((shiftedTab.IsPinned && draggedTab.IsPinned) || (!shiftedTab.IsPinned && !draggedTab.IsPinned)))                              {                                  var offset = changed * (GetWidthForTabItem(this.draggedTab) - this.Overlap);                                  StickyReanimate(shiftedTab' offset' stickyReanimateDuration);                                  this.slideIndex = localSlideIndex;                              }                          }                      }                  }              }
Magic Number,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: if (margin.Left != 0)              {                  int guardValue = Interlocked.Increment(ref this.captureGuard);                  if (guardValue == 1)                  {                      this.draggedTab.Margin = margin;                        //we capture the mouse and start tab movement                      this.originalIndex = this.draggedTab.Index;                      this.slideIndex = this.originalIndex + 1;                      //Add slide intervals' the positions  where the tab slides over the next.                      this.slideIntervals = new List<double>();                      this.slideIntervals.Add(double.NegativeInfinity);                        for (int i = 1; i <= this.Children.Count; i += 1)                      {                          var tab = this.Children[i - 1] as ChromeTabItem;                          var diff = i - this.slideIndex;                          var sign = diff == 0 ? 0 : diff / Math.Abs(diff);                          var bound = Math.Min(1' Math.Abs(diff)) * ((sign * GetWidthForTabItem(tab) * tabWidthSlidePercent) + ((Math.Abs(diff) < 2) ? 0 : (diff - sign) * (GetWidthForTabItem(tab) - this.Overlap)));                          this.slideIntervals.Add(bound);                      }                      this.slideIntervals.Add(double.PositiveInfinity);                      this.Dispatcher.BeginInvoke(new Action(() =>                          {                              if (this.CaptureMouse())                              {                                  Debug.WriteLine("has mouse capture=true");                              }                              else                                  Debug.WriteLine("has mouse capture=false");                          }));                  }                  else if (this.slideIntervals != null)                  {                        if (insideTabPoint.X > 0 && (nowPoint.X + (this.draggedTab.ActualWidth - insideTabPoint.X)) >= this.ActualWidth)                      {                          return;                      }                      else if (insideTabPoint.X < this.downTabBoundsPoint.X && (nowPoint.X - insideTabPoint.X) <= 0)                      {                          return;                      }                      this.draggedTab.Margin = margin;                      //We return on small marging changes to avoid the tabs jumping around when quickly clicking between tabs.                      if (Math.Abs(this.draggedTab.Margin.Left) < 10)                          return;                      this.addButton.Visibility = System.Windows.Visibility.Hidden;                      hideAddButton = true;                        int changed = 0;                      int localSlideIndex = this.slideIndex;                      if (localSlideIndex - 1 >= 0                           && localSlideIndex - 1 < this.slideIntervals.Count                          && margin.Left < this.slideIntervals[localSlideIndex - 1])                      {                          SwapSlideInterval(localSlideIndex - 1);                          localSlideIndex -= 1;                          changed = 1;                      }                      else if (localSlideIndex + 1 >= 0                          && localSlideIndex + 1 < this.slideIntervals.Count                          && margin.Left > this.slideIntervals[localSlideIndex + 1])                      {                          SwapSlideInterval(localSlideIndex + 1);                          localSlideIndex += 1;                          changed = -1;                      }                      if (changed != 0)                      {                          var rightedOriginalIndex = this.originalIndex + 1;                          var diff = 1;                          if (changed > 0 && localSlideIndex >= rightedOriginalIndex)                          {                              changed = 0;                              diff = 0;                          }                          else if (changed < 0 && localSlideIndex <= rightedOriginalIndex)                          {                              changed = 0;                              diff = 2;                          }                            int index = localSlideIndex - diff;                          if (index >= 0 && index < this.Children.Count)                          {                              ChromeTabItem shiftedTab = this.Children[index] as ChromeTabItem;                                if (!shiftedTab.Equals(this.draggedTab)                                  && ((shiftedTab.IsPinned && draggedTab.IsPinned) || (!shiftedTab.IsPinned && !draggedTab.IsPinned)))                              {                                  var offset = changed * (GetWidthForTabItem(this.draggedTab) - this.Overlap);                                  StickyReanimate(shiftedTab' offset' stickyReanimateDuration);                                  this.slideIndex = localSlideIndex;                              }                          }                      }                  }              }
Magic Number,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: if (margin.Left != 0)              {                  int guardValue = Interlocked.Increment(ref this.captureGuard);                  if (guardValue == 1)                  {                      this.draggedTab.Margin = margin;                        //we capture the mouse and start tab movement                      this.originalIndex = this.draggedTab.Index;                      this.slideIndex = this.originalIndex + 1;                      //Add slide intervals' the positions  where the tab slides over the next.                      this.slideIntervals = new List<double>();                      this.slideIntervals.Add(double.NegativeInfinity);                        for (int i = 1; i <= this.Children.Count; i += 1)                      {                          var tab = this.Children[i - 1] as ChromeTabItem;                          var diff = i - this.slideIndex;                          var sign = diff == 0 ? 0 : diff / Math.Abs(diff);                          var bound = Math.Min(1' Math.Abs(diff)) * ((sign * GetWidthForTabItem(tab) * tabWidthSlidePercent) + ((Math.Abs(diff) < 2) ? 0 : (diff - sign) * (GetWidthForTabItem(tab) - this.Overlap)));                          this.slideIntervals.Add(bound);                      }                      this.slideIntervals.Add(double.PositiveInfinity);                      this.Dispatcher.BeginInvoke(new Action(() =>                          {                              if (this.CaptureMouse())                              {                                  Debug.WriteLine("has mouse capture=true");                              }                              else                                  Debug.WriteLine("has mouse capture=false");                          }));                  }                  else if (this.slideIntervals != null)                  {                        if (insideTabPoint.X > 0 && (nowPoint.X + (this.draggedTab.ActualWidth - insideTabPoint.X)) >= this.ActualWidth)                      {                          return;                      }                      else if (insideTabPoint.X < this.downTabBoundsPoint.X && (nowPoint.X - insideTabPoint.X) <= 0)                      {                          return;                      }                      this.draggedTab.Margin = margin;                      //We return on small marging changes to avoid the tabs jumping around when quickly clicking between tabs.                      if (Math.Abs(this.draggedTab.Margin.Left) < 10)                          return;                      this.addButton.Visibility = System.Windows.Visibility.Hidden;                      hideAddButton = true;                        int changed = 0;                      int localSlideIndex = this.slideIndex;                      if (localSlideIndex - 1 >= 0                           && localSlideIndex - 1 < this.slideIntervals.Count                          && margin.Left < this.slideIntervals[localSlideIndex - 1])                      {                          SwapSlideInterval(localSlideIndex - 1);                          localSlideIndex -= 1;                          changed = 1;                      }                      else if (localSlideIndex + 1 >= 0                          && localSlideIndex + 1 < this.slideIntervals.Count                          && margin.Left > this.slideIntervals[localSlideIndex + 1])                      {                          SwapSlideInterval(localSlideIndex + 1);                          localSlideIndex += 1;                          changed = -1;                      }                      if (changed != 0)                      {                          var rightedOriginalIndex = this.originalIndex + 1;                          var diff = 1;                          if (changed > 0 && localSlideIndex >= rightedOriginalIndex)                          {                              changed = 0;                              diff = 0;                          }                          else if (changed < 0 && localSlideIndex <= rightedOriginalIndex)                          {                              changed = 0;                              diff = 2;                          }                            int index = localSlideIndex - diff;                          if (index >= 0 && index < this.Children.Count)                          {                              ChromeTabItem shiftedTab = this.Children[index] as ChromeTabItem;                                if (!shiftedTab.Equals(this.draggedTab)                                  && ((shiftedTab.IsPinned && draggedTab.IsPinned) || (!shiftedTab.IsPinned && !draggedTab.IsPinned)))                              {                                  var offset = changed * (GetWidthForTabItem(this.draggedTab) - this.Overlap);                                  StickyReanimate(shiftedTab' offset' stickyReanimateDuration);                                  this.slideIndex = localSlideIndex;                              }                          }                      }                  }              }
Magic Number,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,OnPreviewMouseMove,The following statement contains a magic number: if (this.draggedTab == null || DateTime.UtcNow.Subtract(lastMouseDown).TotalMilliseconds < 50)              {                  return;              }
Magic Number,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,OnPreviewMouseMove,The following statement contains a magic number: bool isOutsideTabPanel = nowPoint.X < 0 - ParentTabControl.TabTearTriggerDistance                  || nowPoint.X > this.ActualWidth + ParentTabControl.TabTearTriggerDistance                  || nowPoint.Y < -(this.ActualHeight)                  || nowPoint.Y > this.ActualHeight + 5 + ParentTabControl.TabTearTriggerDistance;
Magic Number,ChromeTabs,ChromeTabPanel,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,OnPreviewMouseMove,The following statement contains a magic number: if (isOutsideTabPanel == true && Mouse.LeftButton == MouseButtonState.Pressed)              {                  object viewmodel = draggedTab.Content;                  RaiseEvent(new TabDragEventArgs(ChromeTabControl.TabDraggedOutsideBondsEvent' this' viewmodel' this.PointToScreen(e.GetPosition(this))));                  OnTabRelease(e.GetPosition(this)' ParentTabControl.CloseTabWhenDraggedOutsideBonds' 0.01);//If we set it to 0 the completed event never fires' so we set it to a small decimal.              }
Missing Default,ChromeTabs,ChromeTabControl,C:\repos\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,OnItemsChanged,The following switch statement is missing a default case: switch (e.Action)                  {                      case NotifyCollectionChangedAction.Replace:                      case NotifyCollectionChangedAction.Reset:                          {                              var itemsToRemove = itemsHolder.Children.Cast<ContentPresenter>().Where(x => !Items.Contains(x.Content)).ToList();                              foreach (var item in itemsToRemove)                                  itemsHolder.Children.Remove(item);                          }                          break;                      case NotifyCollectionChangedAction.Add:                          {                              // don't do anything with new items not created by the add button' because we don't want to                              // create visuals that aren't being shown.                              if (_addTabButtonClicked && AddTabButtonBehavior == AddTabButtonBehavior.OpenNewTab)                              {                                  _addTabButtonClicked = false;                                  if (e.NewItems != null)                                      ChangeSelectedItem(AsTabItem(e.NewItems.Cast<object>().Last()));                              }                          }                          break;                      case NotifyCollectionChangedAction.Remove:                          if (e.OldItems != null)                          {                              foreach (var item in e.OldItems)                              {                                  ContentPresenter cp = FindChildContentPresenter(item);                                  if (cp != null)                                  {                                      itemsHolder.Children.Remove(cp);                                  }                              }                          }                              break;                  }
