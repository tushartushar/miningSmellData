Implementation smell,Namespace,Class,File,Method,Description
Long Method,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The method has 82 lines of code.
Complex Method,ChromeTabs,ChromeTabControl,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,OnItemsChanged,Cyclomatic complexity of the method is 18
Complex Method,ChromeTabs,ChromeTabControl,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,SetSelectedContent,Cyclomatic complexity of the method is 10
Complex Method,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,StartTabDrag,Cyclomatic complexity of the method is 7
Complex Method,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,Cyclomatic complexity of the method is 16
Long Parameter List,ChromeTabs,ContainerOverrideEventArgs,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ContainerOverrideEventArgs.cs,ContainerOverrideEventArgs,The method has 4 parameters.
Long Parameter List,ChromeTabs,TabDragEventArgs,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\TabDragEventArgs.cs,TabDragEventArgs,The method has 4 parameters.
Long Parameter List,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,Reanimate,The method has 4 parameters.
Long Parameter List,ChromeTabs.Converters,IsLessThanConverter,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\Converters\IsLessThanConverter.cs,Convert,The method has 4 parameters.
Long Parameter List,ChromeTabs.Converters,IsLessThanConverter,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\Converters\IsLessThanConverter.cs,ConvertBack,The method has 4 parameters.
Long Parameter List,ChromeTabs.Converters,TabPersistBehaviorToContentPresenterVisibilityConverter,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\Converters\TabPersistBehaviorToContentPresenterVisibilityConverter.cs,Convert,The method has 4 parameters.
Long Parameter List,ChromeTabs.Converters,TabPersistBehaviorToContentPresenterVisibilityConverter,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\Converters\TabPersistBehaviorToContentPresenterVisibilityConverter.cs,ConvertBack,The method has 4 parameters.
Long Parameter List,ChromeTabs.Converters,TabPersistBehaviorToItemHolderVisibilityConverter,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\Converters\TabPersistBehaviorToItemHolderVisibilityConverter.cs,Convert,The method has 4 parameters.
Long Parameter List,ChromeTabs.Converters,TabPersistBehaviorToItemHolderVisibilityConverter,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\Converters\TabPersistBehaviorToItemHolderVisibilityConverter.cs,ConvertBack,The method has 4 parameters.
Long Statement,ChromeTabs,TabShape,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\TabShape.cs,GetGeometry,The length of the statement  "	return Geometry.Parse (String.Format (CultureInfo.InvariantCulture' "M0'{5} C2.5'{5} 5'0 10'0 15'0 {0}'0 {1}'0 {2}'0 {3}'{5} {4}'{5}"' x1' x2' x3' x4' x5' height)); " is 164.
Long Statement,ChromeTabs,ChromeTabControl,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,PrepareContainerForItemOverride,The length of the statement  "	RaiseEvent (new ContainerOverrideEventArgs (ChromeTabControl.ContainerItemPreparedForOverrideEvent' this' item' AsTabItem (element))); " is 134.
Long Statement,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ArrangeOverride,The length of the statement  "		this.addButtonRect = new Rect (new Point (offset + Overlap' (finalSize.Height - this.addButtonSize.Height) / 2)' this.addButtonSize); " is 133.
Long Statement,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,CalculateTabWidth,The length of the statement  "	double activeWidth = double.IsPositiveInfinity (availableSize.Width) ? 500 : availableSize.Width - this.leftMargin - this.rightMargin; " is 134.
Long Statement,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,CalculateTabWidth,The length of the statement  "	return Math.Min (Math.Max (totalNonPinnedTabsWidth / (this.Children.Count - numberOfPinnedTabs)' this.MinTabWidth)' this.MaxTabWidth); " is 134.
Long Statement,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,StartTabDrag,The length of the statement  "		if (this.Children.Count == 1 && ParentTabControl.DragWindowWithOneTab && Mouse.LeftButton == MouseButtonState.Pressed && !isTabGrab) { " is 134.
Long Statement,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The length of the statement  "				var bound = Math.Min (1' Math.Abs (diff)) * ((sign * GetWidthForTabItem (tab) * tabWidthSlidePercent) + ((Math.Abs (diff) < 2) ? 0 : (diff - sign) * (GetWidthForTabItem (tab) - this.Overlap))); " is 193.
Long Statement,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The length of the statement  "				if (!shiftedTab.Equals (this.draggedTab) && ((shiftedTab.IsPinned && draggedTab.IsPinned) || (!shiftedTab.IsPinned && !draggedTab.IsPinned))) { " is 143.
Long Statement,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,OnPreviewMouseMove,The length of the statement  "	bool isOutsideTabPanel = nowPoint.X < 0 - ParentTabControl.TabTearTriggerDistance || nowPoint.X > this.ActualWidth + ParentTabControl.TabTearTriggerDistance || nowPoint.Y < -(this.ActualHeight) || nowPoint.Y > this.ActualHeight + 5 + ParentTabControl.TabTearTriggerDistance; " is 274.
Long Statement,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,OnPreviewMouseMove,The length of the statement  "		RaiseEvent (new TabDragEventArgs (ChromeTabControl.TabDraggedOutsideBondsEvent' this' viewmodel' this.PointToScreen (e.GetPosition (this)))); " is 141.
Long Statement,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,OnTabRelease,The length of the statement  "					offset = this.slideIntervals [this.slideIndex + 1] - GetWidthForTabItem (this.draggedTab) * (1 - tabWidthSlidePercent) + this.Overlap; " is 134.
Long Statement,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,OnTabRelease,The length of the statement  "					offset = this.slideIntervals [this.slideIndex - 1] + GetWidthForTabItem (this.draggedTab) * (1 - tabWidthSlidePercent) - this.Overlap; " is 134.
Long Statement,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,Reanimate,The length of the statement  "	ThicknessAnimation moveBackAnimation = new ThicknessAnimation (tab.Margin' offset' new Duration (TimeSpan.FromSeconds (duration))); " is 131.
Complex Conditional,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,StartTabDrag,The conditional expression  "this.Children.Count == 1 && ParentTabControl.DragWindowWithOneTab && Mouse.LeftButton == MouseButtonState.Pressed && !isTabGrab"  is complex.
Complex Conditional,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The conditional expression  "!shiftedTab.Equals (this.draggedTab) && ((shiftedTab.IsPinned && draggedTab.IsPinned) || (!shiftedTab.IsPinned && !draggedTab.IsPinned))"  is complex.
Magic Number,ChromeTabs,ChromeTabControl,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,ChangeSelectedItem,The following statement contains a magic number: if (index != this.SelectedIndex) {  	if (index > -1) {  		if (this.SelectedItem != null) {  			Canvas.SetZIndex (this.AsTabItem (this.SelectedItem)' 0);  		}  		this.SelectedIndex = index;  		Canvas.SetZIndex (item' 1001);  	}  }  
Magic Number,ChromeTabs,ChromeTabControl,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,ChangeSelectedItem,The following statement contains a magic number: if (index > -1) {  	if (this.SelectedItem != null) {  		Canvas.SetZIndex (this.AsTabItem (this.SelectedItem)' 0);  	}  	this.SelectedIndex = index;  	Canvas.SetZIndex (item' 1001);  }  
Magic Number,ChromeTabs,ChromeTabControl,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,ChangeSelectedItem,The following statement contains a magic number: Canvas.SetZIndex (item' 1001);  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ChromeTabPanel,The following statement contains a magic number: this.rightMargin = 25.0;  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ChromeTabPanel,The following statement contains a magic number: this.defaultMeasureHeight = 30.0;  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ChromeTabPanel,The following statement contains a magic number: this.addButtonSize = new Size (20' 12);  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ChromeTabPanel,The following statement contains a magic number: this.addButtonSize = new Size (20' 12);  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ArrangeOverride,The following statement contains a magic number: this.rightMargin = ParentTabControl.IsAddButtonVisible ? 25 : 0;  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ArrangeOverride,The following statement contains a magic number: if (ParentTabControl.IsAddButtonVisible) {  	this.addButtonRect = new Rect (new Point (offset + Overlap' (finalSize.Height - this.addButtonSize.Height) / 2)' this.addButtonSize);  	this.addButton.Arrange (this.addButtonRect);  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ArrangeOverride,The following statement contains a magic number: this.addButtonRect = new Rect (new Point (offset + Overlap' (finalSize.Height - this.addButtonSize.Height) / 2)' this.addButtonSize);  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,StartTabDrag,The following statement contains a magic number: if (tab != null) {  	this.UpdateLayout ();  	double totalWidth = 0;  	for (int i = 0; i < tab.Index; i++) {  		totalWidth += GetWidthForTabItem (Children [i] as ChromeTabItem) - Overlap;  	}  	double xPos = totalWidth + ((GetWidthForTabItem (tab) / 2));  	this.downPoint = new Point (xPos' downPoint.Y);  } else  	this.downPoint = downPoint;  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,StartTabDrag,The following statement contains a magic number: if (this.draggedTab != null) {  	if (this.Children.Count == 1 && ParentTabControl.DragWindowWithOneTab && Mouse.LeftButton == MouseButtonState.Pressed && !isTabGrab) {  		this.draggedTab = null;  		Window.GetWindow (this).DragMove ();  	} else {  		this.downTabBoundsPoint = MouseUtilities.CorrectGetPosition (this.draggedTab);  		Canvas.SetZIndex (this.draggedTab' 1000);  		ParentTabControl.ChangeSelectedItem (this.draggedTab);  		if (isTabGrab) {  			for (int i = 0; i < this.Children.Count; i++) {  				ProcessMouseMove (new Point (p.X + 0.1' p.Y));  			}  		}  	}  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,StartTabDrag,The following statement contains a magic number: if (this.draggedTab != null) {  	if (this.Children.Count == 1 && ParentTabControl.DragWindowWithOneTab && Mouse.LeftButton == MouseButtonState.Pressed && !isTabGrab) {  		this.draggedTab = null;  		Window.GetWindow (this).DragMove ();  	} else {  		this.downTabBoundsPoint = MouseUtilities.CorrectGetPosition (this.draggedTab);  		Canvas.SetZIndex (this.draggedTab' 1000);  		ParentTabControl.ChangeSelectedItem (this.draggedTab);  		if (isTabGrab) {  			for (int i = 0; i < this.Children.Count; i++) {  				ProcessMouseMove (new Point (p.X + 0.1' p.Y));  			}  		}  	}  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,StartTabDrag,The following statement contains a magic number: if (this.Children.Count == 1 && ParentTabControl.DragWindowWithOneTab && Mouse.LeftButton == MouseButtonState.Pressed && !isTabGrab) {  	this.draggedTab = null;  	Window.GetWindow (this).DragMove ();  } else {  	this.downTabBoundsPoint = MouseUtilities.CorrectGetPosition (this.draggedTab);  	Canvas.SetZIndex (this.draggedTab' 1000);  	ParentTabControl.ChangeSelectedItem (this.draggedTab);  	if (isTabGrab) {  		for (int i = 0; i < this.Children.Count; i++) {  			ProcessMouseMove (new Point (p.X + 0.1' p.Y));  		}  	}  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,StartTabDrag,The following statement contains a magic number: if (this.Children.Count == 1 && ParentTabControl.DragWindowWithOneTab && Mouse.LeftButton == MouseButtonState.Pressed && !isTabGrab) {  	this.draggedTab = null;  	Window.GetWindow (this).DragMove ();  } else {  	this.downTabBoundsPoint = MouseUtilities.CorrectGetPosition (this.draggedTab);  	Canvas.SetZIndex (this.draggedTab' 1000);  	ParentTabControl.ChangeSelectedItem (this.draggedTab);  	if (isTabGrab) {  		for (int i = 0; i < this.Children.Count; i++) {  			ProcessMouseMove (new Point (p.X + 0.1' p.Y));  		}  	}  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,StartTabDrag,The following statement contains a magic number: Canvas.SetZIndex (this.draggedTab' 1000);  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,StartTabDrag,The following statement contains a magic number: if (isTabGrab) {  	for (int i = 0; i < this.Children.Count; i++) {  		ProcessMouseMove (new Point (p.X + 0.1' p.Y));  	}  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,StartTabDrag,The following statement contains a magic number: for (int i = 0; i < this.Children.Count; i++) {  	ProcessMouseMove (new Point (p.X + 0.1' p.Y));  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,StartTabDrag,The following statement contains a magic number: ProcessMouseMove (new Point (p.X + 0.1' p.Y));  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: if (margin.Left != 0) {  	int guardValue = Interlocked.Increment (ref this.captureGuard);  	if (guardValue == 1) {  		this.draggedTab.Margin = margin;  		//we capture the mouse and start tab movement  		this.originalIndex = this.draggedTab.Index;  		this.slideIndex = this.originalIndex + 1;  		//Add slide intervals' the positions  where the tab slides over the next.  		this.slideIntervals = new List<double> ();  		this.slideIntervals.Add (double.NegativeInfinity);  		for (int i = 1; i <= this.Children.Count; i += 1) {  			var tab = this.Children [i - 1] as ChromeTabItem;  			var diff = i - this.slideIndex;  			var sign = diff == 0 ? 0 : diff / Math.Abs (diff);  			var bound = Math.Min (1' Math.Abs (diff)) * ((sign * GetWidthForTabItem (tab) * tabWidthSlidePercent) + ((Math.Abs (diff) < 2) ? 0 : (diff - sign) * (GetWidthForTabItem (tab) - this.Overlap)));  			this.slideIntervals.Add (bound);  		}  		this.slideIntervals.Add (double.PositiveInfinity);  		this.Dispatcher.BeginInvoke (new Action (() => {  			if (this.CaptureMouse ()) {  				Debug.WriteLine ("has mouse capture=true");  			} else  				Debug.WriteLine ("has mouse capture=false");  		}));  	} else if (this.slideIntervals != null) {  		if (insideTabPoint.X > 0 && (nowPoint.X + (this.draggedTab.ActualWidth - insideTabPoint.X)) >= this.ActualWidth) {  			return;  		} else if (insideTabPoint.X < this.downTabBoundsPoint.X && (nowPoint.X - insideTabPoint.X) <= 0) {  			return;  		}  		this.draggedTab.Margin = margin;  		//We return on small marging changes to avoid the tabs jumping around when quickly clicking between tabs.  		if (Math.Abs (this.draggedTab.Margin.Left) < 10)  			return;  		this.addButton.Visibility = System.Windows.Visibility.Hidden;  		hideAddButton = true;  		int changed = 0;  		int localSlideIndex = this.slideIndex;  		if (margin.Left < this.slideIntervals [localSlideIndex - 1]) {  			SwapSlideInterval (localSlideIndex - 1);  			localSlideIndex -= 1;  			changed = 1;  		} else if (margin.Left > this.slideIntervals [localSlideIndex + 1]) {  			SwapSlideInterval (localSlideIndex + 1);  			localSlideIndex += 1;  			changed = -1;  		}  		if (changed != 0) {  			var rightedOriginalIndex = this.originalIndex + 1;  			var diff = 1;  			if (changed > 0 && localSlideIndex >= rightedOriginalIndex) {  				changed = 0;  				diff = 0;  			} else if (changed < 0 && localSlideIndex <= rightedOriginalIndex) {  				changed = 0;  				diff = 2;  			}  			ChromeTabItem shiftedTab = this.Children [localSlideIndex - diff] as ChromeTabItem;  			if (!shiftedTab.Equals (this.draggedTab) && ((shiftedTab.IsPinned && draggedTab.IsPinned) || (!shiftedTab.IsPinned && !draggedTab.IsPinned))) {  				var offset = changed * (GetWidthForTabItem (this.draggedTab) - this.Overlap);  				StickyReanimate (shiftedTab' offset' stickyReanimateDuration);  				this.slideIndex = localSlideIndex;  			}  		}  	}  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: if (margin.Left != 0) {  	int guardValue = Interlocked.Increment (ref this.captureGuard);  	if (guardValue == 1) {  		this.draggedTab.Margin = margin;  		//we capture the mouse and start tab movement  		this.originalIndex = this.draggedTab.Index;  		this.slideIndex = this.originalIndex + 1;  		//Add slide intervals' the positions  where the tab slides over the next.  		this.slideIntervals = new List<double> ();  		this.slideIntervals.Add (double.NegativeInfinity);  		for (int i = 1; i <= this.Children.Count; i += 1) {  			var tab = this.Children [i - 1] as ChromeTabItem;  			var diff = i - this.slideIndex;  			var sign = diff == 0 ? 0 : diff / Math.Abs (diff);  			var bound = Math.Min (1' Math.Abs (diff)) * ((sign * GetWidthForTabItem (tab) * tabWidthSlidePercent) + ((Math.Abs (diff) < 2) ? 0 : (diff - sign) * (GetWidthForTabItem (tab) - this.Overlap)));  			this.slideIntervals.Add (bound);  		}  		this.slideIntervals.Add (double.PositiveInfinity);  		this.Dispatcher.BeginInvoke (new Action (() => {  			if (this.CaptureMouse ()) {  				Debug.WriteLine ("has mouse capture=true");  			} else  				Debug.WriteLine ("has mouse capture=false");  		}));  	} else if (this.slideIntervals != null) {  		if (insideTabPoint.X > 0 && (nowPoint.X + (this.draggedTab.ActualWidth - insideTabPoint.X)) >= this.ActualWidth) {  			return;  		} else if (insideTabPoint.X < this.downTabBoundsPoint.X && (nowPoint.X - insideTabPoint.X) <= 0) {  			return;  		}  		this.draggedTab.Margin = margin;  		//We return on small marging changes to avoid the tabs jumping around when quickly clicking between tabs.  		if (Math.Abs (this.draggedTab.Margin.Left) < 10)  			return;  		this.addButton.Visibility = System.Windows.Visibility.Hidden;  		hideAddButton = true;  		int changed = 0;  		int localSlideIndex = this.slideIndex;  		if (margin.Left < this.slideIntervals [localSlideIndex - 1]) {  			SwapSlideInterval (localSlideIndex - 1);  			localSlideIndex -= 1;  			changed = 1;  		} else if (margin.Left > this.slideIntervals [localSlideIndex + 1]) {  			SwapSlideInterval (localSlideIndex + 1);  			localSlideIndex += 1;  			changed = -1;  		}  		if (changed != 0) {  			var rightedOriginalIndex = this.originalIndex + 1;  			var diff = 1;  			if (changed > 0 && localSlideIndex >= rightedOriginalIndex) {  				changed = 0;  				diff = 0;  			} else if (changed < 0 && localSlideIndex <= rightedOriginalIndex) {  				changed = 0;  				diff = 2;  			}  			ChromeTabItem shiftedTab = this.Children [localSlideIndex - diff] as ChromeTabItem;  			if (!shiftedTab.Equals (this.draggedTab) && ((shiftedTab.IsPinned && draggedTab.IsPinned) || (!shiftedTab.IsPinned && !draggedTab.IsPinned))) {  				var offset = changed * (GetWidthForTabItem (this.draggedTab) - this.Overlap);  				StickyReanimate (shiftedTab' offset' stickyReanimateDuration);  				this.slideIndex = localSlideIndex;  			}  		}  	}  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: if (margin.Left != 0) {  	int guardValue = Interlocked.Increment (ref this.captureGuard);  	if (guardValue == 1) {  		this.draggedTab.Margin = margin;  		//we capture the mouse and start tab movement  		this.originalIndex = this.draggedTab.Index;  		this.slideIndex = this.originalIndex + 1;  		//Add slide intervals' the positions  where the tab slides over the next.  		this.slideIntervals = new List<double> ();  		this.slideIntervals.Add (double.NegativeInfinity);  		for (int i = 1; i <= this.Children.Count; i += 1) {  			var tab = this.Children [i - 1] as ChromeTabItem;  			var diff = i - this.slideIndex;  			var sign = diff == 0 ? 0 : diff / Math.Abs (diff);  			var bound = Math.Min (1' Math.Abs (diff)) * ((sign * GetWidthForTabItem (tab) * tabWidthSlidePercent) + ((Math.Abs (diff) < 2) ? 0 : (diff - sign) * (GetWidthForTabItem (tab) - this.Overlap)));  			this.slideIntervals.Add (bound);  		}  		this.slideIntervals.Add (double.PositiveInfinity);  		this.Dispatcher.BeginInvoke (new Action (() => {  			if (this.CaptureMouse ()) {  				Debug.WriteLine ("has mouse capture=true");  			} else  				Debug.WriteLine ("has mouse capture=false");  		}));  	} else if (this.slideIntervals != null) {  		if (insideTabPoint.X > 0 && (nowPoint.X + (this.draggedTab.ActualWidth - insideTabPoint.X)) >= this.ActualWidth) {  			return;  		} else if (insideTabPoint.X < this.downTabBoundsPoint.X && (nowPoint.X - insideTabPoint.X) <= 0) {  			return;  		}  		this.draggedTab.Margin = margin;  		//We return on small marging changes to avoid the tabs jumping around when quickly clicking between tabs.  		if (Math.Abs (this.draggedTab.Margin.Left) < 10)  			return;  		this.addButton.Visibility = System.Windows.Visibility.Hidden;  		hideAddButton = true;  		int changed = 0;  		int localSlideIndex = this.slideIndex;  		if (margin.Left < this.slideIntervals [localSlideIndex - 1]) {  			SwapSlideInterval (localSlideIndex - 1);  			localSlideIndex -= 1;  			changed = 1;  		} else if (margin.Left > this.slideIntervals [localSlideIndex + 1]) {  			SwapSlideInterval (localSlideIndex + 1);  			localSlideIndex += 1;  			changed = -1;  		}  		if (changed != 0) {  			var rightedOriginalIndex = this.originalIndex + 1;  			var diff = 1;  			if (changed > 0 && localSlideIndex >= rightedOriginalIndex) {  				changed = 0;  				diff = 0;  			} else if (changed < 0 && localSlideIndex <= rightedOriginalIndex) {  				changed = 0;  				diff = 2;  			}  			ChromeTabItem shiftedTab = this.Children [localSlideIndex - diff] as ChromeTabItem;  			if (!shiftedTab.Equals (this.draggedTab) && ((shiftedTab.IsPinned && draggedTab.IsPinned) || (!shiftedTab.IsPinned && !draggedTab.IsPinned))) {  				var offset = changed * (GetWidthForTabItem (this.draggedTab) - this.Overlap);  				StickyReanimate (shiftedTab' offset' stickyReanimateDuration);  				this.slideIndex = localSlideIndex;  			}  		}  	}  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: if (guardValue == 1) {  	this.draggedTab.Margin = margin;  	//we capture the mouse and start tab movement  	this.originalIndex = this.draggedTab.Index;  	this.slideIndex = this.originalIndex + 1;  	//Add slide intervals' the positions  where the tab slides over the next.  	this.slideIntervals = new List<double> ();  	this.slideIntervals.Add (double.NegativeInfinity);  	for (int i = 1; i <= this.Children.Count; i += 1) {  		var tab = this.Children [i - 1] as ChromeTabItem;  		var diff = i - this.slideIndex;  		var sign = diff == 0 ? 0 : diff / Math.Abs (diff);  		var bound = Math.Min (1' Math.Abs (diff)) * ((sign * GetWidthForTabItem (tab) * tabWidthSlidePercent) + ((Math.Abs (diff) < 2) ? 0 : (diff - sign) * (GetWidthForTabItem (tab) - this.Overlap)));  		this.slideIntervals.Add (bound);  	}  	this.slideIntervals.Add (double.PositiveInfinity);  	this.Dispatcher.BeginInvoke (new Action (() => {  		if (this.CaptureMouse ()) {  			Debug.WriteLine ("has mouse capture=true");  		} else  			Debug.WriteLine ("has mouse capture=false");  	}));  } else if (this.slideIntervals != null) {  	if (insideTabPoint.X > 0 && (nowPoint.X + (this.draggedTab.ActualWidth - insideTabPoint.X)) >= this.ActualWidth) {  		return;  	} else if (insideTabPoint.X < this.downTabBoundsPoint.X && (nowPoint.X - insideTabPoint.X) <= 0) {  		return;  	}  	this.draggedTab.Margin = margin;  	//We return on small marging changes to avoid the tabs jumping around when quickly clicking between tabs.  	if (Math.Abs (this.draggedTab.Margin.Left) < 10)  		return;  	this.addButton.Visibility = System.Windows.Visibility.Hidden;  	hideAddButton = true;  	int changed = 0;  	int localSlideIndex = this.slideIndex;  	if (margin.Left < this.slideIntervals [localSlideIndex - 1]) {  		SwapSlideInterval (localSlideIndex - 1);  		localSlideIndex -= 1;  		changed = 1;  	} else if (margin.Left > this.slideIntervals [localSlideIndex + 1]) {  		SwapSlideInterval (localSlideIndex + 1);  		localSlideIndex += 1;  		changed = -1;  	}  	if (changed != 0) {  		var rightedOriginalIndex = this.originalIndex + 1;  		var diff = 1;  		if (changed > 0 && localSlideIndex >= rightedOriginalIndex) {  			changed = 0;  			diff = 0;  		} else if (changed < 0 && localSlideIndex <= rightedOriginalIndex) {  			changed = 0;  			diff = 2;  		}  		ChromeTabItem shiftedTab = this.Children [localSlideIndex - diff] as ChromeTabItem;  		if (!shiftedTab.Equals (this.draggedTab) && ((shiftedTab.IsPinned && draggedTab.IsPinned) || (!shiftedTab.IsPinned && !draggedTab.IsPinned))) {  			var offset = changed * (GetWidthForTabItem (this.draggedTab) - this.Overlap);  			StickyReanimate (shiftedTab' offset' stickyReanimateDuration);  			this.slideIndex = localSlideIndex;  		}  	}  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: if (guardValue == 1) {  	this.draggedTab.Margin = margin;  	//we capture the mouse and start tab movement  	this.originalIndex = this.draggedTab.Index;  	this.slideIndex = this.originalIndex + 1;  	//Add slide intervals' the positions  where the tab slides over the next.  	this.slideIntervals = new List<double> ();  	this.slideIntervals.Add (double.NegativeInfinity);  	for (int i = 1; i <= this.Children.Count; i += 1) {  		var tab = this.Children [i - 1] as ChromeTabItem;  		var diff = i - this.slideIndex;  		var sign = diff == 0 ? 0 : diff / Math.Abs (diff);  		var bound = Math.Min (1' Math.Abs (diff)) * ((sign * GetWidthForTabItem (tab) * tabWidthSlidePercent) + ((Math.Abs (diff) < 2) ? 0 : (diff - sign) * (GetWidthForTabItem (tab) - this.Overlap)));  		this.slideIntervals.Add (bound);  	}  	this.slideIntervals.Add (double.PositiveInfinity);  	this.Dispatcher.BeginInvoke (new Action (() => {  		if (this.CaptureMouse ()) {  			Debug.WriteLine ("has mouse capture=true");  		} else  			Debug.WriteLine ("has mouse capture=false");  	}));  } else if (this.slideIntervals != null) {  	if (insideTabPoint.X > 0 && (nowPoint.X + (this.draggedTab.ActualWidth - insideTabPoint.X)) >= this.ActualWidth) {  		return;  	} else if (insideTabPoint.X < this.downTabBoundsPoint.X && (nowPoint.X - insideTabPoint.X) <= 0) {  		return;  	}  	this.draggedTab.Margin = margin;  	//We return on small marging changes to avoid the tabs jumping around when quickly clicking between tabs.  	if (Math.Abs (this.draggedTab.Margin.Left) < 10)  		return;  	this.addButton.Visibility = System.Windows.Visibility.Hidden;  	hideAddButton = true;  	int changed = 0;  	int localSlideIndex = this.slideIndex;  	if (margin.Left < this.slideIntervals [localSlideIndex - 1]) {  		SwapSlideInterval (localSlideIndex - 1);  		localSlideIndex -= 1;  		changed = 1;  	} else if (margin.Left > this.slideIntervals [localSlideIndex + 1]) {  		SwapSlideInterval (localSlideIndex + 1);  		localSlideIndex += 1;  		changed = -1;  	}  	if (changed != 0) {  		var rightedOriginalIndex = this.originalIndex + 1;  		var diff = 1;  		if (changed > 0 && localSlideIndex >= rightedOriginalIndex) {  			changed = 0;  			diff = 0;  		} else if (changed < 0 && localSlideIndex <= rightedOriginalIndex) {  			changed = 0;  			diff = 2;  		}  		ChromeTabItem shiftedTab = this.Children [localSlideIndex - diff] as ChromeTabItem;  		if (!shiftedTab.Equals (this.draggedTab) && ((shiftedTab.IsPinned && draggedTab.IsPinned) || (!shiftedTab.IsPinned && !draggedTab.IsPinned))) {  			var offset = changed * (GetWidthForTabItem (this.draggedTab) - this.Overlap);  			StickyReanimate (shiftedTab' offset' stickyReanimateDuration);  			this.slideIndex = localSlideIndex;  		}  	}  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: if (guardValue == 1) {  	this.draggedTab.Margin = margin;  	//we capture the mouse and start tab movement  	this.originalIndex = this.draggedTab.Index;  	this.slideIndex = this.originalIndex + 1;  	//Add slide intervals' the positions  where the tab slides over the next.  	this.slideIntervals = new List<double> ();  	this.slideIntervals.Add (double.NegativeInfinity);  	for (int i = 1; i <= this.Children.Count; i += 1) {  		var tab = this.Children [i - 1] as ChromeTabItem;  		var diff = i - this.slideIndex;  		var sign = diff == 0 ? 0 : diff / Math.Abs (diff);  		var bound = Math.Min (1' Math.Abs (diff)) * ((sign * GetWidthForTabItem (tab) * tabWidthSlidePercent) + ((Math.Abs (diff) < 2) ? 0 : (diff - sign) * (GetWidthForTabItem (tab) - this.Overlap)));  		this.slideIntervals.Add (bound);  	}  	this.slideIntervals.Add (double.PositiveInfinity);  	this.Dispatcher.BeginInvoke (new Action (() => {  		if (this.CaptureMouse ()) {  			Debug.WriteLine ("has mouse capture=true");  		} else  			Debug.WriteLine ("has mouse capture=false");  	}));  } else if (this.slideIntervals != null) {  	if (insideTabPoint.X > 0 && (nowPoint.X + (this.draggedTab.ActualWidth - insideTabPoint.X)) >= this.ActualWidth) {  		return;  	} else if (insideTabPoint.X < this.downTabBoundsPoint.X && (nowPoint.X - insideTabPoint.X) <= 0) {  		return;  	}  	this.draggedTab.Margin = margin;  	//We return on small marging changes to avoid the tabs jumping around when quickly clicking between tabs.  	if (Math.Abs (this.draggedTab.Margin.Left) < 10)  		return;  	this.addButton.Visibility = System.Windows.Visibility.Hidden;  	hideAddButton = true;  	int changed = 0;  	int localSlideIndex = this.slideIndex;  	if (margin.Left < this.slideIntervals [localSlideIndex - 1]) {  		SwapSlideInterval (localSlideIndex - 1);  		localSlideIndex -= 1;  		changed = 1;  	} else if (margin.Left > this.slideIntervals [localSlideIndex + 1]) {  		SwapSlideInterval (localSlideIndex + 1);  		localSlideIndex += 1;  		changed = -1;  	}  	if (changed != 0) {  		var rightedOriginalIndex = this.originalIndex + 1;  		var diff = 1;  		if (changed > 0 && localSlideIndex >= rightedOriginalIndex) {  			changed = 0;  			diff = 0;  		} else if (changed < 0 && localSlideIndex <= rightedOriginalIndex) {  			changed = 0;  			diff = 2;  		}  		ChromeTabItem shiftedTab = this.Children [localSlideIndex - diff] as ChromeTabItem;  		if (!shiftedTab.Equals (this.draggedTab) && ((shiftedTab.IsPinned && draggedTab.IsPinned) || (!shiftedTab.IsPinned && !draggedTab.IsPinned))) {  			var offset = changed * (GetWidthForTabItem (this.draggedTab) - this.Overlap);  			StickyReanimate (shiftedTab' offset' stickyReanimateDuration);  			this.slideIndex = localSlideIndex;  		}  	}  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: for (int i = 1; i <= this.Children.Count; i += 1) {  	var tab = this.Children [i - 1] as ChromeTabItem;  	var diff = i - this.slideIndex;  	var sign = diff == 0 ? 0 : diff / Math.Abs (diff);  	var bound = Math.Min (1' Math.Abs (diff)) * ((sign * GetWidthForTabItem (tab) * tabWidthSlidePercent) + ((Math.Abs (diff) < 2) ? 0 : (diff - sign) * (GetWidthForTabItem (tab) - this.Overlap)));  	this.slideIntervals.Add (bound);  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: if (this.slideIntervals != null) {  	if (insideTabPoint.X > 0 && (nowPoint.X + (this.draggedTab.ActualWidth - insideTabPoint.X)) >= this.ActualWidth) {  		return;  	} else if (insideTabPoint.X < this.downTabBoundsPoint.X && (nowPoint.X - insideTabPoint.X) <= 0) {  		return;  	}  	this.draggedTab.Margin = margin;  	//We return on small marging changes to avoid the tabs jumping around when quickly clicking between tabs.  	if (Math.Abs (this.draggedTab.Margin.Left) < 10)  		return;  	this.addButton.Visibility = System.Windows.Visibility.Hidden;  	hideAddButton = true;  	int changed = 0;  	int localSlideIndex = this.slideIndex;  	if (margin.Left < this.slideIntervals [localSlideIndex - 1]) {  		SwapSlideInterval (localSlideIndex - 1);  		localSlideIndex -= 1;  		changed = 1;  	} else if (margin.Left > this.slideIntervals [localSlideIndex + 1]) {  		SwapSlideInterval (localSlideIndex + 1);  		localSlideIndex += 1;  		changed = -1;  	}  	if (changed != 0) {  		var rightedOriginalIndex = this.originalIndex + 1;  		var diff = 1;  		if (changed > 0 && localSlideIndex >= rightedOriginalIndex) {  			changed = 0;  			diff = 0;  		} else if (changed < 0 && localSlideIndex <= rightedOriginalIndex) {  			changed = 0;  			diff = 2;  		}  		ChromeTabItem shiftedTab = this.Children [localSlideIndex - diff] as ChromeTabItem;  		if (!shiftedTab.Equals (this.draggedTab) && ((shiftedTab.IsPinned && draggedTab.IsPinned) || (!shiftedTab.IsPinned && !draggedTab.IsPinned))) {  			var offset = changed * (GetWidthForTabItem (this.draggedTab) - this.Overlap);  			StickyReanimate (shiftedTab' offset' stickyReanimateDuration);  			this.slideIndex = localSlideIndex;  		}  	}  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: if (this.slideIntervals != null) {  	if (insideTabPoint.X > 0 && (nowPoint.X + (this.draggedTab.ActualWidth - insideTabPoint.X)) >= this.ActualWidth) {  		return;  	} else if (insideTabPoint.X < this.downTabBoundsPoint.X && (nowPoint.X - insideTabPoint.X) <= 0) {  		return;  	}  	this.draggedTab.Margin = margin;  	//We return on small marging changes to avoid the tabs jumping around when quickly clicking between tabs.  	if (Math.Abs (this.draggedTab.Margin.Left) < 10)  		return;  	this.addButton.Visibility = System.Windows.Visibility.Hidden;  	hideAddButton = true;  	int changed = 0;  	int localSlideIndex = this.slideIndex;  	if (margin.Left < this.slideIntervals [localSlideIndex - 1]) {  		SwapSlideInterval (localSlideIndex - 1);  		localSlideIndex -= 1;  		changed = 1;  	} else if (margin.Left > this.slideIntervals [localSlideIndex + 1]) {  		SwapSlideInterval (localSlideIndex + 1);  		localSlideIndex += 1;  		changed = -1;  	}  	if (changed != 0) {  		var rightedOriginalIndex = this.originalIndex + 1;  		var diff = 1;  		if (changed > 0 && localSlideIndex >= rightedOriginalIndex) {  			changed = 0;  			diff = 0;  		} else if (changed < 0 && localSlideIndex <= rightedOriginalIndex) {  			changed = 0;  			diff = 2;  		}  		ChromeTabItem shiftedTab = this.Children [localSlideIndex - diff] as ChromeTabItem;  		if (!shiftedTab.Equals (this.draggedTab) && ((shiftedTab.IsPinned && draggedTab.IsPinned) || (!shiftedTab.IsPinned && !draggedTab.IsPinned))) {  			var offset = changed * (GetWidthForTabItem (this.draggedTab) - this.Overlap);  			StickyReanimate (shiftedTab' offset' stickyReanimateDuration);  			this.slideIndex = localSlideIndex;  		}  	}  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: if (Math.Abs (this.draggedTab.Margin.Left) < 10)  	return;  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: if (changed != 0) {  	var rightedOriginalIndex = this.originalIndex + 1;  	var diff = 1;  	if (changed > 0 && localSlideIndex >= rightedOriginalIndex) {  		changed = 0;  		diff = 0;  	} else if (changed < 0 && localSlideIndex <= rightedOriginalIndex) {  		changed = 0;  		diff = 2;  	}  	ChromeTabItem shiftedTab = this.Children [localSlideIndex - diff] as ChromeTabItem;  	if (!shiftedTab.Equals (this.draggedTab) && ((shiftedTab.IsPinned && draggedTab.IsPinned) || (!shiftedTab.IsPinned && !draggedTab.IsPinned))) {  		var offset = changed * (GetWidthForTabItem (this.draggedTab) - this.Overlap);  		StickyReanimate (shiftedTab' offset' stickyReanimateDuration);  		this.slideIndex = localSlideIndex;  	}  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: if (changed > 0 && localSlideIndex >= rightedOriginalIndex) {  	changed = 0;  	diff = 0;  } else if (changed < 0 && localSlideIndex <= rightedOriginalIndex) {  	changed = 0;  	diff = 2;  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: if (changed < 0 && localSlideIndex <= rightedOriginalIndex) {  	changed = 0;  	diff = 2;  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,ProcessMouseMove,The following statement contains a magic number: diff = 2;  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,OnPreviewMouseMove,The following statement contains a magic number: if (this.draggedTab == null || DateTime.UtcNow.Subtract (lastMouseDown).TotalMilliseconds < 50) {  	return;  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,OnPreviewMouseMove,The following statement contains a magic number: if (isOutsideTabPanel == true && Mouse.LeftButton == MouseButtonState.Pressed) {  	object viewmodel = draggedTab.Content;  	RaiseEvent (new TabDragEventArgs (ChromeTabControl.TabDraggedOutsideBondsEvent' this' viewmodel' this.PointToScreen (e.GetPosition (this))));  	OnTabRelease (e.GetPosition (this)' ParentTabControl.CloseTabWhenDraggedOutsideBonds' 0.01);  	//If we set it to 0 the completed event never fires' so we set it to a small decimal.  }  
Magic Number,ChromeTabs,ChromeTabPanel,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabPanel.cs,OnPreviewMouseMove,The following statement contains a magic number: OnTabRelease (e.GetPosition (this)' ParentTabControl.CloseTabWhenDraggedOutsideBonds' 0.01);  
Missing Default,ChromeTabs,ChromeTabControl,D:\newReposJune17\sskodje_wpfchrometabs-mvvm\ChromeTabs\ChromeTabControl.cs,OnItemsChanged,The following switch statement is missing a default case: switch (e.Action) {  case NotifyCollectionChangedAction.Replace:  case NotifyCollectionChangedAction.Reset:  	{  		var itemsToRemove = itemsHolder.Children.Cast<ContentPresenter> ().Where (x => !Items.Contains (x.Content)).ToList ();  		foreach (var item in itemsToRemove)  			itemsHolder.Children.Remove (item);  	}  	break;  case NotifyCollectionChangedAction.Add:  	{  		// don't do anything with new items not created by the add button' because we don't want to  		// create visuals that aren't being shown.  		if (_addTabButtonClicked && AddTabButtonBehavior == AddTabButtonBehavior.OpenNewTab) {  			_addTabButtonClicked = false;  			if (e.NewItems != null)  				ChangeSelectedItem (AsTabItem (e.NewItems.Cast<object> ().Last ()));  		}  	}  	break;  case NotifyCollectionChangedAction.Remove:  	if (e.OldItems != null) {  		foreach (var item in e.OldItems) {  			ContentPresenter cp = FindChildContentPresenter (item);  			if (cp != null) {  				itemsHolder.Children.Remove (cp);  			}  		}  	}  	break;  }  
