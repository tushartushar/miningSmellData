Implementation smell,Namespace,Class,File,Method,Description
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The method has 126 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The method has 276 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,QSort3,The method has 104 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The method has 165 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,FullGtU,The method has 109 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The method has 116 lines of code.
Long Method,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadHeader,The method has 129 lines of code.
Long Method,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,Read,The method has 169 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The method has 110 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The method has 103 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The method has 108 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The method has 188 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,RunUpdates,The method has 103 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The method has 131 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The method has 164 lines of code.
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,HbCreateDecodeTables,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,Cyclomatic complexity of the method is 58
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SimpleSort,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,QSort3,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,Cyclomatic complexity of the method is 21
Complex Method,ICSharpCode.SharpZipLib.Checksum,Adler32,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Checksum\Adler32.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Core,FileSystemScanner,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Core\FileSystemScanner.cs,ScanDir,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Core\StreamUtils.cs,Copy,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadHeader,Cyclomatic complexity of the method is 27
Complex Method,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarArchive.cs,WriteEntryCore,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Tar,TarInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarInputStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Tar,TarOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarOutputStream.cs,Write,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractFileEntry,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractEntry,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,WindowsNameTransform,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\WindowsNameTransform.cs,MakeValidName,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestArchive,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,BeginUpdate,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteLocalEntryHeader,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteCentralDirectoryHeader,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,RunUpdates,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteLocalHeader,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,InitialRead,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,Cyclomatic complexity of the method is 26
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,CloseEntry,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,Finish,Cyclomatic complexity of the method is 18
Long Parameter List,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,HbCreateDecodeTables,The method has 7 parameters. Parameters: limit' baseArray' perm' length' minLen' maxLen' alphaSize
Long Parameter List,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,HbAssignCodes,The method has 5 parameters. Parameters: code' length' minLen' maxLen' alphaSize
Long Parameter List,ICSharpCode.SharpZipLib.Core,ExtendedPathFilter,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Core\PathFilter.cs,ExtendedPathFilter,The method has 5 parameters. Parameters: filter' minSize' maxSize' minDate' maxDate
Long Parameter List,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Core\StreamUtils.cs,Copy,The method has 7 parameters. Parameters: source' destination' buffer' progressHandler' updateInterval' sender' name
Long Parameter List,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Core\StreamUtils.cs,Copy,The method has 8 parameters. Parameters: source' destination' buffer' progressHandler' updateInterval' sender' name' fixedTarget
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,PkzipClassicEncryptCryptoTransform,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,PkzipClassicDecryptCryptoTransform,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\ZipAESTransform.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarHeader.cs,GetNameBytes,The method has 5 parameters. Parameters: name' nameOffset' buffer' bufferOffset' length
Long Parameter List,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarHeader.cs,GetNameBytes,The method has 5 parameters. Parameters: name' nameOffset' buffer' bufferOffset' length
Long Parameter List,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarHeader.cs,GetAsciiBytes,The method has 5 parameters. Parameters: toAdd' nameOffset' buffer' bufferOffset' length
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\FastZip.cs,CreateZip,The method has 5 parameters. Parameters: zipFileName' sourceDirectory' recurse' fileFilter' directoryFilter
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\FastZip.cs,CreateZip,The method has 5 parameters. Parameters: outputStream' sourceDirectory' recurse' fileFilter' directoryFilter
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractZip,The method has 7 parameters. Parameters: zipFileName' targetDirectory' overwrite' confirmDelegate' fileFilter' directoryFilter' restoreDateTime
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractZip,The method has 8 parameters. Parameters: inputStream' targetDirectory' overwrite' confirmDelegate' fileFilter' directoryFilter' restoreDateTime' isStreamOwner
Long Parameter List,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CopyBytes,The method has 5 parameters. Parameters: update' destination' source' bytesToCopy' updateCrc
Long Parameter List,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CopyEntryDataDirect,The method has 5 parameters. Parameters: update' stream' updateCrc' destinationPosition' sourcePosition
Long Identifier,ICSharpCode.SharpZipLib.Zip,ZipConstants,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipConstants.cs,,The length of the parameter Zip64CentralFileHeaderSignature is 31.
Long Identifier,ICSharpCode.SharpZipLib.Zip,ZipConstants,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipConstants.cs,,The length of the parameter Zip64CentralDirLocatorSignature is 31.
Long Identifier,ICSharpCode.SharpZipLib.Zip,ZipConstants,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipConstants.cs,,The length of the parameter EndOfCentralDirectorySignature is 30.
Long Identifier,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,UpdateCommentOnly,The length of the parameter CentralHeaderCommentSizeOffset is 30.
Long Statement,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The length of the statement  "						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) { " is 129.
Long Statement,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The length of the statement  "						(int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff))); " is 125.
Long Statement,ICSharpCode.SharpZipLib.Encryption,ZipAESStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\ZipAESStream.cs,Read,The length of the statement  "							throw new Exception("AES Authentication Code does not match. This is a super-CRC check on the data in the file after compression and encryption. \r\n" " is 150.
Long Statement,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipOutputStream.cs,WriteHeader,The length of the statement  "				var mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals " is 124.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarBuffer.cs,WriteBlock,The length of the statement  "				string errorText = string.Format("TarBuffer.WriteBlock - block to write has length '{0}' which is not the block size of '{1}'"' " is 127.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarBuffer.cs,WriteBlock,The length of the statement  "				string errorText = string.Format("TarBuffer.WriteBlock - record has length '{0}' with offset '{1}' which is less than the record size of '{2}'"' " is 144.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarHeader.cs,ParseBinaryOrOctal,The length of the statement  "				// File sizes over 8GB are stored in 8 right-justified bytes of binary indicated by setting the high-order bit of the leftmost byte of a numeric field. " is 151.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarHeader.cs,GetAsciiBytes,The length of the statement  "			// If length is beyond the toAdd string length (which is OK by the prev loop condition)' eg if a field has fixed length and the string is shorter' make sure all of the extra chars are written as NULLs' so that the reader func would ignore them and get back the original string " is 276.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarOutputStream.cs,PutNextEntry,The length of the statement  "				while (nameCharIndex < entry.TarHeader.Name.Length + 1 /* we've allocated one for the null char' now we must make sure it gets written out */) { " is 144.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarOutputStream.cs,PutNextEntry,The length of the statement  "					TarHeader.GetAsciiBytes(entry.TarHeader.Name' nameCharIndex' this.blockBuffer' 0' TarBuffer.BlockSize); // This func handles OK the extra char out of string length " is 163.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,InsertString,The length of the statement  "			int hash = ((ins_h << DeflaterConstants.HASH_SHIFT) ^ window[strstart + (DeflaterConstants.MIN_MATCH - 1)]) & DeflaterConstants.HASH_MASK; " is 138.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateStored,The length of the statement  "				(blockStart < DeflaterConstants.WSIZE && storedLength >= DeflaterConstants.MAX_DIST) ||   // Block may move out of window " is 121.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The length of the statement  "						if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == DeflaterConstants.MIN_MATCH && strstart - matchStart > TooFar))) { " is 141.
Long Statement,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractZip,The length of the statement  "			ExtractZip(inputStream' targetDirectory' overwrite' confirmDelegate' fileFilter' directoryFilter' restoreDateTime' true); " is 121.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The length of the statement  "				// (localHeader ||) was deleted' because actually there is no specific difference with reading sizes between local header & central directory  " is 141.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,FindEntry,The length of the statement  "				if (string.Compare(name' entries_[i].Name' ignoreCase ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal) == 0) { " is 126.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) { " is 158.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) { " is 135.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion)); " is 128.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion)); " is 128.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The length of the statement  "				long offset = LocateBlockWithSignature(ZipConstants.Zip64CentralDirLocatorSignature' locatedEndOfCentralDir' 0' 0x1000); " is 120.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The length of the statement  "			if (method == (int)CompressionMethod.Stored && (!isCrypted && csize != size || (isCrypted && csize - ZipConstants.CryptoHeaderSize != size))) { " is 143.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,Initialize,The conditional expression  "magic1 != 'B' || magic2 != 'Z' || magic3 != 'h' || magic4 < '1' || magic4 > '9'"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,InitBlock,The conditional expression  "magic1 == 0x17 && magic2 == 0x72 && magic3 == 0x45 && magic4 == 0x38 && magic5 == 0x50 && magic6 == 0x90"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,InitBlock,The conditional expression  "magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59 || magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,SetDecompressStructureSizes,The conditional expression  "!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The conditional expression  "ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,AllocateCompressStructures,The conditional expression  "block == null || quadrant == null || zptr == null || ftab == null"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The conditional expression  "(index <= path.Length) &&  							(((path[index] != '\\') && (path[index] != '/')) || (--elements > 0))"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarArchive.cs,IsBinary,The conditional expression  "(b < 8) || ((b > 13) && (b < 32)) || (b == 255)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Tar,TarInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarInputStream.cs,GetNextEntry,The conditional expression  "header.TypeFlag != TarHeader.LF_NORMAL &&  							   header.TypeFlag != TarHeader.LF_OLDNORM &&  							   header.TypeFlag != TarHeader.LF_LINK &&  							   header.TypeFlag != TarHeader.LF_SYMLINK &&  							   header.TypeFlag != TarHeader.LF_DIR"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The conditional expression  "window[match + matchLen] != scan_end               || window[match + matchLen - 1] != scan_end1               || window[match] != window[scan]               || window[++match] != window[++scan]"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The conditional expression  "window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The conditional expression  "window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The conditional expression  "window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The conditional expression  "window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateStored,The conditional expression  "(storedLength >= DeflaterConstants.MAX_BLOCK_SIZE) || // Block is full  				(blockStart < DeflaterConstants.WSIZE && storedLength >= DeflaterConstants.MAX_DIST) ||   // Block may move out of window  				flush"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,The conditional expression  "lookahead >= DeflaterConstants.MIN_MATCH &&  					(hashHead = InsertString()) != 0 &&  					strategy != DeflateStrategy.HuffmanOnly &&  					strstart - hashHead <= DeflaterConstants.MAX_DIST &&  					FindLongestMatch(hashHead)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "strategy != DeflateStrategy.HuffmanOnly &&  						hashHead != 0 &&  						strstart - hashHead <= DeflaterConstants.MAX_DIST &&  						FindLongestMatch(hashHead)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == DeflaterConstants.MIN_MATCH && strstart - matchStart > TooFar))"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,GetDateTime,The conditional expression  "unixData != null &&  				// Only apply modification time' but require all other values to be present  				// This is done to match InfoZIP's behaviour  				((unixData.Include & ExtendedUnixData.Flags.ModificationTime) != 0) &&  				((unixData.Include & ExtendedUnixData.Flags.AccessTime) != 0) &&  				((unixData.Include & ExtendedUnixData.Flags.CreateTime) != 0)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The conditional expression  "(extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The conditional expression  "((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The conditional expression  "(compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The conditional expression  "(thisDiskNumber == 0xffff) ||  				(startCentralDirDisk == 0xffff) ||  				(entriesForThisDisk == 0xffff) ||  				(entriesForWholeCentralDir == 0xffff) ||  				(centralDirSize == 0xffffffff) ||  				(offsetOfCentralDir == 0xffffffff)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The conditional expression  "header == ZipConstants.CentralHeaderSignature ||  				header == ZipConstants.EndOfCentralDirectorySignature ||  				header == ZipConstants.CentralHeaderDigitalSignature ||  				header == ZipConstants.ArchiveExtraDataSignature ||  				header == ZipConstants.Zip64CentralFileHeaderSignature"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The conditional expression  "method == (int)CompressionMethod.Stored && (!isCrypted && csize != size || (isCrypted && csize - ZipConstants.CryptoHeaderSize != size))"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,BodyRead,The conditional expression  "(flags & 8) == 0 &&  							(inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)"  is complex.
Empty Catch Block,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,Dispose,The method has an empty catch block.
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2.cs,Decompress,The following statement contains a magic number: try {  				using (BZip2InputStream bzipInput = new BZip2InputStream(inStream)) {  					bzipInput.IsStreamOwner = isStreamOwner;  					Core.StreamUtils.Copy(bzipInput' outStream' new byte[4096]);  				}  			} finally {  				if (isStreamOwner) {  					// inStream is closed by the BZip2InputStream if stream owner  					outStream.Dispose();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2.cs,Compress,The following statement contains a magic number: try {  				using (BZip2OutputStream bzipOutput = new BZip2OutputStream(outStream' level)) {  					bzipOutput.IsStreamOwner = isStreamOwner;  					Core.StreamUtils.Copy(inStream' bzipOutput' new byte[4096]);  				}  			} finally {  				if (isStreamOwner) {  					// outStream is closed by the BZip2OutputStream if stream owner  					inStream.Dispose();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,MakeMaps,The following statement contains a magic number: for (int i = 0; i < 256; ++i) {  				if (inUse[i]) {  					seqToUnseq[nInUse] = (byte)i;  					unseqToSeq[i] = (byte)nInUse;  					nInUse++;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,EndBlock,The following statement contains a magic number: computedCombinedCRC = ((computedCombinedCRC << 1) & 0xFFFFFFFF) | (computedCombinedCRC >> 31);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,FillBuffer,The following statement contains a magic number: bsBuff = (bsBuff << 8) | (thech & 0xFF);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,FillBuffer,The following statement contains a magic number: bsLive += 8;
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,BsGetUChar,The following statement contains a magic number: return (char)BsR(8);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,BsGetInt32,The following statement contains a magic number: int result = BsR(8);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,BsGetInt32,The following statement contains a magic number: result = (result << 8) | BsR(8);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: bool[] inUse16 = new bool[16];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				inUse16[i] = (BsR(1) == 1);  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				if (inUse16[i]) {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = (BsR(1) == 1);  					}  				} else {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = false;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				if (inUse16[i]) {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = (BsR(1) == 1);  					}  				} else {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = false;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				if (inUse16[i]) {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = (BsR(1) == 1);  					}  				} else {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = false;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				if (inUse16[i]) {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = (BsR(1) == 1);  					}  				} else {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = false;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				if (inUse16[i]) {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = (BsR(1) == 1);  					}  				} else {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = false;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: int alphaSize = nInUse + 2;
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: int nGroups = BsR(3);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: int nSelectors = BsR(15);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int t = 0; t < nGroups; t++) {  				int curr = BsR(5);  				for (int i = 0; i < alphaSize; i++) {  					while (BsR(1) == 1) {  						if (BsR(1) == 0) {  							curr++;  						} else {  							curr--;  						}  					}  					len[t][i] = (char)curr;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int t = 0; t < nGroups; t++) {  				int minLen = 32;  				int maxLen = 0;  				for (int i = 0; i < alphaSize; i++) {  					maxLen = Math.Max(maxLen' len[t][i]);  					minLen = Math.Min(minLen' len[t][i]);  				}  				HbCreateDecodeTables(limit[t]' baseArray[t]' perm[t]' len[t]' minLen' maxLen' alphaSize);  				minLens[t] = minLen;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: byte[] yy = new byte[256];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: origPtr = BsGetIntVS(24);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: for (int i = 0; i <= 255; i++) {  				unzftab[i] = 0;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: for (int i = 0; i <= 255; i++) {  				yy[i] = (byte)i;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: while (zvec > limit[zt][zn]) {  				if (zn > 20) { // the longest code  					throw new BZip2Exception("Bzip data error");  				}  				zn++;  				while (bsLive < 1) {  					FillBuffer();  				}  				zj = (bsBuff >> (bsLive - 1)) & 1;  				bsLive--;  				zvec = (zvec << 1) | zj;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: int[] cftab = new int[257];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: Array.Copy(unzftab' 0' cftab' 1' 256);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: for (int i = 1; i <= 256; i++) {  				cftab[i] += cftab[i - 1];  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: ch2 = 256;
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,SetupRandPartA,The following statement contains a magic number: if (i2 <= last) {  				chPrev = ch2;  				ch2 = ll8[tPos];  				tPos = tt[tPos];  				if (rNToGo == 0) {  					rNToGo = BZip2Constants.RandomNumbers[rTPos];  					rTPos++;  					if (rTPos == 512) {  						rTPos = 0;  					}  				}  				rNToGo--;  				ch2 ^= (int)((rNToGo == 1) ? 1 : 0);  				i2++;    				currentChar = ch2;  				currentState = RAND_PART_B_STATE;  				mCrc.Update(ch2);  			} else {  				EndBlock();  				InitBlock();  				SetupBlock();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,SetupRandPartB,The following statement contains a magic number: if (ch2 != chPrev) {  				currentState = RAND_PART_A_STATE;  				count = 1;  				SetupRandPartA();  			} else {  				count++;  				if (count >= 4) {  					z = ll8[tPos];  					tPos = tt[tPos];  					if (rNToGo == 0) {  						rNToGo = BZip2Constants.RandomNumbers[rTPos];  						rTPos++;  						if (rTPos == 512) {  							rTPos = 0;  						}  					}  					rNToGo--;  					z ^= (byte)((rNToGo == 1) ? 1 : 0);  					j2 = 0;  					currentState = RAND_PART_C_STATE;  					SetupRandPartC();  				} else {  					currentState = RAND_PART_A_STATE;  					SetupRandPartA();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,SetupRandPartB,The following statement contains a magic number: if (ch2 != chPrev) {  				currentState = RAND_PART_A_STATE;  				count = 1;  				SetupRandPartA();  			} else {  				count++;  				if (count >= 4) {  					z = ll8[tPos];  					tPos = tt[tPos];  					if (rNToGo == 0) {  						rNToGo = BZip2Constants.RandomNumbers[rTPos];  						rTPos++;  						if (rTPos == 512) {  							rTPos = 0;  						}  					}  					rNToGo--;  					z ^= (byte)((rNToGo == 1) ? 1 : 0);  					j2 = 0;  					currentState = RAND_PART_C_STATE;  					SetupRandPartC();  				} else {  					currentState = RAND_PART_A_STATE;  					SetupRandPartA();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,SetupNoRandPartB,The following statement contains a magic number: if (ch2 != chPrev) {  				currentState = NO_RAND_PART_A_STATE;  				count = 1;  				SetupNoRandPartA();  			} else {  				count++;  				if (count >= 4) {  					z = ll8[tPos];  					tPos = tt[tPos];  					currentState = NO_RAND_PART_C_STATE;  					j2 = 0;  					SetupNoRandPartC();  				} else {  					currentState = NO_RAND_PART_A_STATE;  					SetupNoRandPartA();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,SetDecompressStructureSizes,The following statement contains a magic number: if (!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9)) {  				throw new BZip2Exception("Invalid block size");  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,SetDecompressStructureSizes,The following statement contains a magic number: if (!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9)) {  				throw new BZip2Exception("Invalid block size");  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BZip2OutputStream,The following statement contains a magic number: workFactor = 50;
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BZip2OutputStream,The following statement contains a magic number: if (blockSize > 9) {  				blockSize = 9;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BZip2OutputStream,The following statement contains a magic number: if (blockSize > 9) {  				blockSize = 9;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,WriteByte,The following statement contains a magic number: int b = (256 + value) % 256;
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,WriteByte,The following statement contains a magic number: int b = (256 + value) % 256;
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,WriteByte,The following statement contains a magic number: if (currentChar != -1) {  				if (currentChar == b) {  					runLength++;  					if (runLength > 254) {  						WriteRun();  						currentChar = -1;  						runLength = 0;  					}  				} else {  					WriteRun();  					runLength = 1;  					currentChar = b;  				}  			} else {  				currentChar = b;  				runLength++;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MakeMaps,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				if (inUse[i]) {  					seqToUnseq[nInUse] = (char)i;  					unseqToSeq[i] = (char)nInUse;  					nInUse++;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: if (last < allowableBlockSize) {  				inUse[currentChar] = true;  				for (int i = 0; i < runLength; i++) {  					mCrc.Update(currentChar);  				}    				switch (runLength) {  				case 1:  					last++;  					block[last + 1] = (byte)currentChar;  					break;  				case 2:  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					break;  				case 3:  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					break;  				default:  					inUse[runLength - 4] = true;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)(runLength - 4);  					break;  				}  			} else {  				EndBlock();  				InitBlock();  				WriteRun();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: if (last < allowableBlockSize) {  				inUse[currentChar] = true;  				for (int i = 0; i < runLength; i++) {  					mCrc.Update(currentChar);  				}    				switch (runLength) {  				case 1:  					last++;  					block[last + 1] = (byte)currentChar;  					break;  				case 2:  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					break;  				case 3:  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					break;  				default:  					inUse[runLength - 4] = true;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)(runLength - 4);  					break;  				}  			} else {  				EndBlock();  				InitBlock();  				WriteRun();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: if (last < allowableBlockSize) {  				inUse[currentChar] = true;  				for (int i = 0; i < runLength; i++) {  					mCrc.Update(currentChar);  				}    				switch (runLength) {  				case 1:  					last++;  					block[last + 1] = (byte)currentChar;  					break;  				case 2:  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					break;  				case 3:  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					break;  				default:  					inUse[runLength - 4] = true;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)(runLength - 4);  					break;  				}  			} else {  				EndBlock();  				InitBlock();  				WriteRun();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: if (last < allowableBlockSize) {  				inUse[currentChar] = true;  				for (int i = 0; i < runLength; i++) {  					mCrc.Update(currentChar);  				}    				switch (runLength) {  				case 1:  					last++;  					block[last + 1] = (byte)currentChar;  					break;  				case 2:  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					break;  				case 3:  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					break;  				default:  					inUse[runLength - 4] = true;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)currentChar;  					last++;  					block[last + 1] = (byte)(runLength - 4);  					break;  				}  			} else {  				EndBlock();  				InitBlock();  				WriteRun();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,InitBlock,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				inUse[i] = false;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,InitBlock,The following statement contains a magic number: allowableBlockSize = BZip2Constants.BaseBlockSize * blockSize100k - 20;
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,EndBlock,The following statement contains a magic number: combinedCRC = (combinedCRC << 1) | (combinedCRC >> 31);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BsFinishedWithStream,The following statement contains a magic number: while (bsLive > 0) {  				int ch = (bsBuff >> 24);  				baseStream.WriteByte((byte)ch); // write 8-bit  				bsBuff <<= 8;  				bsLive -= 8;  				bytesOut++;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BsFinishedWithStream,The following statement contains a magic number: while (bsLive > 0) {  				int ch = (bsBuff >> 24);  				baseStream.WriteByte((byte)ch); // write 8-bit  				bsBuff <<= 8;  				bsLive -= 8;  				bytesOut++;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BsFinishedWithStream,The following statement contains a magic number: while (bsLive > 0) {  				int ch = (bsBuff >> 24);  				baseStream.WriteByte((byte)ch); // write 8-bit  				bsBuff <<= 8;  				bsLive -= 8;  				bytesOut++;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: while (bsLive >= 8) {  				int ch = (bsBuff >> 24);  				unchecked { baseStream.WriteByte((byte)ch); } // write 8-bit  				bsBuff <<= 8;  				bsLive -= 8;  				++bytesOut;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: while (bsLive >= 8) {  				int ch = (bsBuff >> 24);  				unchecked { baseStream.WriteByte((byte)ch); } // write 8-bit  				bsBuff <<= 8;  				bsLive -= 8;  				++bytesOut;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: while (bsLive >= 8) {  				int ch = (bsBuff >> 24);  				unchecked { baseStream.WriteByte((byte)ch); } // write 8-bit  				bsBuff <<= 8;  				bsLive -= 8;  				++bytesOut;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: while (bsLive >= 8) {  				int ch = (bsBuff >> 24);  				unchecked { baseStream.WriteByte((byte)ch); } // write 8-bit  				bsBuff <<= 8;  				bsLive -= 8;  				++bytesOut;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: bsBuff |= (v << (32 - bsLive - n));
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BsPutUChar,The following statement contains a magic number: BsW(8' c);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 24) & 0xFF);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 24) & 0xFF);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 16) & 0xFF);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 16) & 0xFF);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 8) & 0xFF);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 8) & 0xFF);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' u & 0xFF);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: alphaSize = nInUse + 2;
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (nPart > 0) {  				int tFreq = remF / nPart;  				int aFreq = 0;  				ge = gs - 1;  				while (aFreq < tFreq && ge < alphaSize - 1) {  					ge++;  					aFreq += mtfFreq[ge];  				}    				if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)) {  					aFreq -= mtfFreq[ge];  					ge--;  				}    				for (int v = 0; v < alphaSize; v++) {  					if (v >= gs && v <= ge) {  						len[nPart - 1][v] = (char)LESSER_ICOST;  					} else {  						len[nPart - 1][v] = (char)GREATER_ICOST;  					}  				}    				nPart--;  				gs = ge + 1;  				remF -= aFreq;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}    				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}    				nSelectors = 0;  				totc = 0;  				gs = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.GroupSize - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}    					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}    					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}    					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;    					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}    					gs = ge + 1;  				}    				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}    				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}    				nSelectors = 0;  				totc = 0;  				gs = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.GroupSize - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}    					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}    					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}    					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;    					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}    					gs = ge + 1;  				}    				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}    				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}    				nSelectors = 0;  				totc = 0;  				gs = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.GroupSize - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}    					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}    					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}    					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;    					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}    					gs = ge + 1;  				}    				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}    				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}    				nSelectors = 0;  				totc = 0;  				gs = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.GroupSize - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}    					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}    					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}    					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;    					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}    					gs = ge + 1;  				}    				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}    				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}    				nSelectors = 0;  				totc = 0;  				gs = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.GroupSize - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}    					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}    					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}    					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;    					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}    					gs = ge + 1;  				}    				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}    				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}    				nSelectors = 0;  				totc = 0;  				gs = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.GroupSize - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}    					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}    					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}    					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;    					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}    					gs = ge + 1;  				}    				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}    				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}    				nSelectors = 0;  				totc = 0;  				gs = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.GroupSize - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}    					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}    					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}    					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;    					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}    					gs = ge + 1;  				}    				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}    				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}    				nSelectors = 0;  				totc = 0;  				gs = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.GroupSize - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}    					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}    					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}    					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;    					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}    					gs = ge + 1;  				}    				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}    				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}    				nSelectors = 0;  				totc = 0;  				gs = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.GroupSize - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}    					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}    					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}    					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;    					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}    					gs = ge + 1;  				}    				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}    				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}    				nSelectors = 0;  				totc = 0;  				gs = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.GroupSize - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}    					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}    					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}    					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;    					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}    					gs = ge + 1;  				}    				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.NumberOfIterations; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}    				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}    				nSelectors = 0;  				totc = 0;  				gs = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.GroupSize - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}    					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}    					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}    					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;    					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}    					gs = ge + 1;  				}    				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (!(nGroups < 8)) {  				Panic();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.GroupSize)))) {  				Panic();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.GroupSize)))) {  				Panic();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.GroupSize)))) {  				Panic();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; t++) {  				minLen = 32;  				maxLen = 0;  				for (int i = 0; i < alphaSize; i++) {  					if (len[t][i] > maxLen) {  						maxLen = len[t][i];  					}  					if (len[t][i] < minLen) {  						minLen = len[t][i];  					}  				}  				if (maxLen > 20) {  					Panic();  				}  				if (minLen < 1) {  					Panic();  				}  				HbAssignCodes(code[t]' len[t]' minLen' maxLen' alphaSize);  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; t++) {  				minLen = 32;  				maxLen = 0;  				for (int i = 0; i < alphaSize; i++) {  					if (len[t][i] > maxLen) {  						maxLen = len[t][i];  					}  					if (len[t][i] < minLen) {  						minLen = len[t][i];  					}  				}  				if (maxLen > 20) {  					Panic();  				}  				if (minLen < 1) {  					Panic();  				}  				HbAssignCodes(code[t]' len[t]' minLen' maxLen' alphaSize);  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: bool[] inUse16 = new bool[16];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  				inUse16[i] = false;  				for (int j = 0; j < 16; ++j) {  					if (inUse[i * 16 + j]) {  						inUse16[i] = true;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  				inUse16[i] = false;  				for (int j = 0; j < 16; ++j) {  					if (inUse[i * 16 + j]) {  						inUse16[i] = true;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  				inUse16[i] = false;  				for (int j = 0; j < 16; ++j) {  					if (inUse[i * 16 + j]) {  						inUse16[i] = true;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  				if (inUse16[i]) {  					BsW(1' 1);  				} else {  					BsW(1' 0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  				if (inUse16[i]) {  					for (int j = 0; j < 16; ++j) {  						if (inUse[i * 16 + j]) {  							BsW(1' 1);  						} else {  							BsW(1' 0);  						}  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  				if (inUse16[i]) {  					for (int j = 0; j < 16; ++j) {  						if (inUse[i * 16 + j]) {  							BsW(1' 1);  						} else {  							BsW(1' 0);  						}  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  				if (inUse16[i]) {  					for (int j = 0; j < 16; ++j) {  						if (inUse[i * 16 + j]) {  							BsW(1' 1);  						} else {  							BsW(1' 0);  						}  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW(3' nGroups);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW(15' nSelectors);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t) {  				int curr = len[t][0];  				BsW(5' curr);  				for (int i = 0; i < alphaSize; ++i) {  					while (curr < len[t][i]) {  						BsW(2' 2);  						curr++; /* 10 */  					}  					while (curr > len[t][i]) {  						BsW(2' 3);  						curr--; /* 11 */  					}  					BsW(1' 0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t) {  				int curr = len[t][0];  				BsW(5' curr);  				for (int i = 0; i < alphaSize; ++i) {  					while (curr < len[t][i]) {  						BsW(2' 2);  						curr++; /* 10 */  					}  					while (curr > len[t][i]) {  						BsW(2' 3);  						curr--; /* 11 */  					}  					BsW(1' 0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t) {  				int curr = len[t][0];  				BsW(5' curr);  				for (int i = 0; i < alphaSize; ++i) {  					while (curr < len[t][i]) {  						BsW(2' 2);  						curr++; /* 10 */  					}  					while (curr > len[t][i]) {  						BsW(2' 3);  						curr--; /* 11 */  					}  					BsW(1' 0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t) {  				int curr = len[t][0];  				BsW(5' curr);  				for (int i = 0; i < alphaSize; ++i) {  					while (curr < len[t][i]) {  						BsW(2' 2);  						curr++; /* 10 */  					}  					while (curr > len[t][i]) {  						BsW(2' 3);  						curr--; /* 11 */  					}  					BsW(1' 0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t) {  				int curr = len[t][0];  				BsW(5' curr);  				for (int i = 0; i < alphaSize; ++i) {  					while (curr < len[t][i]) {  						BsW(2' 2);  						curr++; /* 10 */  					}  					while (curr > len[t][i]) {  						BsW(2' 3);  						curr--; /* 11 */  					}  					BsW(1' 0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MoveToFrontCodeAndSend,The following statement contains a magic number: BsPutIntVS(24' origPtr);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,SimpleSort,The following statement contains a magic number: if (bigN < 2) {  				return;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: int[] runningOrder = new int[256];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: int[] copy = new int[256];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: bool[] bigDone = new bool[256];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i < BZip2Constants.OvershootBytes; i++) {  				block[last + i + 2] = block[(i % (last + 1)) + 1];  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}    				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}    				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}    				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}    				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;    				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/    				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}    				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j - h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);    				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {    					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];    					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if (!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb + 1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}    					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;    					if (i < 255) {  						int bbStart = ftab[ss << 8] & CLEARMASK;  						int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;  						int shifts = 0;    						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}    						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.OvershootBytes) {  								quadrant[a2update + last + 1] = qVal;  							}  						}    						if (!(((bbSize - 1) >> shifts) <= 65535)) {  							Panic();  						}  					}    					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}    					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1]++;  						}  					}    					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,RandomiseBlock,The following statement contains a magic number: for (i = 0; i < 256; i++) {  				inUse[i] = false;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,RandomiseBlock,The following statement contains a magic number: for (i = 0; i <= last; i++) {  				if (rNToGo == 0) {  					rNToGo = (int)BZip2Constants.RandomNumbers[rTPos];  					rTPos++;  					if (rTPos == 512) {  						rTPos = 0;  					}  				}  				rNToGo--;  				block[i + 1] ^= (byte)((rNToGo == 1) ? 1 : 0);  				// handle 16 bit signed numbers  				block[i + 1] &= 0xFF;    				inUse[block[i + 1]] = true;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,FullGtU,The following statement contains a magic number: do {  				c1 = block[i1 + 1];  				c2 = block[i2 + 1];  				if (c1 != c2) {  					return c1 > c2;  				}  				s1 = quadrant[i1];  				s2 = quadrant[i2];  				if (s1 != s2) {  					return s1 > s2;  				}  				i1++;  				i2++;    				c1 = block[i1 + 1];  				c2 = block[i2 + 1];  				if (c1 != c2) {  					return c1 > c2;  				}  				s1 = quadrant[i1];  				s2 = quadrant[i2];  				if (s1 != s2) {  					return s1 > s2;  				}  				i1++;  				i2++;    				c1 = block[i1 + 1];  				c2 = block[i2 + 1];  				if (c1 != c2) {  					return c1 > c2;  				}  				s1 = quadrant[i1];  				s2 = quadrant[i2];  				if (s1 != s2) {  					return s1 > s2;  				}  				i1++;  				i2++;    				c1 = block[i1 + 1];  				c2 = block[i2 + 1];  				if (c1 != c2) {  					return c1 > c2;  				}  				s1 = quadrant[i1];  				s2 = quadrant[i2];  				if (s1 != s2) {  					return s1 > s2;  				}  				i1++;  				i2++;    				if (i1 > last) {  					i1 -= last;  					i1--;  				}  				if (i2 > last) {  					i2 -= last;  					i2--;  				}    				k -= 4;  				++workDone;  			} while (k >= 0);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,AllocateCompressStructures,The following statement contains a magic number: ftab = new int[65537];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,AllocateCompressStructures,The following statement contains a magic number: szptr = new short[2 * n];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: char[] yy = new char[256];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: for (i = 0; i <= last; i++) {  				char ll_i;    				ll_i = unseqToSeq[block[zptr[i]]];    				j = 0;  				tmp = yy[j];  				while (ll_i != tmp) {  					j++;  					tmp2 = tmp;  					tmp = yy[j];  					yy[j] = tmp2;  				}  				yy[0] = tmp;    				if (j == 0) {  					zPend++;  				} else {  					if (zPend > 0) {  						zPend--;  						while (true) {  							switch (zPend % 2) {  							case 0:  								szptr[wr] = (short)BZip2Constants.RunA;  								wr++;  								mtfFreq[BZip2Constants.RunA]++;  								break;  							case 1:  								szptr[wr] = (short)BZip2Constants.RunB;  								wr++;  								mtfFreq[BZip2Constants.RunB]++;  								break;  							}  							if (zPend < 2) {  								break;  							}  							zPend = (zPend - 2) / 2;  						}  						zPend = 0;  					}  					szptr[wr] = (short)(j + 1);  					wr++;  					mtfFreq[j + 1]++;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: for (i = 0; i <= last; i++) {  				char ll_i;    				ll_i = unseqToSeq[block[zptr[i]]];    				j = 0;  				tmp = yy[j];  				while (ll_i != tmp) {  					j++;  					tmp2 = tmp;  					tmp = yy[j];  					yy[j] = tmp2;  				}  				yy[0] = tmp;    				if (j == 0) {  					zPend++;  				} else {  					if (zPend > 0) {  						zPend--;  						while (true) {  							switch (zPend % 2) {  							case 0:  								szptr[wr] = (short)BZip2Constants.RunA;  								wr++;  								mtfFreq[BZip2Constants.RunA]++;  								break;  							case 1:  								szptr[wr] = (short)BZip2Constants.RunB;  								wr++;  								mtfFreq[BZip2Constants.RunB]++;  								break;  							}  							if (zPend < 2) {  								break;  							}  							zPend = (zPend - 2) / 2;  						}  						zPend = 0;  					}  					szptr[wr] = (short)(j + 1);  					wr++;  					mtfFreq[j + 1]++;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: for (i = 0; i <= last; i++) {  				char ll_i;    				ll_i = unseqToSeq[block[zptr[i]]];    				j = 0;  				tmp = yy[j];  				while (ll_i != tmp) {  					j++;  					tmp2 = tmp;  					tmp = yy[j];  					yy[j] = tmp2;  				}  				yy[0] = tmp;    				if (j == 0) {  					zPend++;  				} else {  					if (zPend > 0) {  						zPend--;  						while (true) {  							switch (zPend % 2) {  							case 0:  								szptr[wr] = (short)BZip2Constants.RunA;  								wr++;  								mtfFreq[BZip2Constants.RunA]++;  								break;  							case 1:  								szptr[wr] = (short)BZip2Constants.RunB;  								wr++;  								mtfFreq[BZip2Constants.RunB]++;  								break;  							}  							if (zPend < 2) {  								break;  							}  							zPend = (zPend - 2) / 2;  						}  						zPend = 0;  					}  					szptr[wr] = (short)(j + 1);  					wr++;  					mtfFreq[j + 1]++;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: for (i = 0; i <= last; i++) {  				char ll_i;    				ll_i = unseqToSeq[block[zptr[i]]];    				j = 0;  				tmp = yy[j];  				while (ll_i != tmp) {  					j++;  					tmp2 = tmp;  					tmp = yy[j];  					yy[j] = tmp2;  				}  				yy[0] = tmp;    				if (j == 0) {  					zPend++;  				} else {  					if (zPend > 0) {  						zPend--;  						while (true) {  							switch (zPend % 2) {  							case 0:  								szptr[wr] = (short)BZip2Constants.RunA;  								wr++;  								mtfFreq[BZip2Constants.RunA]++;  								break;  							case 1:  								szptr[wr] = (short)BZip2Constants.RunB;  								wr++;  								mtfFreq[BZip2Constants.RunB]++;  								break;  							}  							if (zPend < 2) {  								break;  							}  							zPend = (zPend - 2) / 2;  						}  						zPend = 0;  					}  					szptr[wr] = (short)(j + 1);  					wr++;  					mtfFreq[j + 1]++;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0) {  				zPend--;  				while (true) {  					switch (zPend % 2) {  					case 0:  						szptr[wr] = (short)BZip2Constants.RunA;  						wr++;  						mtfFreq[BZip2Constants.RunA]++;  						break;  					case 1:  						szptr[wr] = (short)BZip2Constants.RunB;  						wr++;  						mtfFreq[BZip2Constants.RunB]++;  						break;  					}  					if (zPend < 2) {  						break;  					}  					zPend = (zPend - 2) / 2;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0) {  				zPend--;  				while (true) {  					switch (zPend % 2) {  					case 0:  						szptr[wr] = (short)BZip2Constants.RunA;  						wr++;  						mtfFreq[BZip2Constants.RunA]++;  						break;  					case 1:  						szptr[wr] = (short)BZip2Constants.RunB;  						wr++;  						mtfFreq[BZip2Constants.RunB]++;  						break;  					}  					if (zPend < 2) {  						break;  					}  					zPend = (zPend - 2) / 2;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0) {  				zPend--;  				while (true) {  					switch (zPend % 2) {  					case 0:  						szptr[wr] = (short)BZip2Constants.RunA;  						wr++;  						mtfFreq[BZip2Constants.RunA]++;  						break;  					case 1:  						szptr[wr] = (short)BZip2Constants.RunB;  						wr++;  						mtfFreq[BZip2Constants.RunB]++;  						break;  					}  					if (zPend < 2) {  						break;  					}  					zPend = (zPend - 2) / 2;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0) {  				zPend--;  				while (true) {  					switch (zPend % 2) {  					case 0:  						szptr[wr] = (short)BZip2Constants.RunA;  						wr++;  						mtfFreq[BZip2Constants.RunA]++;  						break;  					case 1:  						szptr[wr] = (short)BZip2Constants.RunB;  						wr++;  						mtfFreq[BZip2Constants.RunB]++;  						break;  					}  					if (zPend < 2) {  						break;  					}  					zPend = (zPend - 2) / 2;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: int[] heap = new int[BZip2Constants.MaximumAlphaSize + 2];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: int[] weight = new int[BZip2Constants.MaximumAlphaSize * 2];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: int[] parent = new int[BZip2Constants.MaximumAlphaSize * 2];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: for (int i = 0; i < alphaSize; ++i) {  				weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true) {  				nNodes = alphaSize;  				nHeap = 0;    				heap[0] = 0;  				weight[0] = 0;  				parent[0] = -2;    				for (int i = 1; i <= alphaSize; ++i) {  					parent[i] = -1;  					nHeap++;  					heap[nHeap] = i;  					int zz = nHeap;  					int tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]]) {  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2))) {  					Panic();  				}    				while (nHeap > 1) {  					n1 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					int zz = 1;  					int yy = 0;  					int tmp = heap[zz];  					while (true) {  						yy = zz << 1;  						if (yy > nHeap) {  							break;  						}  						if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]]) {  							break;  						}    						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					n2 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;    					zz = 1;  					yy = 0;  					tmp = heap[zz];  					while (true) {  						yy = zz << 1;  						if (yy > nHeap) {  							break;  						}  						if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]]) {  							break;  						}  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					nNodes++;  					parent[n1] = parent[n2] = nNodes;    					weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |  						(int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));    					parent[nNodes] = -1;  					nHeap++;  					heap[nHeap] = nNodes;    					zz = nHeap;  					tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]]) {  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2))) {  					Panic();  				}    				tooLong = false;  				for (int i = 1; i <= alphaSize; ++i) {  					j = 0;  					k = i;  					while (parent[k] >= 0) {  						k = parent[k];  						j++;  					}  					len[i - 1] = (char)j;  					tooLong |= j > maxLen;  				}    				if (!tooLong) {  					break;  				}    				for (int i = 1; i < alphaSize; ++i) {  					j = weight[i] >> 8;  					j = 1 + (j / 2);  					weight[i] = j << 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true) {  				nNodes = alphaSize;  				nHeap = 0;    				heap[0] = 0;  				weight[0] = 0;  				parent[0] = -2;    				for (int i = 1; i <= alphaSize; ++i) {  					parent[i] = -1;  					nHeap++;  					heap[nHeap] = i;  					int zz = nHeap;  					int tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]]) {  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2))) {  					Panic();  				}    				while (nHeap > 1) {  					n1 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					int zz = 1;  					int yy = 0;  					int tmp = heap[zz];  					while (true) {  						yy = zz << 1;  						if (yy > nHeap) {  							break;  						}  						if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]]) {  							break;  						}    						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					n2 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;    					zz = 1;  					yy = 0;  					tmp = heap[zz];  					while (true) {  						yy = zz << 1;  						if (yy > nHeap) {  							break;  						}  						if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]]) {  							break;  						}  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					nNodes++;  					parent[n1] = parent[n2] = nNodes;    					weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |  						(int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));    					parent[nNodes] = -1;  					nHeap++;  					heap[nHeap] = nNodes;    					zz = nHeap;  					tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]]) {  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2))) {  					Panic();  				}    				tooLong = false;  				for (int i = 1; i <= alphaSize; ++i) {  					j = 0;  					k = i;  					while (parent[k] >= 0) {  						k = parent[k];  						j++;  					}  					len[i - 1] = (char)j;  					tooLong |= j > maxLen;  				}    				if (!tooLong) {  					break;  				}    				for (int i = 1; i < alphaSize; ++i) {  					j = weight[i] >> 8;  					j = 1 + (j / 2);  					weight[i] = j << 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true) {  				nNodes = alphaSize;  				nHeap = 0;    				heap[0] = 0;  				weight[0] = 0;  				parent[0] = -2;    				for (int i = 1; i <= alphaSize; ++i) {  					parent[i] = -1;  					nHeap++;  					heap[nHeap] = i;  					int zz = nHeap;  					int tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]]) {  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2))) {  					Panic();  				}    				while (nHeap > 1) {  					n1 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					int zz = 1;  					int yy = 0;  					int tmp = heap[zz];  					while (true) {  						yy = zz << 1;  						if (yy > nHeap) {  							break;  						}  						if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]]) {  							break;  						}    						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					n2 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;    					zz = 1;  					yy = 0;  					tmp = heap[zz];  					while (true) {  						yy = zz << 1;  						if (yy > nHeap) {  							break;  						}  						if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]]) {  							break;  						}  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					nNodes++;  					parent[n1] = parent[n2] = nNodes;    					weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |  						(int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));    					parent[nNodes] = -1;  					nHeap++;  					heap[nHeap] = nNodes;    					zz = nHeap;  					tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]]) {  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2))) {  					Panic();  				}    				tooLong = false;  				for (int i = 1; i <= alphaSize; ++i) {  					j = 0;  					k = i;  					while (parent[k] >= 0) {  						k = parent[k];  						j++;  					}  					len[i - 1] = (char)j;  					tooLong |= j > maxLen;  				}    				if (!tooLong) {  					break;  				}    				for (int i = 1; i < alphaSize; ++i) {  					j = weight[i] >> 8;  					j = 1 + (j / 2);  					weight[i] = j << 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true) {  				nNodes = alphaSize;  				nHeap = 0;    				heap[0] = 0;  				weight[0] = 0;  				parent[0] = -2;    				for (int i = 1; i <= alphaSize; ++i) {  					parent[i] = -1;  					nHeap++;  					heap[nHeap] = i;  					int zz = nHeap;  					int tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]]) {  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2))) {  					Panic();  				}    				while (nHeap > 1) {  					n1 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					int zz = 1;  					int yy = 0;  					int tmp = heap[zz];  					while (true) {  						yy = zz << 1;  						if (yy > nHeap) {  							break;  						}  						if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]]) {  							break;  						}    						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					n2 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;    					zz = 1;  					yy = 0;  					tmp = heap[zz];  					while (true) {  						yy = zz << 1;  						if (yy > nHeap) {  							break;  						}  						if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]]) {  							break;  						}  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					nNodes++;  					parent[n1] = parent[n2] = nNodes;    					weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |  						(int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));    					parent[nNodes] = -1;  					nHeap++;  					heap[nHeap] = nNodes;    					zz = nHeap;  					tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]]) {  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2))) {  					Panic();  				}    				tooLong = false;  				for (int i = 1; i <= alphaSize; ++i) {  					j = 0;  					k = i;  					while (parent[k] >= 0) {  						k = parent[k];  						j++;  					}  					len[i - 1] = (char)j;  					tooLong |= j > maxLen;  				}    				if (!tooLong) {  					break;  				}    				for (int i = 1; i < alphaSize; ++i) {  					j = weight[i] >> 8;  					j = 1 + (j / 2);  					weight[i] = j << 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true) {  				nNodes = alphaSize;  				nHeap = 0;    				heap[0] = 0;  				weight[0] = 0;  				parent[0] = -2;    				for (int i = 1; i <= alphaSize; ++i) {  					parent[i] = -1;  					nHeap++;  					heap[nHeap] = i;  					int zz = nHeap;  					int tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]]) {  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2))) {  					Panic();  				}    				while (nHeap > 1) {  					n1 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					int zz = 1;  					int yy = 0;  					int tmp = heap[zz];  					while (true) {  						yy = zz << 1;  						if (yy > nHeap) {  							break;  						}  						if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]]) {  							break;  						}    						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					n2 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;    					zz = 1;  					yy = 0;  					tmp = heap[zz];  					while (true) {  						yy = zz << 1;  						if (yy > nHeap) {  							break;  						}  						if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]]) {  							break;  						}  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					nNodes++;  					parent[n1] = parent[n2] = nNodes;    					weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |  						(int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));    					parent[nNodes] = -1;  					nHeap++;  					heap[nHeap] = nNodes;    					zz = nHeap;  					tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]]) {  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2))) {  					Panic();  				}    				tooLong = false;  				for (int i = 1; i <= alphaSize; ++i) {  					j = 0;  					k = i;  					while (parent[k] >= 0) {  						k = parent[k];  						j++;  					}  					len[i - 1] = (char)j;  					tooLong |= j > maxLen;  				}    				if (!tooLong) {  					break;  				}    				for (int i = 1; i < alphaSize; ++i) {  					j = weight[i] >> 8;  					j = 1 + (j / 2);  					weight[i] = j << 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true) {  				nNodes = alphaSize;  				nHeap = 0;    				heap[0] = 0;  				weight[0] = 0;  				parent[0] = -2;    				for (int i = 1; i <= alphaSize; ++i) {  					parent[i] = -1;  					nHeap++;  					heap[nHeap] = i;  					int zz = nHeap;  					int tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]]) {  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nHeap < (BZip2Constants.MaximumAlphaSize + 2))) {  					Panic();  				}    				while (nHeap > 1) {  					n1 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					int zz = 1;  					int yy = 0;  					int tmp = heap[zz];  					while (true) {  						yy = zz << 1;  						if (yy > nHeap) {  							break;  						}  						if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]]) {  							break;  						}    						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					n2 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;    					zz = 1;  					yy = 0;  					tmp = heap[zz];  					while (true) {  						yy = zz << 1;  						if (yy > nHeap) {  							break;  						}  						if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]]) {  							break;  						}  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					nNodes++;  					parent[n1] = parent[n2] = nNodes;    					weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |  						(int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));    					parent[nNodes] = -1;  					nHeap++;  					heap[nHeap] = nNodes;    					zz = nHeap;  					tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]]) {  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nNodes < (BZip2Constants.MaximumAlphaSize * 2))) {  					Panic();  				}    				tooLong = false;  				for (int i = 1; i <= alphaSize; ++i) {  					j = 0;  					k = i;  					while (parent[k] >= 0) {  						k = parent[k];  						j++;  					}  					len[i - 1] = (char)j;  					tooLong |= j > maxLen;  				}    				if (!tooLong) {  					break;  				}    				for (int i = 1; i < alphaSize; ++i) {  					j = weight[i] >> 8;  					j = 1 + (j / 2);  					weight[i] = j << 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Checksum,Adler32,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Checksum\Adler32.cs,Update,The following statement contains a magic number: uint s2 = checkValue >> 16;
Magic Number,ICSharpCode.SharpZipLib.Checksum,Adler32,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Checksum\Adler32.cs,Update,The following statement contains a magic number: checkValue = (s2 << 16) + s1;
Magic Number,ICSharpCode.SharpZipLib.Checksum,Adler32,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Checksum\Adler32.cs,Update,The following statement contains a magic number: uint s2 = checkValue >> 16;
Magic Number,ICSharpCode.SharpZipLib.Checksum,Adler32,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Checksum\Adler32.cs,Update,The following statement contains a magic number: while (count > 0) {  				// We can defer the modulo operation:  				// s1 maximally grows from 65521 to 65521 + 255 * 3800  				// s2 maximally grows by 3800 * median(s1) = 2090079800 < 2^31  				int n = 3800;  				if (n > count) {  					n = count;  				}  				count -= n;  				while (--n >= 0) {  					s1 = s1 + (uint)(buffer[offset++] & 0xff);  					s2 = s2 + s1;  				}  				s1 %= BASE;  				s2 %= BASE;  			}
Magic Number,ICSharpCode.SharpZipLib.Checksum,Adler32,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Checksum\Adler32.cs,Update,The following statement contains a magic number: checkValue = (s2 << 16) | s1;
Magic Number,ICSharpCode.SharpZipLib.Checksum,BZip2Crc,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Checksum\BZip2Crc.cs,Update,The following statement contains a magic number: checkValue = unchecked(crcTable[(byte)(((checkValue >> 24) & 0xFF) ^ bval)] ^ (checkValue << 8));
Magic Number,ICSharpCode.SharpZipLib.Checksum,BZip2Crc,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Checksum\BZip2Crc.cs,Update,The following statement contains a magic number: checkValue = unchecked(crcTable[(byte)(((checkValue >> 24) & 0xFF) ^ bval)] ^ (checkValue << 8));
Magic Number,ICSharpCode.SharpZipLib.Checksum,Crc32,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Checksum\Crc32.cs,ComputeCrc32,The following statement contains a magic number: return (uint)(Crc32.crcTable[(oldCrc ^ bval) & 0xFF] ^ (oldCrc >> 8));
Magic Number,ICSharpCode.SharpZipLib.Checksum,Crc32,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Checksum\Crc32.cs,Update,The following statement contains a magic number: checkValue = unchecked(crcTable[(checkValue ^ bval) & 0xFF] ^ (checkValue >> 8));
Magic Number,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Core\StreamUtils.cs,Copy,The following statement contains a magic number: if (buffer.Length < 128) {  				throw new ArgumentException("Buffer is too small"' nameof(buffer));  			}
Magic Number,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Core\StreamUtils.cs,Copy,The following statement contains a magic number: if (buffer.Length < 128) {  				throw new ArgumentException("Buffer is too small"' nameof(buffer));  			}
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if (!string.IsNullOrEmpty(path)) {  				if ((path[0] == '\\') || (path[0] == '/')) {  					// UNC name ?  					if ((path.Length > 1) && ((path[1] == '\\') || (path[1] == '/'))) {  						int index = 2;  						int elements = 2;    						// Scan for two separate elements \\machine\share\restofpath  						while ((index <= path.Length) &&  							(((path[index] != '\\') && (path[index] != '/')) || (--elements > 0))) {  							index++;  						}    						index++;    						if (index < path.Length) {  							result = path.Substring(index);  						} else {  							result = "";  						}  					}  				} else if ((path.Length > 1) && (path[1] == ':')) {  					int dropCount = 2;  					if ((path.Length > 2) && ((path[2] == '\\') || (path[2] == '/'))) {  						dropCount = 3;  					}  					result = result.Remove(0' dropCount);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if (!string.IsNullOrEmpty(path)) {  				if ((path[0] == '\\') || (path[0] == '/')) {  					// UNC name ?  					if ((path.Length > 1) && ((path[1] == '\\') || (path[1] == '/'))) {  						int index = 2;  						int elements = 2;    						// Scan for two separate elements \\machine\share\restofpath  						while ((index <= path.Length) &&  							(((path[index] != '\\') && (path[index] != '/')) || (--elements > 0))) {  							index++;  						}    						index++;    						if (index < path.Length) {  							result = path.Substring(index);  						} else {  							result = "";  						}  					}  				} else if ((path.Length > 1) && (path[1] == ':')) {  					int dropCount = 2;  					if ((path.Length > 2) && ((path[2] == '\\') || (path[2] == '/'))) {  						dropCount = 3;  					}  					result = result.Remove(0' dropCount);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if (!string.IsNullOrEmpty(path)) {  				if ((path[0] == '\\') || (path[0] == '/')) {  					// UNC name ?  					if ((path.Length > 1) && ((path[1] == '\\') || (path[1] == '/'))) {  						int index = 2;  						int elements = 2;    						// Scan for two separate elements \\machine\share\restofpath  						while ((index <= path.Length) &&  							(((path[index] != '\\') && (path[index] != '/')) || (--elements > 0))) {  							index++;  						}    						index++;    						if (index < path.Length) {  							result = path.Substring(index);  						} else {  							result = "";  						}  					}  				} else if ((path.Length > 1) && (path[1] == ':')) {  					int dropCount = 2;  					if ((path.Length > 2) && ((path[2] == '\\') || (path[2] == '/'))) {  						dropCount = 3;  					}  					result = result.Remove(0' dropCount);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if (!string.IsNullOrEmpty(path)) {  				if ((path[0] == '\\') || (path[0] == '/')) {  					// UNC name ?  					if ((path.Length > 1) && ((path[1] == '\\') || (path[1] == '/'))) {  						int index = 2;  						int elements = 2;    						// Scan for two separate elements \\machine\share\restofpath  						while ((index <= path.Length) &&  							(((path[index] != '\\') && (path[index] != '/')) || (--elements > 0))) {  							index++;  						}    						index++;    						if (index < path.Length) {  							result = path.Substring(index);  						} else {  							result = "";  						}  					}  				} else if ((path.Length > 1) && (path[1] == ':')) {  					int dropCount = 2;  					if ((path.Length > 2) && ((path[2] == '\\') || (path[2] == '/'))) {  						dropCount = 3;  					}  					result = result.Remove(0' dropCount);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if (!string.IsNullOrEmpty(path)) {  				if ((path[0] == '\\') || (path[0] == '/')) {  					// UNC name ?  					if ((path.Length > 1) && ((path[1] == '\\') || (path[1] == '/'))) {  						int index = 2;  						int elements = 2;    						// Scan for two separate elements \\machine\share\restofpath  						while ((index <= path.Length) &&  							(((path[index] != '\\') && (path[index] != '/')) || (--elements > 0))) {  							index++;  						}    						index++;    						if (index < path.Length) {  							result = path.Substring(index);  						} else {  							result = "";  						}  					}  				} else if ((path.Length > 1) && (path[1] == ':')) {  					int dropCount = 2;  					if ((path.Length > 2) && ((path[2] == '\\') || (path[2] == '/'))) {  						dropCount = 3;  					}  					result = result.Remove(0' dropCount);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if (!string.IsNullOrEmpty(path)) {  				if ((path[0] == '\\') || (path[0] == '/')) {  					// UNC name ?  					if ((path.Length > 1) && ((path[1] == '\\') || (path[1] == '/'))) {  						int index = 2;  						int elements = 2;    						// Scan for two separate elements \\machine\share\restofpath  						while ((index <= path.Length) &&  							(((path[index] != '\\') && (path[index] != '/')) || (--elements > 0))) {  							index++;  						}    						index++;    						if (index < path.Length) {  							result = path.Substring(index);  						} else {  							result = "";  						}  					}  				} else if ((path.Length > 1) && (path[1] == ':')) {  					int dropCount = 2;  					if ((path.Length > 2) && ((path[2] == '\\') || (path[2] == '/'))) {  						dropCount = 3;  					}  					result = result.Remove(0' dropCount);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Core,WindowsPathUtils,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Core\WindowsPathUtils.cs,DropPathRoot,The following statement contains a magic number: if (!string.IsNullOrEmpty(path)) {  				if ((path[0] == '\\') || (path[0] == '/')) {  					// UNC name ?  					if ((path.Length > 1) && ((path[1] == '\\') || (path[1] == '/'))) {  						int index = 2;  						int elements = 2;    						// Scan for two separate elements \\machine\share\restofpath  						while ((index <= path.Length) &&  							(((path[index] != '\\') && (path[index] != '/')) || (--elements > 0))) {  							index++;  						}    						index++;    						if (index < path.Length) {  							result = path.Substring(index);  						} else {  							result = "";  						}  					}  				} else if ((path.Length > 1) && (path[1] == ':')) {  					int dropCount = 2;  					if ((path.Length > 2) && ((path[2] == '\\') || (path[2] == '/'))) {  						dropCount = 3;  					}  					result = result.Remove(0' dropCount);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  				newKeys[0] = Crc32.ComputeCrc32(newKeys[0]' seed[i]);  				newKeys[1] = newKeys[1] + (byte)newKeys[0];  				newKeys[1] = newKeys[1] * 134775813 + 1;  				newKeys[2] = Crc32.ComputeCrc32(newKeys[2]' (byte)(newKeys[1] >> 24));  			}
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  				newKeys[0] = Crc32.ComputeCrc32(newKeys[0]' seed[i]);  				newKeys[1] = newKeys[1] + (byte)newKeys[0];  				newKeys[1] = newKeys[1] * 134775813 + 1;  				newKeys[2] = Crc32.ComputeCrc32(newKeys[2]' (byte)(newKeys[1] >> 24));  			}
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  				newKeys[0] = Crc32.ComputeCrc32(newKeys[0]' seed[i]);  				newKeys[1] = newKeys[1] + (byte)newKeys[0];  				newKeys[1] = newKeys[1] * 134775813 + 1;  				newKeys[2] = Crc32.ComputeCrc32(newKeys[2]' (byte)(newKeys[1] >> 24));  			}
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  				newKeys[0] = Crc32.ComputeCrc32(newKeys[0]' seed[i]);  				newKeys[1] = newKeys[1] + (byte)newKeys[0];  				newKeys[1] = newKeys[1] * 134775813 + 1;  				newKeys[2] = Crc32.ComputeCrc32(newKeys[2]' (byte)(newKeys[1] >> 24));  			}
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: byte[] result = new byte[12];
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[1] = (byte)((newKeys[0] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[2] = (byte)((newKeys[0] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[2] = (byte)((newKeys[0] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[3] = (byte)((newKeys[0] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[3] = (byte)((newKeys[0] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[4] = (byte)(newKeys[1] & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[5] = (byte)((newKeys[1] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[5] = (byte)((newKeys[1] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[6] = (byte)((newKeys[1] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[6] = (byte)((newKeys[1] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[7] = (byte)((newKeys[1] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[7] = (byte)((newKeys[1] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[8] = (byte)(newKeys[2] & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[8] = (byte)(newKeys[2] & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[9] = (byte)((newKeys[2] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[9] = (byte)((newKeys[2] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[9] = (byte)((newKeys[2] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[10] = (byte)((newKeys[2] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[10] = (byte)((newKeys[2] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[10] = (byte)((newKeys[2] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[11] = (byte)((newKeys[2] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[11] = (byte)((newKeys[2] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[11] = (byte)((newKeys[2] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,TransformByte,The following statement contains a magic number: uint temp = ((keys[2] & 0xFFFF) | 2);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,TransformByte,The following statement contains a magic number: uint temp = ((keys[2] & 0xFFFF) | 2);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,TransformByte,The following statement contains a magic number: return (byte)((temp * (temp ^ 1)) >> 8);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: if (keyData.Length != 12) {  				throw new InvalidOperationException("Key length is not valid");  			}
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys = new uint[3];
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[0] = (uint)((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[0] = (uint)((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[0] = (uint)((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[0] = (uint)((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[0] = (uint)((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint)((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint)((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint)((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint)((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint)((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint)((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint)((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys[1] = keys[1] * 134775813 + 1;
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys[2] = Crc32.ComputeCrc32(keys[2]' (byte)(keys[1] >> 24));
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys[2] = Crc32.ComputeCrc32(keys[2]' (byte)(keys[1] >> 24));
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys[2] = Crc32.ComputeCrc32(keys[2]' (byte)(keys[1] >> 24));
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,Reset,The following statement contains a magic number: keys[2] = 0;
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicManaged,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\PkzipClassic.cs,GenerateKey,The following statement contains a magic number: key_ = new byte[12];
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\ZipAESStream.cs,ZipAESStream,The following statement contains a magic number: _slideBuffer = new byte[1024];
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (blockSize != 16 && blockSize != 32) // 24 valid for AES but not supported by Winzip  				throw new Exception("Invalid blocksize " + blockSize + ". Must be 16 or 32.");
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (blockSize != 16 && blockSize != 32) // 24 valid for AES but not supported by Winzip  				throw new Exception("Invalid blocksize " + blockSize + ". Must be 16 or 32.");
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (saltBytes.Length != blockSize / 2)  				throw new Exception("Invalid salt len. Must be " + blockSize / 2 + " for blocksize " + blockSize);
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (saltBytes.Length != blockSize / 2)  				throw new Exception("Invalid salt len. Must be " + blockSize / 2 + " for blocksize " + blockSize);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZip,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GZip.cs,Decompress,The following statement contains a magic number: try {  				using (GZipInputStream bzipInput = new GZipInputStream(inStream)) {  					bzipInput.IsStreamOwner = isStreamOwner;  					Core.StreamUtils.Copy(bzipInput' outStream' new byte[4096]);  				}  			} finally {  				if (isStreamOwner) {  					// inStream is closed by the GZipInputStream if stream owner  					outStream.Dispose();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZip,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GZip.cs,Compress,The following statement contains a magic number: try {  				using (GZipOutputStream bzipOutput = new GZipOutputStream(outStream' level)) {  					bzipOutput.IsStreamOwner = isStreamOwner;  					Core.StreamUtils.Copy(inStream' bzipOutput' new byte[4096]);  				}  			} finally {  				if (isStreamOwner) {  					// outStream is closed by the GZipOutputStream if stream owner  					inStream.Dispose();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if (magic != (GZipConstants.GZIP_MAGIC >> 8)) {                  throw new GZipException("Error GZIP header' first magic byte doesn't match");  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if (compressionType != 8) {  				throw new GZipException("Error GZIP header' data not in deflate format");  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: for (int i = 0; i < 6; i++) {  				int readByte = inputBuffer.ReadLeByte();  				if (readByte < 0) {  					throw new EndOfStreamException("EOS reading GZIP header");  				}  				headCRC.Update(readByte);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if ((flags & GZipConstants.FEXTRA) != 0) {    				// XLEN is total length of extra subfields' we will skip them all  				int len1' len2;  				len1 = inputBuffer.ReadLeByte();  				len2 = inputBuffer.ReadLeByte();  				if ((len1 < 0) || (len2 < 0)) {  					throw new EndOfStreamException("EOS reading GZIP header");  				}  				headCRC.Update(len1);  				headCRC.Update(len2);    				int extraLen = (len2 << 8) | len1;      // gzip is LSB first  				for (int i = 0; i < extraLen; i++) {  					int readByte = inputBuffer.ReadLeByte();  					if (readByte < 0) {  						throw new EndOfStreamException("EOS reading GZIP header");  					}  					headCRC.Update(readByte);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if ((flags & GZipConstants.FHCRC) != 0) {  				int tempByte;  				int crcval = inputBuffer.ReadLeByte();  				if (crcval < 0) {  					throw new EndOfStreamException("EOS reading GZIP header");  				}    				tempByte = inputBuffer.ReadLeByte();  				if (tempByte < 0) {  					throw new EndOfStreamException("EOS reading GZIP header");  				}    				crcval = (crcval << 8) | tempByte;  				if (crcval != ((int)headCRC.Value & 0xffff)) {  					throw new GZipException("Header CRC value mismatch");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: byte[] footer = new byte[8];
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: int needed = 8;
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: while (needed > 0) {  				int count = inputBuffer.ReadClearTextBuffer(footer' 8 - needed' needed);  				if (count <= 0) {  					throw new EndOfStreamException("EOS reading GZIP footer");  				}  				needed -= count; // Jewel Jan 16  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: uint total =  				(uint)((uint)footer[4] & 0xff) |  				(uint)(((uint)footer[5] & 0xff) << 8) |  				(uint)(((uint)footer[6] & 0xff) << 16) |  				(uint)((uint)footer[7] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: uint total =  				(uint)((uint)footer[4] & 0xff) |  				(uint)(((uint)footer[5] & 0xff) << 8) |  				(uint)(((uint)footer[6] & 0xff) << 16) |  				(uint)((uint)footer[7] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: uint total =  				(uint)((uint)footer[4] & 0xff) |  				(uint)(((uint)footer[5] & 0xff) << 8) |  				(uint)(((uint)footer[6] & 0xff) << 16) |  				(uint)((uint)footer[7] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: uint total =  				(uint)((uint)footer[4] & 0xff) |  				(uint)(((uint)footer[5] & 0xff) << 8) |  				(uint)(((uint)footer[6] & 0xff) << 16) |  				(uint)((uint)footer[7] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: uint total =  				(uint)((uint)footer[4] & 0xff) |  				(uint)(((uint)footer[5] & 0xff) << 8) |  				(uint)(((uint)footer[6] & 0xff) << 16) |  				(uint)((uint)footer[7] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: uint total =  				(uint)((uint)footer[4] & 0xff) |  				(uint)(((uint)footer[5] & 0xff) << 8) |  				(uint)(((uint)footer[6] & 0xff) << 16) |  				(uint)((uint)footer[7] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: uint total =  				(uint)((uint)footer[4] & 0xff) |  				(uint)(((uint)footer[5] & 0xff) << 8) |  				(uint)(((uint)footer[6] & 0xff) << 16) |  				(uint)((uint)footer[7] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  				state_ = OutputState.Finished;  				base.Finish();    				var totalin = (uint)(deflater_.TotalIn & 0xffffffff);  				var crcval = (uint)(crc.Value & 0xffffffff);    				byte[] gzipFooter;    				unchecked {  					gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'    					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};  				}    				baseOutputStream_.Write(gzipFooter' 0' gzipFooter.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  				state_ = OutputState.Finished;  				base.Finish();    				var totalin = (uint)(deflater_.TotalIn & 0xffffffff);  				var crcval = (uint)(crc.Value & 0xffffffff);    				byte[] gzipFooter;    				unchecked {  					gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'    					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};  				}    				baseOutputStream_.Write(gzipFooter' 0' gzipFooter.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  				state_ = OutputState.Finished;  				base.Finish();    				var totalin = (uint)(deflater_.TotalIn & 0xffffffff);  				var crcval = (uint)(crc.Value & 0xffffffff);    				byte[] gzipFooter;    				unchecked {  					gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'    					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};  				}    				baseOutputStream_.Write(gzipFooter' 0' gzipFooter.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  				state_ = OutputState.Finished;  				base.Finish();    				var totalin = (uint)(deflater_.TotalIn & 0xffffffff);  				var crcval = (uint)(crc.Value & 0xffffffff);    				byte[] gzipFooter;    				unchecked {  					gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'    					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};  				}    				baseOutputStream_.Write(gzipFooter' 0' gzipFooter.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  				state_ = OutputState.Finished;  				base.Finish();    				var totalin = (uint)(deflater_.TotalIn & 0xffffffff);  				var crcval = (uint)(crc.Value & 0xffffffff);    				byte[] gzipFooter;    				unchecked {  					gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'    					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};  				}    				baseOutputStream_.Write(gzipFooter' 0' gzipFooter.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: if (state_ == OutputState.Footer) {  				state_ = OutputState.Finished;  				base.Finish();    				var totalin = (uint)(deflater_.TotalIn & 0xffffffff);  				var crcval = (uint)(crc.Value & 0xffffffff);    				byte[] gzipFooter;    				unchecked {  					gzipFooter = new byte[] {  					(byte) crcval' (byte) (crcval >> 8)'  					(byte) (crcval >> 16)' (byte) (crcval >> 24)'    					(byte) totalin' (byte) (totalin >> 8)'  					(byte) (totalin >> 16)' (byte) (totalin >> 24)  				};  				}    				baseOutputStream_.Write(gzipFooter' 0' gzipFooter.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  				state_ = OutputState.Footer;    				var mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  				byte[] gzipHeader = {  					// The two magic bytes  					(byte) (GZipConstants.GZIP_MAGIC >> 8)' (byte) (GZipConstants.GZIP_MAGIC & 0xff)'    					// The compression type  					(byte) Deflater.DEFLATED'    					// The flags (not set)  					0'    					// The modification time  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'    					// The extra flags  					0'    					// The OS type (unknown)  					(byte) 255  				};  				baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  				state_ = OutputState.Footer;    				var mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  				byte[] gzipHeader = {  					// The two magic bytes  					(byte) (GZipConstants.GZIP_MAGIC >> 8)' (byte) (GZipConstants.GZIP_MAGIC & 0xff)'    					// The compression type  					(byte) Deflater.DEFLATED'    					// The flags (not set)  					0'    					// The modification time  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'    					// The extra flags  					0'    					// The OS type (unknown)  					(byte) 255  				};  				baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  				state_ = OutputState.Footer;    				var mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  				byte[] gzipHeader = {  					// The two magic bytes  					(byte) (GZipConstants.GZIP_MAGIC >> 8)' (byte) (GZipConstants.GZIP_MAGIC & 0xff)'    					// The compression type  					(byte) Deflater.DEFLATED'    					// The flags (not set)  					0'    					// The modification time  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'    					// The extra flags  					0'    					// The OS type (unknown)  					(byte) 255  				};  				baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  				state_ = OutputState.Footer;    				var mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  				byte[] gzipHeader = {  					// The two magic bytes  					(byte) (GZipConstants.GZIP_MAGIC >> 8)' (byte) (GZipConstants.GZIP_MAGIC & 0xff)'    					// The compression type  					(byte) Deflater.DEFLATED'    					// The flags (not set)  					0'    					// The modification time  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'    					// The extra flags  					0'    					// The OS type (unknown)  					(byte) 255  				};  				baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  				state_ = OutputState.Footer;    				var mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  				byte[] gzipHeader = {  					// The two magic bytes  					(byte) (GZipConstants.GZIP_MAGIC >> 8)' (byte) (GZipConstants.GZIP_MAGIC & 0xff)'    					// The compression type  					(byte) Deflater.DEFLATED'    					// The flags (not set)  					0'    					// The modification time  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'    					// The extra flags  					0'    					// The OS type (unknown)  					(byte) 255  				};  				baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if (state_ == OutputState.Header) {  				state_ = OutputState.Footer;    				var mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  				byte[] gzipHeader = {  					// The two magic bytes  					(byte) (GZipConstants.GZIP_MAGIC >> 8)' (byte) (GZipConstants.GZIP_MAGIC & 0xff)'    					// The compression type  					(byte) Deflater.DEFLATED'    					// The flags (not set)  					0'    					// The modification time  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'    					// The extra flags  					0'    					// The OS type (unknown)  					(byte) 255  				};  				baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,Read,The following statement contains a magic number: MainLoop:  			do {  				if (end < EXTRA) {  					Fill();  				}    				int bitIn = (got > 0) ? (end - end % lNBits) << 3 :  										(end << 3) - (lNBits - 1);    				while (lBitPos < bitIn) {  					#region A  					// handle 1-byte reads correctly  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						maxMaxCode = lMaxMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}    					// check for code-width expansion  					if (lFreeEnt > lMaxCode) {  						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) +  						nBytes - (lBitPos - 1 + nBytes) % nBytes;    						lNBits++;  						lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :  														(1 << lNBits) - 1;    						lBitMask = (1 << lNBits) - 1;  						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region B  					// read next code  					int pos = lBitPos >> 3;  					int code = (((lData[pos] & 0xFF) |  						((lData[pos + 1] & 0xFF) << 8) |  						((lData[pos + 2] & 0xFF) << 16)) >>  						(lBitPos & 0x7)) & lBitMask;    					lBitPos += lNBits;    					// handle first iteration  					if (lOldCode == -1) {  						if (code >= 256)  							throw new LzwException("corrupt input: " + code + " > 255");    						lFinChar = (byte)(lOldCode = code);  						buffer[offset++] = lFinChar;  						count--;  						continue;  					}    					// handle CLEAR code  					if (code == TBL_CLEAR && blockMode) {  						Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);  						lFreeEnt = TBL_FIRST - 1;    						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;  						lNBits = LzwConstants.INIT_BITS;  						lMaxCode = (1 << lNBits) - 1;  						lBitMask = lMaxCode;    						// Code tables reset    						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region C  					// setup  					int inCode = code;  					lStackP = lStack.Length;    					// Handle KwK case  					if (code >= lFreeEnt) {  						if (code > lFreeEnt) {  							throw new LzwException("corrupt input: code=" + code +  								"' freeEnt=" + lFreeEnt);  						}    						lStack[--lStackP] = lFinChar;  						code = lOldCode;  					}    					// Generate output characters in reverse order  					while (code >= 256) {  						lStack[--lStackP] = lTabSuffix[code];  						code = lTabPrefix[code];  					}    					lFinChar = lTabSuffix[code];  					buffer[offset++] = lFinChar;  					count--;    					// And put them out in forward order  					sSize = lStack.Length - lStackP;  					int num = (sSize >= count) ? count : sSize;  					Array.Copy(lStack' lStackP' buffer' offset' num);  					offset += num;  					count -= num;  					lStackP += num;  					#endregion    					#region D  					// generate new entry in table  					if (lFreeEnt < lMaxMaxCode) {  						lTabPrefix[lFreeEnt] = lOldCode;  						lTabSuffix[lFreeEnt] = lFinChar;  						lFreeEnt++;  					}    					// Remember previous code  					lOldCode = inCode;    					// if output buffer full' then return  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}  					#endregion  				}   // while    				lBitPos = ResetBuf(lBitPos);    			} while (got > 0);
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,Read,The following statement contains a magic number: MainLoop:  			do {  				if (end < EXTRA) {  					Fill();  				}    				int bitIn = (got > 0) ? (end - end % lNBits) << 3 :  										(end << 3) - (lNBits - 1);    				while (lBitPos < bitIn) {  					#region A  					// handle 1-byte reads correctly  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						maxMaxCode = lMaxMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}    					// check for code-width expansion  					if (lFreeEnt > lMaxCode) {  						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) +  						nBytes - (lBitPos - 1 + nBytes) % nBytes;    						lNBits++;  						lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :  														(1 << lNBits) - 1;    						lBitMask = (1 << lNBits) - 1;  						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region B  					// read next code  					int pos = lBitPos >> 3;  					int code = (((lData[pos] & 0xFF) |  						((lData[pos + 1] & 0xFF) << 8) |  						((lData[pos + 2] & 0xFF) << 16)) >>  						(lBitPos & 0x7)) & lBitMask;    					lBitPos += lNBits;    					// handle first iteration  					if (lOldCode == -1) {  						if (code >= 256)  							throw new LzwException("corrupt input: " + code + " > 255");    						lFinChar = (byte)(lOldCode = code);  						buffer[offset++] = lFinChar;  						count--;  						continue;  					}    					// handle CLEAR code  					if (code == TBL_CLEAR && blockMode) {  						Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);  						lFreeEnt = TBL_FIRST - 1;    						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;  						lNBits = LzwConstants.INIT_BITS;  						lMaxCode = (1 << lNBits) - 1;  						lBitMask = lMaxCode;    						// Code tables reset    						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region C  					// setup  					int inCode = code;  					lStackP = lStack.Length;    					// Handle KwK case  					if (code >= lFreeEnt) {  						if (code > lFreeEnt) {  							throw new LzwException("corrupt input: code=" + code +  								"' freeEnt=" + lFreeEnt);  						}    						lStack[--lStackP] = lFinChar;  						code = lOldCode;  					}    					// Generate output characters in reverse order  					while (code >= 256) {  						lStack[--lStackP] = lTabSuffix[code];  						code = lTabPrefix[code];  					}    					lFinChar = lTabSuffix[code];  					buffer[offset++] = lFinChar;  					count--;    					// And put them out in forward order  					sSize = lStack.Length - lStackP;  					int num = (sSize >= count) ? count : sSize;  					Array.Copy(lStack' lStackP' buffer' offset' num);  					offset += num;  					count -= num;  					lStackP += num;  					#endregion    					#region D  					// generate new entry in table  					if (lFreeEnt < lMaxMaxCode) {  						lTabPrefix[lFreeEnt] = lOldCode;  						lTabSuffix[lFreeEnt] = lFinChar;  						lFreeEnt++;  					}    					// Remember previous code  					lOldCode = inCode;    					// if output buffer full' then return  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}  					#endregion  				}   // while    				lBitPos = ResetBuf(lBitPos);    			} while (got > 0);
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,Read,The following statement contains a magic number: MainLoop:  			do {  				if (end < EXTRA) {  					Fill();  				}    				int bitIn = (got > 0) ? (end - end % lNBits) << 3 :  										(end << 3) - (lNBits - 1);    				while (lBitPos < bitIn) {  					#region A  					// handle 1-byte reads correctly  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						maxMaxCode = lMaxMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}    					// check for code-width expansion  					if (lFreeEnt > lMaxCode) {  						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) +  						nBytes - (lBitPos - 1 + nBytes) % nBytes;    						lNBits++;  						lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :  														(1 << lNBits) - 1;    						lBitMask = (1 << lNBits) - 1;  						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region B  					// read next code  					int pos = lBitPos >> 3;  					int code = (((lData[pos] & 0xFF) |  						((lData[pos + 1] & 0xFF) << 8) |  						((lData[pos + 2] & 0xFF) << 16)) >>  						(lBitPos & 0x7)) & lBitMask;    					lBitPos += lNBits;    					// handle first iteration  					if (lOldCode == -1) {  						if (code >= 256)  							throw new LzwException("corrupt input: " + code + " > 255");    						lFinChar = (byte)(lOldCode = code);  						buffer[offset++] = lFinChar;  						count--;  						continue;  					}    					// handle CLEAR code  					if (code == TBL_CLEAR && blockMode) {  						Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);  						lFreeEnt = TBL_FIRST - 1;    						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;  						lNBits = LzwConstants.INIT_BITS;  						lMaxCode = (1 << lNBits) - 1;  						lBitMask = lMaxCode;    						// Code tables reset    						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region C  					// setup  					int inCode = code;  					lStackP = lStack.Length;    					// Handle KwK case  					if (code >= lFreeEnt) {  						if (code > lFreeEnt) {  							throw new LzwException("corrupt input: code=" + code +  								"' freeEnt=" + lFreeEnt);  						}    						lStack[--lStackP] = lFinChar;  						code = lOldCode;  					}    					// Generate output characters in reverse order  					while (code >= 256) {  						lStack[--lStackP] = lTabSuffix[code];  						code = lTabPrefix[code];  					}    					lFinChar = lTabSuffix[code];  					buffer[offset++] = lFinChar;  					count--;    					// And put them out in forward order  					sSize = lStack.Length - lStackP;  					int num = (sSize >= count) ? count : sSize;  					Array.Copy(lStack' lStackP' buffer' offset' num);  					offset += num;  					count -= num;  					lStackP += num;  					#endregion    					#region D  					// generate new entry in table  					if (lFreeEnt < lMaxMaxCode) {  						lTabPrefix[lFreeEnt] = lOldCode;  						lTabSuffix[lFreeEnt] = lFinChar;  						lFreeEnt++;  					}    					// Remember previous code  					lOldCode = inCode;    					// if output buffer full' then return  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}  					#endregion  				}   // while    				lBitPos = ResetBuf(lBitPos);    			} while (got > 0);
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,Read,The following statement contains a magic number: MainLoop:  			do {  				if (end < EXTRA) {  					Fill();  				}    				int bitIn = (got > 0) ? (end - end % lNBits) << 3 :  										(end << 3) - (lNBits - 1);    				while (lBitPos < bitIn) {  					#region A  					// handle 1-byte reads correctly  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						maxMaxCode = lMaxMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}    					// check for code-width expansion  					if (lFreeEnt > lMaxCode) {  						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) +  						nBytes - (lBitPos - 1 + nBytes) % nBytes;    						lNBits++;  						lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :  														(1 << lNBits) - 1;    						lBitMask = (1 << lNBits) - 1;  						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region B  					// read next code  					int pos = lBitPos >> 3;  					int code = (((lData[pos] & 0xFF) |  						((lData[pos + 1] & 0xFF) << 8) |  						((lData[pos + 2] & 0xFF) << 16)) >>  						(lBitPos & 0x7)) & lBitMask;    					lBitPos += lNBits;    					// handle first iteration  					if (lOldCode == -1) {  						if (code >= 256)  							throw new LzwException("corrupt input: " + code + " > 255");    						lFinChar = (byte)(lOldCode = code);  						buffer[offset++] = lFinChar;  						count--;  						continue;  					}    					// handle CLEAR code  					if (code == TBL_CLEAR && blockMode) {  						Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);  						lFreeEnt = TBL_FIRST - 1;    						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;  						lNBits = LzwConstants.INIT_BITS;  						lMaxCode = (1 << lNBits) - 1;  						lBitMask = lMaxCode;    						// Code tables reset    						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region C  					// setup  					int inCode = code;  					lStackP = lStack.Length;    					// Handle KwK case  					if (code >= lFreeEnt) {  						if (code > lFreeEnt) {  							throw new LzwException("corrupt input: code=" + code +  								"' freeEnt=" + lFreeEnt);  						}    						lStack[--lStackP] = lFinChar;  						code = lOldCode;  					}    					// Generate output characters in reverse order  					while (code >= 256) {  						lStack[--lStackP] = lTabSuffix[code];  						code = lTabPrefix[code];  					}    					lFinChar = lTabSuffix[code];  					buffer[offset++] = lFinChar;  					count--;    					// And put them out in forward order  					sSize = lStack.Length - lStackP;  					int num = (sSize >= count) ? count : sSize;  					Array.Copy(lStack' lStackP' buffer' offset' num);  					offset += num;  					count -= num;  					lStackP += num;  					#endregion    					#region D  					// generate new entry in table  					if (lFreeEnt < lMaxMaxCode) {  						lTabPrefix[lFreeEnt] = lOldCode;  						lTabSuffix[lFreeEnt] = lFinChar;  						lFreeEnt++;  					}    					// Remember previous code  					lOldCode = inCode;    					// if output buffer full' then return  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}  					#endregion  				}   // while    				lBitPos = ResetBuf(lBitPos);    			} while (got > 0);
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,Read,The following statement contains a magic number: MainLoop:  			do {  				if (end < EXTRA) {  					Fill();  				}    				int bitIn = (got > 0) ? (end - end % lNBits) << 3 :  										(end << 3) - (lNBits - 1);    				while (lBitPos < bitIn) {  					#region A  					// handle 1-byte reads correctly  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						maxMaxCode = lMaxMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}    					// check for code-width expansion  					if (lFreeEnt > lMaxCode) {  						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) +  						nBytes - (lBitPos - 1 + nBytes) % nBytes;    						lNBits++;  						lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :  														(1 << lNBits) - 1;    						lBitMask = (1 << lNBits) - 1;  						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region B  					// read next code  					int pos = lBitPos >> 3;  					int code = (((lData[pos] & 0xFF) |  						((lData[pos + 1] & 0xFF) << 8) |  						((lData[pos + 2] & 0xFF) << 16)) >>  						(lBitPos & 0x7)) & lBitMask;    					lBitPos += lNBits;    					// handle first iteration  					if (lOldCode == -1) {  						if (code >= 256)  							throw new LzwException("corrupt input: " + code + " > 255");    						lFinChar = (byte)(lOldCode = code);  						buffer[offset++] = lFinChar;  						count--;  						continue;  					}    					// handle CLEAR code  					if (code == TBL_CLEAR && blockMode) {  						Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);  						lFreeEnt = TBL_FIRST - 1;    						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;  						lNBits = LzwConstants.INIT_BITS;  						lMaxCode = (1 << lNBits) - 1;  						lBitMask = lMaxCode;    						// Code tables reset    						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region C  					// setup  					int inCode = code;  					lStackP = lStack.Length;    					// Handle KwK case  					if (code >= lFreeEnt) {  						if (code > lFreeEnt) {  							throw new LzwException("corrupt input: code=" + code +  								"' freeEnt=" + lFreeEnt);  						}    						lStack[--lStackP] = lFinChar;  						code = lOldCode;  					}    					// Generate output characters in reverse order  					while (code >= 256) {  						lStack[--lStackP] = lTabSuffix[code];  						code = lTabPrefix[code];  					}    					lFinChar = lTabSuffix[code];  					buffer[offset++] = lFinChar;  					count--;    					// And put them out in forward order  					sSize = lStack.Length - lStackP;  					int num = (sSize >= count) ? count : sSize;  					Array.Copy(lStack' lStackP' buffer' offset' num);  					offset += num;  					count -= num;  					lStackP += num;  					#endregion    					#region D  					// generate new entry in table  					if (lFreeEnt < lMaxMaxCode) {  						lTabPrefix[lFreeEnt] = lOldCode;  						lTabSuffix[lFreeEnt] = lFinChar;  						lFreeEnt++;  					}    					// Remember previous code  					lOldCode = inCode;    					// if output buffer full' then return  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}  					#endregion  				}   // while    				lBitPos = ResetBuf(lBitPos);    			} while (got > 0);
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,Read,The following statement contains a magic number: MainLoop:  			do {  				if (end < EXTRA) {  					Fill();  				}    				int bitIn = (got > 0) ? (end - end % lNBits) << 3 :  										(end << 3) - (lNBits - 1);    				while (lBitPos < bitIn) {  					#region A  					// handle 1-byte reads correctly  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						maxMaxCode = lMaxMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}    					// check for code-width expansion  					if (lFreeEnt > lMaxCode) {  						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) +  						nBytes - (lBitPos - 1 + nBytes) % nBytes;    						lNBits++;  						lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :  														(1 << lNBits) - 1;    						lBitMask = (1 << lNBits) - 1;  						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region B  					// read next code  					int pos = lBitPos >> 3;  					int code = (((lData[pos] & 0xFF) |  						((lData[pos + 1] & 0xFF) << 8) |  						((lData[pos + 2] & 0xFF) << 16)) >>  						(lBitPos & 0x7)) & lBitMask;    					lBitPos += lNBits;    					// handle first iteration  					if (lOldCode == -1) {  						if (code >= 256)  							throw new LzwException("corrupt input: " + code + " > 255");    						lFinChar = (byte)(lOldCode = code);  						buffer[offset++] = lFinChar;  						count--;  						continue;  					}    					// handle CLEAR code  					if (code == TBL_CLEAR && blockMode) {  						Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);  						lFreeEnt = TBL_FIRST - 1;    						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;  						lNBits = LzwConstants.INIT_BITS;  						lMaxCode = (1 << lNBits) - 1;  						lBitMask = lMaxCode;    						// Code tables reset    						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region C  					// setup  					int inCode = code;  					lStackP = lStack.Length;    					// Handle KwK case  					if (code >= lFreeEnt) {  						if (code > lFreeEnt) {  							throw new LzwException("corrupt input: code=" + code +  								"' freeEnt=" + lFreeEnt);  						}    						lStack[--lStackP] = lFinChar;  						code = lOldCode;  					}    					// Generate output characters in reverse order  					while (code >= 256) {  						lStack[--lStackP] = lTabSuffix[code];  						code = lTabPrefix[code];  					}    					lFinChar = lTabSuffix[code];  					buffer[offset++] = lFinChar;  					count--;    					// And put them out in forward order  					sSize = lStack.Length - lStackP;  					int num = (sSize >= count) ? count : sSize;  					Array.Copy(lStack' lStackP' buffer' offset' num);  					offset += num;  					count -= num;  					lStackP += num;  					#endregion    					#region D  					// generate new entry in table  					if (lFreeEnt < lMaxMaxCode) {  						lTabPrefix[lFreeEnt] = lOldCode;  						lTabSuffix[lFreeEnt] = lFinChar;  						lFreeEnt++;  					}    					// Remember previous code  					lOldCode = inCode;    					// if output buffer full' then return  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}  					#endregion  				}   // while    				lBitPos = ResetBuf(lBitPos);    			} while (got > 0);
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,Read,The following statement contains a magic number: MainLoop:  			do {  				if (end < EXTRA) {  					Fill();  				}    				int bitIn = (got > 0) ? (end - end % lNBits) << 3 :  										(end << 3) - (lNBits - 1);    				while (lBitPos < bitIn) {  					#region A  					// handle 1-byte reads correctly  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						maxMaxCode = lMaxMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}    					// check for code-width expansion  					if (lFreeEnt > lMaxCode) {  						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) +  						nBytes - (lBitPos - 1 + nBytes) % nBytes;    						lNBits++;  						lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :  														(1 << lNBits) - 1;    						lBitMask = (1 << lNBits) - 1;  						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region B  					// read next code  					int pos = lBitPos >> 3;  					int code = (((lData[pos] & 0xFF) |  						((lData[pos + 1] & 0xFF) << 8) |  						((lData[pos + 2] & 0xFF) << 16)) >>  						(lBitPos & 0x7)) & lBitMask;    					lBitPos += lNBits;    					// handle first iteration  					if (lOldCode == -1) {  						if (code >= 256)  							throw new LzwException("corrupt input: " + code + " > 255");    						lFinChar = (byte)(lOldCode = code);  						buffer[offset++] = lFinChar;  						count--;  						continue;  					}    					// handle CLEAR code  					if (code == TBL_CLEAR && blockMode) {  						Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);  						lFreeEnt = TBL_FIRST - 1;    						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;  						lNBits = LzwConstants.INIT_BITS;  						lMaxCode = (1 << lNBits) - 1;  						lBitMask = lMaxCode;    						// Code tables reset    						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region C  					// setup  					int inCode = code;  					lStackP = lStack.Length;    					// Handle KwK case  					if (code >= lFreeEnt) {  						if (code > lFreeEnt) {  							throw new LzwException("corrupt input: code=" + code +  								"' freeEnt=" + lFreeEnt);  						}    						lStack[--lStackP] = lFinChar;  						code = lOldCode;  					}    					// Generate output characters in reverse order  					while (code >= 256) {  						lStack[--lStackP] = lTabSuffix[code];  						code = lTabPrefix[code];  					}    					lFinChar = lTabSuffix[code];  					buffer[offset++] = lFinChar;  					count--;    					// And put them out in forward order  					sSize = lStack.Length - lStackP;  					int num = (sSize >= count) ? count : sSize;  					Array.Copy(lStack' lStackP' buffer' offset' num);  					offset += num;  					count -= num;  					lStackP += num;  					#endregion    					#region D  					// generate new entry in table  					if (lFreeEnt < lMaxMaxCode) {  						lTabPrefix[lFreeEnt] = lOldCode;  						lTabSuffix[lFreeEnt] = lFinChar;  						lFreeEnt++;  					}    					// Remember previous code  					lOldCode = inCode;    					// if output buffer full' then return  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}  					#endregion  				}   // while    				lBitPos = ResetBuf(lBitPos);    			} while (got > 0);
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,Read,The following statement contains a magic number: MainLoop:  			do {  				if (end < EXTRA) {  					Fill();  				}    				int bitIn = (got > 0) ? (end - end % lNBits) << 3 :  										(end << 3) - (lNBits - 1);    				while (lBitPos < bitIn) {  					#region A  					// handle 1-byte reads correctly  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						maxMaxCode = lMaxMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}    					// check for code-width expansion  					if (lFreeEnt > lMaxCode) {  						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) +  						nBytes - (lBitPos - 1 + nBytes) % nBytes;    						lNBits++;  						lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :  														(1 << lNBits) - 1;    						lBitMask = (1 << lNBits) - 1;  						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region B  					// read next code  					int pos = lBitPos >> 3;  					int code = (((lData[pos] & 0xFF) |  						((lData[pos + 1] & 0xFF) << 8) |  						((lData[pos + 2] & 0xFF) << 16)) >>  						(lBitPos & 0x7)) & lBitMask;    					lBitPos += lNBits;    					// handle first iteration  					if (lOldCode == -1) {  						if (code >= 256)  							throw new LzwException("corrupt input: " + code + " > 255");    						lFinChar = (byte)(lOldCode = code);  						buffer[offset++] = lFinChar;  						count--;  						continue;  					}    					// handle CLEAR code  					if (code == TBL_CLEAR && blockMode) {  						Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);  						lFreeEnt = TBL_FIRST - 1;    						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;  						lNBits = LzwConstants.INIT_BITS;  						lMaxCode = (1 << lNBits) - 1;  						lBitMask = lMaxCode;    						// Code tables reset    						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region C  					// setup  					int inCode = code;  					lStackP = lStack.Length;    					// Handle KwK case  					if (code >= lFreeEnt) {  						if (code > lFreeEnt) {  							throw new LzwException("corrupt input: code=" + code +  								"' freeEnt=" + lFreeEnt);  						}    						lStack[--lStackP] = lFinChar;  						code = lOldCode;  					}    					// Generate output characters in reverse order  					while (code >= 256) {  						lStack[--lStackP] = lTabSuffix[code];  						code = lTabPrefix[code];  					}    					lFinChar = lTabSuffix[code];  					buffer[offset++] = lFinChar;  					count--;    					// And put them out in forward order  					sSize = lStack.Length - lStackP;  					int num = (sSize >= count) ? count : sSize;  					Array.Copy(lStack' lStackP' buffer' offset' num);  					offset += num;  					count -= num;  					lStackP += num;  					#endregion    					#region D  					// generate new entry in table  					if (lFreeEnt < lMaxMaxCode) {  						lTabPrefix[lFreeEnt] = lOldCode;  						lTabSuffix[lFreeEnt] = lFinChar;  						lFreeEnt++;  					}    					// Remember previous code  					lOldCode = inCode;    					// if output buffer full' then return  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}  					#endregion  				}   // while    				lBitPos = ResetBuf(lBitPos);    			} while (got > 0);
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,Read,The following statement contains a magic number: MainLoop:  			do {  				if (end < EXTRA) {  					Fill();  				}    				int bitIn = (got > 0) ? (end - end % lNBits) << 3 :  										(end << 3) - (lNBits - 1);    				while (lBitPos < bitIn) {  					#region A  					// handle 1-byte reads correctly  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						maxMaxCode = lMaxMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}    					// check for code-width expansion  					if (lFreeEnt > lMaxCode) {  						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) +  						nBytes - (lBitPos - 1 + nBytes) % nBytes;    						lNBits++;  						lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :  														(1 << lNBits) - 1;    						lBitMask = (1 << lNBits) - 1;  						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region B  					// read next code  					int pos = lBitPos >> 3;  					int code = (((lData[pos] & 0xFF) |  						((lData[pos + 1] & 0xFF) << 8) |  						((lData[pos + 2] & 0xFF) << 16)) >>  						(lBitPos & 0x7)) & lBitMask;    					lBitPos += lNBits;    					// handle first iteration  					if (lOldCode == -1) {  						if (code >= 256)  							throw new LzwException("corrupt input: " + code + " > 255");    						lFinChar = (byte)(lOldCode = code);  						buffer[offset++] = lFinChar;  						count--;  						continue;  					}    					// handle CLEAR code  					if (code == TBL_CLEAR && blockMode) {  						Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);  						lFreeEnt = TBL_FIRST - 1;    						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;  						lNBits = LzwConstants.INIT_BITS;  						lMaxCode = (1 << lNBits) - 1;  						lBitMask = lMaxCode;    						// Code tables reset    						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region C  					// setup  					int inCode = code;  					lStackP = lStack.Length;    					// Handle KwK case  					if (code >= lFreeEnt) {  						if (code > lFreeEnt) {  							throw new LzwException("corrupt input: code=" + code +  								"' freeEnt=" + lFreeEnt);  						}    						lStack[--lStackP] = lFinChar;  						code = lOldCode;  					}    					// Generate output characters in reverse order  					while (code >= 256) {  						lStack[--lStackP] = lTabSuffix[code];  						code = lTabPrefix[code];  					}    					lFinChar = lTabSuffix[code];  					buffer[offset++] = lFinChar;  					count--;    					// And put them out in forward order  					sSize = lStack.Length - lStackP;  					int num = (sSize >= count) ? count : sSize;  					Array.Copy(lStack' lStackP' buffer' offset' num);  					offset += num;  					count -= num;  					lStackP += num;  					#endregion    					#region D  					// generate new entry in table  					if (lFreeEnt < lMaxMaxCode) {  						lTabPrefix[lFreeEnt] = lOldCode;  						lTabSuffix[lFreeEnt] = lFinChar;  						lFreeEnt++;  					}    					// Remember previous code  					lOldCode = inCode;    					// if output buffer full' then return  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}  					#endregion  				}   // while    				lBitPos = ResetBuf(lBitPos);    			} while (got > 0);
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,Read,The following statement contains a magic number: MainLoop:  			do {  				if (end < EXTRA) {  					Fill();  				}    				int bitIn = (got > 0) ? (end - end % lNBits) << 3 :  										(end << 3) - (lNBits - 1);    				while (lBitPos < bitIn) {  					#region A  					// handle 1-byte reads correctly  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						maxMaxCode = lMaxMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}    					// check for code-width expansion  					if (lFreeEnt > lMaxCode) {  						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) +  						nBytes - (lBitPos - 1 + nBytes) % nBytes;    						lNBits++;  						lMaxCode = (lNBits == maxBits) ? lMaxMaxCode :  														(1 << lNBits) - 1;    						lBitMask = (1 << lNBits) - 1;  						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region B  					// read next code  					int pos = lBitPos >> 3;  					int code = (((lData[pos] & 0xFF) |  						((lData[pos + 1] & 0xFF) << 8) |  						((lData[pos + 2] & 0xFF) << 16)) >>  						(lBitPos & 0x7)) & lBitMask;    					lBitPos += lNBits;    					// handle first iteration  					if (lOldCode == -1) {  						if (code >= 256)  							throw new LzwException("corrupt input: " + code + " > 255");    						lFinChar = (byte)(lOldCode = code);  						buffer[offset++] = lFinChar;  						count--;  						continue;  					}    					// handle CLEAR code  					if (code == TBL_CLEAR && blockMode) {  						Array.Copy(zeros' 0' lTabPrefix' 0' zeros.Length);  						lFreeEnt = TBL_FIRST - 1;    						int nBytes = lNBits << 3;  						lBitPos = (lBitPos - 1) + nBytes - (lBitPos - 1 + nBytes) % nBytes;  						lNBits = LzwConstants.INIT_BITS;  						lMaxCode = (1 << lNBits) - 1;  						lBitMask = lMaxCode;    						// Code tables reset    						lBitPos = ResetBuf(lBitPos);  						goto MainLoop;  					}  					#endregion    					#region C  					// setup  					int inCode = code;  					lStackP = lStack.Length;    					// Handle KwK case  					if (code >= lFreeEnt) {  						if (code > lFreeEnt) {  							throw new LzwException("corrupt input: code=" + code +  								"' freeEnt=" + lFreeEnt);  						}    						lStack[--lStackP] = lFinChar;  						code = lOldCode;  					}    					// Generate output characters in reverse order  					while (code >= 256) {  						lStack[--lStackP] = lTabSuffix[code];  						code = lTabPrefix[code];  					}    					lFinChar = lTabSuffix[code];  					buffer[offset++] = lFinChar;  					count--;    					// And put them out in forward order  					sSize = lStack.Length - lStackP;  					int num = (sSize >= count) ? count : sSize;  					Array.Copy(lStack' lStackP' buffer' offset' num);  					offset += num;  					count -= num;  					lStackP += num;  					#endregion    					#region D  					// generate new entry in table  					if (lFreeEnt < lMaxMaxCode) {  						lTabPrefix[lFreeEnt] = lOldCode;  						lTabSuffix[lFreeEnt] = lFinChar;  						lFreeEnt++;  					}    					// Remember previous code  					lOldCode = inCode;    					// if output buffer full' then return  					if (count == 0) {  						nBits = lNBits;  						maxCode = lMaxCode;  						bitMask = lBitMask;  						oldCode = lOldCode;  						finChar = lFinChar;  						stackP = lStackP;  						freeEnt = lFreeEnt;  						bitPos = lBitPos;    						return offset - start;  					}  					#endregion  				}   // while    				lBitPos = ResetBuf(lBitPos);    			} while (got > 0);
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,ResetBuf,The following statement contains a magic number: int pos = bitPosition >> 3;
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,ParseHeader,The following statement contains a magic number: if (hdr[0] != (LzwConstants.MAGIC >> 8) || hdr[1] != (LzwConstants.MAGIC & 0xff)) {  				throw new LzwException(String.Format(  					"Wrong LZW header. Magic bytes don't match. 0x{0:x2} 0x{1:x2}"'  					hdr[0]' hdr[1]));  			}
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,ParseHeader,The following statement contains a magic number: blockMode = (hdr[2] & LzwConstants.BLOCK_MODE_MASK) > 0;
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,ParseHeader,The following statement contains a magic number: maxBits = hdr[2] & LzwConstants.BIT_MASK;
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,ParseHeader,The following statement contains a magic number: if ((hdr[2] & LzwConstants.RESERVED_MASK) > 0) {  				throw new LzwException("Unsupported bits set in the header.");  			}
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,ParseHeader,The following statement contains a magic number: freeEnt = blockMode ? TBL_FIRST : 256;
Magic Number,ICSharpCode.SharpZipLib.Lzw,LzwInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Lzw\LzwInputStream.cs,ParseHeader,The following statement contains a magic number: for (int idx = 255; idx >= 0; idx--)  				tabSuffix[idx] = (byte)idx;
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (entry.IsDirectory) {  				EnsureDirectoryExists(destFile);  			} else {  				string parentDirectory = Path.GetDirectoryName(destFile);  				EnsureDirectoryExists(parentDirectory);    				bool process = true;  				var fileInfo = new FileInfo(destFile);  				if (fileInfo.Exists) {  					if (keepOldFiles) {  						OnProgressMessageEvent(entry' "Destination file already exists");  						process = false;  					} else if ((fileInfo.Attributes & FileAttributes.ReadOnly) != 0) {  						OnProgressMessageEvent(entry' "Destination file already exists' and is read-only");  						process = false;  					}  				}    				if (process) {  					bool asciiTrans = false;    					Stream outputStream = File.Create(destFile);  					if (this.asciiTranslate) {  						asciiTrans = !IsBinary(destFile);  					}    					StreamWriter outw = null;  					if (asciiTrans) {  						outw = new StreamWriter(outputStream);  					}    					byte[] rdbuf = new byte[32 * 1024];    					while (true) {  						int numRead = tarIn.Read(rdbuf' 0' rdbuf.Length);    						if (numRead <= 0) {  							break;  						}    						if (asciiTrans) {  							for (int off = 0' b = 0; b < numRead; ++b) {  								if (rdbuf[b] == 10) {  									string s = Encoding.ASCII.GetString(rdbuf' off' (b - off));  									outw.WriteLine(s);  									off = b + 1;  								}  							}  						} else {  							outputStream.Write(rdbuf' 0' numRead);  						}  					}    					if (asciiTrans) {  						outw.Dispose();  					} else {  						outputStream.Dispose();  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (entry.IsDirectory) {  				EnsureDirectoryExists(destFile);  			} else {  				string parentDirectory = Path.GetDirectoryName(destFile);  				EnsureDirectoryExists(parentDirectory);    				bool process = true;  				var fileInfo = new FileInfo(destFile);  				if (fileInfo.Exists) {  					if (keepOldFiles) {  						OnProgressMessageEvent(entry' "Destination file already exists");  						process = false;  					} else if ((fileInfo.Attributes & FileAttributes.ReadOnly) != 0) {  						OnProgressMessageEvent(entry' "Destination file already exists' and is read-only");  						process = false;  					}  				}    				if (process) {  					bool asciiTrans = false;    					Stream outputStream = File.Create(destFile);  					if (this.asciiTranslate) {  						asciiTrans = !IsBinary(destFile);  					}    					StreamWriter outw = null;  					if (asciiTrans) {  						outw = new StreamWriter(outputStream);  					}    					byte[] rdbuf = new byte[32 * 1024];    					while (true) {  						int numRead = tarIn.Read(rdbuf' 0' rdbuf.Length);    						if (numRead <= 0) {  							break;  						}    						if (asciiTrans) {  							for (int off = 0' b = 0; b < numRead; ++b) {  								if (rdbuf[b] == 10) {  									string s = Encoding.ASCII.GetString(rdbuf' off' (b - off));  									outw.WriteLine(s);  									off = b + 1;  								}  							}  						} else {  							outputStream.Write(rdbuf' 0' numRead);  						}  					}    					if (asciiTrans) {  						outw.Dispose();  					} else {  						outputStream.Dispose();  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (entry.IsDirectory) {  				EnsureDirectoryExists(destFile);  			} else {  				string parentDirectory = Path.GetDirectoryName(destFile);  				EnsureDirectoryExists(parentDirectory);    				bool process = true;  				var fileInfo = new FileInfo(destFile);  				if (fileInfo.Exists) {  					if (keepOldFiles) {  						OnProgressMessageEvent(entry' "Destination file already exists");  						process = false;  					} else if ((fileInfo.Attributes & FileAttributes.ReadOnly) != 0) {  						OnProgressMessageEvent(entry' "Destination file already exists' and is read-only");  						process = false;  					}  				}    				if (process) {  					bool asciiTrans = false;    					Stream outputStream = File.Create(destFile);  					if (this.asciiTranslate) {  						asciiTrans = !IsBinary(destFile);  					}    					StreamWriter outw = null;  					if (asciiTrans) {  						outw = new StreamWriter(outputStream);  					}    					byte[] rdbuf = new byte[32 * 1024];    					while (true) {  						int numRead = tarIn.Read(rdbuf' 0' rdbuf.Length);    						if (numRead <= 0) {  							break;  						}    						if (asciiTrans) {  							for (int off = 0' b = 0; b < numRead; ++b) {  								if (rdbuf[b] == 10) {  									string s = Encoding.ASCII.GetString(rdbuf' off' (b - off));  									outw.WriteLine(s);  									off = b + 1;  								}  							}  						} else {  							outputStream.Write(rdbuf' 0' numRead);  						}  					}    					if (asciiTrans) {  						outw.Dispose();  					} else {  						outputStream.Dispose();  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarArchive.cs,WriteEntryCore,The following statement contains a magic number: if (entry.IsDirectory) {  				if (recurse) {  					TarEntry[] list = entry.GetDirectoryEntries();  					for (int i = 0; i < list.Length; ++i) {  						WriteEntryCore(list[i]' recurse);  					}  				}  			} else {  				using (Stream inputStream = File.OpenRead(entryFilename)) {  					byte[] localBuffer = new byte[32 * 1024];  					while (true) {  						int numRead = inputStream.Read(localBuffer' 0' localBuffer.Length);    						if (numRead <= 0) {  							break;  						}    						tarOut.Write(localBuffer' 0' numRead);  					}  				}    				if (!string.IsNullOrEmpty(tempFileName)) {  					File.Delete(tempFileName);  				}    				tarOut.CloseEntry();  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarArchive.cs,WriteEntryCore,The following statement contains a magic number: if (entry.IsDirectory) {  				if (recurse) {  					TarEntry[] list = entry.GetDirectoryEntries();  					for (int i = 0; i < list.Length; ++i) {  						WriteEntryCore(list[i]' recurse);  					}  				}  			} else {  				using (Stream inputStream = File.OpenRead(entryFilename)) {  					byte[] localBuffer = new byte[32 * 1024];  					while (true) {  						int numRead = inputStream.Read(localBuffer' 0' localBuffer.Length);    						if (numRead <= 0) {  							break;  						}    						tarOut.Write(localBuffer' 0' numRead);  					}  				}    				if (!string.IsNullOrEmpty(tempFileName)) {  					File.Delete(tempFileName);  				}    				tarOut.CloseEntry();  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = File.OpenRead(filename)) {  				int sampleSize = Math.Min(4096' (int)fs.Length);  				byte[] content = new byte[sampleSize];    				int bytesRead = fs.Read(content' 0' sampleSize);    				for (int i = 0; i < bytesRead; ++i) {  					byte b = content[i];  					if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  						return true;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = File.OpenRead(filename)) {  				int sampleSize = Math.Min(4096' (int)fs.Length);  				byte[] content = new byte[sampleSize];    				int bytesRead = fs.Read(content' 0' sampleSize);    				for (int i = 0; i < bytesRead; ++i) {  					byte b = content[i];  					if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  						return true;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = File.OpenRead(filename)) {  				int sampleSize = Math.Min(4096' (int)fs.Length);  				byte[] content = new byte[sampleSize];    				int bytesRead = fs.Read(content' 0' sampleSize);    				for (int i = 0; i < bytesRead; ++i) {  					byte b = content[i];  					if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  						return true;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = File.OpenRead(filename)) {  				int sampleSize = Math.Min(4096' (int)fs.Length);  				byte[] content = new byte[sampleSize];    				int bytesRead = fs.Read(content' 0' sampleSize);    				for (int i = 0; i < bytesRead; ++i) {  					byte b = content[i];  					if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  						return true;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = File.OpenRead(filename)) {  				int sampleSize = Math.Min(4096' (int)fs.Length);  				byte[] content = new byte[sampleSize];    				int bytesRead = fs.Read(content' 0' sampleSize);    				for (int i = 0; i < bytesRead; ++i) {  					byte b = content[i];  					if ((b < 8) || ((b > 13) && (b < 32)) || (b == 255)) {  						return true;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarEntry.cs,GetFileTarHeader,The following statement contains a magic number: if (Directory.Exists(file)) {  				header.Mode = 1003; // Magic number for security access for a UNIX filesystem  				header.TypeFlag = TarHeader.LF_DIR;  				if ((header.Name.Length == 0) || header.Name[header.Name.Length - 1] != '/') {  					header.Name = header.Name + "/";  				}    				header.Size = 0;  			} else {  				header.Mode = 33216; // Magic number for security access for a UNIX filesystem  				header.TypeFlag = TarHeader.LF_NORMAL;  				header.Size = new FileInfo(file.Replace('/'' Path.DirectorySeparatorChar)).Length;  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarEntry.cs,GetFileTarHeader,The following statement contains a magic number: if (Directory.Exists(file)) {  				header.Mode = 1003; // Magic number for security access for a UNIX filesystem  				header.TypeFlag = TarHeader.LF_DIR;  				if ((header.Name.Length == 0) || header.Name[header.Name.Length - 1] != '/') {  					header.Name = header.Name + "/";  				}    				header.Size = 0;  			} else {  				header.Mode = 33216; // Magic number for security access for a UNIX filesystem  				header.TypeFlag = TarHeader.LF_NORMAL;  				header.Size = new FileInfo(file.Replace('/'' Path.DirectorySeparatorChar)).Length;  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarEntry.cs,NameTarHeader,The following statement contains a magic number: header.Mode = isDir ? 1003 : 33216;
Magic Number,ICSharpCode.SharpZipLib.Tar,TarEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarEntry.cs,NameTarHeader,The following statement contains a magic number: header.Mode = isDir ? 1003 : 33216;
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarHeader.cs,ParseBinaryOrOctal,The following statement contains a magic number: if (header[offset] >= 0x80) {  				// File sizes over 8GB are stored in 8 right-justified bytes of binary indicated by setting the high-order bit of the leftmost byte of a numeric field.  				long result = 0;  				for (int pos = length - 8; pos < length; pos++) {  					result = result << 8 | header[offset + pos];  				}  				return result;  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarHeader.cs,ParseBinaryOrOctal,The following statement contains a magic number: if (header[offset] >= 0x80) {  				// File sizes over 8GB are stored in 8 right-justified bytes of binary indicated by setting the high-order bit of the leftmost byte of a numeric field.  				long result = 0;  				for (int pos = length - 8; pos < length; pos++) {  					result = result << 8 | header[offset + pos];  				}  				return result;  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarHeader.cs,ParseOctal,The following statement contains a magic number: for (int i = offset; i < end; ++i) {  				if (header[i] == 0) {  					break;  				}    				if (header[i] == (byte)' ' || header[i] == '0') {  					if (stillPadding) {  						continue;  					}    					if (header[i] == (byte)' ') {  						break;  					}  				}    				stillPadding = false;    				result = (result << 3) + (header[i] - '0');  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarHeader.cs,GetOctalBytes,The following statement contains a magic number: if (value > 0) {  				for (long v = value; (localIndex >= 0) && (v > 0); --localIndex) {  					buffer[offset + localIndex] = (byte)((byte)'0' + (byte)(v & 7));  					v >>= 3;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarHeader.cs,GetOctalBytes,The following statement contains a magic number: if (value > 0) {  				for (long v = value; (localIndex >= 0) && (v > 0); --localIndex) {  					buffer[offset + localIndex] = (byte)((byte)'0' + (byte)(v & 7));  					v >>= 3;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarHeader.cs,GetBinaryOrOctalBytes,The following statement contains a magic number: if (value > 0x1FFFFFFFF) {  // Octal 77777777777 (11 digits)  										// Put value as binary' right-justified into the buffer. Set high order bit of left-most byte.  				for (int pos = length - 1; pos > 0; pos--) {  					buffer[offset + pos] = (byte)value;  					value = value >> 8;  				}  				buffer[offset] = 0x80;  				return offset + length;  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarInputStream.cs,Skip,The following statement contains a magic number: byte[] skipBuf = new byte[8 * 1024];
Magic Number,ICSharpCode.SharpZipLib.Tar,TarInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarInputStream.cs,Skip,The following statement contains a magic number: byte[] skipBuf = new byte[8 * 1024];
Magic Number,ICSharpCode.SharpZipLib.Tar,TarInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarInputStream.cs,CopyEntryContents,The following statement contains a magic number: byte[] tempBuffer = new byte[32 * 1024];
Magic Number,ICSharpCode.SharpZipLib.Tar,TarInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarInputStream.cs,CopyEntryContents,The following statement contains a magic number: byte[] tempBuffer = new byte[32 * 1024];
Magic Number,ICSharpCode.SharpZipLib.Tar,TarOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Tar\TarOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (entry.TarHeader.Name.Length > TarHeader.NAMELEN) {  				var longHeader = new TarHeader();  				longHeader.TypeFlag = TarHeader.LF_GNU_LONGNAME;  				longHeader.Name = longHeader.Name + "././@LongLink";  				longHeader.Mode = 420;//644 by default  				longHeader.UserId = entry.UserId;  				longHeader.GroupId = entry.GroupId;  				longHeader.GroupName = entry.GroupName;  				longHeader.UserName = entry.UserName;  				longHeader.LinkName = "";  				longHeader.Size = entry.TarHeader.Name.Length + 1;  // Plus one to avoid dropping last char    				longHeader.WriteHeader(blockBuffer);  				buffer.WriteBlock(blockBuffer);  // Add special long filename header block    				int nameCharIndex = 0;    				while (nameCharIndex < entry.TarHeader.Name.Length + 1 /* we've allocated one for the null char' now we must make sure it gets written out */) {  					Array.Clear(blockBuffer' 0' blockBuffer.Length);  					TarHeader.GetAsciiBytes(entry.TarHeader.Name' nameCharIndex' this.blockBuffer' 0' TarBuffer.BlockSize); // This func handles OK the extra char out of string length  					nameCharIndex += TarBuffer.BlockSize;  					buffer.WriteBlock(blockBuffer);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflater,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION) {  				level = 6;  			} else if (level < NO_COMPRESSION || level > BEST_COMPRESSION) {  				throw new ArgumentOutOfRangeException(nameof(level));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,SetLevel,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION) {  				level = 6;  			} else if (level < NO_COMPRESSION || level > BEST_COMPRESSION) {  				throw new ArgumentOutOfRangeException(nameof(level));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);    				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}    				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);    				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}    				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);    				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}    				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);    				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}    				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);    				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}    				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);    				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}    				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);    				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}    				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);    				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}    				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);    				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}    				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;) {  				int count = pending.Flush(output' offset' length);  				offset += count;  				totalOut += count;  				length -= count;    				if (length == 0 || state == FINISHED_STATE) {  					break;  				}    				if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  					switch (state) {  						case BUSY_STATE:  							// We need more input now  							return origLength - length;  						case FLUSHING_STATE:  							if (level != NO_COMPRESSION) {  								/* We have to supply some lookahead.  8 bit lookahead  								 * is needed by the zlib inflater' and we must fill  								 * the next byte' so that all bits are flushed.  								 */  								int neededbits = 8 + ((-pending.BitCount) & 7);  								while (neededbits > 0) {  									/* write a static tree block consisting solely of  									 * an EOF:  									 */  									pending.WriteBits(2' 10);  									neededbits -= 10;  								}  							}  							state = BUSY_STATE;  							break;  						case FINISHING_STATE:  							pending.AlignToByte();    							// Compressed data is complete.  Write footer information if required.  							if (!noZlibHeaderOrFooter) {  								int adler = engine.Adler;  								pending.WriteShortMSB(adler >> 16);  								pending.WriteShortMSB(adler & 0xffff);  							}  							state = FINISHED_STATE;  							break;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;) {  				int count = pending.Flush(output' offset' length);  				offset += count;  				totalOut += count;  				length -= count;    				if (length == 0 || state == FINISHED_STATE) {  					break;  				}    				if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  					switch (state) {  						case BUSY_STATE:  							// We need more input now  							return origLength - length;  						case FLUSHING_STATE:  							if (level != NO_COMPRESSION) {  								/* We have to supply some lookahead.  8 bit lookahead  								 * is needed by the zlib inflater' and we must fill  								 * the next byte' so that all bits are flushed.  								 */  								int neededbits = 8 + ((-pending.BitCount) & 7);  								while (neededbits > 0) {  									/* write a static tree block consisting solely of  									 * an EOF:  									 */  									pending.WriteBits(2' 10);  									neededbits -= 10;  								}  							}  							state = BUSY_STATE;  							break;  						case FINISHING_STATE:  							pending.AlignToByte();    							// Compressed data is complete.  Write footer information if required.  							if (!noZlibHeaderOrFooter) {  								int adler = engine.Adler;  								pending.WriteShortMSB(adler >> 16);  								pending.WriteShortMSB(adler & 0xffff);  							}  							state = FINISHED_STATE;  							break;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;) {  				int count = pending.Flush(output' offset' length);  				offset += count;  				totalOut += count;  				length -= count;    				if (length == 0 || state == FINISHED_STATE) {  					break;  				}    				if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  					switch (state) {  						case BUSY_STATE:  							// We need more input now  							return origLength - length;  						case FLUSHING_STATE:  							if (level != NO_COMPRESSION) {  								/* We have to supply some lookahead.  8 bit lookahead  								 * is needed by the zlib inflater' and we must fill  								 * the next byte' so that all bits are flushed.  								 */  								int neededbits = 8 + ((-pending.BitCount) & 7);  								while (neededbits > 0) {  									/* write a static tree block consisting solely of  									 * an EOF:  									 */  									pending.WriteBits(2' 10);  									neededbits -= 10;  								}  							}  							state = BUSY_STATE;  							break;  						case FINISHING_STATE:  							pending.AlignToByte();    							// Compressed data is complete.  Write footer information if required.  							if (!noZlibHeaderOrFooter) {  								int adler = engine.Adler;  								pending.WriteShortMSB(adler >> 16);  								pending.WriteShortMSB(adler & 0xffff);  							}  							state = FINISHED_STATE;  							break;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;) {  				int count = pending.Flush(output' offset' length);  				offset += count;  				totalOut += count;  				length -= count;    				if (length == 0 || state == FINISHED_STATE) {  					break;  				}    				if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  					switch (state) {  						case BUSY_STATE:  							// We need more input now  							return origLength - length;  						case FLUSHING_STATE:  							if (level != NO_COMPRESSION) {  								/* We have to supply some lookahead.  8 bit lookahead  								 * is needed by the zlib inflater' and we must fill  								 * the next byte' so that all bits are flushed.  								 */  								int neededbits = 8 + ((-pending.BitCount) & 7);  								while (neededbits > 0) {  									/* write a static tree block consisting solely of  									 * an EOF:  									 */  									pending.WriteBits(2' 10);  									neededbits -= 10;  								}  							}  							state = BUSY_STATE;  							break;  						case FINISHING_STATE:  							pending.AlignToByte();    							// Compressed data is complete.  Write footer information if required.  							if (!noZlibHeaderOrFooter) {  								int adler = engine.Adler;  								pending.WriteShortMSB(adler >> 16);  								pending.WriteShortMSB(adler & 0xffff);  							}  							state = FINISHED_STATE;  							break;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;) {  				int count = pending.Flush(output' offset' length);  				offset += count;  				totalOut += count;  				length -= count;    				if (length == 0 || state == FINISHED_STATE) {  					break;  				}    				if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  					switch (state) {  						case BUSY_STATE:  							// We need more input now  							return origLength - length;  						case FLUSHING_STATE:  							if (level != NO_COMPRESSION) {  								/* We have to supply some lookahead.  8 bit lookahead  								 * is needed by the zlib inflater' and we must fill  								 * the next byte' so that all bits are flushed.  								 */  								int neededbits = 8 + ((-pending.BitCount) & 7);  								while (neededbits > 0) {  									/* write a static tree block consisting solely of  									 * an EOF:  									 */  									pending.WriteBits(2' 10);  									neededbits -= 10;  								}  							}  							state = BUSY_STATE;  							break;  						case FINISHING_STATE:  							pending.AlignToByte();    							// Compressed data is complete.  Write footer information if required.  							if (!noZlibHeaderOrFooter) {  								int adler = engine.Adler;  								pending.WriteShortMSB(adler >> 16);  								pending.WriteShortMSB(adler & 0xffff);  							}  							state = FINISHED_STATE;  							break;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;) {  				int count = pending.Flush(output' offset' length);  				offset += count;  				totalOut += count;  				length -= count;    				if (length == 0 || state == FINISHED_STATE) {  					break;  				}    				if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  					switch (state) {  						case BUSY_STATE:  							// We need more input now  							return origLength - length;  						case FLUSHING_STATE:  							if (level != NO_COMPRESSION) {  								/* We have to supply some lookahead.  8 bit lookahead  								 * is needed by the zlib inflater' and we must fill  								 * the next byte' so that all bits are flushed.  								 */  								int neededbits = 8 + ((-pending.BitCount) & 7);  								while (neededbits > 0) {  									/* write a static tree block consisting solely of  									 * an EOF:  									 */  									pending.WriteBits(2' 10);  									neededbits -= 10;  								}  							}  							state = BUSY_STATE;  							break;  						case FINISHING_STATE:  							pending.AlignToByte();    							// Compressed data is complete.  Write footer information if required.  							if (!noZlibHeaderOrFooter) {  								int adler = engine.Adler;  								pending.WriteShortMSB(adler >> 16);  								pending.WriteShortMSB(adler & 0xffff);  							}  							state = FINISHED_STATE;  							break;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflaterEngine,The following statement contains a magic number: window = new byte[2 * DeflaterConstants.WSIZE];
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,SetDictionary,The following statement contains a magic number: strstart += 2;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,SetLevel,The following statement contains a magic number: if ((level < 0) || (level > 9)) {  				throw new ArgumentOutOfRangeException(nameof(level));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FillWindow,The following statement contains a magic number: if (lookahead < DeflaterConstants.MIN_LOOKAHEAD && inputOff < inputEnd) {  				int more = 2 * DeflaterConstants.WSIZE - lookahead - strstart;    				if (more > inputEnd - inputOff) {  					more = inputEnd - inputOff;  				}    				System.Array.Copy(inputBuf' inputOff' window' strstart + lookahead' more);  				adler.Update(inputBuf' inputOff' more);    				inputOff += more;  				totalIn += more;  				lookahead += more;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: if (matchLen >= this.goodLength) chainLength >>= 2;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do            {              match = curMatch;              scan = strstart;                if (window[match + matchLen] != scan_end               || window[match + matchLen - 1] != scan_end1               || window[match] != window[scan]               || window[++match] != window[++scan])              {                continue;              }                // scan is set to strstart+1 and the comparison passed' so              // scanMax - scan is the maximum number of bytes we can compare.              // below we compare 8 bytes at a time' so first we compare              // (scanMax - scan) % 8 bytes' so the remainder is a multiple of 8                switch( (scanMax - scan) % 8 )              {              case 1: if (window[++scan] == window[++match]) break;                break;              case 2: if (window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 3: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 4: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 5: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 6: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 7: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              }                if (window[scan] == window[match])              {              /* We check for insufficient lookahead only every 8th comparison;               * the 256th check will be made at strstart + 258 unless lookahead is               * exhausted first.               */                do                {                  if (scan == scanMax)                  {                    ++scan;     // advance to first position not matched                    ++match;                      break;                  }                }                while (window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]);              }                if (scan - strstart > matchLen)              {                #if DebugDeflation                if (DeflaterConstants.DEBUGGING && (ins_h == 0) )                Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart));                #endif                  matchStart = curMatch;                matchLen = scan - strstart;                  if (matchLen >= niceLength)                  break;                            scan_end1 = window[scan - 1];                scan_end = window[scan];              }            } while ((curMatch = (prev[curMatch & DeflaterConstants.WMASK] & 0xffff)) > limit && 0 != --chainLength );
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do            {              match = curMatch;              scan = strstart;                if (window[match + matchLen] != scan_end               || window[match + matchLen - 1] != scan_end1               || window[match] != window[scan]               || window[++match] != window[++scan])              {                continue;              }                // scan is set to strstart+1 and the comparison passed' so              // scanMax - scan is the maximum number of bytes we can compare.              // below we compare 8 bytes at a time' so first we compare              // (scanMax - scan) % 8 bytes' so the remainder is a multiple of 8                switch( (scanMax - scan) % 8 )              {              case 1: if (window[++scan] == window[++match]) break;                break;              case 2: if (window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 3: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 4: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 5: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 6: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 7: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              }                if (window[scan] == window[match])              {              /* We check for insufficient lookahead only every 8th comparison;               * the 256th check will be made at strstart + 258 unless lookahead is               * exhausted first.               */                do                {                  if (scan == scanMax)                  {                    ++scan;     // advance to first position not matched                    ++match;                      break;                  }                }                while (window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]);              }                if (scan - strstart > matchLen)              {                #if DebugDeflation                if (DeflaterConstants.DEBUGGING && (ins_h == 0) )                Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart));                #endif                  matchStart = curMatch;                matchLen = scan - strstart;                  if (matchLen >= niceLength)                  break;                            scan_end1 = window[scan - 1];                scan_end = window[scan];              }            } while ((curMatch = (prev[curMatch & DeflaterConstants.WMASK] & 0xffff)) > limit && 0 != --chainLength );
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do            {              match = curMatch;              scan = strstart;                if (window[match + matchLen] != scan_end               || window[match + matchLen - 1] != scan_end1               || window[match] != window[scan]               || window[++match] != window[++scan])              {                continue;              }                // scan is set to strstart+1 and the comparison passed' so              // scanMax - scan is the maximum number of bytes we can compare.              // below we compare 8 bytes at a time' so first we compare              // (scanMax - scan) % 8 bytes' so the remainder is a multiple of 8                switch( (scanMax - scan) % 8 )              {              case 1: if (window[++scan] == window[++match]) break;                break;              case 2: if (window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 3: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 4: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 5: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 6: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 7: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              }                if (window[scan] == window[match])              {              /* We check for insufficient lookahead only every 8th comparison;               * the 256th check will be made at strstart + 258 unless lookahead is               * exhausted first.               */                do                {                  if (scan == scanMax)                  {                    ++scan;     // advance to first position not matched                    ++match;                      break;                  }                }                while (window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]);              }                if (scan - strstart > matchLen)              {                #if DebugDeflation                if (DeflaterConstants.DEBUGGING && (ins_h == 0) )                Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart));                #endif                  matchStart = curMatch;                matchLen = scan - strstart;                  if (matchLen >= niceLength)                  break;                            scan_end1 = window[scan - 1];                scan_end = window[scan];              }            } while ((curMatch = (prev[curMatch & DeflaterConstants.WMASK] & 0xffff)) > limit && 0 != --chainLength );
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do            {              match = curMatch;              scan = strstart;                if (window[match + matchLen] != scan_end               || window[match + matchLen - 1] != scan_end1               || window[match] != window[scan]               || window[++match] != window[++scan])              {                continue;              }                // scan is set to strstart+1 and the comparison passed' so              // scanMax - scan is the maximum number of bytes we can compare.              // below we compare 8 bytes at a time' so first we compare              // (scanMax - scan) % 8 bytes' so the remainder is a multiple of 8                switch( (scanMax - scan) % 8 )              {              case 1: if (window[++scan] == window[++match]) break;                break;              case 2: if (window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 3: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 4: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 5: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 6: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 7: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              }                if (window[scan] == window[match])              {              /* We check for insufficient lookahead only every 8th comparison;               * the 256th check will be made at strstart + 258 unless lookahead is               * exhausted first.               */                do                {                  if (scan == scanMax)                  {                    ++scan;     // advance to first position not matched                    ++match;                      break;                  }                }                while (window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]);              }                if (scan - strstart > matchLen)              {                #if DebugDeflation                if (DeflaterConstants.DEBUGGING && (ins_h == 0) )                Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart));                #endif                  matchStart = curMatch;                matchLen = scan - strstart;                  if (matchLen >= niceLength)                  break;                            scan_end1 = window[scan - 1];                scan_end = window[scan];              }            } while ((curMatch = (prev[curMatch & DeflaterConstants.WMASK] & 0xffff)) > limit && 0 != --chainLength );
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do            {              match = curMatch;              scan = strstart;                if (window[match + matchLen] != scan_end               || window[match + matchLen - 1] != scan_end1               || window[match] != window[scan]               || window[++match] != window[++scan])              {                continue;              }                // scan is set to strstart+1 and the comparison passed' so              // scanMax - scan is the maximum number of bytes we can compare.              // below we compare 8 bytes at a time' so first we compare              // (scanMax - scan) % 8 bytes' so the remainder is a multiple of 8                switch( (scanMax - scan) % 8 )              {              case 1: if (window[++scan] == window[++match]) break;                break;              case 2: if (window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 3: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 4: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 5: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 6: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 7: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              }                if (window[scan] == window[match])              {              /* We check for insufficient lookahead only every 8th comparison;               * the 256th check will be made at strstart + 258 unless lookahead is               * exhausted first.               */                do                {                  if (scan == scanMax)                  {                    ++scan;     // advance to first position not matched                    ++match;                      break;                  }                }                while (window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]);              }                if (scan - strstart > matchLen)              {                #if DebugDeflation                if (DeflaterConstants.DEBUGGING && (ins_h == 0) )                Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart));                #endif                  matchStart = curMatch;                matchLen = scan - strstart;                  if (matchLen >= niceLength)                  break;                            scan_end1 = window[scan - 1];                scan_end = window[scan];              }            } while ((curMatch = (prev[curMatch & DeflaterConstants.WMASK] & 0xffff)) > limit && 0 != --chainLength );
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do            {              match = curMatch;              scan = strstart;                if (window[match + matchLen] != scan_end               || window[match + matchLen - 1] != scan_end1               || window[match] != window[scan]               || window[++match] != window[++scan])              {                continue;              }                // scan is set to strstart+1 and the comparison passed' so              // scanMax - scan is the maximum number of bytes we can compare.              // below we compare 8 bytes at a time' so first we compare              // (scanMax - scan) % 8 bytes' so the remainder is a multiple of 8                switch( (scanMax - scan) % 8 )              {              case 1: if (window[++scan] == window[++match]) break;                break;              case 2: if (window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 3: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 4: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 5: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 6: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 7: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              }                if (window[scan] == window[match])              {              /* We check for insufficient lookahead only every 8th comparison;               * the 256th check will be made at strstart + 258 unless lookahead is               * exhausted first.               */                do                {                  if (scan == scanMax)                  {                    ++scan;     // advance to first position not matched                    ++match;                      break;                  }                }                while (window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]);              }                if (scan - strstart > matchLen)              {                #if DebugDeflation                if (DeflaterConstants.DEBUGGING && (ins_h == 0) )                Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart));                #endif                  matchStart = curMatch;                matchLen = scan - strstart;                  if (matchLen >= niceLength)                  break;                            scan_end1 = window[scan - 1];                scan_end = window[scan];              }            } while ((curMatch = (prev[curMatch & DeflaterConstants.WMASK] & 0xffff)) > limit && 0 != --chainLength );
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do            {              match = curMatch;              scan = strstart;                if (window[match + matchLen] != scan_end               || window[match + matchLen - 1] != scan_end1               || window[match] != window[scan]               || window[++match] != window[++scan])              {                continue;              }                // scan is set to strstart+1 and the comparison passed' so              // scanMax - scan is the maximum number of bytes we can compare.              // below we compare 8 bytes at a time' so first we compare              // (scanMax - scan) % 8 bytes' so the remainder is a multiple of 8                switch( (scanMax - scan) % 8 )              {              case 1: if (window[++scan] == window[++match]) break;                break;              case 2: if (window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 3: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 4: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 5: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 6: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 7: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              }                if (window[scan] == window[match])              {              /* We check for insufficient lookahead only every 8th comparison;               * the 256th check will be made at strstart + 258 unless lookahead is               * exhausted first.               */                do                {                  if (scan == scanMax)                  {                    ++scan;     // advance to first position not matched                    ++match;                      break;                  }                }                while (window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]                    && window[++scan] == window[++match]);              }                if (scan - strstart > matchLen)              {                #if DebugDeflation                if (DeflaterConstants.DEBUGGING && (ins_h == 0) )                Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart));                #endif                  matchStart = curMatch;                matchLen = scan - strstart;                  if (matchLen >= niceLength)                  break;                            scan_end1 = window[scan - 1];                scan_end = window[scan];              }            } while ((curMatch = (prev[curMatch & DeflaterConstants.WMASK] & 0xffff)) > limit && 0 != --chainLength );
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,The following statement contains a magic number: while (lookahead >= DeflaterConstants.MIN_LOOKAHEAD || flush) {  				if (lookahead == 0) {  					// We are flushing everything  					huffman.FlushBlock(window' blockStart' strstart - blockStart' finish);  					blockStart = strstart;  					return false;  				}    				if (strstart > 2 * DeflaterConstants.WSIZE - DeflaterConstants.MIN_LOOKAHEAD) {  					/* slide window' as FindLongestMatch needs this.  					 * This should only happen when flushing and the window  					 * is almost full.  					 */  					SlideWindow();  				}    				int hashHead;  				if (lookahead >= DeflaterConstants.MIN_MATCH &&  					(hashHead = InsertString()) != 0 &&  					strategy != DeflateStrategy.HuffmanOnly &&  					strstart - hashHead <= DeflaterConstants.MAX_DIST &&  					FindLongestMatch(hashHead)) {  					// longestMatch sets matchStart and matchLen  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING)   					{  						for (int i = 0 ; i < matchLen; i++) {  							if (window[strstart + i] != window[matchStart + i]) {  								throw new SharpZipBaseException("Match failure");  							}  						}  					}  #endif    					bool full = huffman.TallyDist(strstart - matchStart' matchLen);    					lookahead -= matchLen;  					if (matchLen <= max_lazy && lookahead >= DeflaterConstants.MIN_MATCH) {  						while (--matchLen > 0) {  							++strstart;  							InsertString();  						}  						++strstart;  					} else {  						strstart += matchLen;  						if (lookahead >= DeflaterConstants.MIN_MATCH - 1) {  							UpdateHash();  						}  					}  					matchLen = DeflaterConstants.MIN_MATCH - 1;  					if (!full) {  						continue;  					}  				} else {  					// No match found  					huffman.TallyLit(window[strstart] & 0xff);  					++strstart;  					--lookahead;  				}    				if (huffman.IsFull()) {  					bool lastBlock = finish && (lookahead == 0);  					huffman.FlushBlock(window' blockStart' strstart - blockStart' lastBlock);  					blockStart = strstart;  					return !lastBlock;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= DeflaterConstants.MIN_LOOKAHEAD || flush) {  				if (lookahead == 0) {  					if (prevAvailable) {  						huffman.TallyLit(window[strstart - 1] & 0xff);  					}  					prevAvailable = false;    					// We are flushing everything  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING && !flush)   					{  						throw new SharpZipBaseException("Not flushing' but no lookahead");  					}  #endif  					huffman.FlushBlock(window' blockStart' strstart - blockStart'  						finish);  					blockStart = strstart;  					return false;  				}    				if (strstart >= 2 * DeflaterConstants.WSIZE - DeflaterConstants.MIN_LOOKAHEAD) {  					/* slide window' as FindLongestMatch needs this.  					 * This should only happen when flushing and the window  					 * is almost full.  					 */  					SlideWindow();  				}    				int prevMatch = matchStart;  				int prevLen = matchLen;  				if (lookahead >= DeflaterConstants.MIN_MATCH) {    					int hashHead = InsertString();    					if (strategy != DeflateStrategy.HuffmanOnly &&  						hashHead != 0 &&  						strstart - hashHead <= DeflaterConstants.MAX_DIST &&  						FindLongestMatch(hashHead)) {    						// longestMatch sets matchStart and matchLen    						// Discard match if too small and too far away  						if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == DeflaterConstants.MIN_MATCH && strstart - matchStart > TooFar))) {  							matchLen = DeflaterConstants.MIN_MATCH - 1;  						}  					}  				}    				// previous match was better  				if ((prevLen >= DeflaterConstants.MIN_MATCH) && (matchLen <= prevLen)) {  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING)   					{  					   for (int i = 0 ; i < matchLen; i++) {  						  if (window[strstart-1+i] != window[prevMatch + i])  							 throw new SharpZipBaseException();  						}  					}  #endif  					huffman.TallyDist(strstart - 1 - prevMatch' prevLen);  					prevLen -= 2;  					do {  						strstart++;  						lookahead--;  						if (lookahead >= DeflaterConstants.MIN_MATCH) {  							InsertString();  						}  					} while (--prevLen > 0);    					strstart++;  					lookahead--;  					prevAvailable = false;  					matchLen = DeflaterConstants.MIN_MATCH - 1;  				} else {  					if (prevAvailable) {  						huffman.TallyLit(window[strstart - 1] & 0xff);  					}  					prevAvailable = true;  					strstart++;  					lookahead--;  				}    				if (huffman.IsFull()) {  					int len = strstart - blockStart;  					if (prevAvailable) {  						len--;  					}  					bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  					huffman.FlushBlock(window' blockStart' len' lastBlock);  					blockStart += len;  					return !lastBlock;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= DeflaterConstants.MIN_LOOKAHEAD || flush) {  				if (lookahead == 0) {  					if (prevAvailable) {  						huffman.TallyLit(window[strstart - 1] & 0xff);  					}  					prevAvailable = false;    					// We are flushing everything  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING && !flush)   					{  						throw new SharpZipBaseException("Not flushing' but no lookahead");  					}  #endif  					huffman.FlushBlock(window' blockStart' strstart - blockStart'  						finish);  					blockStart = strstart;  					return false;  				}    				if (strstart >= 2 * DeflaterConstants.WSIZE - DeflaterConstants.MIN_LOOKAHEAD) {  					/* slide window' as FindLongestMatch needs this.  					 * This should only happen when flushing and the window  					 * is almost full.  					 */  					SlideWindow();  				}    				int prevMatch = matchStart;  				int prevLen = matchLen;  				if (lookahead >= DeflaterConstants.MIN_MATCH) {    					int hashHead = InsertString();    					if (strategy != DeflateStrategy.HuffmanOnly &&  						hashHead != 0 &&  						strstart - hashHead <= DeflaterConstants.MAX_DIST &&  						FindLongestMatch(hashHead)) {    						// longestMatch sets matchStart and matchLen    						// Discard match if too small and too far away  						if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == DeflaterConstants.MIN_MATCH && strstart - matchStart > TooFar))) {  							matchLen = DeflaterConstants.MIN_MATCH - 1;  						}  					}  				}    				// previous match was better  				if ((prevLen >= DeflaterConstants.MIN_MATCH) && (matchLen <= prevLen)) {  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING)   					{  					   for (int i = 0 ; i < matchLen; i++) {  						  if (window[strstart-1+i] != window[prevMatch + i])  							 throw new SharpZipBaseException();  						}  					}  #endif  					huffman.TallyDist(strstart - 1 - prevMatch' prevLen);  					prevLen -= 2;  					do {  						strstart++;  						lookahead--;  						if (lookahead >= DeflaterConstants.MIN_MATCH) {  							InsertString();  						}  					} while (--prevLen > 0);    					strstart++;  					lookahead--;  					prevAvailable = false;  					matchLen = DeflaterConstants.MIN_MATCH - 1;  				} else {  					if (prevAvailable) {  						huffman.TallyLit(window[strstart - 1] & 0xff);  					}  					prevAvailable = true;  					strstart++;  					lookahead--;  				}    				if (huffman.IsFull()) {  					int len = strstart - blockStart;  					if (prevAvailable) {  						len--;  					}  					bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  					huffman.FlushBlock(window' blockStart' len' lastBlock);  					blockStart += len;  					return !lastBlock;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= DeflaterConstants.MIN_LOOKAHEAD || flush) {  				if (lookahead == 0) {  					if (prevAvailable) {  						huffman.TallyLit(window[strstart - 1] & 0xff);  					}  					prevAvailable = false;    					// We are flushing everything  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING && !flush)   					{  						throw new SharpZipBaseException("Not flushing' but no lookahead");  					}  #endif  					huffman.FlushBlock(window' blockStart' strstart - blockStart'  						finish);  					blockStart = strstart;  					return false;  				}    				if (strstart >= 2 * DeflaterConstants.WSIZE - DeflaterConstants.MIN_LOOKAHEAD) {  					/* slide window' as FindLongestMatch needs this.  					 * This should only happen when flushing and the window  					 * is almost full.  					 */  					SlideWindow();  				}    				int prevMatch = matchStart;  				int prevLen = matchLen;  				if (lookahead >= DeflaterConstants.MIN_MATCH) {    					int hashHead = InsertString();    					if (strategy != DeflateStrategy.HuffmanOnly &&  						hashHead != 0 &&  						strstart - hashHead <= DeflaterConstants.MAX_DIST &&  						FindLongestMatch(hashHead)) {    						// longestMatch sets matchStart and matchLen    						// Discard match if too small and too far away  						if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == DeflaterConstants.MIN_MATCH && strstart - matchStart > TooFar))) {  							matchLen = DeflaterConstants.MIN_MATCH - 1;  						}  					}  				}    				// previous match was better  				if ((prevLen >= DeflaterConstants.MIN_MATCH) && (matchLen <= prevLen)) {  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING)   					{  					   for (int i = 0 ; i < matchLen; i++) {  						  if (window[strstart-1+i] != window[prevMatch + i])  							 throw new SharpZipBaseException();  						}  					}  #endif  					huffman.TallyDist(strstart - 1 - prevMatch' prevLen);  					prevLen -= 2;  					do {  						strstart++;  						lookahead--;  						if (lookahead >= DeflaterConstants.MIN_MATCH) {  							InsertString();  						}  					} while (--prevLen > 0);    					strstart++;  					lookahead--;  					prevAvailable = false;  					matchLen = DeflaterConstants.MIN_MATCH - 1;  				} else {  					if (prevAvailable) {  						huffman.TallyLit(window[strstart - 1] & 0xff);  					}  					prevAvailable = true;  					strstart++;  					lookahead--;  				}    				if (huffman.IsFull()) {  					int len = strstart - blockStart;  					if (prevAvailable) {  						len--;  					}  					bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  					huffman.FlushBlock(window' blockStart' len' lastBlock);  					blockStart += len;  					return !lastBlock;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  				staticLCodes[i] = BitReverse((0x030 + i) << 8);  				staticLLength[i++] = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  				staticLCodes[i] = BitReverse((0x030 + i) << 8);  				staticLLength[i++] = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  				staticLCodes[i] = BitReverse((0x030 + i) << 8);  				staticLLength[i++] = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  				staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);  				staticLLength[i++] = 9;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  				staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);  				staticLLength[i++] = 9;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  				staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);  				staticLLength[i++] = 9;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  				staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);  				staticLLength[i++] = 9;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  				staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);  				staticLLength[i++] = 7;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  				staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);  				staticLLength[i++] = 7;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  				staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);  				staticLLength[i++] = 7;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  				staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);  				staticLLength[i++] = 7;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  				staticLCodes[i] = BitReverse((0x0c0 - 280 + i) << 8);  				staticLLength[i++] = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  				staticLCodes[i] = BitReverse((0x0c0 - 280 + i) << 8);  				staticLLength[i++] = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  				staticLCodes[i] = BitReverse((0x0c0 - 280 + i) << 8);  				staticLLength[i++] = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++) {  				staticDCodes[i] = BitReverse(i << 11);  				staticDLength[i] = 5;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++) {  				staticDCodes[i] = BitReverse(i << 11);  				staticDLength[i] = 5;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree(this' LITERAL_NUM' 257' 15);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree(this' LITERAL_NUM' 257' 15);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: distTree = new Tree(this' DIST_NUM' 1' 15);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree(this' BITLEN_NUM' 4' 7);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree(this' BITLEN_NUM' 4' 7);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(literalTree.numCodes - 257' 5);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(literalTree.numCodes - 257' 5);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(distTree.numCodes - 1' 5);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(blTreeCodes - 4' 4);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(blTreeCodes - 4' 4);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: for (int rank = 0; rank < blTreeCodes; rank++) {  				pending.WriteBits(blTree.length[BL_ORDER[rank]]' 3);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  				int litlen = l_buf[i] & 0xff;  				int dist = d_buf[i];  				if (dist-- != 0) {  					//					if (DeflaterConstants.DEBUGGING) {  					//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  					//					}    					int lc = Lcode(litlen);  					literalTree.WriteSymbol(lc);    					int bits = (lc - 261) / 4;  					if (bits > 0 && bits <= 5) {  						pending.WriteBits(litlen & ((1 << bits) - 1)' bits);  					}    					int dc = Dcode(dist);  					distTree.WriteSymbol(dc);    					bits = dc / 2 - 1;  					if (bits > 0) {  						pending.WriteBits(dist & ((1 << bits) - 1)' bits);  					}  				} else {  					//					if (DeflaterConstants.DEBUGGING) {  					//						if (litlen > 32 && litlen < 127) {  					//							Console.Write("("+(char)litlen+"): ");  					//						} else {  					//							Console.Write("{"+litlen+"}: ");  					//						}  					//					}  					literalTree.WriteSymbol(litlen);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  				int litlen = l_buf[i] & 0xff;  				int dist = d_buf[i];  				if (dist-- != 0) {  					//					if (DeflaterConstants.DEBUGGING) {  					//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  					//					}    					int lc = Lcode(litlen);  					literalTree.WriteSymbol(lc);    					int bits = (lc - 261) / 4;  					if (bits > 0 && bits <= 5) {  						pending.WriteBits(litlen & ((1 << bits) - 1)' bits);  					}    					int dc = Dcode(dist);  					distTree.WriteSymbol(dc);    					bits = dc / 2 - 1;  					if (bits > 0) {  						pending.WriteBits(dist & ((1 << bits) - 1)' bits);  					}  				} else {  					//					if (DeflaterConstants.DEBUGGING) {  					//						if (litlen > 32 && litlen < 127) {  					//							Console.Write("("+(char)litlen+"): ");  					//						} else {  					//							Console.Write("{"+litlen+"}: ");  					//						}  					//					}  					literalTree.WriteSymbol(litlen);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  				int litlen = l_buf[i] & 0xff;  				int dist = d_buf[i];  				if (dist-- != 0) {  					//					if (DeflaterConstants.DEBUGGING) {  					//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  					//					}    					int lc = Lcode(litlen);  					literalTree.WriteSymbol(lc);    					int bits = (lc - 261) / 4;  					if (bits > 0 && bits <= 5) {  						pending.WriteBits(litlen & ((1 << bits) - 1)' bits);  					}    					int dc = Dcode(dist);  					distTree.WriteSymbol(dc);    					bits = dc / 2 - 1;  					if (bits > 0) {  						pending.WriteBits(dist & ((1 << bits) - 1)' bits);  					}  				} else {  					//					if (DeflaterConstants.DEBUGGING) {  					//						if (litlen > 32 && litlen < 127) {  					//							Console.Write("("+(char)litlen+"): ");  					//						} else {  					//							Console.Write("{"+litlen+"}: ");  					//						}  					//					}  					literalTree.WriteSymbol(litlen);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  				int litlen = l_buf[i] & 0xff;  				int dist = d_buf[i];  				if (dist-- != 0) {  					//					if (DeflaterConstants.DEBUGGING) {  					//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  					//					}    					int lc = Lcode(litlen);  					literalTree.WriteSymbol(lc);    					int bits = (lc - 261) / 4;  					if (bits > 0 && bits <= 5) {  						pending.WriteBits(litlen & ((1 << bits) - 1)' bits);  					}    					int dc = Dcode(dist);  					distTree.WriteSymbol(dc);    					bits = dc / 2 - 1;  					if (bits > 0) {  						pending.WriteBits(dist & ((1 << bits) - 1)' bits);  					}  				} else {  					//					if (DeflaterConstants.DEBUGGING) {  					//						if (litlen > 32 && litlen < 127) {  					//							Console.Write("("+(char)litlen+"): ");  					//						} else {  					//							Console.Write("{"+litlen+"}: ");  					//						}  					//					}  					literalTree.WriteSymbol(litlen);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushStoredBlock,The following statement contains a magic number: pending.WriteBits((DeflaterConstants.STORED_BLOCK << 1) + (lastBlock ? 1 : 0)' 3);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: int blTreeCodes = 4;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: for (int i = 18; i > blTreeCodes; i--) {  				if (blTree.length[BL_ORDER[i]] > 0) {  					blTreeCodes = i + 1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: int opt_len = 14 + blTreeCodes * 3 + blTree.GetEncodedLength() +  				literalTree.GetEncodedLength() + distTree.GetEncodedLength() +  				extra_bits;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: int opt_len = 14 + blTreeCodes * 3 + blTree.GetEncodedLength() +  				literalTree.GetEncodedLength() + distTree.GetEncodedLength() +  				extra_bits;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  				// Store Block    				//				if (DeflaterConstants.DEBUGGING) {  				//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  				//					                  + " <= " + static_len);  				//				}  				FlushStoredBlock(stored' storedOffset' storedLength' lastBlock);  			} else if (opt_len == static_len) {  				// Encode with static tree  				pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  				literalTree.SetStaticCodes(staticLCodes' staticLLength);  				distTree.SetStaticCodes(staticDCodes' staticDLength);  				CompressBlock();  				Reset();  			} else {  				// Encode with dynamic tree  				pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  				SendAllTrees(blTreeCodes);  				CompressBlock();  				Reset();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  				// Store Block    				//				if (DeflaterConstants.DEBUGGING) {  				//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  				//					                  + " <= " + static_len);  				//				}  				FlushStoredBlock(stored' storedOffset' storedLength' lastBlock);  			} else if (opt_len == static_len) {  				// Encode with static tree  				pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  				literalTree.SetStaticCodes(staticLCodes' staticLLength);  				distTree.SetStaticCodes(staticDCodes' staticDLength);  				CompressBlock();  				Reset();  			} else {  				// Encode with dynamic tree  				pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  				SendAllTrees(blTreeCodes);  				CompressBlock();  				Reset();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  				// Store Block    				//				if (DeflaterConstants.DEBUGGING) {  				//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  				//					                  + " <= " + static_len);  				//				}  				FlushStoredBlock(stored' storedOffset' storedLength' lastBlock);  			} else if (opt_len == static_len) {  				// Encode with static tree  				pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  				literalTree.SetStaticCodes(staticLCodes' staticLLength);  				distTree.SetStaticCodes(staticDCodes' staticDLength);  				CompressBlock();  				Reset();  			} else {  				// Encode with dynamic tree  				pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  				SendAllTrees(blTreeCodes);  				CompressBlock();  				Reset();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  				// Store Block    				//				if (DeflaterConstants.DEBUGGING) {  				//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  				//					                  + " <= " + static_len);  				//				}  				FlushStoredBlock(stored' storedOffset' storedLength' lastBlock);  			} else if (opt_len == static_len) {  				// Encode with static tree  				pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  				literalTree.SetStaticCodes(staticLCodes' staticLLength);  				distTree.SetStaticCodes(staticDCodes' staticDLength);  				CompressBlock();  				Reset();  			} else {  				// Encode with dynamic tree  				pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  				SendAllTrees(blTreeCodes);  				CompressBlock();  				Reset();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: l_buf[last_lit++] = (byte)(length - 3);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: int lc = Lcode(length - 3);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  				extra_bits += (lc - 261) / 4;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  				extra_bits += (lc - 261) / 4;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  				extra_bits += (lc - 261) / 4;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  				extra_bits += (lc - 261) / 4;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4) {  				extra_bits += dc / 2 - 1;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4) {  				extra_bits += dc / 2 - 1;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |  							bit4Reverse[(toReverse >> 4) & 0xF] << 8 |  							bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  							bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |  							bit4Reverse[(toReverse >> 4) & 0xF] << 8 |  							bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  							bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |  							bit4Reverse[(toReverse >> 4) & 0xF] << 8 |  							bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  							bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |  							bit4Reverse[(toReverse >> 4) & 0xF] << 8 |  							bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  							bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |  							bit4Reverse[(toReverse >> 4) & 0xF] << 8 |  							bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  							bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse[toReverse & 0xF] << 12 |  							bit4Reverse[(toReverse >> 4) & 0xF] << 8 |  							bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  							bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (length == 255) {  				return 285;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (length == 255) {  				return 285;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: int code = 257;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (length >= 8) {  				code += 4;  				length >>= 1;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (length >= 8) {  				code += 4;  				length >>= 1;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4) {  				code += 2;  				distance >>= 1;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4) {  				code += 2;  				distance >>= 1;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildCodes,The following statement contains a magic number: for (int bits = 0; bits < maxLength; bits++) {  					nextCode[bits] = code;  					code += bl_counts[bits] << (15 - bits);    					//					if (DeflaterConstants.DEBUGGING) {  					//						//Console.WriteLine("bits: " + ( bits + 1) + " count: " + bl_counts[bits]  					//						                  +" nextCode: "+code);  					//					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildCodes,The following statement contains a magic number: for (int i = 0; i < numCodes; i++) {  					int bits = length[i];  					if (bits > 0) {    						//						if (DeflaterConstants.DEBUGGING) {  						//								//Console.WriteLine("codes["+i+"] = rev(" + nextCode[bits-1]+")'  						//								                  +bits);  						//						}    						codes[i] = BitReverse(nextCode[bits - 1]);  						nextCode[bits - 1] += 1 << (16 - bits);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: for (int n = 0; n < numSymbols; n++) {  					int freq = freqs[n];  					if (freq != 0) {  						// Insert n into heap  						int pos = heapLen++;  						int ppos;  						while (pos > 0 && freqs[heap[ppos = (pos - 1) / 2]] > freq) {  							heap[pos] = heap[ppos];  							pos = ppos;  						}  						heap[pos] = n;    						maxCode = n;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: while (heapLen < 2) {  					int node = maxCode < 2 ? ++maxCode : 0;  					heap[heapLen++] = node;  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: while (heapLen < 2) {  					int node = maxCode < 2 ? ++maxCode : 0;  					heap[heapLen++] = node;  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: int[] childs = new int[4 * heapLen - 2];
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: int[] childs = new int[4 * heapLen - 2];
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: int[] values = new int[2 * heapLen - 1];
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < heapLen; i++) {  					int node = heap[i];  					childs[2 * i] = node;  					childs[2 * i + 1] = -1;  					values[i] = freqs[node] << 8;  					heap[i] = i;  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < heapLen; i++) {  					int node = heap[i];  					childs[2 * i] = node;  					childs[2 * i + 1] = -1;  					values[i] = freqs[node] << 8;  					heap[i] = i;  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < heapLen; i++) {  					int node = heap[i];  					childs[2 * i] = node;  					childs[2 * i + 1] = -1;  					values[i] = freqs[node] << 8;  					heap[i] = i;  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do {  					int first = heap[0];  					int last = heap[--heapLen];    					// Propagate the hole to the leafs of the heap  					int ppos = 0;  					int path = 1;    					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]]) {  							path++;  						}    						heap[ppos] = heap[path];  						ppos = path;  						path = path * 2 + 1;  					}    					/* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/  					int lastVal = values[last];  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;      					int second = heap[0];    					// Create a new node father of first and second  					last = numNodes++;  					childs[2 * last] = first;  					childs[2 * last + 1] = second;  					int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);  					values[last] = lastVal = values[first] + values[second] - mindepth + 1;    					// Again' propagate the hole to the leafs  					ppos = 0;  					path = 1;    					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]]) {  							path++;  						}    						heap[ppos] = heap[path];  						ppos = path;  						path = ppos * 2 + 1;  					}    					// Now propagate the new element down along path  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  				} while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do {  					int first = heap[0];  					int last = heap[--heapLen];    					// Propagate the hole to the leafs of the heap  					int ppos = 0;  					int path = 1;    					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]]) {  							path++;  						}    						heap[ppos] = heap[path];  						ppos = path;  						path = path * 2 + 1;  					}    					/* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/  					int lastVal = values[last];  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;      					int second = heap[0];    					// Create a new node father of first and second  					last = numNodes++;  					childs[2 * last] = first;  					childs[2 * last + 1] = second;  					int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);  					values[last] = lastVal = values[first] + values[second] - mindepth + 1;    					// Again' propagate the hole to the leafs  					ppos = 0;  					path = 1;    					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]]) {  							path++;  						}    						heap[ppos] = heap[path];  						ppos = path;  						path = ppos * 2 + 1;  					}    					// Now propagate the new element down along path  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  				} while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do {  					int first = heap[0];  					int last = heap[--heapLen];    					// Propagate the hole to the leafs of the heap  					int ppos = 0;  					int path = 1;    					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]]) {  							path++;  						}    						heap[ppos] = heap[path];  						ppos = path;  						path = path * 2 + 1;  					}    					/* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/  					int lastVal = values[last];  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;      					int second = heap[0];    					// Create a new node father of first and second  					last = numNodes++;  					childs[2 * last] = first;  					childs[2 * last + 1] = second;  					int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);  					values[last] = lastVal = values[first] + values[second] - mindepth + 1;    					// Again' propagate the hole to the leafs  					ppos = 0;  					path = 1;    					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]]) {  							path++;  						}    						heap[ppos] = heap[path];  						ppos = path;  						path = ppos * 2 + 1;  					}    					// Now propagate the new element down along path  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  				} while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do {  					int first = heap[0];  					int last = heap[--heapLen];    					// Propagate the hole to the leafs of the heap  					int ppos = 0;  					int path = 1;    					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]]) {  							path++;  						}    						heap[ppos] = heap[path];  						ppos = path;  						path = path * 2 + 1;  					}    					/* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/  					int lastVal = values[last];  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;      					int second = heap[0];    					// Create a new node father of first and second  					last = numNodes++;  					childs[2 * last] = first;  					childs[2 * last + 1] = second;  					int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);  					values[last] = lastVal = values[first] + values[second] - mindepth + 1;    					// Again' propagate the hole to the leafs  					ppos = 0;  					path = 1;    					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]]) {  							path++;  						}    						heap[ppos] = heap[path];  						ppos = path;  						path = ppos * 2 + 1;  					}    					// Now propagate the new element down along path  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  				} while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do {  					int first = heap[0];  					int last = heap[--heapLen];    					// Propagate the hole to the leafs of the heap  					int ppos = 0;  					int path = 1;    					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]]) {  							path++;  						}    						heap[ppos] = heap[path];  						ppos = path;  						path = path * 2 + 1;  					}    					/* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/  					int lastVal = values[last];  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;      					int second = heap[0];    					// Create a new node father of first and second  					last = numNodes++;  					childs[2 * last] = first;  					childs[2 * last + 1] = second;  					int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);  					values[last] = lastVal = values[first] + values[second] - mindepth + 1;    					// Again' propagate the hole to the leafs  					ppos = 0;  					path = 1;    					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]]) {  							path++;  						}    						heap[ppos] = heap[path];  						ppos = path;  						path = ppos * 2 + 1;  					}    					// Now propagate the new element down along path  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  				} while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do {  					int first = heap[0];  					int last = heap[--heapLen];    					// Propagate the hole to the leafs of the heap  					int ppos = 0;  					int path = 1;    					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]]) {  							path++;  						}    						heap[ppos] = heap[path];  						ppos = path;  						path = path * 2 + 1;  					}    					/* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/  					int lastVal = values[last];  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;      					int second = heap[0];    					// Create a new node father of first and second  					last = numNodes++;  					childs[2 * last] = first;  					childs[2 * last + 1] = second;  					int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);  					values[last] = lastVal = values[first] + values[second] - mindepth + 1;    					// Again' propagate the hole to the leafs  					ppos = 0;  					path = 1;    					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path + 1]]) {  							path++;  						}    						heap[ppos] = heap[path];  						ppos = path;  						path = ppos * 2 + 1;  					}    					// Now propagate the new element down along path  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1) / 2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  				} while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: if (heap[0] != childs.Length / 2 - 1) {  					throw new SharpZipBaseException("Heap invariant violated");  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.freqs[nextlen]++;  							count = 0;  						}  					}  					curlen = nextlen;  					i++;    					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}    					if (count < min_count) {  						blTree.freqs[curlen] += (short)count;  					} else if (curlen != 0) {  						blTree.freqs[REP_3_6]++;  					} else if (count <= 10) {  						blTree.freqs[REP_3_10]++;  					} else {  						blTree.freqs[REP_11_138]++;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.freqs[nextlen]++;  							count = 0;  						}  					}  					curlen = nextlen;  					i++;    					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}    					if (count < min_count) {  						blTree.freqs[curlen] += (short)count;  					} else if (curlen != 0) {  						blTree.freqs[REP_3_6]++;  					} else if (count <= 10) {  						blTree.freqs[REP_3_10]++;  					} else {  						blTree.freqs[REP_11_138]++;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.freqs[nextlen]++;  							count = 0;  						}  					}  					curlen = nextlen;  					i++;    					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}    					if (count < min_count) {  						blTree.freqs[curlen] += (short)count;  					} else if (curlen != 0) {  						blTree.freqs[REP_3_6]++;  					} else if (count <= 10) {  						blTree.freqs[REP_3_10]++;  					} else {  						blTree.freqs[REP_11_138]++;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.freqs[nextlen]++;  							count = 0;  						}  					}  					curlen = nextlen;  					i++;    					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}    					if (count < min_count) {  						blTree.freqs[curlen] += (short)count;  					} else if (curlen != 0) {  						blTree.freqs[REP_3_6]++;  					} else if (count <= 10) {  						blTree.freqs[REP_3_10]++;  					} else {  						blTree.freqs[REP_11_138]++;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.freqs[nextlen]++;  							count = 0;  						}  					}  					curlen = nextlen;  					i++;    					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}    					if (count < min_count) {  						blTree.freqs[curlen] += (short)count;  					} else if (curlen != 0) {  						blTree.freqs[REP_3_6]++;  					} else if (count <= 10) {  						blTree.freqs[REP_3_10]++;  					} else {  						blTree.freqs[REP_11_138]++;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;    					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}    					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;    					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}    					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;    					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}    					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;    					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}    					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;    					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}    					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;    					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}    					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;    					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}    					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;    					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}    					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;    					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}    					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;    					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}    					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;    					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}    					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: int numNodes = childs.Length / 2;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: int numLeafs = (numNodes + 1) / 2;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: for (int i = numNodes - 1; i >= 0; i--) {  					if (childs[2 * i + 1] != -1) {  						int bitLength = lengths[i] + 1;  						if (bitLength > maxLength) {  							bitLength = maxLength;  							overflow++;  						}  						lengths[childs[2 * i]] = lengths[childs[2 * i + 1]] = bitLength;  					} else {  						// A leaf node  						int bitLength = lengths[i];  						bl_counts[bitLength - 1]++;  						this.length[childs[2 * i]] = (byte)lengths[i];  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: for (int i = numNodes - 1; i >= 0; i--) {  					if (childs[2 * i + 1] != -1) {  						int bitLength = lengths[i] + 1;  						if (bitLength > maxLength) {  							bitLength = maxLength;  							overflow++;  						}  						lengths[childs[2 * i]] = lengths[childs[2 * i + 1]] = bitLength;  					} else {  						// A leaf node  						int bitLength = lengths[i];  						bl_counts[bitLength - 1]++;  						this.length[childs[2 * i]] = (byte)lengths[i];  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: for (int i = numNodes - 1; i >= 0; i--) {  					if (childs[2 * i + 1] != -1) {  						int bitLength = lengths[i] + 1;  						if (bitLength > maxLength) {  							bitLength = maxLength;  							overflow++;  						}  						lengths[childs[2 * i]] = lengths[childs[2 * i + 1]] = bitLength;  					} else {  						// A leaf node  						int bitLength = lengths[i];  						bl_counts[bitLength - 1]++;  						this.length[childs[2 * i]] = (byte)lengths[i];  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: for (int i = numNodes - 1; i >= 0; i--) {  					if (childs[2 * i + 1] != -1) {  						int bitLength = lengths[i] + 1;  						if (bitLength > maxLength) {  							bitLength = maxLength;  							overflow++;  						}  						lengths[childs[2 * i]] = lengths[childs[2 * i + 1]] = bitLength;  					} else {  						// A leaf node  						int bitLength = lengths[i];  						bl_counts[bitLength - 1]++;  						this.length[childs[2 * i]] = (byte)lengths[i];  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: bl_counts[maxLength - 2] -= overflow;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: int nodePtr = 2 * numLeafs;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: for (int bits = maxLength; bits != 0; bits--) {  					int n = bl_counts[bits - 1];  					while (n > 0) {  						int childPtr = 2 * childs[nodePtr++];  						if (childs[childPtr + 1] == -1) {  							// We found another leaf  							length[childs[childPtr]] = (byte)bits;  							n--;  						}  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: int header = input.PeekBits(16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: input.DropBits(16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if (header % 31 != 0) {  				throw new SharpZipBaseException("Header checksum illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0f00) != (Deflater.DEFLATED << 8)) {  				throw new SharpZipBaseException("Compression Method unknown");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0020) == 0) { // Dictionary flag?  				mode = DECODE_BLOCKS;  			} else {  				mode = DECODE_DICT;  				neededBits = 32;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  				int dictByte = input.PeekBits(8);  				if (dictByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | dictByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  				int dictByte = input.PeekBits(8);  				if (dictByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | dictByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  				int dictByte = input.PeekBits(8);  				if (dictByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | dictByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  				int dictByte = input.PeekBits(8);  				if (dictByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | dictByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  				int symbol;  				switch (mode) {  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0) {  							outputWindow.Write(symbol);  							if (--free < 258) {  								return true;  							}  						}    						if (symbol < 257) {  							if (symbol < 0) {  								return false;  							} else {  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}    						try {  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						} catch (Exception) {  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through    					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0) {  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0) {  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through    					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0) {  							return false;  						}    						try {  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						} catch (Exception) {  							throw new SharpZipBaseException("Illegal rep dist code");  						}    						goto case DECODE_HUFFMAN_DISTBITS; // fall through    					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0) {  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0) {  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}    						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;    					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  				int symbol;  				switch (mode) {  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0) {  							outputWindow.Write(symbol);  							if (--free < 258) {  								return true;  							}  						}    						if (symbol < 257) {  							if (symbol < 0) {  								return false;  							} else {  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}    						try {  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						} catch (Exception) {  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through    					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0) {  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0) {  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through    					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0) {  							return false;  						}    						try {  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						} catch (Exception) {  							throw new SharpZipBaseException("Illegal rep dist code");  						}    						goto case DECODE_HUFFMAN_DISTBITS; // fall through    					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0) {  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0) {  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}    						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;    					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  				int symbol;  				switch (mode) {  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0) {  							outputWindow.Write(symbol);  							if (--free < 258) {  								return true;  							}  						}    						if (symbol < 257) {  							if (symbol < 0) {  								return false;  							} else {  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}    						try {  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						} catch (Exception) {  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through    					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0) {  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0) {  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through    					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0) {  							return false;  						}    						try {  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						} catch (Exception) {  							throw new SharpZipBaseException("Illegal rep dist code");  						}    						goto case DECODE_HUFFMAN_DISTBITS; // fall through    					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0) {  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0) {  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}    						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;    					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  				int symbol;  				switch (mode) {  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0) {  							outputWindow.Write(symbol);  							if (--free < 258) {  								return true;  							}  						}    						if (symbol < 257) {  							if (symbol < 0) {  								return false;  							} else {  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}    						try {  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						} catch (Exception) {  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through    					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0) {  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0) {  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through    					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0) {  							return false;  						}    						try {  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						} catch (Exception) {  							throw new SharpZipBaseException("Illegal rep dist code");  						}    						goto case DECODE_HUFFMAN_DISTBITS; // fall through    					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0) {  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0) {  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}    						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;    					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  				int symbol;  				switch (mode) {  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0) {  							outputWindow.Write(symbol);  							if (--free < 258) {  								return true;  							}  						}    						if (symbol < 257) {  							if (symbol < 0) {  								return false;  							} else {  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}    						try {  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						} catch (Exception) {  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through    					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0) {  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0) {  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through    					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0) {  							return false;  						}    						try {  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						} catch (Exception) {  							throw new SharpZipBaseException("Illegal rep dist code");  						}    						goto case DECODE_HUFFMAN_DISTBITS; // fall through    					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0) {  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0) {  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}    						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;    					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  				int chkByte = input.PeekBits(8);  				if (chkByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | chkByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  				int chkByte = input.PeekBits(8);  				if (chkByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | chkByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  				int chkByte = input.PeekBits(8);  				if (chkByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | chkByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  				int chkByte = input.PeekBits(8);  				if (chkByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | chkByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  				case DECODE_HEADER:  					return DecodeHeader();    				case DECODE_DICT:  					return DecodeDict();    				case DECODE_CHKSUM:  					return DecodeChksum();    				case DECODE_BLOCKS:  					if (isLastBlock) {  						if (noHeader) {  							mode = FINISHED;  							return false;  						} else {  							input.SkipToByteBoundary();  							neededBits = 32;  							mode = DECODE_CHKSUM;  							return true;  						}  					}    					int type = input.PeekBits(3);  					if (type < 0) {  						return false;  					}  					input.DropBits(3);    					isLastBlock |= (type & 1) != 0;  					switch (type >> 1) {  						case DeflaterConstants.STORED_BLOCK:  							input.SkipToByteBoundary();  							mode = DECODE_STORED_LEN1;  							break;  						case DeflaterConstants.STATIC_TREES:  							litlenTree = InflaterHuffmanTree.defLitLenTree;  							distTree = InflaterHuffmanTree.defDistTree;  							mode = DECODE_HUFFMAN;  							break;  						case DeflaterConstants.DYN_TREES:  							dynHeader = new InflaterDynHeader();  							mode = DECODE_DYN_HEADER;  							break;  						default:  							throw new SharpZipBaseException("Unknown block type " + type);  					}  					return true;    				case DECODE_STORED_LEN1: {  						if ((uncomprLen = input.PeekBits(16)) < 0) {  							return false;  						}  						input.DropBits(16);  						mode = DECODE_STORED_LEN2;  					}  					goto case DECODE_STORED_LEN2; // fall through    				case DECODE_STORED_LEN2: {  						int nlen = input.PeekBits(16);  						if (nlen < 0) {  							return false;  						}  						input.DropBits(16);  						if (nlen != (uncomprLen ^ 0xffff)) {  							throw new SharpZipBaseException("broken uncompressed block");  						}  						mode = DECODE_STORED;  					}  					goto case DECODE_STORED; // fall through    				case DECODE_STORED: {  						int more = outputWindow.CopyStored(input' uncomprLen);  						uncomprLen -= more;  						if (uncomprLen == 0) {  							mode = DECODE_BLOCKS;  							return true;  						}  						return !input.IsNeedingInput;  					}    				case DECODE_DYN_HEADER:  					if (!dynHeader.Decode(input)) {  						return false;  					}    					litlenTree = dynHeader.BuildLitLenTree();  					distTree = dynHeader.BuildDistTree();  					mode = DECODE_HUFFMAN;  					goto case DECODE_HUFFMAN; // fall through    				case DECODE_HUFFMAN:  				case DECODE_HUFFMAN_LENBITS:  				case DECODE_HUFFMAN_DIST:  				case DECODE_HUFFMAN_DISTBITS:  					return DecodeHuffman();    				case FINISHED:  					return false;    				default:  					throw new SharpZipBaseException("Inflater.Decode unknown mode");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  				case DECODE_HEADER:  					return DecodeHeader();    				case DECODE_DICT:  					return DecodeDict();    				case DECODE_CHKSUM:  					return DecodeChksum();    				case DECODE_BLOCKS:  					if (isLastBlock) {  						if (noHeader) {  							mode = FINISHED;  							return false;  						} else {  							input.SkipToByteBoundary();  							neededBits = 32;  							mode = DECODE_CHKSUM;  							return true;  						}  					}    					int type = input.PeekBits(3);  					if (type < 0) {  						return false;  					}  					input.DropBits(3);    					isLastBlock |= (type & 1) != 0;  					switch (type >> 1) {  						case DeflaterConstants.STORED_BLOCK:  							input.SkipToByteBoundary();  							mode = DECODE_STORED_LEN1;  							break;  						case DeflaterConstants.STATIC_TREES:  							litlenTree = InflaterHuffmanTree.defLitLenTree;  							distTree = InflaterHuffmanTree.defDistTree;  							mode = DECODE_HUFFMAN;  							break;  						case DeflaterConstants.DYN_TREES:  							dynHeader = new InflaterDynHeader();  							mode = DECODE_DYN_HEADER;  							break;  						default:  							throw new SharpZipBaseException("Unknown block type " + type);  					}  					return true;    				case DECODE_STORED_LEN1: {  						if ((uncomprLen = input.PeekBits(16)) < 0) {  							return false;  						}  						input.DropBits(16);  						mode = DECODE_STORED_LEN2;  					}  					goto case DECODE_STORED_LEN2; // fall through    				case DECODE_STORED_LEN2: {  						int nlen = input.PeekBits(16);  						if (nlen < 0) {  							return false;  						}  						input.DropBits(16);  						if (nlen != (uncomprLen ^ 0xffff)) {  							throw new SharpZipBaseException("broken uncompressed block");  						}  						mode = DECODE_STORED;  					}  					goto case DECODE_STORED; // fall through    				case DECODE_STORED: {  						int more = outputWindow.CopyStored(input' uncomprLen);  						uncomprLen -= more;  						if (uncomprLen == 0) {  							mode = DECODE_BLOCKS;  							return true;  						}  						return !input.IsNeedingInput;  					}    				case DECODE_DYN_HEADER:  					if (!dynHeader.Decode(input)) {  						return false;  					}    					litlenTree = dynHeader.BuildLitLenTree();  					distTree = dynHeader.BuildDistTree();  					mode = DECODE_HUFFMAN;  					goto case DECODE_HUFFMAN; // fall through    				case DECODE_HUFFMAN:  				case DECODE_HUFFMAN_LENBITS:  				case DECODE_HUFFMAN_DIST:  				case DECODE_HUFFMAN_DISTBITS:  					return DecodeHuffman();    				case FINISHED:  					return false;    				default:  					throw new SharpZipBaseException("Inflater.Decode unknown mode");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  				case DECODE_HEADER:  					return DecodeHeader();    				case DECODE_DICT:  					return DecodeDict();    				case DECODE_CHKSUM:  					return DecodeChksum();    				case DECODE_BLOCKS:  					if (isLastBlock) {  						if (noHeader) {  							mode = FINISHED;  							return false;  						} else {  							input.SkipToByteBoundary();  							neededBits = 32;  							mode = DECODE_CHKSUM;  							return true;  						}  					}    					int type = input.PeekBits(3);  					if (type < 0) {  						return false;  					}  					input.DropBits(3);    					isLastBlock |= (type & 1) != 0;  					switch (type >> 1) {  						case DeflaterConstants.STORED_BLOCK:  							input.SkipToByteBoundary();  							mode = DECODE_STORED_LEN1;  							break;  						case DeflaterConstants.STATIC_TREES:  							litlenTree = InflaterHuffmanTree.defLitLenTree;  							distTree = InflaterHuffmanTree.defDistTree;  							mode = DECODE_HUFFMAN;  							break;  						case DeflaterConstants.DYN_TREES:  							dynHeader = new InflaterDynHeader();  							mode = DECODE_DYN_HEADER;  							break;  						default:  							throw new SharpZipBaseException("Unknown block type " + type);  					}  					return true;    				case DECODE_STORED_LEN1: {  						if ((uncomprLen = input.PeekBits(16)) < 0) {  							return false;  						}  						input.DropBits(16);  						mode = DECODE_STORED_LEN2;  					}  					goto case DECODE_STORED_LEN2; // fall through    				case DECODE_STORED_LEN2: {  						int nlen = input.PeekBits(16);  						if (nlen < 0) {  							return false;  						}  						input.DropBits(16);  						if (nlen != (uncomprLen ^ 0xffff)) {  							throw new SharpZipBaseException("broken uncompressed block");  						}  						mode = DECODE_STORED;  					}  					goto case DECODE_STORED; // fall through    				case DECODE_STORED: {  						int more = outputWindow.CopyStored(input' uncomprLen);  						uncomprLen -= more;  						if (uncomprLen == 0) {  							mode = DECODE_BLOCKS;  							return true;  						}  						return !input.IsNeedingInput;  					}    				case DECODE_DYN_HEADER:  					if (!dynHeader.Decode(input)) {  						return false;  					}    					litlenTree = dynHeader.BuildLitLenTree();  					distTree = dynHeader.BuildDistTree();  					mode = DECODE_HUFFMAN;  					goto case DECODE_HUFFMAN; // fall through    				case DECODE_HUFFMAN:  				case DECODE_HUFFMAN_LENBITS:  				case DECODE_HUFFMAN_DIST:  				case DECODE_HUFFMAN_DISTBITS:  					return DecodeHuffman();    				case FINISHED:  					return false;    				default:  					throw new SharpZipBaseException("Inflater.Decode unknown mode");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  				case DECODE_HEADER:  					return DecodeHeader();    				case DECODE_DICT:  					return DecodeDict();    				case DECODE_CHKSUM:  					return DecodeChksum();    				case DECODE_BLOCKS:  					if (isLastBlock) {  						if (noHeader) {  							mode = FINISHED;  							return false;  						} else {  							input.SkipToByteBoundary();  							neededBits = 32;  							mode = DECODE_CHKSUM;  							return true;  						}  					}    					int type = input.PeekBits(3);  					if (type < 0) {  						return false;  					}  					input.DropBits(3);    					isLastBlock |= (type & 1) != 0;  					switch (type >> 1) {  						case DeflaterConstants.STORED_BLOCK:  							input.SkipToByteBoundary();  							mode = DECODE_STORED_LEN1;  							break;  						case DeflaterConstants.STATIC_TREES:  							litlenTree = InflaterHuffmanTree.defLitLenTree;  							distTree = InflaterHuffmanTree.defDistTree;  							mode = DECODE_HUFFMAN;  							break;  						case DeflaterConstants.DYN_TREES:  							dynHeader = new InflaterDynHeader();  							mode = DECODE_DYN_HEADER;  							break;  						default:  							throw new SharpZipBaseException("Unknown block type " + type);  					}  					return true;    				case DECODE_STORED_LEN1: {  						if ((uncomprLen = input.PeekBits(16)) < 0) {  							return false;  						}  						input.DropBits(16);  						mode = DECODE_STORED_LEN2;  					}  					goto case DECODE_STORED_LEN2; // fall through    				case DECODE_STORED_LEN2: {  						int nlen = input.PeekBits(16);  						if (nlen < 0) {  							return false;  						}  						input.DropBits(16);  						if (nlen != (uncomprLen ^ 0xffff)) {  							throw new SharpZipBaseException("broken uncompressed block");  						}  						mode = DECODE_STORED;  					}  					goto case DECODE_STORED; // fall through    				case DECODE_STORED: {  						int more = outputWindow.CopyStored(input' uncomprLen);  						uncomprLen -= more;  						if (uncomprLen == 0) {  							mode = DECODE_BLOCKS;  							return true;  						}  						return !input.IsNeedingInput;  					}    				case DECODE_DYN_HEADER:  					if (!dynHeader.Decode(input)) {  						return false;  					}    					litlenTree = dynHeader.BuildLitLenTree();  					distTree = dynHeader.BuildDistTree();  					mode = DECODE_HUFFMAN;  					goto case DECODE_HUFFMAN; // fall through    				case DECODE_HUFFMAN:  				case DECODE_HUFFMAN_LENBITS:  				case DECODE_HUFFMAN_DIST:  				case DECODE_HUFFMAN_DISTBITS:  					return DecodeHuffman();    				case FINISHED:  					return false;    				default:  					throw new SharpZipBaseException("Inflater.Decode unknown mode");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  				case DECODE_HEADER:  					return DecodeHeader();    				case DECODE_DICT:  					return DecodeDict();    				case DECODE_CHKSUM:  					return DecodeChksum();    				case DECODE_BLOCKS:  					if (isLastBlock) {  						if (noHeader) {  							mode = FINISHED;  							return false;  						} else {  							input.SkipToByteBoundary();  							neededBits = 32;  							mode = DECODE_CHKSUM;  							return true;  						}  					}    					int type = input.PeekBits(3);  					if (type < 0) {  						return false;  					}  					input.DropBits(3);    					isLastBlock |= (type & 1) != 0;  					switch (type >> 1) {  						case DeflaterConstants.STORED_BLOCK:  							input.SkipToByteBoundary();  							mode = DECODE_STORED_LEN1;  							break;  						case DeflaterConstants.STATIC_TREES:  							litlenTree = InflaterHuffmanTree.defLitLenTree;  							distTree = InflaterHuffmanTree.defDistTree;  							mode = DECODE_HUFFMAN;  							break;  						case DeflaterConstants.DYN_TREES:  							dynHeader = new InflaterDynHeader();  							mode = DECODE_DYN_HEADER;  							break;  						default:  							throw new SharpZipBaseException("Unknown block type " + type);  					}  					return true;    				case DECODE_STORED_LEN1: {  						if ((uncomprLen = input.PeekBits(16)) < 0) {  							return false;  						}  						input.DropBits(16);  						mode = DECODE_STORED_LEN2;  					}  					goto case DECODE_STORED_LEN2; // fall through    				case DECODE_STORED_LEN2: {  						int nlen = input.PeekBits(16);  						if (nlen < 0) {  							return false;  						}  						input.DropBits(16);  						if (nlen != (uncomprLen ^ 0xffff)) {  							throw new SharpZipBaseException("broken uncompressed block");  						}  						mode = DECODE_STORED;  					}  					goto case DECODE_STORED; // fall through    				case DECODE_STORED: {  						int more = outputWindow.CopyStored(input' uncomprLen);  						uncomprLen -= more;  						if (uncomprLen == 0) {  							mode = DECODE_BLOCKS;  							return true;  						}  						return !input.IsNeedingInput;  					}    				case DECODE_DYN_HEADER:  					if (!dynHeader.Decode(input)) {  						return false;  					}    					litlenTree = dynHeader.BuildLitLenTree();  					distTree = dynHeader.BuildDistTree();  					mode = DECODE_HUFFMAN;  					goto case DECODE_HUFFMAN; // fall through    				case DECODE_HUFFMAN:  				case DECODE_HUFFMAN_LENBITS:  				case DECODE_HUFFMAN_DIST:  				case DECODE_HUFFMAN_DISTBITS:  					return DecodeHuffman();    				case FINISHED:  					return false;    				default:  					throw new SharpZipBaseException("Inflater.Decode unknown mode");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  				case DECODE_HEADER:  					return DecodeHeader();    				case DECODE_DICT:  					return DecodeDict();    				case DECODE_CHKSUM:  					return DecodeChksum();    				case DECODE_BLOCKS:  					if (isLastBlock) {  						if (noHeader) {  							mode = FINISHED;  							return false;  						} else {  							input.SkipToByteBoundary();  							neededBits = 32;  							mode = DECODE_CHKSUM;  							return true;  						}  					}    					int type = input.PeekBits(3);  					if (type < 0) {  						return false;  					}  					input.DropBits(3);    					isLastBlock |= (type & 1) != 0;  					switch (type >> 1) {  						case DeflaterConstants.STORED_BLOCK:  							input.SkipToByteBoundary();  							mode = DECODE_STORED_LEN1;  							break;  						case DeflaterConstants.STATIC_TREES:  							litlenTree = InflaterHuffmanTree.defLitLenTree;  							distTree = InflaterHuffmanTree.defDistTree;  							mode = DECODE_HUFFMAN;  							break;  						case DeflaterConstants.DYN_TREES:  							dynHeader = new InflaterDynHeader();  							mode = DECODE_DYN_HEADER;  							break;  						default:  							throw new SharpZipBaseException("Unknown block type " + type);  					}  					return true;    				case DECODE_STORED_LEN1: {  						if ((uncomprLen = input.PeekBits(16)) < 0) {  							return false;  						}  						input.DropBits(16);  						mode = DECODE_STORED_LEN2;  					}  					goto case DECODE_STORED_LEN2; // fall through    				case DECODE_STORED_LEN2: {  						int nlen = input.PeekBits(16);  						if (nlen < 0) {  							return false;  						}  						input.DropBits(16);  						if (nlen != (uncomprLen ^ 0xffff)) {  							throw new SharpZipBaseException("broken uncompressed block");  						}  						mode = DECODE_STORED;  					}  					goto case DECODE_STORED; // fall through    				case DECODE_STORED: {  						int more = outputWindow.CopyStored(input' uncomprLen);  						uncomprLen -= more;  						if (uncomprLen == 0) {  							mode = DECODE_BLOCKS;  							return true;  						}  						return !input.IsNeedingInput;  					}    				case DECODE_DYN_HEADER:  					if (!dynHeader.Decode(input)) {  						return false;  					}    					litlenTree = dynHeader.BuildLitLenTree();  					distTree = dynHeader.BuildDistTree();  					mode = DECODE_HUFFMAN;  					goto case DECODE_HUFFMAN; // fall through    				case DECODE_HUFFMAN:  				case DECODE_HUFFMAN_LENBITS:  				case DECODE_HUFFMAN_DIST:  				case DECODE_HUFFMAN_DISTBITS:  					return DecodeHuffman();    				case FINISHED:  					return false;    				default:  					throw new SharpZipBaseException("Inflater.Decode unknown mode");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  				case DECODE_HEADER:  					return DecodeHeader();    				case DECODE_DICT:  					return DecodeDict();    				case DECODE_CHKSUM:  					return DecodeChksum();    				case DECODE_BLOCKS:  					if (isLastBlock) {  						if (noHeader) {  							mode = FINISHED;  							return false;  						} else {  							input.SkipToByteBoundary();  							neededBits = 32;  							mode = DECODE_CHKSUM;  							return true;  						}  					}    					int type = input.PeekBits(3);  					if (type < 0) {  						return false;  					}  					input.DropBits(3);    					isLastBlock |= (type & 1) != 0;  					switch (type >> 1) {  						case DeflaterConstants.STORED_BLOCK:  							input.SkipToByteBoundary();  							mode = DECODE_STORED_LEN1;  							break;  						case DeflaterConstants.STATIC_TREES:  							litlenTree = InflaterHuffmanTree.defLitLenTree;  							distTree = InflaterHuffmanTree.defDistTree;  							mode = DECODE_HUFFMAN;  							break;  						case DeflaterConstants.DYN_TREES:  							dynHeader = new InflaterDynHeader();  							mode = DECODE_DYN_HEADER;  							break;  						default:  							throw new SharpZipBaseException("Unknown block type " + type);  					}  					return true;    				case DECODE_STORED_LEN1: {  						if ((uncomprLen = input.PeekBits(16)) < 0) {  							return false;  						}  						input.DropBits(16);  						mode = DECODE_STORED_LEN2;  					}  					goto case DECODE_STORED_LEN2; // fall through    				case DECODE_STORED_LEN2: {  						int nlen = input.PeekBits(16);  						if (nlen < 0) {  							return false;  						}  						input.DropBits(16);  						if (nlen != (uncomprLen ^ 0xffff)) {  							throw new SharpZipBaseException("broken uncompressed block");  						}  						mode = DECODE_STORED;  					}  					goto case DECODE_STORED; // fall through    				case DECODE_STORED: {  						int more = outputWindow.CopyStored(input' uncomprLen);  						uncomprLen -= more;  						if (uncomprLen == 0) {  							mode = DECODE_BLOCKS;  							return true;  						}  						return !input.IsNeedingInput;  					}    				case DECODE_DYN_HEADER:  					if (!dynHeader.Decode(input)) {  						return false;  					}    					litlenTree = dynHeader.BuildLitLenTree();  					distTree = dynHeader.BuildDistTree();  					mode = DECODE_HUFFMAN;  					goto case DECODE_HUFFMAN; // fall through    				case DECODE_HUFFMAN:  				case DECODE_HUFFMAN_LENBITS:  				case DECODE_HUFFMAN_DIST:  				case DECODE_HUFFMAN_DISTBITS:  					return DecodeHuffman();    				case FINISHED:  					return false;    				default:  					throw new SharpZipBaseException("Inflater.Decode unknown mode");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  			for (;;) {  				switch (mode) {  					case LNUM:  						lnum = input.PeekBits(5);  						if (lnum < 0) {  							return false;  						}  						lnum += 257;  						input.DropBits(5);  						//  	    System.err.println("LNUM: "+lnum);  						mode = DNUM;  						goto case DNUM; // fall through  					case DNUM:  						dnum = input.PeekBits(5);  						if (dnum < 0) {  							return false;  						}  						dnum++;  						input.DropBits(5);  						//  	    System.err.println("DNUM: "+dnum);  						num = lnum + dnum;  						litdistLens = new byte[num];  						mode = BLNUM;  						goto case BLNUM; // fall through  					case BLNUM:  						blnum = input.PeekBits(4);  						if (blnum < 0) {  							return false;  						}  						blnum += 4;  						input.DropBits(4);  						blLens = new byte[19];  						ptr = 0;  						//  	    System.err.println("BLNUM: "+blnum);  						mode = BLLENS;  						goto case BLLENS; // fall through  					case BLLENS:  						while (ptr < blnum) {  							int len = input.PeekBits(3);  							if (len < 0) {  								return false;  							}  							input.DropBits(3);  							//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  							blLens[BL_ORDER[ptr]] = (byte)len;  							ptr++;  						}  						blTree = new InflaterHuffmanTree(blLens);  						blLens = null;  						ptr = 0;  						mode = LENS;  						goto case LENS; // fall through  					case LENS: {  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */    								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;    								if (ptr == num) {  									/* Finished */  									return true;  								}  							}    							/* need more input ? */  							if (symbol < 0) {  								return false;  							}    							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol - 16;  						}  						mode = REPS;  						goto case REPS; // fall through  					case REPS: {  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);    							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}    							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  			for (;;) {  				switch (mode) {  					case LNUM:  						lnum = input.PeekBits(5);  						if (lnum < 0) {  							return false;  						}  						lnum += 257;  						input.DropBits(5);  						//  	    System.err.println("LNUM: "+lnum);  						mode = DNUM;  						goto case DNUM; // fall through  					case DNUM:  						dnum = input.PeekBits(5);  						if (dnum < 0) {  							return false;  						}  						dnum++;  						input.DropBits(5);  						//  	    System.err.println("DNUM: "+dnum);  						num = lnum + dnum;  						litdistLens = new byte[num];  						mode = BLNUM;  						goto case BLNUM; // fall through  					case BLNUM:  						blnum = input.PeekBits(4);  						if (blnum < 0) {  							return false;  						}  						blnum += 4;  						input.DropBits(4);  						blLens = new byte[19];  						ptr = 0;  						//  	    System.err.println("BLNUM: "+blnum);  						mode = BLLENS;  						goto case BLLENS; // fall through  					case BLLENS:  						while (ptr < blnum) {  							int len = input.PeekBits(3);  							if (len < 0) {  								return false;  							}  							input.DropBits(3);  							//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  							blLens[BL_ORDER[ptr]] = (byte)len;  							ptr++;  						}  						blTree = new InflaterHuffmanTree(blLens);  						blLens = null;  						ptr = 0;  						mode = LENS;  						goto case LENS; // fall through  					case LENS: {  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */    								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;    								if (ptr == num) {  									/* Finished */  									return true;  								}  							}    							/* need more input ? */  							if (symbol < 0) {  								return false;  							}    							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol - 16;  						}  						mode = REPS;  						goto case REPS; // fall through  					case REPS: {  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);    							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}    							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  			for (;;) {  				switch (mode) {  					case LNUM:  						lnum = input.PeekBits(5);  						if (lnum < 0) {  							return false;  						}  						lnum += 257;  						input.DropBits(5);  						//  	    System.err.println("LNUM: "+lnum);  						mode = DNUM;  						goto case DNUM; // fall through  					case DNUM:  						dnum = input.PeekBits(5);  						if (dnum < 0) {  							return false;  						}  						dnum++;  						input.DropBits(5);  						//  	    System.err.println("DNUM: "+dnum);  						num = lnum + dnum;  						litdistLens = new byte[num];  						mode = BLNUM;  						goto case BLNUM; // fall through  					case BLNUM:  						blnum = input.PeekBits(4);  						if (blnum < 0) {  							return false;  						}  						blnum += 4;  						input.DropBits(4);  						blLens = new byte[19];  						ptr = 0;  						//  	    System.err.println("BLNUM: "+blnum);  						mode = BLLENS;  						goto case BLLENS; // fall through  					case BLLENS:  						while (ptr < blnum) {  							int len = input.PeekBits(3);  							if (len < 0) {  								return false;  							}  							input.DropBits(3);  							//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  							blLens[BL_ORDER[ptr]] = (byte)len;  							ptr++;  						}  						blTree = new InflaterHuffmanTree(blLens);  						blLens = null;  						ptr = 0;  						mode = LENS;  						goto case LENS; // fall through  					case LENS: {  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */    								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;    								if (ptr == num) {  									/* Finished */  									return true;  								}  							}    							/* need more input ? */  							if (symbol < 0) {  								return false;  							}    							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol - 16;  						}  						mode = REPS;  						goto case REPS; // fall through  					case REPS: {  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);    							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}    							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  			for (;;) {  				switch (mode) {  					case LNUM:  						lnum = input.PeekBits(5);  						if (lnum < 0) {  							return false;  						}  						lnum += 257;  						input.DropBits(5);  						//  	    System.err.println("LNUM: "+lnum);  						mode = DNUM;  						goto case DNUM; // fall through  					case DNUM:  						dnum = input.PeekBits(5);  						if (dnum < 0) {  							return false;  						}  						dnum++;  						input.DropBits(5);  						//  	    System.err.println("DNUM: "+dnum);  						num = lnum + dnum;  						litdistLens = new byte[num];  						mode = BLNUM;  						goto case BLNUM; // fall through  					case BLNUM:  						blnum = input.PeekBits(4);  						if (blnum < 0) {  							return false;  						}  						blnum += 4;  						input.DropBits(4);  						blLens = new byte[19];  						ptr = 0;  						//  	    System.err.println("BLNUM: "+blnum);  						mode = BLLENS;  						goto case BLLENS; // fall through  					case BLLENS:  						while (ptr < blnum) {  							int len = input.PeekBits(3);  							if (len < 0) {  								return false;  							}  							input.DropBits(3);  							//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  							blLens[BL_ORDER[ptr]] = (byte)len;  							ptr++;  						}  						blTree = new InflaterHuffmanTree(blLens);  						blLens = null;  						ptr = 0;  						mode = LENS;  						goto case LENS; // fall through  					case LENS: {  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */    								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;    								if (ptr == num) {  									/* Finished */  									return true;  								}  							}    							/* need more input ? */  							if (symbol < 0) {  								return false;  							}    							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol - 16;  						}  						mode = REPS;  						goto case REPS; // fall through  					case REPS: {  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);    							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}    							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  			for (;;) {  				switch (mode) {  					case LNUM:  						lnum = input.PeekBits(5);  						if (lnum < 0) {  							return false;  						}  						lnum += 257;  						input.DropBits(5);  						//  	    System.err.println("LNUM: "+lnum);  						mode = DNUM;  						goto case DNUM; // fall through  					case DNUM:  						dnum = input.PeekBits(5);  						if (dnum < 0) {  							return false;  						}  						dnum++;  						input.DropBits(5);  						//  	    System.err.println("DNUM: "+dnum);  						num = lnum + dnum;  						litdistLens = new byte[num];  						mode = BLNUM;  						goto case BLNUM; // fall through  					case BLNUM:  						blnum = input.PeekBits(4);  						if (blnum < 0) {  							return false;  						}  						blnum += 4;  						input.DropBits(4);  						blLens = new byte[19];  						ptr = 0;  						//  	    System.err.println("BLNUM: "+blnum);  						mode = BLLENS;  						goto case BLLENS; // fall through  					case BLLENS:  						while (ptr < blnum) {  							int len = input.PeekBits(3);  							if (len < 0) {  								return false;  							}  							input.DropBits(3);  							//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  							blLens[BL_ORDER[ptr]] = (byte)len;  							ptr++;  						}  						blTree = new InflaterHuffmanTree(blLens);  						blLens = null;  						ptr = 0;  						mode = LENS;  						goto case LENS; // fall through  					case LENS: {  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */    								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;    								if (ptr == num) {  									/* Finished */  									return true;  								}  							}    							/* need more input ? */  							if (symbol < 0) {  								return false;  							}    							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol - 16;  						}  						mode = REPS;  						goto case REPS; // fall through  					case REPS: {  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);    							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}    							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  			for (;;) {  				switch (mode) {  					case LNUM:  						lnum = input.PeekBits(5);  						if (lnum < 0) {  							return false;  						}  						lnum += 257;  						input.DropBits(5);  						//  	    System.err.println("LNUM: "+lnum);  						mode = DNUM;  						goto case DNUM; // fall through  					case DNUM:  						dnum = input.PeekBits(5);  						if (dnum < 0) {  							return false;  						}  						dnum++;  						input.DropBits(5);  						//  	    System.err.println("DNUM: "+dnum);  						num = lnum + dnum;  						litdistLens = new byte[num];  						mode = BLNUM;  						goto case BLNUM; // fall through  					case BLNUM:  						blnum = input.PeekBits(4);  						if (blnum < 0) {  							return false;  						}  						blnum += 4;  						input.DropBits(4);  						blLens = new byte[19];  						ptr = 0;  						//  	    System.err.println("BLNUM: "+blnum);  						mode = BLLENS;  						goto case BLLENS; // fall through  					case BLLENS:  						while (ptr < blnum) {  							int len = input.PeekBits(3);  							if (len < 0) {  								return false;  							}  							input.DropBits(3);  							//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  							blLens[BL_ORDER[ptr]] = (byte)len;  							ptr++;  						}  						blTree = new InflaterHuffmanTree(blLens);  						blLens = null;  						ptr = 0;  						mode = LENS;  						goto case LENS; // fall through  					case LENS: {  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */    								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;    								if (ptr == num) {  									/* Finished */  									return true;  								}  							}    							/* need more input ? */  							if (symbol < 0) {  								return false;  							}    							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol - 16;  						}  						mode = REPS;  						goto case REPS; // fall through  					case REPS: {  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);    							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}    							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  			for (;;) {  				switch (mode) {  					case LNUM:  						lnum = input.PeekBits(5);  						if (lnum < 0) {  							return false;  						}  						lnum += 257;  						input.DropBits(5);  						//  	    System.err.println("LNUM: "+lnum);  						mode = DNUM;  						goto case DNUM; // fall through  					case DNUM:  						dnum = input.PeekBits(5);  						if (dnum < 0) {  							return false;  						}  						dnum++;  						input.DropBits(5);  						//  	    System.err.println("DNUM: "+dnum);  						num = lnum + dnum;  						litdistLens = new byte[num];  						mode = BLNUM;  						goto case BLNUM; // fall through  					case BLNUM:  						blnum = input.PeekBits(4);  						if (blnum < 0) {  							return false;  						}  						blnum += 4;  						input.DropBits(4);  						blLens = new byte[19];  						ptr = 0;  						//  	    System.err.println("BLNUM: "+blnum);  						mode = BLLENS;  						goto case BLLENS; // fall through  					case BLLENS:  						while (ptr < blnum) {  							int len = input.PeekBits(3);  							if (len < 0) {  								return false;  							}  							input.DropBits(3);  							//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  							blLens[BL_ORDER[ptr]] = (byte)len;  							ptr++;  						}  						blTree = new InflaterHuffmanTree(blLens);  						blLens = null;  						ptr = 0;  						mode = LENS;  						goto case LENS; // fall through  					case LENS: {  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */    								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;    								if (ptr == num) {  									/* Finished */  									return true;  								}  							}    							/* need more input ? */  							if (symbol < 0) {  								return false;  							}    							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol - 16;  						}  						mode = REPS;  						goto case REPS; // fall through  					case REPS: {  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);    							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}    							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  			for (;;) {  				switch (mode) {  					case LNUM:  						lnum = input.PeekBits(5);  						if (lnum < 0) {  							return false;  						}  						lnum += 257;  						input.DropBits(5);  						//  	    System.err.println("LNUM: "+lnum);  						mode = DNUM;  						goto case DNUM; // fall through  					case DNUM:  						dnum = input.PeekBits(5);  						if (dnum < 0) {  							return false;  						}  						dnum++;  						input.DropBits(5);  						//  	    System.err.println("DNUM: "+dnum);  						num = lnum + dnum;  						litdistLens = new byte[num];  						mode = BLNUM;  						goto case BLNUM; // fall through  					case BLNUM:  						blnum = input.PeekBits(4);  						if (blnum < 0) {  							return false;  						}  						blnum += 4;  						input.DropBits(4);  						blLens = new byte[19];  						ptr = 0;  						//  	    System.err.println("BLNUM: "+blnum);  						mode = BLLENS;  						goto case BLLENS; // fall through  					case BLLENS:  						while (ptr < blnum) {  							int len = input.PeekBits(3);  							if (len < 0) {  								return false;  							}  							input.DropBits(3);  							//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  							blLens[BL_ORDER[ptr]] = (byte)len;  							ptr++;  						}  						blTree = new InflaterHuffmanTree(blLens);  						blLens = null;  						ptr = 0;  						mode = LENS;  						goto case LENS; // fall through  					case LENS: {  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */    								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;    								if (ptr == num) {  									/* Finished */  									return true;  								}  							}    							/* need more input ? */  							if (symbol < 0) {  								return false;  							}    							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol - 16;  						}  						mode = REPS;  						goto case REPS; // fall through  					case REPS: {  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);    							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}    							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  			for (;;) {  				switch (mode) {  					case LNUM:  						lnum = input.PeekBits(5);  						if (lnum < 0) {  							return false;  						}  						lnum += 257;  						input.DropBits(5);  						//  	    System.err.println("LNUM: "+lnum);  						mode = DNUM;  						goto case DNUM; // fall through  					case DNUM:  						dnum = input.PeekBits(5);  						if (dnum < 0) {  							return false;  						}  						dnum++;  						input.DropBits(5);  						//  	    System.err.println("DNUM: "+dnum);  						num = lnum + dnum;  						litdistLens = new byte[num];  						mode = BLNUM;  						goto case BLNUM; // fall through  					case BLNUM:  						blnum = input.PeekBits(4);  						if (blnum < 0) {  							return false;  						}  						blnum += 4;  						input.DropBits(4);  						blLens = new byte[19];  						ptr = 0;  						//  	    System.err.println("BLNUM: "+blnum);  						mode = BLLENS;  						goto case BLLENS; // fall through  					case BLLENS:  						while (ptr < blnum) {  							int len = input.PeekBits(3);  							if (len < 0) {  								return false;  							}  							input.DropBits(3);  							//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  							blLens[BL_ORDER[ptr]] = (byte)len;  							ptr++;  						}  						blTree = new InflaterHuffmanTree(blLens);  						blLens = null;  						ptr = 0;  						mode = LENS;  						goto case LENS; // fall through  					case LENS: {  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */    								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;    								if (ptr == num) {  									/* Finished */  									return true;  								}  							}    							/* need more input ? */  							if (symbol < 0) {  								return false;  							}    							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol - 16;  						}  						mode = REPS;  						goto case REPS; // fall through  					case REPS: {  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);    							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}    							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  			for (;;) {  				switch (mode) {  					case LNUM:  						lnum = input.PeekBits(5);  						if (lnum < 0) {  							return false;  						}  						lnum += 257;  						input.DropBits(5);  						//  	    System.err.println("LNUM: "+lnum);  						mode = DNUM;  						goto case DNUM; // fall through  					case DNUM:  						dnum = input.PeekBits(5);  						if (dnum < 0) {  							return false;  						}  						dnum++;  						input.DropBits(5);  						//  	    System.err.println("DNUM: "+dnum);  						num = lnum + dnum;  						litdistLens = new byte[num];  						mode = BLNUM;  						goto case BLNUM; // fall through  					case BLNUM:  						blnum = input.PeekBits(4);  						if (blnum < 0) {  							return false;  						}  						blnum += 4;  						input.DropBits(4);  						blLens = new byte[19];  						ptr = 0;  						//  	    System.err.println("BLNUM: "+blnum);  						mode = BLLENS;  						goto case BLLENS; // fall through  					case BLLENS:  						while (ptr < blnum) {  							int len = input.PeekBits(3);  							if (len < 0) {  								return false;  							}  							input.DropBits(3);  							//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  							blLens[BL_ORDER[ptr]] = (byte)len;  							ptr++;  						}  						blTree = new InflaterHuffmanTree(blLens);  						blLens = null;  						ptr = 0;  						mode = LENS;  						goto case LENS; // fall through  					case LENS: {  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */    								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;    								if (ptr == num) {  									/* Finished */  									return true;  								}  							}    							/* need more input ? */  							if (symbol < 0) {  								return false;  							}    							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol - 16;  						}  						mode = REPS;  						goto case REPS; // fall through  					case REPS: {  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);    							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}    							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  			for (;;) {  				switch (mode) {  					case LNUM:  						lnum = input.PeekBits(5);  						if (lnum < 0) {  							return false;  						}  						lnum += 257;  						input.DropBits(5);  						//  	    System.err.println("LNUM: "+lnum);  						mode = DNUM;  						goto case DNUM; // fall through  					case DNUM:  						dnum = input.PeekBits(5);  						if (dnum < 0) {  							return false;  						}  						dnum++;  						input.DropBits(5);  						//  	    System.err.println("DNUM: "+dnum);  						num = lnum + dnum;  						litdistLens = new byte[num];  						mode = BLNUM;  						goto case BLNUM; // fall through  					case BLNUM:  						blnum = input.PeekBits(4);  						if (blnum < 0) {  							return false;  						}  						blnum += 4;  						input.DropBits(4);  						blLens = new byte[19];  						ptr = 0;  						//  	    System.err.println("BLNUM: "+blnum);  						mode = BLLENS;  						goto case BLLENS; // fall through  					case BLLENS:  						while (ptr < blnum) {  							int len = input.PeekBits(3);  							if (len < 0) {  								return false;  							}  							input.DropBits(3);  							//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  							blLens[BL_ORDER[ptr]] = (byte)len;  							ptr++;  						}  						blTree = new InflaterHuffmanTree(blLens);  						blLens = null;  						ptr = 0;  						mode = LENS;  						goto case LENS; // fall through  					case LENS: {  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */    								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;    								if (ptr == num) {  									/* Finished */  									return true;  								}  							}    							/* need more input ? */  							if (symbol < 0) {  								return false;  							}    							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol - 16;  						}  						mode = REPS;  						goto case REPS; // fall through  					case REPS: {  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);    							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}    							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  			for (;;) {  				switch (mode) {  					case LNUM:  						lnum = input.PeekBits(5);  						if (lnum < 0) {  							return false;  						}  						lnum += 257;  						input.DropBits(5);  						//  	    System.err.println("LNUM: "+lnum);  						mode = DNUM;  						goto case DNUM; // fall through  					case DNUM:  						dnum = input.PeekBits(5);  						if (dnum < 0) {  							return false;  						}  						dnum++;  						input.DropBits(5);  						//  	    System.err.println("DNUM: "+dnum);  						num = lnum + dnum;  						litdistLens = new byte[num];  						mode = BLNUM;  						goto case BLNUM; // fall through  					case BLNUM:  						blnum = input.PeekBits(4);  						if (blnum < 0) {  							return false;  						}  						blnum += 4;  						input.DropBits(4);  						blLens = new byte[19];  						ptr = 0;  						//  	    System.err.println("BLNUM: "+blnum);  						mode = BLLENS;  						goto case BLLENS; // fall through  					case BLLENS:  						while (ptr < blnum) {  							int len = input.PeekBits(3);  							if (len < 0) {  								return false;  							}  							input.DropBits(3);  							//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  							blLens[BL_ORDER[ptr]] = (byte)len;  							ptr++;  						}  						blTree = new InflaterHuffmanTree(blLens);  						blLens = null;  						ptr = 0;  						mode = LENS;  						goto case LENS; // fall through  					case LENS: {  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */    								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;    								if (ptr == num) {  									/* Finished */  									return true;  								}  							}    							/* need more input ? */  							if (symbol < 0) {  								return false;  							}    							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol - 16;  						}  						mode = REPS;  						goto case REPS; // fall through  					case REPS: {  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);    							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}    							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  			for (;;) {  				switch (mode) {  					case LNUM:  						lnum = input.PeekBits(5);  						if (lnum < 0) {  							return false;  						}  						lnum += 257;  						input.DropBits(5);  						//  	    System.err.println("LNUM: "+lnum);  						mode = DNUM;  						goto case DNUM; // fall through  					case DNUM:  						dnum = input.PeekBits(5);  						if (dnum < 0) {  							return false;  						}  						dnum++;  						input.DropBits(5);  						//  	    System.err.println("DNUM: "+dnum);  						num = lnum + dnum;  						litdistLens = new byte[num];  						mode = BLNUM;  						goto case BLNUM; // fall through  					case BLNUM:  						blnum = input.PeekBits(4);  						if (blnum < 0) {  							return false;  						}  						blnum += 4;  						input.DropBits(4);  						blLens = new byte[19];  						ptr = 0;  						//  	    System.err.println("BLNUM: "+blnum);  						mode = BLLENS;  						goto case BLLENS; // fall through  					case BLLENS:  						while (ptr < blnum) {  							int len = input.PeekBits(3);  							if (len < 0) {  								return false;  							}  							input.DropBits(3);  							//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  							blLens[BL_ORDER[ptr]] = (byte)len;  							ptr++;  						}  						blTree = new InflaterHuffmanTree(blLens);  						blLens = null;  						ptr = 0;  						mode = LENS;  						goto case LENS; // fall through  					case LENS: {  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */    								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;    								if (ptr == num) {  									/* Finished */  									return true;  								}  							}    							/* need more input ? */  							if (symbol < 0) {  								return false;  							}    							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol - 16;  						}  						mode = REPS;  						goto case REPS; // fall through  					case REPS: {  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);    							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}    							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  			for (;;) {  				switch (mode) {  					case LNUM:  						lnum = input.PeekBits(5);  						if (lnum < 0) {  							return false;  						}  						lnum += 257;  						input.DropBits(5);  						//  	    System.err.println("LNUM: "+lnum);  						mode = DNUM;  						goto case DNUM; // fall through  					case DNUM:  						dnum = input.PeekBits(5);  						if (dnum < 0) {  							return false;  						}  						dnum++;  						input.DropBits(5);  						//  	    System.err.println("DNUM: "+dnum);  						num = lnum + dnum;  						litdistLens = new byte[num];  						mode = BLNUM;  						goto case BLNUM; // fall through  					case BLNUM:  						blnum = input.PeekBits(4);  						if (blnum < 0) {  							return false;  						}  						blnum += 4;  						input.DropBits(4);  						blLens = new byte[19];  						ptr = 0;  						//  	    System.err.println("BLNUM: "+blnum);  						mode = BLLENS;  						goto case BLLENS; // fall through  					case BLLENS:  						while (ptr < blnum) {  							int len = input.PeekBits(3);  							if (len < 0) {  								return false;  							}  							input.DropBits(3);  							//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  							blLens[BL_ORDER[ptr]] = (byte)len;  							ptr++;  						}  						blTree = new InflaterHuffmanTree(blLens);  						blLens = null;  						ptr = 0;  						mode = LENS;  						goto case LENS; // fall through  					case LENS: {  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */    								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;    								if (ptr == num) {  									/* Finished */  									return true;  								}  							}    							/* need more input ? */  							if (symbol < 0) {  								return false;  							}    							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol - 16;  						}  						mode = REPS;  						goto case REPS; // fall through  					case REPS: {  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);    							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}    							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);    				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);    				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);    				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);    				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);    				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);    				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);    				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);    				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);    				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);    				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);    				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);    				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: int treeSize = 512;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  				nextCode[bits] = code;  				code += blCount[bits] << (16 - bits);  				if (bits >= 10) {  					/* We need an extra table for bit lengths >= 10. */  					int start = nextCode[bits] & 0x1ff80;  					int end = code & 0x1ff80;  					treeSize += (end - start) >> (16 - bits);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  				nextCode[bits] = code;  				code += blCount[bits] << (16 - bits);  				if (bits >= 10) {  					/* We need an extra table for bit lengths >= 10. */  					int start = nextCode[bits] & 0x1ff80;  					int end = code & 0x1ff80;  					treeSize += (end - start) >> (16 - bits);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  				nextCode[bits] = code;  				code += blCount[bits] << (16 - bits);  				if (bits >= 10) {  					/* We need an extra table for bit lengths >= 10. */  					int start = nextCode[bits] & 0x1ff80;  					int end = code & 0x1ff80;  					treeSize += (end - start) >> (16 - bits);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: int treePtr = 512;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[DeflaterHuffman.BitReverse(i)] = (short)((-treePtr << 4) | bits);  					treePtr += 1 << (bits - 9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[DeflaterHuffman.BitReverse(i)] = (short)((-treePtr << 4) | bits);  					treePtr += 1 << (bits - 9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[DeflaterHuffman.BitReverse(i)] = (short)((-treePtr << 4) | bits);  					treePtr += 1 << (bits - 9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[DeflaterHuffman.BitReverse(i)] = (short)((-treePtr << 4) | bits);  					treePtr += 1 << (bits - 9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[DeflaterHuffman.BitReverse(i)] = (short)((-treePtr << 4) | bits);  					treePtr += 1 << (bits - 9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short)((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteShort,The following statement contains a magic number: buffer[end++] = unchecked((byte)(value >> 8));
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer[end++] = unchecked((byte)(value >> 8));
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer[end++] = unchecked((byte)(value >> 16));
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer[end++] = unchecked((byte)(value >> 24));
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0) {  				buffer[end++] = unchecked((byte)bits);  				if (bitCount > 8) {  					buffer[end++] = unchecked((byte)(bits >> 8));  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0) {  				buffer[end++] = unchecked((byte)bits);  				if (bitCount > 8) {  					buffer[end++] = unchecked((byte)(bits >> 8));  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  				buffer[end++] = unchecked((byte)bits);  				buffer[end++] = unchecked((byte)(bits >> 8));  				bits >>= 16;  				bitCount -= 16;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  				buffer[end++] = unchecked((byte)bits);  				buffer[end++] = unchecked((byte)(bits >> 8));  				bits >>= 16;  				bitCount -= 16;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  				buffer[end++] = unchecked((byte)bits);  				buffer[end++] = unchecked((byte)(bits >> 8));  				bits >>= 16;  				bitCount -= 16;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  				buffer[end++] = unchecked((byte)bits);  				buffer[end++] = unchecked((byte)(bits >> 8));  				bits >>= 16;  				bitCount -= 16;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteShortMSB,The following statement contains a magic number: buffer[end++] = unchecked((byte)(s >> 8));
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  				buffer[end++] = unchecked((byte)bits);  				bits >>= 8;  				bitCount -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  				buffer[end++] = unchecked((byte)bits);  				bits >>= 8;  				bitCount -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  				buffer[end++] = unchecked((byte)bits);  				bits >>= 8;  				bitCount -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\DeflaterOutputStream.cs,DeflaterOutputStream,The following statement contains a magic number: if (bufferSize < 512) {  				throw new ArgumentOutOfRangeException(nameof(bufferSize));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\DeflaterOutputStream.cs,InitializeAESPassword,The following statement contains a magic number: int blockSize = entry.AESKeySize / 8;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: if (bufferSize < 1024) {  				bufferSize = 1024;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: if (bufferSize < 1024) {  				bufferSize = 1024;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeShort,The following statement contains a magic number: return ReadLeByte() | (ReadLeByte() << 8);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeInt,The following statement contains a magic number: return ReadLeShort() | (ReadLeShort() << 16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeLong,The following statement contains a magic number: return (uint)ReadLeInt() | ((long)ReadLeInt() << 32);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,Skip,The following statement contains a magic number: if (baseInputStream.CanSeek) {  				baseInputStream.Seek(count' SeekOrigin.Current);  				return count;  			} else {  				int length = 2048;  				if (count < length) {  					length = (int)count;  				}    				byte[] tmp = new byte[length];  				int readCount = 1;  				long toSkip = count;    				while ((toSkip > 0) && (readCount > 0)) {  					if (toSkip < length) {  						length = (int)toSkip;  					}    					readCount = baseInputStream.Read(tmp' 0' length);  					toSkip -= readCount;  				}    				return count - toSkip;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  				if (windowStart_ == windowEnd_) {  					return -1; // ok  				}  				buffer_ |= (uint)((window_[windowStart_++] & 0xff |  								 (window_[windowStart_++] & 0xff) << 8) << bitsInBuffer_);  				bitsInBuffer_ += 16;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  				if (windowStart_ == windowEnd_) {  					return -1; // ok  				}  				buffer_ |= (uint)((window_[windowStart_++] & 0xff |  								 (window_[windowStart_++] & 0xff) << 8) << bitsInBuffer_);  				bitsInBuffer_ += 16;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: buffer_ >>= (bitsInBuffer_ & 7);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: bitsInBuffer_ &= ~7;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if ((bitsInBuffer_ & 7) != 0) {  				// bits_in_buffer may only be 0 or a multiple of 8  				throw new InvalidOperationException("Bit buffer is not byte aligned!");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  				output[offset++] = (byte)buffer_;  				buffer_ >>= 8;  				bitsInBuffer_ -= 8;  				length--;  				count++;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  				output[offset++] = (byte)buffer_;  				buffer_ >>= 8;  				bitsInBuffer_ -= 8;  				length--;  				count++;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if (((windowStart_ - windowEnd_) & 1) != 0) {  				// We always want an even number of bytes in input' see peekBits  				buffer_ = (uint)(window_[windowStart_++] & 0xff);  				bitsInBuffer_ = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: if ((count & 1) != 0) {  				// We always want an even number of bytes in input' see PeekBits  				buffer_ |= (uint)((buffer[offset++] & 0xff) << bitsInBuffer_);  				bitsInBuffer_ += 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\FastZip.cs,AddFileContents,The following statement contains a magic number: if (buffer_ == null) {  				buffer_ = new byte[4096];  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: if (proceed) {  				if (events_ != null) {  					continueRunning_ = events_.OnProcessFile(entry.Name);  				}    				if (continueRunning_) {  					try {  						using (FileStream outputStream = File.Create(targetName)) {  							if (buffer_ == null) {  								buffer_ = new byte[4096];  							}  							if ((events_ != null) && (events_.Progress != null)) {  								StreamUtils.Copy(zipFile_.GetInputStream(entry)' outputStream' buffer_'  									events_.Progress' events_.ProgressInterval' this' entry.Name' entry.Size);  							} else {  								StreamUtils.Copy(zipFile_.GetInputStream(entry)' outputStream' buffer_);  							}    							if (events_ != null) {  								continueRunning_ = events_.OnCompletedFile(entry.Name);  							}  						}    						if (restoreDateTimeOnExtract_) {  							File.SetLastWriteTime(targetName' entry.DateTime);  						}    						if (RestoreAttributesOnExtract && entry.IsDOSEntry && (entry.ExternalFileAttributes != -1)) {  							var fileAttributes = (FileAttributes)entry.ExternalFileAttributes;  							// TODO: FastZip - Setting of other file attributes on extraction is a little trickier.  							fileAttributes &= (FileAttributes.Archive | FileAttributes.Normal | FileAttributes.ReadOnly | FileAttributes.Hidden);  							File.SetAttributes(targetName' fileAttributes);  						}  					} catch (Exception ex) {  						if (events_ != null) {  							continueRunning_ = events_.OnFileFailure(targetName' ex);  						} else {  							continueRunning_ = false;  							throw;  						}  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ZipEntry,The following statement contains a magic number: if ((versionRequiredToExtract != 0) && (versionRequiredToExtract < 10)) {  				throw new ArgumentOutOfRangeException(nameof(versionRequiredToExtract));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find(0x0001)) {  				// Version required to extract is ignored here as some archivers dont set it correctly  				// in theory it should be version 45 or higher    				// The recorded size will change but remember that this is zip64.  				forceZip64_ = true;    				if (extraData.ValueLength < 4) {  					throw new ZipException("Extra data extended Zip64 information length is invalid");  				}    				// (localHeader ||) was deleted' because actually there is no specific difference with reading sizes between local header & central directory   				// https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT   				// ...  				// 4.4  Explanation of fields  				// ...  				//	4.4.8 compressed size: (4 bytes)  				//	4.4.9 uncompressed size: (4 bytes)  				//   				//		The size of the file compressed (4.4.8) and uncompressed'  				//		(4.4.9) respectively.  When a decryption header is present it   				//		will be placed in front of the file data and the value of the  				//		compressed file size will include the bytes of the decryption  				//		header.  If bit 3 of the general purpose bit flag is set'   				//		these fields are set to zero in the local header and the   				//		correct values are put in the data descriptor and  				//		in the central directory.  If an archive is in ZIP64 format  				//		and the value in this field is 0xFFFFFFFF' the size will be  				//		in the corresponding 8 byte ZIP64 extended information   				//		extra field.  When encrypting the central directory' if the  				//		local header is not in ZIP64 format and general purpose bit   				//		flag 13 is set indicating masking' the value stored for the   				//		uncompressed size in the Local Header will be zero.   				//   				// Othewise there is problem with minizip implementation  				if (size == uint.MaxValue) {  					size = (ulong)extraData.ReadLong();  				}    				if (compressedSize == uint.MaxValue) {  					compressedSize = (ulong)extraData.ReadLong();  				}    				if (!localHeader && (offset == uint.MaxValue)) {  					offset = extraData.ReadLong();  				}    				// Disk number on which file starts is ignored  			} else {  				if (  					((versionToExtract & 0xff) >= ZipConstants.VersionZip64) &&  					((size == uint.MaxValue) || (compressedSize == uint.MaxValue))  				) {  					throw new ZipException("Zip64 Extended information required but is missing.");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,GetDateTime,The following statement contains a magic number: uint sec = Math.Min(59' 2 * (dosTime & 0x1f));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,GetDateTime,The following statement contains a magic number: uint sec = Math.Min(59' 2 * (dosTime & 0x1f));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,GetDateTime,The following statement contains a magic number: uint min = Math.Min(59' (dosTime >> 5) & 0x3f);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,GetDateTime,The following statement contains a magic number: uint min = Math.Min(59' (dosTime >> 5) & 0x3f);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,GetDateTime,The following statement contains a magic number: uint hrs = Math.Min(23' (dosTime >> 11) & 0x1f);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,GetDateTime,The following statement contains a magic number: uint hrs = Math.Min(23' (dosTime >> 11) & 0x1f);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,GetDateTime,The following statement contains a magic number: uint mon = Math.Max(1' Math.Min(12' ((dosTime >> 21) & 0xf)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,GetDateTime,The following statement contains a magic number: uint mon = Math.Max(1' Math.Min(12' ((dosTime >> 21) & 0xf)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,GetDateTime,The following statement contains a magic number: uint year = ((dosTime >> 25) & 0x7f) + 1980;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,GetDateTime,The following statement contains a magic number: uint year = ((dosTime >> 25) & 0x7f) + 1980;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,GetDateTime,The following statement contains a magic number: int day = Math.Max(1' Math.Min(DateTime.DaysInMonth((int)year' (int)mon)' (int)((dosTime >> 16) & 0x1f)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntry.cs,ProcessAESExtraData,The following statement contains a magic number: if (extraData.Find(0x9901)) {  				// Set version and flag for Zipfile.CreateAndInitDecryptionStream  				versionToExtract = ZipConstants.VERSION_AES;            // Ver 5.1 = AES see "Version" getter  																		// Set StrongEncryption flag for ZipFile.CreateAndInitDecryptionStream  				Flags = Flags | (int)GeneralBitFlags.StrongEncryption;  				//  				// Unpack AES extra data field see http://www.winzip.com/aes_info.htm  				int length = extraData.ValueLength;         // Data size currently 7  				if (length < 7)  					throw new ZipException("AES Extra Data Length " + length + " invalid.");  				int ver = extraData.ReadShort();            // Version number (1=AE-1 2=AE-2)  				int vendorId = extraData.ReadShort();       // 2-character vendor ID 0x4541 = "AE"  				int encrStrength = extraData.ReadByte();    // encryption strength 1 = 128 2 = 192 3 = 256  				int actualCompress = extraData.ReadShort(); // The actual compression method used to compress the file  				_aesVer = ver;  				_aesEncryptionStrength = encrStrength;  				method = (CompressionMethod)actualCompress;  			} else  				throw new ZipException("AES Extra Data missing");
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntryFactory,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipEntryFactory.cs,MakeDirectoryEntry,The following statement contains a magic number: externalAttributes |= (setAttributes_ | 16);
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(data' index' count' false))  			using (ZipHelperStream helperStream = new ZipHelperStream(ms)) {  				// bit 0           if set' modification time is present  				// bit 1           if set' access time is present  				// bit 2           if set' creation time is present    				_flags = (Flags)helperStream.ReadByte();  				if (((_flags & Flags.ModificationTime) != 0))  				{  					int iTime = helperStream.ReadLEInt();    					_modificationTime = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc) +  						new TimeSpan(0' 0' 0' iTime' 0);    					// Central-header version is truncated after modification time  					if (count <= 5) return;  				}    				if ((_flags & Flags.AccessTime) != 0) {  					int iTime = helperStream.ReadLEInt();    					_lastAccessTime = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc) +  						new TimeSpan(0' 0' 0' iTime' 0);  				}    				if ((_flags & Flags.CreateTime) != 0) {  					int iTime = helperStream.ReadLEInt();    					_createTime = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc) +  						new TimeSpan(0' 0' 0' iTime' 0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(data' index' count' false))  			using (ZipHelperStream helperStream = new ZipHelperStream(ms)) {  				// bit 0           if set' modification time is present  				// bit 1           if set' access time is present  				// bit 2           if set' creation time is present    				_flags = (Flags)helperStream.ReadByte();  				if (((_flags & Flags.ModificationTime) != 0))  				{  					int iTime = helperStream.ReadLEInt();    					_modificationTime = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc) +  						new TimeSpan(0' 0' 0' iTime' 0);    					// Central-header version is truncated after modification time  					if (count <= 5) return;  				}    				if ((_flags & Flags.AccessTime) != 0) {  					int iTime = helperStream.ReadLEInt();    					_lastAccessTime = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc) +  						new TimeSpan(0' 0' 0' iTime' 0);  				}    				if ((_flags & Flags.CreateTime) != 0) {  					int iTime = helperStream.ReadLEInt();    					_createTime = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc) +  						new TimeSpan(0' 0' 0' iTime' 0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(data' index' count' false))  			using (ZipHelperStream helperStream = new ZipHelperStream(ms)) {  				// bit 0           if set' modification time is present  				// bit 1           if set' access time is present  				// bit 2           if set' creation time is present    				_flags = (Flags)helperStream.ReadByte();  				if (((_flags & Flags.ModificationTime) != 0))  				{  					int iTime = helperStream.ReadLEInt();    					_modificationTime = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc) +  						new TimeSpan(0' 0' 0' iTime' 0);    					// Central-header version is truncated after modification time  					if (count <= 5) return;  				}    				if ((_flags & Flags.AccessTime) != 0) {  					int iTime = helperStream.ReadLEInt();    					_lastAccessTime = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc) +  						new TimeSpan(0' 0' 0' iTime' 0);  				}    				if ((_flags & Flags.CreateTime) != 0) {  					int iTime = helperStream.ReadLEInt();    					_createTime = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc) +  						new TimeSpan(0' 0' 0' iTime' 0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(data' index' count' false))  			using (ZipHelperStream helperStream = new ZipHelperStream(ms)) {  				// bit 0           if set' modification time is present  				// bit 1           if set' access time is present  				// bit 2           if set' creation time is present    				_flags = (Flags)helperStream.ReadByte();  				if (((_flags & Flags.ModificationTime) != 0))  				{  					int iTime = helperStream.ReadLEInt();    					_modificationTime = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc) +  						new TimeSpan(0' 0' 0' iTime' 0);    					// Central-header version is truncated after modification time  					if (count <= 5) return;  				}    				if ((_flags & Flags.AccessTime) != 0) {  					int iTime = helperStream.ReadLEInt();    					_lastAccessTime = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc) +  						new TimeSpan(0' 0' 0' iTime' 0);  				}    				if ((_flags & Flags.CreateTime) != 0) {  					int iTime = helperStream.ReadLEInt();    					_createTime = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc) +  						new TimeSpan(0' 0' 0' iTime' 0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream())  			using (ZipHelperStream helperStream = new ZipHelperStream(ms)) {  				helperStream.IsStreamOwner = false;  				helperStream.WriteByte((byte)_flags);     // Flags  				if ((_flags & Flags.ModificationTime) != 0) {  					TimeSpan span = _modificationTime - new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  					var seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				if ((_flags & Flags.AccessTime) != 0) {  					TimeSpan span = _lastAccessTime - new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  					var seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				if ((_flags & Flags.CreateTime) != 0) {  					TimeSpan span = _createTime - new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  					var seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				return ms.ToArray();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream())  			using (ZipHelperStream helperStream = new ZipHelperStream(ms)) {  				helperStream.IsStreamOwner = false;  				helperStream.WriteByte((byte)_flags);     // Flags  				if ((_flags & Flags.ModificationTime) != 0) {  					TimeSpan span = _modificationTime - new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  					var seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				if ((_flags & Flags.AccessTime) != 0) {  					TimeSpan span = _lastAccessTime - new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  					var seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				if ((_flags & Flags.CreateTime) != 0) {  					TimeSpan span = _createTime - new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  					var seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				return ms.ToArray();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream())  			using (ZipHelperStream helperStream = new ZipHelperStream(ms)) {  				helperStream.IsStreamOwner = false;  				helperStream.WriteByte((byte)_flags);     // Flags  				if ((_flags & Flags.ModificationTime) != 0) {  					TimeSpan span = _modificationTime - new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  					var seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				if ((_flags & Flags.AccessTime) != 0) {  					TimeSpan span = _lastAccessTime - new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  					var seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				if ((_flags & Flags.CreateTime) != 0) {  					TimeSpan span = _createTime - new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  					var seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				return ms.ToArray();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||  					(value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||  					(value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||  					(value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||  					(value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||  					(value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||  					(value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||  					(value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||  					(value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||  					(value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||  					(value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||  					(value <= new DateTime(2038' 1' 19' 03' 14' 07)));
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(data' index' count' false))  			using (ZipHelperStream helperStream = new ZipHelperStream(ms)) {  				helperStream.ReadLEInt(); // Reserved  				while (helperStream.Position < helperStream.Length) {  					int ntfsTag = helperStream.ReadLEShort();  					int ntfsLength = helperStream.ReadLEShort();  					if (ntfsTag == 1) {  						if (ntfsLength >= 24) {  							long lastModificationTicks = helperStream.ReadLELong();  							_lastModificationTime = DateTime.FromFileTimeUtc(lastModificationTicks);    							long lastAccessTicks = helperStream.ReadLELong();  							_lastAccessTime = DateTime.FromFileTimeUtc(lastAccessTicks);    							long createTimeTicks = helperStream.ReadLELong();  							_createTime = DateTime.FromFileTimeUtc(createTimeTicks);  						}  						break;  					} else {  						// An unknown NTFS tag so simply skip it.  						helperStream.Seek(ntfsLength' SeekOrigin.Current);  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream())  			using (ZipHelperStream helperStream = new ZipHelperStream(ms)) {  				helperStream.IsStreamOwner = false;  				helperStream.WriteLEInt(0);       // Reserved  				helperStream.WriteLEShort(1);     // Tag  				helperStream.WriteLEShort(24);    // Length = 3 x 8.  				helperStream.WriteLELong(_lastModificationTime.ToFileTimeUtc());  				helperStream.WriteLELong(_lastAccessTime.ToFileTimeUtc());  				helperStream.WriteLELong(_createTime.ToFileTimeUtc());  				return ms.ToArray();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,Find,The following statement contains a magic number: while ((localTag != headerID) && (_index < _data.Length - 3)) {  				localTag = ReadShortInternal();  				localLength = ReadShortInternal();  				if (localTag != headerID) {  					_index += localLength;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,AddEntry,The following statement contains a magic number: int newLength = _data.Length + addLength + 4;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,AddEntry,The following statement contains a magic number: if (Find(headerID)) {  				newLength -= (ValueLength + 4);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,AddLeShort,The following statement contains a magic number: unchecked {  				_newEntry.WriteByte((byte)toAdd);  				_newEntry.WriteByte((byte)(toAdd >> 8));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,AddLeInt,The following statement contains a magic number: unchecked {  				AddLeShort((short)toAdd);  				AddLeShort((short)(toAdd >> 16));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,AddLeLong,The following statement contains a magic number: unchecked {  				AddLeInt((int)(toAdd & 0xffffffff));  				AddLeInt((int)(toAdd >> 32));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find(headerID)) {  				result = true;  				int trueStart = _readValueStart - 4;    				byte[] newData = new byte[_data.Length - (ValueLength + 4)];  				Array.Copy(_data' 0' newData' 0' trueStart);    				int trueEnd = trueStart + ValueLength + 4;  				Array.Copy(_data' trueEnd' newData' trueStart' _data.Length - trueEnd);  				_data = newData;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find(headerID)) {  				result = true;  				int trueStart = _readValueStart - 4;    				byte[] newData = new byte[_data.Length - (ValueLength + 4)];  				Array.Copy(_data' 0' newData' 0' trueStart);    				int trueEnd = trueStart + ValueLength + 4;  				Array.Copy(_data' trueEnd' newData' trueStart' _data.Length - trueEnd);  				_data = newData;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find(headerID)) {  				result = true;  				int trueStart = _readValueStart - 4;    				byte[] newData = new byte[_data.Length - (ValueLength + 4)];  				Array.Copy(_data' 0' newData' 0' trueStart);    				int trueEnd = trueStart + ValueLength + 4;  				Array.Copy(_data' trueEnd' newData' trueStart' _data.Length - trueEnd);  				_data = newData;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadLong,The following statement contains a magic number: ReadCheck(8);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadLong,The following statement contains a magic number: return (ReadInt() & 0xffffffff) | (((long)ReadInt()) << 32);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: ReadCheck(4);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: int result = _data[_index] + (_data[_index + 1] << 8) +  				(_data[_index + 2] << 16) + (_data[_index + 3] << 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: int result = _data[_index] + (_data[_index + 1] << 8) +  				(_data[_index + 2] << 16) + (_data[_index + 3] << 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: int result = _data[_index] + (_data[_index + 1] << 8) +  				(_data[_index + 2] << 16) + (_data[_index + 3] << 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: int result = _data[_index] + (_data[_index + 1] << 8) +  				(_data[_index + 2] << 16) + (_data[_index + 3] << 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: int result = _data[_index] + (_data[_index + 1] << 8) +  				(_data[_index + 2] << 16) + (_data[_index + 3] << 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: _index += 4;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadShort,The following statement contains a magic number: ReadCheck(2);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadShort,The following statement contains a magic number: int result = _data[_index] + (_data[_index + 1] << 8);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadShort,The following statement contains a magic number: _index += 2;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadCheck,The following statement contains a magic number: if ((_readValueStart > _data.Length) ||  				(_readValueStart < 4)) {  				throw new ZipException("Find must be called before calling a Read method");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadCheck,The following statement contains a magic number: if (_index + length < 4) {  				throw new ZipException("Cannot read before start of tag");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: if (_index > _data.Length - 2) {  				throw new ZipException("End of extra data");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: int result = _data[_index] + (_data[_index + 1] << 8);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: _index += 2;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetShort,The following statement contains a magic number: _data[index + 1] = (byte)(source >> 8);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipExtraData.cs,SetShort,The following statement contains a magic number: index += 2;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestArchive,The following statement contains a magic number: try {  				int entryIndex = 0;    				while (testing && (entryIndex < Count)) {  					if (resultHandler != null) {  						status.SetEntry(this[entryIndex]);  						status.SetOperation(TestOperation.EntryHeader);  						resultHandler(status' null);  					}    					try {  						TestLocalHeader(this[entryIndex]' test);  					} catch (ZipException ex) {  						status.AddError();    						if (resultHandler != null) {  							resultHandler(status'  								string.Format("Exception during test - '{0}'"' ex.Message));  						}    						testing &= strategy != TestStrategy.FindFirstError;  					}    					if (testing && testData && this[entryIndex].IsFile) {  						if (resultHandler != null) {  							status.SetOperation(TestOperation.EntryData);  							resultHandler(status' null);  						}    						var crc = new Crc32();    						using (Stream entryStream = this.GetInputStream(this[entryIndex])) {    							byte[] buffer = new byte[4096];  							long totalBytes = 0;  							int bytesRead;  							while ((bytesRead = entryStream.Read(buffer' 0' buffer.Length)) > 0) {  								crc.Update(buffer' 0' bytesRead);    								if (resultHandler != null) {  									totalBytes += bytesRead;  									status.SetBytesTested(totalBytes);  									resultHandler(status' null);  								}  							}  						}    						if (this[entryIndex].Crc != crc.Value) {  							status.AddError();    							if (resultHandler != null) {  								resultHandler(status' "CRC mismatch");  							}    							testing &= strategy != TestStrategy.FindFirstError;  						}    						if ((this[entryIndex].Flags & (int)GeneralBitFlags.Descriptor) != 0) {  							var helper = new ZipHelperStream(baseStream_);  							var data = new DescriptorData();  							helper.ReadDataDescriptor(this[entryIndex].LocalHeaderRequiresZip64' data);  							if (this[entryIndex].Crc != data.Crc) {  								status.AddError();  							}    							if (this[entryIndex].CompressedSize != data.CompressedSize) {  								status.AddError();  							}    							if (this[entryIndex].Size != data.Size) {  								status.AddError();  							}  						}  					}    					if (resultHandler != null) {  						status.SetOperation(TestOperation.EntryComplete);  						resultHandler(status' null);  					}    					entryIndex += 1;  				}    				if (resultHandler != null) {  					status.SetOperation(TestOperation.MiscellaneousTests);  					resultHandler(status' null);  				}    				// TODO: the 'Corrina Johns' test where local headers are missing from  				// the central directory.  They are therefore invisible to many archivers.  			} catch (Exception ex) {  				status.AddError();    				if (resultHandler != null) {  					resultHandler(status' string.Format("Exception during test - '{0}'"' ex.Message));  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock (baseStream_) {  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				var extractVersion = (short)(ReadLEUshort() & 0x00ff);  				var localFlags = (short)ReadLEUshort();  				var compressionMethod = (short)ReadLEUshort();  				var fileTime = (short)ReadLEUshort();  				var fileDate = (short)ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				var localExtraData = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (localExtraData.Find(1)) {  					// 2010-03-04 Forum 10512: removed checks for version >= ZipConstants.VersionZip64  					// and size or compressedSize = MaxValue' due to rogue creators.    					size = localExtraData.ReadLong();  					compressedSize = localExtraData.ReadLong();    					if ((localFlags & (int)GeneralBitFlags.Descriptor) != 0) {  						// These may be valid if patched later  						if ((size != -1) && (size != entry.Size)) {  							throw new ZipException("Size invalid for descriptor");  						}    						if ((compressedSize != -1) && (compressedSize != entry.CompressedSize)) {  							throw new ZipException("Compressed size invalid for descriptor");  						}  					}  				} else {  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue))) {  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if (testData) {  					if (entry.IsFile) {  						if (!entry.IsCompressionMethodSupported()) {  							throw new ZipException("Compression method not supported");  						}    						if ((extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64))) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ((localFlags & (int)(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if (testHeader) {  					if ((extractVersion <= 63) &&   // Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ((localFlags & (int)(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if (((localFlags & (int)GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20)) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if ((localFlags & (int)GeneralBitFlags.Encrypted) == 0) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if (extractVersion < 50) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if (((localFlags & (int)GeneralBitFlags.Patched) != 0) && (extractVersion < 27)) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if (localFlags != entry.Flags) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if (entry.CompressionMethod != (CompressionMethod)compressionMethod) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					if (entry.Version != extractVersion) {  						throw new ZipException("Extract version mismatch");  					}    					// Strong encryption and extract version match  					if ((localFlags & (int)GeneralBitFlags.StrongEncryption) != 0) {  						if (extractVersion < 62) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.HeaderMasked) != 0) {  						if ((fileTime != 0) || (fileDate != 0)) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0) {  						if (crcValue != (uint)entry.Crc) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ((size == 0) && (compressedSize == 0)) {  						if (crcValue != 0) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if (entry.Name.Length > storedNameLength) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if (localName != entry.Name) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero actual size but can have compressed size  					if (entry.IsDirectory) {  						if (size > 0) {  							throw new ZipException("Directory cannot have size");  						}    						// There may be other cases where the compressed size can be greater than this?  						// If so until details are known we will be strict.  						if (entry.IsCrypted) {  							if (compressedSize > ZipConstants.CryptoHeaderSize + 2) {  								throw new ZipException("Directory compressed size invalid");  							}  						} else if (compressedSize > 2) {  							// When not compressed the directory size can validly be 2 bytes  							// if the true size wasnt known when data was originally being written.  							// NOTE: Versions of the library 0.85.4 and earlier always added 2 bytes  							throw new ZipException("Directory compressed size invalid");  						}  					}    					if (!ZipNameTransform.IsValidName(localName' true)) {  						throw new ZipException("Name is invalid");  					}  				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if (((localFlags & (int)GeneralBitFlags.Descriptor) == 0) ||  					((size > 0 || compressedSize > 0) && entry.Size > 0)) {    					if ((size != 0)  						&& (size != entry.Size)) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if ((compressedSize != 0)  						&& (compressedSize != entry.CompressedSize && compressedSize != 0xFFFFFFFF && compressedSize != -1)) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteLEShort,The following statement contains a magic number: baseStream_.WriteByte((byte)((value >> 8) & 0xff));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteLEUshort,The following statement contains a magic number: baseStream_.WriteByte((byte)(value >> 8));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteLEInt,The following statement contains a magic number: WriteLEShort(value >> 16);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteLEUint,The following statement contains a magic number: WriteLEUshort((ushort)(value >> 16));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteLeLong,The following statement contains a magic number: WriteLEInt((int)(value >> 32));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteLEUlong,The following statement contains a magic number: WriteLEUint((uint)(value >> 32));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteCentralDirectoryHeader,The following statement contains a magic number: if (entry.ExternalFileAttributes != -1) {  				WriteLEInt(entry.ExternalFileAttributes);  			} else {  				if (entry.IsDirectory) {  					WriteLEUint(16);  				} else {  					WriteLEUint(0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: if ((update.Entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  				result = ZipConstants.DataDescriptorSize - 4;  				if (update.Entry.LocalHeaderRequiresZip64) {  					result = ZipConstants.Zip64DataDescriptorSize - 4;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: if ((update.Entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  				result = ZipConstants.DataDescriptorSize - 4;  				if (update.Entry.LocalHeaderRequiresZip64) {  					result = ZipConstants.Zip64DataDescriptorSize - 4;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,GetOutputStream,The following statement contains a magic number: switch (entry.CompressionMethod) {  				case CompressionMethod.Stored:  					result = new UncompressedStream(result);  					break;    				case CompressionMethod.Deflated:  					var dos = new DeflaterOutputStream(result' new Deflater(9' true));  					dos.IsStreamOwner = false;  					result = dos;  					break;    				default:  					throw new ZipException("Unknown compression method " + entry.CompressionMethod);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CopyEntryDirect,The following statement contains a magic number: const int NameLengthOffset = 26;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CopyEntry,The following statement contains a magic number: if (update.Entry.CompressedSize > 0) {  				const int NameLengthOffset = 26;    				long entryDataOffset = update.Entry.Offset + NameLengthOffset;    				// TODO: This wont work for SFX files!  				baseStream_.Seek(entryDataOffset' SeekOrigin.Begin);    				uint nameLength = ReadLEUshort();  				uint extraLength = ReadLEUshort();    				baseStream_.Seek(nameLength + extraLength' SeekOrigin.Current);    				CopyBytes(update' workFile.baseStream_' baseStream_' update.Entry.CompressedSize' false);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,UpdateCommentOnly,The following statement contains a magic number: using (updateFile) {  				long locatedCentralDirOffset =  					updateFile.LocateBlockWithSignature(ZipConstants.EndOfCentralDirectorySignature'  														baseLength' ZipConstants.EndOfCentralRecordBaseSize' 0xffff);  				if (locatedCentralDirOffset < 0) {  					throw new ZipException("Cannot find central directory");  				}    				const int CentralHeaderCommentSizeOffset = 16;  				updateFile.Position += CentralHeaderCommentSizeOffset;    				byte[] rawComment = newComment_.RawComment;    				updateFile.WriteLEShort(rawComment.Length);  				updateFile.Write(rawComment' 0' rawComment.Length);  				updateFile.SetLength(updateFile.Position);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadLEUshort,The following statement contains a magic number: return unchecked((ushort)((ushort)data1 | (ushort)(data2 << 8)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadLEUint,The following statement contains a magic number: return (uint)(ReadLEUshort() | (ReadLEUshort() << 16));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadLEUlong,The following statement contains a magic number: return ReadLEUint() | ((ulong)ReadLEUint() << 32);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if (!isZip64 && (offsetOfCentralDir < locatedEndOfCentralDir - (4 + (long)centralDirSize))) {  				offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long)centralDirSize + offsetOfCentralDir);  				if (offsetOfFirstEntry <= 0) {  					throw new ZipException("Invalid embedded zip archive");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if (!isZip64 && (offsetOfCentralDir < locatedEndOfCentralDir - (4 + (long)centralDirSize))) {  				offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long)centralDirSize + offsetOfCentralDir);  				if (offsetOfFirstEntry <= 0) {  					throw new ZipException("Invalid embedded zip archive");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++) {  				if (ReadLEUint() != ZipConstants.CentralHeaderSignature) {  					throw new ZipException("Wrong Central Directory signature");  				}    				int versionMadeBy = ReadLEUshort();  				int versionToExtract = ReadLEUshort();  				int bitFlags = ReadLEUshort();  				int method = ReadLEUshort();  				uint dostime = ReadLEUint();  				uint crc = ReadLEUint();  				var csize = (long)ReadLEUint();  				var size = (long)ReadLEUint();  				int nameLen = ReadLEUshort();  				int extraLen = ReadLEUshort();  				int commentLen = ReadLEUshort();    				int diskStartNo = ReadLEUshort();  // Not currently used  				int internalAttributes = ReadLEUshort();  // Not currently used    				uint externalAttributes = ReadLEUint();  				long offset = ReadLEUint();    				byte[] buffer = new byte[Math.Max(nameLen' commentLen)];    				StreamUtils.ReadFully(baseStream_' buffer' 0' nameLen);  				string name = ZipConstants.ConvertToStringExt(bitFlags' buffer' nameLen);    				var entry = new ZipEntry(name' versionToExtract' versionMadeBy' (CompressionMethod)method);  				entry.Crc = crc & 0xffffffffL;  				entry.Size = size & 0xffffffffL;  				entry.CompressedSize = csize & 0xffffffffL;  				entry.Flags = bitFlags;  				entry.DosTime = (uint)dostime;  				entry.ZipFileIndex = (long)i;  				entry.Offset = offset;  				entry.ExternalFileAttributes = (int)externalAttributes;    				if ((bitFlags & 8) == 0) {  					entry.CryptoCheckValue = (byte)(crc >> 24);  				} else {  					entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  				}    				if (extraLen > 0) {  					byte[] extra = new byte[extraLen];  					StreamUtils.ReadFully(baseStream_' extra);  					entry.ExtraData = extra;  				}    				entry.ProcessExtraData(false);    				if (commentLen > 0) {  					StreamUtils.ReadFully(baseStream_' buffer' 0' commentLen);  					entry.Comment = ZipConstants.ConvertToStringExt(bitFlags' buffer' commentLen);  				}    				entries_[i] = entry;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++) {  				if (ReadLEUint() != ZipConstants.CentralHeaderSignature) {  					throw new ZipException("Wrong Central Directory signature");  				}    				int versionMadeBy = ReadLEUshort();  				int versionToExtract = ReadLEUshort();  				int bitFlags = ReadLEUshort();  				int method = ReadLEUshort();  				uint dostime = ReadLEUint();  				uint crc = ReadLEUint();  				var csize = (long)ReadLEUint();  				var size = (long)ReadLEUint();  				int nameLen = ReadLEUshort();  				int extraLen = ReadLEUshort();  				int commentLen = ReadLEUshort();    				int diskStartNo = ReadLEUshort();  // Not currently used  				int internalAttributes = ReadLEUshort();  // Not currently used    				uint externalAttributes = ReadLEUint();  				long offset = ReadLEUint();    				byte[] buffer = new byte[Math.Max(nameLen' commentLen)];    				StreamUtils.ReadFully(baseStream_' buffer' 0' nameLen);  				string name = ZipConstants.ConvertToStringExt(bitFlags' buffer' nameLen);    				var entry = new ZipEntry(name' versionToExtract' versionMadeBy' (CompressionMethod)method);  				entry.Crc = crc & 0xffffffffL;  				entry.Size = size & 0xffffffffL;  				entry.CompressedSize = csize & 0xffffffffL;  				entry.Flags = bitFlags;  				entry.DosTime = (uint)dostime;  				entry.ZipFileIndex = (long)i;  				entry.Offset = offset;  				entry.ExternalFileAttributes = (int)externalAttributes;    				if ((bitFlags & 8) == 0) {  					entry.CryptoCheckValue = (byte)(crc >> 24);  				} else {  					entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  				}    				if (extraLen > 0) {  					byte[] extra = new byte[extraLen];  					StreamUtils.ReadFully(baseStream_' extra);  					entry.ExtraData = extra;  				}    				entry.ProcessExtraData(false);    				if (commentLen > 0) {  					StreamUtils.ReadFully(baseStream_' buffer' 0' commentLen);  					entry.Comment = ZipConstants.ConvertToStringExt(bitFlags' buffer' commentLen);  				}    				entries_[i] = entry;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++) {  				if (ReadLEUint() != ZipConstants.CentralHeaderSignature) {  					throw new ZipException("Wrong Central Directory signature");  				}    				int versionMadeBy = ReadLEUshort();  				int versionToExtract = ReadLEUshort();  				int bitFlags = ReadLEUshort();  				int method = ReadLEUshort();  				uint dostime = ReadLEUint();  				uint crc = ReadLEUint();  				var csize = (long)ReadLEUint();  				var size = (long)ReadLEUint();  				int nameLen = ReadLEUshort();  				int extraLen = ReadLEUshort();  				int commentLen = ReadLEUshort();    				int diskStartNo = ReadLEUshort();  // Not currently used  				int internalAttributes = ReadLEUshort();  // Not currently used    				uint externalAttributes = ReadLEUint();  				long offset = ReadLEUint();    				byte[] buffer = new byte[Math.Max(nameLen' commentLen)];    				StreamUtils.ReadFully(baseStream_' buffer' 0' nameLen);  				string name = ZipConstants.ConvertToStringExt(bitFlags' buffer' nameLen);    				var entry = new ZipEntry(name' versionToExtract' versionMadeBy' (CompressionMethod)method);  				entry.Crc = crc & 0xffffffffL;  				entry.Size = size & 0xffffffffL;  				entry.CompressedSize = csize & 0xffffffffL;  				entry.Flags = bitFlags;  				entry.DosTime = (uint)dostime;  				entry.ZipFileIndex = (long)i;  				entry.Offset = offset;  				entry.ExternalFileAttributes = (int)externalAttributes;    				if ((bitFlags & 8) == 0) {  					entry.CryptoCheckValue = (byte)(crc >> 24);  				} else {  					entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  				}    				if (extraLen > 0) {  					byte[] extra = new byte[extraLen];  					StreamUtils.ReadFully(baseStream_' extra);  					entry.ExtraData = extra;  				}    				entry.ProcessExtraData(false);    				if (commentLen > 0) {  					StreamUtils.ReadFully(baseStream_' buffer' 0' commentLen);  					entry.Comment = ZipConstants.ConvertToStringExt(bitFlags' buffer' commentLen);  				}    				entries_[i] = entry;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption)  				|| (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  				var classicManaged = new PkzipClassicManaged();    				OnKeysRequired(entry.Name);  				if (HaveKeys == false) {  					throw new ZipException("No password available for encrypted stream");  				}    				result = new CryptoStream(baseStream' classicManaged.CreateDecryptor(key' null)' CryptoStreamMode.Read);  				CheckClassicPassword(result' entry);  			} else {  				if (entry.Version == ZipConstants.VERSION_AES) {  					//  					OnKeysRequired(entry.Name);  					if (HaveKeys == false) {  						throw new ZipException("No password available for AES encrypted stream");  					}  					int saltLen = entry.AESSaltLen;  					byte[] saltBytes = new byte[saltLen];  					int saltIn = baseStream.Read(saltBytes' 0' saltLen);  					if (saltIn != saltLen)  						throw new ZipException("AES Salt expected " + saltLen + " got " + saltIn);  					//  					byte[] pwdVerifyRead = new byte[2];  					baseStream.Read(pwdVerifyRead' 0' 2);  					int blockSize = entry.AESKeySize / 8;   // bits to bytes    					var decryptor = new ZipAESTransform(rawPassword_' saltBytes' blockSize' false);  					byte[] pwdVerifyCalc = decryptor.PwdVerifier;  					if (pwdVerifyCalc[0] != pwdVerifyRead[0] || pwdVerifyCalc[1] != pwdVerifyRead[1])  						throw new ZipException("Invalid password for AES");  					result = new ZipAESStream(baseStream' decryptor' CryptoStreamMode.Read);  				} else {  					throw new ZipException("Decryption method not supported");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption)  				|| (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  				var classicManaged = new PkzipClassicManaged();    				OnKeysRequired(entry.Name);  				if (HaveKeys == false) {  					throw new ZipException("No password available for encrypted stream");  				}    				result = new CryptoStream(baseStream' classicManaged.CreateDecryptor(key' null)' CryptoStreamMode.Read);  				CheckClassicPassword(result' entry);  			} else {  				if (entry.Version == ZipConstants.VERSION_AES) {  					//  					OnKeysRequired(entry.Name);  					if (HaveKeys == false) {  						throw new ZipException("No password available for AES encrypted stream");  					}  					int saltLen = entry.AESSaltLen;  					byte[] saltBytes = new byte[saltLen];  					int saltIn = baseStream.Read(saltBytes' 0' saltLen);  					if (saltIn != saltLen)  						throw new ZipException("AES Salt expected " + saltLen + " got " + saltIn);  					//  					byte[] pwdVerifyRead = new byte[2];  					baseStream.Read(pwdVerifyRead' 0' 2);  					int blockSize = entry.AESKeySize / 8;   // bits to bytes    					var decryptor = new ZipAESTransform(rawPassword_' saltBytes' blockSize' false);  					byte[] pwdVerifyCalc = decryptor.PwdVerifier;  					if (pwdVerifyCalc[0] != pwdVerifyRead[0] || pwdVerifyCalc[1] != pwdVerifyRead[1])  						throw new ZipException("Invalid password for AES");  					result = new ZipAESStream(baseStream' decryptor' CryptoStreamMode.Read);  				} else {  					throw new ZipException("Decryption method not supported");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitDecryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption)  				|| (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  				var classicManaged = new PkzipClassicManaged();    				OnKeysRequired(entry.Name);  				if (HaveKeys == false) {  					throw new ZipException("No password available for encrypted stream");  				}    				result = new CryptoStream(baseStream' classicManaged.CreateDecryptor(key' null)' CryptoStreamMode.Read);  				CheckClassicPassword(result' entry);  			} else {  				if (entry.Version == ZipConstants.VERSION_AES) {  					//  					OnKeysRequired(entry.Name);  					if (HaveKeys == false) {  						throw new ZipException("No password available for AES encrypted stream");  					}  					int saltLen = entry.AESSaltLen;  					byte[] saltBytes = new byte[saltLen];  					int saltIn = baseStream.Read(saltBytes' 0' saltLen);  					if (saltIn != saltLen)  						throw new ZipException("AES Salt expected " + saltLen + " got " + saltIn);  					//  					byte[] pwdVerifyRead = new byte[2];  					baseStream.Read(pwdVerifyRead' 0' 2);  					int blockSize = entry.AESKeySize / 8;   // bits to bytes    					var decryptor = new ZipAESTransform(rawPassword_' saltBytes' blockSize' false);  					byte[] pwdVerifyCalc = decryptor.PwdVerifier;  					if (pwdVerifyCalc[0] != pwdVerifyRead[0] || pwdVerifyCalc[1] != pwdVerifyRead[1])  						throw new ZipException("Invalid password for AES");  					result = new ZipAESStream(baseStream' decryptor' CryptoStreamMode.Read);  				} else {  					throw new ZipException("Decryption method not supported");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption)  				|| (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  				var classicManaged = new PkzipClassicManaged();    				OnKeysRequired(entry.Name);  				if (HaveKeys == false) {  					throw new ZipException("No password available for encrypted stream");  				}    				// Closing a CryptoStream will close the base stream as well so wrap it in an UncompressedStream  				// which doesnt do this.  				result = new CryptoStream(new UncompressedStream(baseStream)'  					classicManaged.CreateEncryptor(key' null)' CryptoStreamMode.Write);    				if ((entry.Crc < 0) || (entry.Flags & 8) != 0) {  					WriteEncryptionHeader(result' entry.DosTime << 16);  				} else {  					WriteEncryptionHeader(result' entry.Crc);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ((entry.Version < ZipConstants.VersionStrongEncryption)  				|| (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  				var classicManaged = new PkzipClassicManaged();    				OnKeysRequired(entry.Name);  				if (HaveKeys == false) {  					throw new ZipException("No password available for encrypted stream");  				}    				// Closing a CryptoStream will close the base stream as well so wrap it in an UncompressedStream  				// which doesnt do this.  				result = new CryptoStream(new UncompressedStream(baseStream)'  					classicManaged.CreateEncryptor(key' null)' CryptoStreamMode.Write);    				if ((entry.Crc < 0) || (entry.Flags & 8) != 0) {  					WriteEncryptionHeader(result' entry.DosTime << 16);  				} else {  					WriteEncryptionHeader(result' entry.Crc);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer[11] = (byte)(crcValue >> 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer[11] = (byte)(crcValue >> 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,MakeTemporaryCopy,The following statement contains a magic number: StreamUtils.Copy(stream' temporaryStream_' new byte[4096]);
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,OpenForDirectUpdate,The following statement contains a magic number: if ((stream == null) || !stream.CanWrite) {    				result = new MemoryStream();    				if (stream != null) {  					stream.Position = 0;  					StreamUtils.Copy(stream' result' new byte[4096]);    					stream.Dispose();  				}  			} else {  				result = stream;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteZip64EndOfCentralDirectory,The following statement contains a magic number: WriteLELong(44);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,ReadLEShort,The following statement contains a magic number: return byteValue1 | (byteValue2 << 8);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,ReadLEInt,The following statement contains a magic number: return ReadLEShort() | (ReadLEShort() << 16);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,ReadLELong,The following statement contains a magic number: return (uint)ReadLEInt() | ((long)ReadLEInt() << 32);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteLEShort,The following statement contains a magic number: stream_.WriteByte((byte)((value >> 8) & 0xff));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteLEUshort,The following statement contains a magic number: stream_.WriteByte((byte)(value >> 8));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteLEInt,The following statement contains a magic number: WriteLEShort(value >> 16);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteLEUint,The following statement contains a magic number: WriteLEUshort((ushort)(value >> 16));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteLELong,The following statement contains a magic number: WriteLEInt((int)(value >> 32));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteLEUlong,The following statement contains a magic number: WriteLEUint((uint)(value >> 32));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  				// The signature is not PKZIP originally but is now described as optional  				// in the PKZIP Appnote documenting trhe format.  				WriteLEInt(ZipConstants.DataDescriptorSignature);  				WriteLEInt(unchecked((int)(entry.Crc)));    				result += 8;    				if (entry.LocalHeaderRequiresZip64) {  					WriteLELong(entry.CompressedSize);  					WriteLELong(entry.Size);  					result += 16;  				} else {  					WriteLEInt((int)entry.CompressedSize);  					WriteLEInt((int)entry.Size);  					result += 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  				// The signature is not PKZIP originally but is now described as optional  				// in the PKZIP Appnote documenting trhe format.  				WriteLEInt(ZipConstants.DataDescriptorSignature);  				WriteLEInt(unchecked((int)(entry.Crc)));    				result += 8;    				if (entry.LocalHeaderRequiresZip64) {  					WriteLELong(entry.CompressedSize);  					WriteLELong(entry.Size);  					result += 16;  				} else {  					WriteLEInt((int)entry.CompressedSize);  					WriteLEInt((int)entry.Size);  					result += 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  				// The signature is not PKZIP originally but is now described as optional  				// in the PKZIP Appnote documenting trhe format.  				WriteLEInt(ZipConstants.DataDescriptorSignature);  				WriteLEInt(unchecked((int)(entry.Crc)));    				result += 8;    				if (entry.LocalHeaderRequiresZip64) {  					WriteLELong(entry.CompressedSize);  					WriteLELong(entry.Size);  					result += 16;  				} else {  					WriteLEInt((int)entry.CompressedSize);  					WriteLEInt((int)entry.Size);  					result += 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0) {  				entry.Crc = crc2 & 0xFFFFFFFFL;  				entry.Size = size & 0xFFFFFFFFL;  				entry.CompressedSize = csize & 0xFFFFFFFFL;    				entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);    			} else {    				// This allows for GNU' WinZip and possibly other archives' the PKZIP spec  				// says these values are zero under these circumstances.  				if (crc2 != 0) {  					entry.Crc = crc2 & 0xFFFFFFFFL;  				}    				if (size != 0) {  					entry.Size = size & 0xFFFFFFFFL;  				}    				if (csize != 0) {  					entry.CompressedSize = csize & 0xFFFFFFFFL;  				}    				entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0) {  				entry.Crc = crc2 & 0xFFFFFFFFL;  				entry.Size = size & 0xFFFFFFFFL;  				entry.CompressedSize = csize & 0xFFFFFFFFL;    				entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);    			} else {    				// This allows for GNU' WinZip and possibly other archives' the PKZIP spec  				// says these values are zero under these circumstances.  				if (crc2 != 0) {  					entry.Crc = crc2 & 0xFFFFFFFFL;  				}    				if (size != 0) {  					entry.Size = size & 0xFFFFFFFFL;  				}    				if (csize != 0) {  					entry.CompressedSize = csize & 0xFFFFFFFFL;  				}    				entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0) {  				entry.Crc = crc2 & 0xFFFFFFFFL;  				entry.Size = size & 0xFFFFFFFFL;  				entry.CompressedSize = csize & 0xFFFFFFFFL;    				entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);    			} else {    				// This allows for GNU' WinZip and possibly other archives' the PKZIP spec  				// says these values are zero under these circumstances.  				if (crc2 != 0) {  					entry.Crc = crc2 & 0xFFFFFFFFL;  				}    				if (size != 0) {  					entry.Size = size & 0xFFFFFFFFL;  				}    				if (csize != 0) {  					entry.CompressedSize = csize & 0xFFFFFFFFL;  				}    				entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,CompleteCloseEntry,The following statement contains a magic number: if ((flags & 8) != 0) {  				ReadDataDescriptor();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if (method == (int)CompressionMethod.Deflated) {  				if ((flags & 8) != 0) {  					// We don't know how much we must skip' read until end.  					byte[] tmp = new byte[4096];    					// Read will close this entry  					while (Read(tmp' 0' tmp.Length) > 0) {  					}  					return;  				}    				csize -= inf.TotalIn;  				inputBuffer.Available += inf.RemainingInput;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if (method == (int)CompressionMethod.Deflated) {  				if ((flags & 8) != 0) {  					// We don't know how much we must skip' read until end.  					byte[] tmp = new byte[4096];    					// Read will close this entry  					while (Read(tmp' 0' tmp.Length) > 0) {  					}  					return;  				}    				csize -= inf.TotalIn;  				inputBuffer.Available += inf.RemainingInput;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,BodyRead,The following statement contains a magic number: switch (method) {  				case (int)CompressionMethod.Deflated:  					count = base.Read(buffer' offset' count);  					if (count <= 0) {  						if (!inf.IsFinished) {  							throw new ZipException("Inflater not finished!");  						}  						inputBuffer.Available = inf.RemainingInput;    						// A csize of -1 is from an unpatched local header  						if ((flags & 8) == 0 &&  							(inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)) {  							throw new ZipException("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);  						}  						inf.Reset();  						finished = true;  					}  					break;    				case (int)CompressionMethod.Stored:  					if ((count > csize) && (csize >= 0)) {  						count = (int)csize;  					}    					if (count > 0) {  						count = inputBuffer.ReadClearTextBuffer(buffer' offset' count);  						if (count > 0) {  							csize -= count;  							size -= count;  						}  					}    					if (csize == 0) {  						finished = true;  					} else {  						if (count < 0) {  							throw new ZipException("EOF in stored block");  						}  					}  					break;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: int howMany = invalidPathChars.Length + 2;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryCharsRelaxed[howMany - 2] = '?';
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: howMany = invalidPathChars.Length + 4;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars[howMany - 2] = '\\';
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars[howMany - 3] = '*';
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars[howMany - 4] = '?';
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,WriteLeShort,The following statement contains a magic number: unchecked {  				baseOutputStream_.WriteByte((byte)(value & 0xff));  				baseOutputStream_.WriteByte((byte)((value >> 8) & 0xff));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,WriteLeInt,The following statement contains a magic number: unchecked {  				WriteLeShort(value);  				WriteLeShort(value >> 16);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,WriteLeLong,The following statement contains a magic number: unchecked {  				WriteLeInt((int)value);  				WriteLeInt((int)(value >> 32));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (headerInfoAvailable == false) {  				if (CanPatchEntries == false) {  					// Only way to record size and compressed size is to append a data descriptor  					// after compressed data.    					// Stored entries of this form have already been converted to deflating.  					entry.Flags |= 8;  				} else {  					patchEntryHeader = true;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (Password != null) {  				entry.IsCrypted = true;  				if (entry.Crc < 0) {  					// Need to append a data descriptor as the crc isnt available for use  					// with encryption' the date is used instead.  Setting the flag  					// indicates this to the decompressor.  					entry.Flags |= 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (entry.IsCrypted) {  				if (entry.AESKeySize > 0) {  					WriteAESHeader(entry);  				} else {  					if (entry.Crc < 0) {            // so testing Zip will says its ok  						WriteEncryptionHeader(entry.DosTime << 16);  					} else {  						WriteEncryptionHeader(entry.Crc);  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,CloseEntry,The following statement contains a magic number: if (curEntry.AESKeySize > 0) {  				baseOutputStream_.Write(AESAuthCode' 0' 10);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,CloseEntry,The following statement contains a magic number: if ((curEntry.Flags & 8) != 0) {  				WriteLeInt(ZipConstants.DataDescriptorSignature);  				WriteLeInt(unchecked((int)curEntry.Crc));    				if (curEntry.LocalHeaderRequiresZip64) {  					WriteLeLong(curEntry.CompressedSize);  					WriteLeLong(curEntry.Size);  					offset += ZipConstants.Zip64DataDescriptorSize;  				} else {  					WriteLeInt((int)curEntry.CompressedSize);  					WriteLeInt((int)curEntry.Size);  					offset += ZipConstants.DataDescriptorSize;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer[11] = (byte)(crcValue >> 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer[11] = (byte)(crcValue >> 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,AddExtraDataAES,The following statement contains a magic number: const int VENDOR_VERSION = 2;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,CopyAndEncrypt,The following statement contains a magic number: const int CopyBufferSize = 4096;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,Finish,The following statement contains a magic number: foreach (ZipEntry entry in entries) {  				WriteLeInt(ZipConstants.CentralHeaderSignature);  				WriteLeShort(ZipConstants.VersionMadeBy);  				WriteLeShort(entry.Version);  				WriteLeShort(entry.Flags);  				WriteLeShort((short)entry.CompressionMethodForHeader);  				WriteLeInt((int)entry.DosTime);  				WriteLeInt((int)entry.Crc);    				if (entry.IsZip64Forced() ||  					(entry.CompressedSize >= uint.MaxValue)) {  					WriteLeInt(-1);  				} else {  					WriteLeInt((int)entry.CompressedSize);  				}    				if (entry.IsZip64Forced() ||  					(entry.Size >= uint.MaxValue)) {  					WriteLeInt(-1);  				} else {  					WriteLeInt((int)entry.Size);  				}    				byte[] name = ZipConstants.ConvertToArray(entry.Flags' entry.Name);    				if (name.Length > 0xffff) {  					throw new ZipException("Name too long.");  				}    				var ed = new ZipExtraData(entry.ExtraData);    				if (entry.CentralHeaderRequiresZip64) {  					ed.StartNewEntry();  					if (entry.IsZip64Forced() ||  						(entry.Size >= 0xffffffff)) {  						ed.AddLeLong(entry.Size);  					}    					if (entry.IsZip64Forced() ||  						(entry.CompressedSize >= 0xffffffff)) {  						ed.AddLeLong(entry.CompressedSize);  					}    					if (entry.Offset >= 0xffffffff) {  						ed.AddLeLong(entry.Offset);  					}    					ed.AddNewEntry(1);  				} else {  					ed.Delete(1);  				}    				if (entry.AESKeySize > 0) {  					AddExtraDataAES(entry' ed);  				}  				byte[] extra = ed.GetEntryData();    				byte[] entryComment =  					(entry.Comment != null) ?  					ZipConstants.ConvertToArray(entry.Flags' entry.Comment) :  					new byte[0];    				if (entryComment.Length > 0xffff) {  					throw new ZipException("Comment too long.");  				}    				WriteLeShort(name.Length);  				WriteLeShort(extra.Length);  				WriteLeShort(entryComment.Length);  				WriteLeShort(0);    // disk number  				WriteLeShort(0);    // internal file attributes  									// external file attributes    				if (entry.ExternalFileAttributes != -1) {  					WriteLeInt(entry.ExternalFileAttributes);  				} else {  					if (entry.IsDirectory) {                         // mark entry as directory (from nikolam.AT.perfectinfo.com)  						WriteLeInt(16);  					} else {  						WriteLeInt(0);  					}  				}    				if (entry.Offset >= uint.MaxValue) {  					WriteLeInt(-1);  				} else {  					WriteLeInt((int)entry.Offset);  				}    				if (name.Length > 0) {  					baseOutputStream_.Write(name' 0' name.Length);  				}    				if (extra.Length > 0) {  					baseOutputStream_.Write(extra' 0' extra.Length);  				}    				if (entryComment.Length > 0) {  					baseOutputStream_.Write(entryComment' 0' entryComment.Length);  				}    				sizeEntries += ZipConstants.CentralHeaderBaseSize + name.Length + extra.Length + entryComment.Length;  			}
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 24)' (13' 32)' (21' 40)' (29' 48))
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 39)' (13' 47))
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 24)' (21' 40)' (29' 48))
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((57' 88)' (70' 101))
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((57' 76)' (83' 102))
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The method contains a code clone-set at the following line numbers (starting from the method definition): ((42' 61)' (70' 89))
Missing Default,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2InputStream.cs,ReadByte,The following switch statement is missing a default case: switch (currentState) {  				case RAND_PART_B_STATE:  					SetupRandPartB();  					break;  				case RAND_PART_C_STATE:  					SetupRandPartC();  					break;  				case NO_RAND_PART_B_STATE:  					SetupNoRandPartB();  					break;  				case NO_RAND_PART_C_STATE:  					SetupNoRandPartC();  					break;  				case START_BLOCK_STATE:  				case NO_RAND_PART_A_STATE:  				case RAND_PART_A_STATE:  					break;  			}
Missing Default,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following switch statement is missing a default case: switch (zPend % 2) {  							case 0:  								szptr[wr] = (short)BZip2Constants.RunA;  								wr++;  								mtfFreq[BZip2Constants.RunA]++;  								break;  							case 1:  								szptr[wr] = (short)BZip2Constants.RunB;  								wr++;  								mtfFreq[BZip2Constants.RunB]++;  								break;  							}
Missing Default,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following switch statement is missing a default case: switch (zPend % 2) {  					case 0:  						szptr[wr] = (short)BZip2Constants.RunA;  						wr++;  						mtfFreq[BZip2Constants.RunA]++;  						break;  					case 1:  						szptr[wr] = (short)BZip2Constants.RunB;  						wr++;  						mtfFreq[BZip2Constants.RunB]++;  						break;  					}
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following switch statement is missing a default case: switch (state) {  						case BUSY_STATE:  							// We need more input now  							return origLength - length;  						case FLUSHING_STATE:  							if (level != NO_COMPRESSION) {  								/* We have to supply some lookahead.  8 bit lookahead  								 * is needed by the zlib inflater' and we must fill  								 * the next byte' so that all bits are flushed.  								 */  								int neededbits = 8 + ((-pending.BitCount) & 7);  								while (neededbits > 0) {  									/* write a static tree block consisting solely of  									 * an EOF:  									 */  									pending.WriteBits(2' 10);  									neededbits -= 10;  								}  							}  							state = BUSY_STATE;  							break;  						case FINISHING_STATE:  							pending.AlignToByte();    							// Compressed data is complete.  Write footer information if required.  							if (!noZlibHeaderOrFooter) {  								int adler = engine.Adler;  								pending.WriteShortMSB(adler >> 16);  								pending.WriteShortMSB(adler & 0xffff);  							}  							state = FINISHED_STATE;  							break;  					}
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,SetLevel,The following switch statement is missing a default case: switch (compressionFunction) {  					case DeflaterConstants.DEFLATE_STORED:  						if (strstart > blockStart) {  							huffman.FlushStoredBlock(window' blockStart'  								strstart - blockStart' false);  							blockStart = strstart;  						}  						UpdateHash();  						break;    					case DeflaterConstants.DEFLATE_FAST:  						if (strstart > blockStart) {  							huffman.FlushBlock(window' blockStart' strstart - blockStart'  								false);  							blockStart = strstart;  						}  						break;    					case DeflaterConstants.DEFLATE_SLOW:  						if (prevAvailable) {  							huffman.TallyLit(window[strstart - 1] & 0xff);  						}  						if (strstart > blockStart) {  							huffman.FlushBlock(window' blockStart' strstart - blockStart' false);  							blockStart = strstart;  						}  						prevAvailable = false;  						matchLen = DeflaterConstants.MIN_MATCH - 1;  						break;  				}
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following switch statement is missing a default case: switch( (scanMax - scan) % 8 )              {              case 1: if (window[++scan] == window[++match]) break;                break;              case 2: if (window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 3: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 4: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 5: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 6: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              case 7: if (window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]                && window[++scan] == window[++match]) break;                break;              }
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following switch statement is missing a default case: switch (mode) {  					case LNUM:  						lnum = input.PeekBits(5);  						if (lnum < 0) {  							return false;  						}  						lnum += 257;  						input.DropBits(5);  						//  	    System.err.println("LNUM: "+lnum);  						mode = DNUM;  						goto case DNUM; // fall through  					case DNUM:  						dnum = input.PeekBits(5);  						if (dnum < 0) {  							return false;  						}  						dnum++;  						input.DropBits(5);  						//  	    System.err.println("DNUM: "+dnum);  						num = lnum + dnum;  						litdistLens = new byte[num];  						mode = BLNUM;  						goto case BLNUM; // fall through  					case BLNUM:  						blnum = input.PeekBits(4);  						if (blnum < 0) {  							return false;  						}  						blnum += 4;  						input.DropBits(4);  						blLens = new byte[19];  						ptr = 0;  						//  	    System.err.println("BLNUM: "+blnum);  						mode = BLLENS;  						goto case BLLENS; // fall through  					case BLLENS:  						while (ptr < blnum) {  							int len = input.PeekBits(3);  							if (len < 0) {  								return false;  							}  							input.DropBits(3);  							//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  							blLens[BL_ORDER[ptr]] = (byte)len;  							ptr++;  						}  						blTree = new InflaterHuffmanTree(blLens);  						blLens = null;  						ptr = 0;  						mode = LENS;  						goto case LENS; // fall through  					case LENS: {  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */    								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;    								if (ptr == num) {  									/* Finished */  									return true;  								}  							}    							/* need more input ? */  							if (symbol < 0) {  								return false;  							}    							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol - 16;  						}  						mode = REPS;  						goto case REPS; // fall through  					case REPS: {  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);    							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}    							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  				}
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,WriteLocalEntryHeader,The following switch statement is missing a default case: switch (useZip64_) {  					case UseZip64.Dynamic:  						if (entry.Size < 0) {  							entry.ForceZip64();  						}  						break;    					case UseZip64.On:  						entry.ForceZip64();  						break;    					case UseZip64.Off:  						// Do nothing.  The entry itself may be using Zip64 independantly.  						break;  				}
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,RunUpdates,The following switch statement is missing a default case: switch (update.Command) {  							case UpdateCommand.Copy:  								if (directUpdate) {  									CopyEntryDirect(workFile' update' ref destinationPosition);  								} else {  									CopyEntry(workFile' update);  								}  								break;    							case UpdateCommand.Modify:  								// TODO: Direct modifying of an entry will take some legwork.  								ModifyEntry(workFile' update);  								break;    							case UpdateCommand.Add:  								if (!IsNewArchive && directUpdate) {  									workFile.baseStream_.Position = destinationPosition;  								}    								AddEntry(workFile' update);    								if (directUpdate) {  									destinationPosition = workFile.baseStream_.Position;  								}  								break;  						}
Missing Default,ICSharpCode.SharpZipLib.Zip,PartialInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipFile.cs,Seek,The following switch statement is missing a default case: switch (origin) {  					case SeekOrigin.Begin:  						newPos = start_ + offset;  						break;    					case SeekOrigin.Current:  						newPos = readPos_ + offset;  						break;    					case SeekOrigin.End:  						newPos = end_ + offset;  						break;  				}
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipInputStream.cs,BodyRead,The following switch statement is missing a default case: switch (method) {  				case (int)CompressionMethod.Deflated:  					count = base.Read(buffer' offset' count);  					if (count <= 0) {  						if (!inf.IsFinished) {  							throw new ZipException("Inflater not finished!");  						}  						inputBuffer.Available = inf.RemainingInput;    						// A csize of -1 is from an unpatched local header  						if ((flags & 8) == 0 &&  							(inf.TotalIn != csize && csize != 0xFFFFFFFF && csize != -1 || inf.TotalOut != size)) {  							throw new ZipException("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);  						}  						inf.Reset();  						finished = true;  					}  					break;    				case (int)CompressionMethod.Stored:  					if ((count > csize) && (csize >= 0)) {  						count = (int)csize;  					}    					if (count > 0) {  						count = inputBuffer.ReadClearTextBuffer(buffer' offset' count);  						if (count > 0) {  							csize -= count;  							size -= count;  						}  					}    					if (csize == 0) {  						finished = true;  					} else {  						if (count < 0) {  							throw new ZipException("EOF in stored block");  						}  					}  					break;  			}
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\icsharpcode_SharpZipLib\src\ICSharpCode.SharpZipLib\Zip\ZipOutputStream.cs,Write,The following switch statement is missing a default case: switch (curMethod) {  				case CompressionMethod.Deflated:  					base.Write(buffer' offset' count);  					break;    				case CompressionMethod.Stored:  					if (Password != null) {  						CopyAndEncrypt(buffer' offset' count);  					} else {  						baseOutputStream_.Write(buffer' offset' count);  					}  					break;  			}
