Implementation smell,Namespace,Class,File,Method,Description
Long Method,jabber.connection,XmppStream,C:\repos\meebey_jabber-net\jabber\connection\XmppStream.cs,OnElement,The method has 125 lines of code.
Long Method,bedrock.net,HttpSocket,C:\repos\meebey_jabber-net\bedrock\net\HttpSocket.cs,OnRead,The method has 103 lines of code.
Long Method,bedrock.net,XEP25Socket,C:\repos\meebey_jabber-net\bedrock\net\XEP25Socket.cs,PollThread,The method has 137 lines of code.
Long Method,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,Push,The method has 100 lines of code.
Long Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The method has 121 lines of code.
Long Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The method has 212 lines of code.
Long Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The method has 138 lines of code.
Long Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The method has 232 lines of code.
Complex Method,bedrock.collections,Set,C:\repos\meebey_jabber-net\bedrock\collections\Set.cs,Set,Cyclomatic complexity of the method is 11
Complex Method,bedrock.collections,SkipList,C:\repos\meebey_jabber-net\bedrock\collections\SkipList.cs,Add,Cyclomatic complexity of the method is 8
Complex Method,bedrock.collections,Tree,C:\repos\meebey_jabber-net\bedrock\collections\Tree.cs,Add,Cyclomatic complexity of the method is 8
Complex Method,bedrock.collections,Tree,C:\repos\meebey_jabber-net\bedrock\collections\Tree.cs,Remove,Cyclomatic complexity of the method is 12
Complex Method,bedrock.collections,Tree,C:\repos\meebey_jabber-net\bedrock\collections\Tree.cs,swapPosition,Cyclomatic complexity of the method is 15
Complex Method,bedrock.collections,Tree,C:\repos\meebey_jabber-net\bedrock\collections\Tree.cs,fixAfterInsertion,Cyclomatic complexity of the method is 9
Complex Method,bedrock.collections,Tree,C:\repos\meebey_jabber-net\bedrock\collections\Tree.cs,fixAfterDeletion,Cyclomatic complexity of the method is 9
Complex Method,jabber.client,JabberClient,C:\repos\meebey_jabber-net\jabber\client\JabberClient.cs,Presence,Cyclomatic complexity of the method is 8
Complex Method,jabber.client,JabberClient,C:\repos\meebey_jabber-net\jabber\client\JabberClient.cs,OnGetRegister,Cyclomatic complexity of the method is 17
Complex Method,jabber.client,JabberClient,C:\repos\meebey_jabber-net\jabber\client\JabberClient.cs,OnGetAuth,Cyclomatic complexity of the method is 8
Complex Method,jabber.client,JabberClient,C:\repos\meebey_jabber-net\jabber\client\JabberClient.cs,OnElement,Cyclomatic complexity of the method is 9
Complex Method,jabber.client,RosterManager,C:\repos\meebey_jabber-net\jabber\client\RosterManager.cs,cli_OnPresence,Cyclomatic complexity of the method is 18
Complex Method,jabber.connection,CapsManager,C:\repos\meebey_jabber-net\jabber\connection\CapsManager.cs,CalculateVer,Cyclomatic complexity of the method is 10
Complex Method,jabber.connection,Room,C:\repos\meebey_jabber-net\jabber\connection\ConferenceManager.cs,m_stream_OnProtocol,Cyclomatic complexity of the method is 45
Complex Method,jabber.connection,DiscoManager,C:\repos\meebey_jabber-net\jabber\connection\DiscoManager.cs,GotAgents,Cyclomatic complexity of the method is 30
Complex Method,jabber.connection,PubSubManager,C:\repos\meebey_jabber-net\jabber\connection\PubSubManager.cs,OnDefaults,Cyclomatic complexity of the method is 9
Complex Method,jabber.connection,PubSubNode,C:\repos\meebey_jabber-net\jabber\connection\PubSubManager.cs,GotCreated,Cyclomatic complexity of the method is 8
Complex Method,jabber.connection,PubSubNode,C:\repos\meebey_jabber-net\jabber\connection\PubSubManager.cs,GotSubscribed,Cyclomatic complexity of the method is 12
Complex Method,jabber.connection,PubSubNode,C:\repos\meebey_jabber-net\jabber\connection\PubSubManager.cs,OnConfigure,Cyclomatic complexity of the method is 9
Complex Method,jabber.connection,XmppStream,C:\repos\meebey_jabber-net\jabber\connection\XmppStream.cs,ProcessFeatures,Cyclomatic complexity of the method is 14
Complex Method,jabber.connection,XmppStream,C:\repos\meebey_jabber-net\jabber\connection\XmppStream.cs,OnElement,Cyclomatic complexity of the method is 31
Complex Method,jabber.connection,SocketStanzaStream,C:\repos\meebey_jabber-net\jabber\connection\SocketStanzaStream.cs,Connect,Cyclomatic complexity of the method is 18
Complex Method,bedrock.net,AsyncSocket,C:\repos\meebey_jabber-net\bedrock\net\AsyncSocket.cs,ChooseClientCertificate,Cyclomatic complexity of the method is 10
Complex Method,bedrock.net,HttpSocket,C:\repos\meebey_jabber-net\bedrock\net\HttpSocket.cs,OnRead,Cyclomatic complexity of the method is 54
Complex Method,bedrock.net,ShttpProxy,C:\repos\meebey_jabber-net\bedrock\net\ShttpProxy.cs,OnRead,Cyclomatic complexity of the method is 25
Complex Method,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,HandleGetMethodsResponse,Cyclomatic complexity of the method is 17
Complex Method,bedrock.net,XEP124Socket,C:\repos\meebey_jabber-net\bedrock\net\XEP124Socket.cs,OnRead,Cyclomatic complexity of the method is 11
Complex Method,bedrock.net,XEP25Socket,C:\repos\meebey_jabber-net\bedrock\net\XEP25Socket.cs,PollThread,Cyclomatic complexity of the method is 29
Complex Method,bedrock.util,GetOpt,C:\repos\meebey_jabber-net\bedrock\util\GetOptBase.cs,Process,Cyclomatic complexity of the method is 11
Complex Method,bedrock.util,GetOpt,C:\repos\meebey_jabber-net\bedrock\util\GetOptBase.cs,SetValue,Cyclomatic complexity of the method is 10
Complex Method,bedrock.util,GetOpt,C:\repos\meebey_jabber-net\bedrock\util\GetOptBase.cs,GetValue,Cyclomatic complexity of the method is 10
Complex Method,bedrock.util,GetOpt,C:\repos\meebey_jabber-net\bedrock\util\GetOptBase.cs,GetMemberType,Cyclomatic complexity of the method is 13
Complex Method,bedrock.util,IdleTime,C:\repos\meebey_jabber-net\bedrock\util\IdleTime.cs,m_timer_Elapsed,Cyclomatic complexity of the method is 8
Complex Method,jabber.connection.sasl,MD5Processor,C:\repos\meebey_jabber-net\jabber\connection\sasl\MD5Processor.cs,validateStartDirectives,Cyclomatic complexity of the method is 8
Complex Method,jabber,JID,C:\repos\meebey_jabber-net\jabber\JID.cs,parse,Cyclomatic complexity of the method is 12
Complex Method,jabber,JID,C:\repos\meebey_jabber-net\jabber\JID.cs,Escape,Cyclomatic complexity of the method is 36
Complex Method,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,Push,Cyclomatic complexity of the method is 44
Complex Method,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,StartTag,Cyclomatic complexity of the method is 10
Complex Method,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,CloneNode,Cyclomatic complexity of the method is 10
Complex Method,jabber.protocol.iq,PubSubIQ,C:\repos\meebey_jabber-net\jabber\protocol\iq\PubSub.cs,PubSubIQ,Cyclomatic complexity of the method is 27
Complex Method,jabber.protocol.stream,Mechanism,C:\repos\meebey_jabber-net\jabber\protocol\stream\SASL.cs,GetMechanismType,Cyclomatic complexity of the method is 23
Complex Method,jabber.protocol.stream,Mechanism,C:\repos\meebey_jabber-net\jabber\protocol\stream\SASL.cs,GetMechanism,Cyclomatic complexity of the method is 23
Complex Method,jabber.server,JabberService,C:\repos\meebey_jabber-net\jabber\server\JabberService.cs,OnElement,Cyclomatic complexity of the method is 10
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,Cyclomatic complexity of the method is 33
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanDecl,Cyclomatic complexity of the method is 23
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,targetIsXml,Cyclomatic complexity of the method is 17
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,Cyclomatic complexity of the method is 70
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeCdataSection,Cyclomatic complexity of the method is 47
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,Cyclomatic complexity of the method is 24
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,Cyclomatic complexity of the method is 72
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,Cyclomatic complexity of the method is 64
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanCharRef,Cyclomatic complexity of the method is 33
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,Cyclomatic complexity of the method is 17
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,Cyclomatic complexity of the method is 59
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,Cyclomatic complexity of the method is 153
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,Cyclomatic complexity of the method is 109
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeContent,Cyclomatic complexity of the method is 49
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,Cyclomatic complexity of the method is 26
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,Cyclomatic complexity of the method is 63
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,Cyclomatic complexity of the method is 63
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,Cyclomatic complexity of the method is 33
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,Cyclomatic complexity of the method is 10
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,Cyclomatic complexity of the method is 135
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,Cyclomatic complexity of the method is 40
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,Cyclomatic complexity of the method is 37
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,Cyclomatic complexity of the method is 54
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getPublicId,Cyclomatic complexity of the method is 35
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipS,Cyclomatic complexity of the method is 8
Complex Method,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,Encoding,Cyclomatic complexity of the method is 14
Complex Method,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,Cyclomatic complexity of the method is 20
Complex Method,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,Cyclomatic complexity of the method is 26
Long Parameter List,bedrock.io,ReadEventStream,C:\repos\meebey_jabber-net\bedrock\io\ReadEventStream.cs,BeginRead,The method has 5 parameters.
Long Parameter List,bedrock.io,ReadEventStream,C:\repos\meebey_jabber-net\bedrock\io\ReadEventStream.cs,BeginWrite,The method has 5 parameters.
Long Parameter List,jabber.connection,DiscoManager,C:\repos\meebey_jabber-net\jabber\connection\DiscoManager.cs,BeginGetFeatures,The method has 5 parameters.
Long Parameter List,jabber.connection,DiscoManager,C:\repos\meebey_jabber-net\jabber\connection\DiscoManager.cs,BeginGetItems,The method has 5 parameters.
Long Parameter List,bedrock.net,AsyncSocket,C:\repos\meebey_jabber-net\bedrock\net\AsyncSocket.cs,ChooseClientCertificate,The method has 5 parameters.
Long Parameter List,bedrock.net,HttpSocket,C:\repos\meebey_jabber-net\bedrock\net\HttpSocket.cs,Execute,The method has 6 parameters.
Long Parameter List,bedrock.net,HttpSocket,C:\repos\meebey_jabber-net\bedrock\net\HttpSocket.cs,ParseAt,The method has 5 parameters.
Long Parameter List,jabber.connection.sasl,SSPIHelper,C:\repos\meebey_jabber-net\jabber\connection\sasl\KerbProcessor.cs,AcquireCredentialsHandle,The method has 9 parameters.
Long Parameter List,jabber.connection.sasl,SSPIHelper,C:\repos\meebey_jabber-net\jabber\connection\sasl\KerbProcessor.cs,AcquireCredentialsHandle,The method has 9 parameters.
Long Parameter List,jabber.connection.sasl,SSPIHelper,C:\repos\meebey_jabber-net\jabber\connection\sasl\KerbProcessor.cs,InitializeSecurityContext,The method has 12 parameters.
Long Parameter List,jabber.connection.sasl,SSPIHelper,C:\repos\meebey_jabber-net\jabber\connection\sasl\KerbProcessor.cs,InitializeSecurityContext,The method has 12 parameters.
Long Parameter List,jabber.protocol.x,Data,C:\repos\meebey_jabber-net\jabber\protocol\x\Data.cs,AddField,The method has 5 parameters.
Long Parameter List,jabber.server,XdbTracker,C:\repos\meebey_jabber-net\jabber\server\XdbTracker.cs,BeginXdbSet,The method has 5 parameters.
Long Parameter List,jabber.server,XdbTracker,C:\repos\meebey_jabber-net\jabber\server\XdbTracker.cs,BeginXdb,The method has 6 parameters.
Long Parameter List,jabber.server,XdbTracker,C:\repos\meebey_jabber-net\jabber\server\XdbTracker.cs,BeginXdb,The method has 7 parameters.
Long Parameter List,xpnet,ContentToken,C:\repos\meebey_jabber-net\xpnet\ContentToken.cs,appendAttribute,The method has 5 parameters.
Long Parameter List,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,convert,The method has 5 parameters.
Long Parameter List,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The method has 5 parameters.
Long Parameter List,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The method has 5 parameters.
Long Parameter List,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The method has 5 parameters.
Long Statement,bedrock.collections,TrieNode,C:\repos\meebey_jabber-net\bedrock\collections\TrieNode.cs,Equals,The length of the statement  "	return ((Key == null) ? (e.Key == null) : Key.Equals (e.Key)) && ((Value == null) ? (e.Value == null) : Value.Equals (e.Value)); " is 128.
Long Statement,jabber.client,PresenceManager,C:\repos\meebey_jabber-net\jabber\client\PresenceManager.cs,AddPresence,The length of the statement  "	Debug.Assert (p.GetAttribute ("from") != ""' "Do not call AddPresence by hand.  I can tell you are doing that because you didn't put a from address on your presence packet' and all presences from the server have a from address."); " is 230.
Long Statement,jabber.client,RosterManager,C:\repos\meebey_jabber-net\jabber\client\RosterManager.cs,GotIQ,The length of the statement  "	if ((iq.Query == null) || (iq.Query.NamespaceURI != jabber.protocol.URI.ROSTER) || ((iq.Type != IQType.result) && (iq.Type != IQType.set))) " is 139.
Long Statement,jabber.connection,HttpStanzaStream,C:\repos\meebey_jabber-net\jabber\connection\HttpStanzaStream.cs,Accept,The length of the statement  "	s.LocalCertificate = m_listener [Options.LOCAL_CERTIFICATE] as System.Security.Cryptography.X509Certificates.X509Certificate2; " is 126.
Long Statement,jabber.connection,XmppStream,C:\repos\meebey_jabber-net\jabber\connection\XmppStream.cs,TryReconnect,The length of the statement  "		m_reconnectTimer = new System.Threading.Timer (new System.Threading.TimerCallback (Reconnect)' null' (int)this [Options.RECONNECT_TIMEOUT]' System.Threading.Timeout.Infinite); " is 175.
Long Statement,jabber.connection,XmppStream,C:\repos\meebey_jabber-net\jabber\connection\XmppStream.cs,ProcessFeatures,The length of the statement  "	if ((bool)this [Options.AUTO_COMPRESS] && (comp != null) && comp.HasMethod ("zlib") && (!m_compressionOn) && m_stanzas.SupportsCompression) { " is 141.
Long Statement,jabber.connection,XmppStream,C:\repos\meebey_jabber-net\jabber\connection\XmppStream.cs,FireOnError,The length of the statement  "	if (((State == ClosingState.Instance) || (State == ClosedState.Instance)) && ((e is System.IO.IOException) || (e.InnerException is System.IO.IOException))) " is 155.
Long Statement,jabber.connection,XmppStream,C:\repos\meebey_jabber-net\jabber\connection\XmppStream.cs,OnInvalidCertificate,The length of the statement  "	return (bool)m_invoker.Invoke (new System.Net.Security.RemoteCertificateValidationCallback (ShowCertificatePrompt)' new object[] { " is 130.
Long Statement,jabber.connection,SocketStanzaStream,C:\repos\meebey_jabber-net\jabber\connection\SocketStanzaStream.cs,Connect,The length of the statement  "		((AsyncSocket)m_sock).LocalCertificate = m_listener [Options.LOCAL_CERTIFICATE] as System.Security.Cryptography.X509Certificates.X509Certificate2; " is 146.
Long Statement,jabber.connection,SocketStanzaStream,C:\repos\meebey_jabber-net\jabber\connection\SocketStanzaStream.cs,Connect,The length of the statement  "		((AsyncSocket)proxy.Socket).LocalCertificate = m_listener [Options.LOCAL_CERTIFICATE] as System.Security.Cryptography.X509Certificates.X509Certificate2; " is 152.
Long Statement,jabber.connection,SocketStanzaStream,C:\repos\meebey_jabber-net\jabber\connection\SocketStanzaStream.cs,Accept,The length of the statement  "		((AsyncSocket)m_accept).LocalCertificate = m_listener [Options.LOCAL_CERTIFICATE] as System.Security.Cryptography.X509Certificates.X509Certificate2; " is 148.
Long Statement,bedrock.net,XEP124Socket,C:\repos\meebey_jabber-net\bedrock\net\XEP124Socket.cs,OnRead,The length of the statement  "		m_listener.OnError (this' new ProtocolViolationException ("Invalid HTTP binding XML.  Token type: " + tok.ToString ())); " is 120.
Long Statement,bedrock.util,GetOpt,C:\repos\meebey_jabber-net\bedrock\util\GetOptBase.cs,GetCommandLineMembers,The length of the statement  "	MemberInfo[] mis = t.FindMembers (MemberTypes.All' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance' new MemberFilter (AttrMemberFilter)' typeof(CommandLineAttribute)); " is 210.
Long Statement,jabber.connection.sasl,SSPIHelper,C:\repos\meebey_jabber-net\jabber\connection\sasl\KerbProcessor.cs,InitializeClient,The length of the statement  "			returnValue = AcquireCredentialsHandle (null' "Kerberos"' SECPKG_CRED_OUTBOUND' IntPtr.Zero' ref ident' 0' IntPtr.Zero' ref _hOutboundCred' ref ClientLifeTime); " is 160.
Long Statement,jabber.connection.sasl,SSPIHelper,C:\repos\meebey_jabber-net\jabber\connection\sasl\KerbProcessor.cs,InitializeClient,The length of the statement  "			returnValue = AcquireCredentialsHandle (null' "Kerberos"' SECPKG_CRED_OUTBOUND' HANDLE.Zero' HANDLE.Zero' 0' HANDLE.Zero' ref _hOutboundCred' ref ClientLifeTime); " is 162.
Long Statement,jabber,JIDTypeConverter,C:\repos\meebey_jabber-net\jabber\JID.cs,CanConvertFrom,The length of the statement  "	return ((sourceType == typeof(string)) || (typeof(JID).IsAssignableFrom (sourceType) || base.CanConvertFrom (context' sourceType))); " is 132.
Long Statement,jabber,JIDTypeConverter,C:\repos\meebey_jabber-net\jabber\JID.cs,CanConvertTo,The length of the statement  "	return ((destinationType == typeof(string)) || ((destinationType == typeof(JID)) || base.CanConvertTo (context' destinationType))); " is 131.
Long Statement,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,CreateChildElement,The length of the statement  "	Debug.Assert (constructor != null' "Type " + typeof(T).ToString () + " does not have a constructor taking an XmlDocument"); " is 123.
Long Statement,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The length of the statement  "		return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2))); " is 221.
Long Statement,jabber.protocol.iq,Time,C:\repos\meebey_jabber-net\jabber\protocol\iq\Time.cs,SetCurrentTime,The length of the statement  "	TZ = TimeZone.CurrentTimeZone.IsDaylightSavingTime (dt) ? TimeZone.CurrentTimeZone.DaylightName : TimeZone.CurrentTimeZone.StandardName; " is 136.
Long Statement,stringprep.unicode,Compose,C:\repos\meebey_jabber-net\stringprep\unicode\Compose.cs,Combine,The length of the statement  "	if (Between (index_a' ComposeData.FIRST_START' ComposeData.FIRST_SINGLE_START) && Between (index_b' ComposeData.SECOND_START' ComposeData.SECOND_SINGLE_START)) { " is 161.
Long Statement,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The length of the statement  "			if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) { " is 162.
Long Statement,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The length of the statement  "		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) { " is 202.
Long Statement,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The length of the statement  "					if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open)))) " is 180.
Complex Conditional,jabber.client,JabberClient,C:\repos\meebey_jabber-net\jabber\client\JabberClient.cs,FireOnIQ,The conditional expression  "!iq.Handled && iq.HasAttribute ("from") && // Belt.  Suspenders.  Don't respond to roster pushes.  ((iq.Type == IQType.get) || (iq.Type == IQType.set))"  is complex.
Complex Conditional,jabber.client,RosterManager,C:\repos\meebey_jabber-net\jabber\client\RosterManager.cs,GotIQ,The conditional expression  "(iq.Query == null) || (iq.Query.NamespaceURI != jabber.protocol.URI.ROSTER) || ((iq.Type != IQType.result) && (iq.Type != IQType.set))"  is complex.
Complex Conditional,jabber.connection,XmppStream,C:\repos\meebey_jabber-net\jabber\connection\XmppStream.cs,ProcessFeatures,The conditional expression  "(bool)this [Options.AUTO_TLS] && (m_features.StartTLS != null) && (!m_sslOn) && m_stanzas.SupportsTLS"  is complex.
Complex Conditional,jabber.connection,XmppStream,C:\repos\meebey_jabber-net\jabber\connection\XmppStream.cs,ProcessFeatures,The conditional expression  "(bool)this [Options.AUTO_COMPRESS] && (comp != null) && comp.HasMethod ("zlib") && (!m_compressionOn) && m_stanzas.SupportsCompression"  is complex.
Complex Conditional,jabber.connection,XmppStream,C:\repos\meebey_jabber-net\jabber\connection\XmppStream.cs,FireOnError,The conditional expression  "((State == ClosingState.Instance) || (State == ClosedState.Instance)) && ((e is System.IO.IOException) || (e.InnerException is System.IO.IOException))"  is complex.
Complex Conditional,bedrock.net,ShttpProxy,C:\repos\meebey_jabber-net\bedrock\net\ShttpProxy.cs,OnConnect,The conditional expression  "Username != null && Username.Length > 0 && Password != null && Password.Length > 0"  is complex.
Complex Conditional,bedrock.net,XEP124Socket,C:\repos\meebey_jabber-net\bedrock\net\XEP124Socket.cs,OnConnect,The conditional expression  "!m_running && (m_sockA != null) && m_sockA.Connected && (m_sockB != null) && m_sockB.Connected"  is complex.
Complex Conditional,stringprep.steps,NFKCStep,C:\repos\meebey_jabber-net\stringprep\steps\NFKCStep.cs,Comp,The conditional expression  "(i > 0) && ((last_cc == 0) || (last_cc != cc)) && Compose.Combine (result [last_start]' result [i]' out c)"  is complex.
Complex Conditional,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The conditional expression  "end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')"  is complex.
Complex Conditional,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The conditional expression  "end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')"  is complex.
Complex Conditional,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The conditional expression  "normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open)))"  is complex.
Empty Catch Block,bedrock.net,AsyncSocket,C:\repos\meebey_jabber-net\bedrock\net\AsyncSocket.cs,Close,The method has an empty catch block.
Empty Catch Block,bedrock.net,XEP25Socket,C:\repos\meebey_jabber-net\bedrock\net\XEP25Socket.cs,PollThread,The method has an empty catch block.
Empty Catch Block,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,Push,The method has an empty catch block.
Empty Catch Block,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,Push,The method has an empty catch block.
Magic Number,bedrock.collections,LinkedList,C:\repos\meebey_jabber-net\bedrock\collections\LinkedList.cs,GetNode,The following statement contains a magic number: if (index < m_size / 2) {  	for (int i = 0; i <= index; i++)  		e = e.next;  }  else {  	for (int i = m_size; i > index; i--)  		e = e.previous;  }  
Magic Number,jabber.client,JabberClient,C:\repos\meebey_jabber-net\jabber\client\JabberClient.cs,Presence,The following statement contains a magic number: if (IsAuthenticated) {  	if ((priority < -128) || (priority > 127)) {  		throw new ArgumentException ("Priority must be -128 to 127"' "priority");  	}  	Presence p = new Presence (Document);  	if (status != null)  		p.Status = status;  	if (t != PresenceType.available) {  		p.Type = t;  	}  	if (show != null)  		p.Show = show;  	p.Priority = priority.ToString ();  	if (OnBeforePresenceOut != null)  		OnBeforePresenceOut (this' p);  	Write (p);  	if (OnAfterPresenceOut != null)  		OnAfterPresenceOut (this' p);  }  else {  	throw new InvalidOperationException ("Client must be authenticated before sending presence.");  }  
Magic Number,jabber.client,JabberClient,C:\repos\meebey_jabber-net\jabber\client\JabberClient.cs,Presence,The following statement contains a magic number: if (IsAuthenticated) {  	if ((priority < -128) || (priority > 127)) {  		throw new ArgumentException ("Priority must be -128 to 127"' "priority");  	}  	Presence p = new Presence (Document);  	if (status != null)  		p.Status = status;  	if (t != PresenceType.available) {  		p.Type = t;  	}  	if (show != null)  		p.Show = show;  	p.Priority = priority.ToString ();  	if (OnBeforePresenceOut != null)  		OnBeforePresenceOut (this' p);  	Write (p);  	if (OnAfterPresenceOut != null)  		OnAfterPresenceOut (this' p);  }  else {  	throw new InvalidOperationException ("Client must be authenticated before sending presence.");  }  
Magic Number,jabber.client,JabberClient,C:\repos\meebey_jabber-net\jabber\client\JabberClient.cs,Presence,The following statement contains a magic number: if ((priority < -128) || (priority > 127)) {  	throw new ArgumentException ("Priority must be -128 to 127"' "priority");  }  
Magic Number,jabber.client,JabberClient,C:\repos\meebey_jabber-net\jabber\client\JabberClient.cs,Presence,The following statement contains a magic number: if ((priority < -128) || (priority > 127)) {  	throw new ArgumentException ("Priority must be -128 to 127"' "priority");  }  
Magic Number,jabber.connection,BindingStanzaStream,C:\repos\meebey_jabber-net\jabber\connection\BindingStanzaStream.cs,CreateSocket,The following statement contains a magic number: if (pt == ProxyType.HTTP) {  	string host = m_listener [Options.PROXY_HOST] as string;  	int port = (int)m_listener [Options.PROXY_PORT];  	if (port == -1)  		port = 80;  	string proxy_uri = string.Format ("http://{0}:{1}/"' host' port);  	sock.ProxyURI = new System.Uri (proxy_uri);  	string user = m_listener [Options.PROXY_USER] as string;  	if ((user != null) && (user != "")) {  		sock.ProxyCredentials = new System.Net.NetworkCredential (user' m_listener [Options.PROXY_PW] as string);  	}  }  
Magic Number,jabber.connection,BindingStanzaStream,C:\repos\meebey_jabber-net\jabber\connection\BindingStanzaStream.cs,CreateSocket,The following statement contains a magic number: if (port == -1)  	port = 80;  
Magic Number,jabber.connection,BindingStanzaStream,C:\repos\meebey_jabber-net\jabber\connection\BindingStanzaStream.cs,CreateSocket,The following statement contains a magic number: port = 80;  
Magic Number,jabber.connection,PubSubManager,C:\repos\meebey_jabber-net\jabber\connection\PubSubManager.cs,RemoveNode,The following statement contains a magic number: if (m_nodes.TryGetValue (jn' out psNode)) {  	m_nodes.Remove (jn);  }  else {  	psNode = new PubSubNode (Stream' service' node' 10);  }  
Magic Number,jabber.connection,PubSubManager,C:\repos\meebey_jabber-net\jabber\connection\PubSubManager.cs,RemoveNode,The following statement contains a magic number: psNode = new PubSubNode (Stream' service' node' 10);  
Magic Number,jabber.connection,SocketStanzaStream,C:\repos\meebey_jabber-net\jabber\connection\SocketStanzaStream.cs,DoKeepAlive,The following statement contains a magic number: if ((m_sock != null) && this.Connected && ((int)m_listener [Options.CURRENT_KEEP_ALIVE] > 0))  	m_sock.Write (new byte[] {  		32  	});  
Magic Number,jabber.connection,SocketStanzaStream,C:\repos\meebey_jabber-net\jabber\connection\SocketStanzaStream.cs,DoKeepAlive,The following statement contains a magic number: m_sock.Write (new byte[] {  	32  });  
Magic Number,bedrock.net,AsyncSocket,C:\repos\meebey_jabber-net\bedrock\net\AsyncSocket.cs,OnConnectResolved,The following statement contains a magic number: lock (this) {  	if (State != SocketState.Resolving) {  		// closed in the mean time.   Probably not an error.  		return;  	}  	if ((addr == null) || (addr.IP == null) || (addr.Endpoint == null)) {  		FireError (new AsyncSocketConnectionException ("Bad host: " + addr.Hostname));  		return;  	}  	if (m_watcher != null)  		m_watcher.RegisterSocket (this);  	m_addr = addr;  	State = SocketState.Connecting;  	if (Socket.OSSupportsIPv6 && (m_addr.Endpoint.AddressFamily == AddressFamily.InterNetworkV6)) {  		// Debug.WriteLine("ipv6");  		m_sock = new Socket (AddressFamily.InterNetworkV6' SocketType.Stream' ProtocolType.Tcp);  	}  	else {  		// Debug.WriteLine("ipv4");  		m_sock = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp);  	}  	// well' of course this isn't right.  	m_sock.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.ReceiveBuffer' 4 * m_buf.Length);  }  
Magic Number,bedrock.net,AsyncSocket,C:\repos\meebey_jabber-net\bedrock\net\AsyncSocket.cs,OnConnectResolved,The following statement contains a magic number: m_sock.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.ReceiveBuffer' 4 * m_buf.Length);  
Magic Number,bedrock.net,AsyncSocket,C:\repos\meebey_jabber-net\bedrock\net\AsyncSocket.cs,RequestRead,The following statement contains a magic number: try {  	if (m_synch) {  		lock (this) {  			if (State != SocketState.Connected) {  				throw new InvalidOperationException ("Socket not connected.");  			}  		}  		while (SyncRead ()) {  			;  		}  		return;  	}  	lock (this) {  		if (m_reading) {  			throw new InvalidOperationException ("Cannot call RequestRead while another read is pending.");  		}  		if (State != SocketState.Connected) {  			throw new InvalidOperationException ("Socket not connected.");  		}  		m_reading = true;  	}  	m_stream.BeginRead (m_buf' 0' m_buf.Length' new AsyncCallback (GotData)' null);  }  catch (AuthenticationException) {  	Close ();  	// don't throw.  this gets caught elsewhere.  }  catch (SocketException e) {  	Close ();  	// 10053 = An established connection was aborted by the  	//         software in your host machine.  	// 10054 = An existing connection was forcibly closed  	//         by the remote host.  	if ((e.ErrorCode != 10053) && (e.ErrorCode != 10054)) {  		throw;  	}  }  catch (IOException) {  	Close ();  }  catch (Exception e) {  	Debug.WriteLine ("Exception in RequestRead: " + e.ToString ());  	Close ();  	throw e;  }  
Magic Number,bedrock.net,AsyncSocket,C:\repos\meebey_jabber-net\bedrock\net\AsyncSocket.cs,RequestRead,The following statement contains a magic number: try {  	if (m_synch) {  		lock (this) {  			if (State != SocketState.Connected) {  				throw new InvalidOperationException ("Socket not connected.");  			}  		}  		while (SyncRead ()) {  			;  		}  		return;  	}  	lock (this) {  		if (m_reading) {  			throw new InvalidOperationException ("Cannot call RequestRead while another read is pending.");  		}  		if (State != SocketState.Connected) {  			throw new InvalidOperationException ("Socket not connected.");  		}  		m_reading = true;  	}  	m_stream.BeginRead (m_buf' 0' m_buf.Length' new AsyncCallback (GotData)' null);  }  catch (AuthenticationException) {  	Close ();  	// don't throw.  this gets caught elsewhere.  }  catch (SocketException e) {  	Close ();  	// 10053 = An established connection was aborted by the  	//         software in your host machine.  	// 10054 = An existing connection was forcibly closed  	//         by the remote host.  	if ((e.ErrorCode != 10053) && (e.ErrorCode != 10054)) {  		throw;  	}  }  catch (IOException) {  	Close ();  }  catch (Exception e) {  	Debug.WriteLine ("Exception in RequestRead: " + e.ToString ());  	Close ();  	throw e;  }  
Magic Number,bedrock.net,AsyncSocket,C:\repos\meebey_jabber-net\bedrock\net\AsyncSocket.cs,RequestRead,The following statement contains a magic number: if ((e.ErrorCode != 10053) && (e.ErrorCode != 10054)) {  	throw;  }  
Magic Number,bedrock.net,AsyncSocket,C:\repos\meebey_jabber-net\bedrock\net\AsyncSocket.cs,RequestRead,The following statement contains a magic number: if ((e.ErrorCode != 10053) && (e.ErrorCode != 10054)) {  	throw;  }  
Magic Number,bedrock.net,AsyncSocket,C:\repos\meebey_jabber-net\bedrock\net\AsyncSocket.cs,GotData,The following statement contains a magic number: try {  	count = m_stream.EndRead (ar);  }  catch (SocketException e) {  	AsyncClose ();  	// closed in middle of read  	if (e.ErrorCode != 64) {  		FireError (e);  	}  	return;  }  catch (ObjectDisposedException) {  	//object already disposed' just exit  	return;  }  catch (Exception e) {  	AsyncClose ();  	FireError (e);  	return;  }  
Magic Number,bedrock.net,AsyncSocket,C:\repos\meebey_jabber-net\bedrock\net\AsyncSocket.cs,GotData,The following statement contains a magic number: if (e.ErrorCode != 64) {  	FireError (e);  }  
Magic Number,bedrock.net,AsyncSocket,C:\repos\meebey_jabber-net\bedrock\net\AsyncSocket.cs,Write,The following statement contains a magic number: lock (this) {  	if (State != SocketState.Connected) {  		return;  		//throw new InvalidOperationException("Socket must be connected before writing.  Current state: " + State.ToString());  	}  	try {  		if (m_synch) {  			m_stream.Write (buf' offset' len);  			m_listener.OnWrite (this' buf' offset' len);  		}  		else {  			if (m_writing) {  				// already writing.  save this for later.  				m_pending.Write (buf' offset' len);  			}  			else {  				m_writing = true;  				// make copy' since we might be a while in async-land  				byte[] ret = new byte[len];  				Buffer.BlockCopy (buf' offset' ret' 0' len);  				m_stream.BeginWrite (ret' 0' ret.Length' new AsyncCallback (WroteData)' ret);  			}  		}  	}  	catch (SocketException e) {  		Close ();  		// closed in middle of write  		if (e.ErrorCode != 10054) {  			FireError (e);  		}  		return;  	}  	catch (Exception e) {  		Close ();  		FireError (e);  		return;  	}  }  
Magic Number,bedrock.net,AsyncSocket,C:\repos\meebey_jabber-net\bedrock\net\AsyncSocket.cs,Write,The following statement contains a magic number: try {  	if (m_synch) {  		m_stream.Write (buf' offset' len);  		m_listener.OnWrite (this' buf' offset' len);  	}  	else {  		if (m_writing) {  			// already writing.  save this for later.  			m_pending.Write (buf' offset' len);  		}  		else {  			m_writing = true;  			// make copy' since we might be a while in async-land  			byte[] ret = new byte[len];  			Buffer.BlockCopy (buf' offset' ret' 0' len);  			m_stream.BeginWrite (ret' 0' ret.Length' new AsyncCallback (WroteData)' ret);  		}  	}  }  catch (SocketException e) {  	Close ();  	// closed in middle of write  	if (e.ErrorCode != 10054) {  		FireError (e);  	}  	return;  }  catch (Exception e) {  	Close ();  	FireError (e);  	return;  }  
Magic Number,bedrock.net,AsyncSocket,C:\repos\meebey_jabber-net\bedrock\net\AsyncSocket.cs,Write,The following statement contains a magic number: if (e.ErrorCode != 10054) {  	FireError (e);  }  
Magic Number,bedrock.net,BaseSocket,C:\repos\meebey_jabber-net\bedrock\net\BaseSocket.cs,Accept,The following statement contains a magic number: Accept (addr' 5);  
Magic Number,bedrock.net,HttpSocket,C:\repos\meebey_jabber-net\bedrock\net\HttpSocket.cs,Execute,The following statement contains a magic number: if (req.Method != null) {  	lock (m_lock) {  		if (!Connected) {  			Connect (req.URI);  			Monitor.Wait (m_lock' (int)(m_connectRetrySec * 1000));  			if (!m_keepRunning)  				return;  			Debug.Assert (Connected);  			Debug.Assert (!IsPending);  		}  	}  }  
Magic Number,bedrock.net,HttpSocket,C:\repos\meebey_jabber-net\bedrock\net\HttpSocket.cs,Execute,The following statement contains a magic number: lock (m_lock) {  	if (!Connected) {  		Connect (req.URI);  		Monitor.Wait (m_lock' (int)(m_connectRetrySec * 1000));  		if (!m_keepRunning)  			return;  		Debug.Assert (Connected);  		Debug.Assert (!IsPending);  	}  }  
Magic Number,bedrock.net,HttpSocket,C:\repos\meebey_jabber-net\bedrock\net\HttpSocket.cs,Execute,The following statement contains a magic number: if (!Connected) {  	Connect (req.URI);  	Monitor.Wait (m_lock' (int)(m_connectRetrySec * 1000));  	if (!m_keepRunning)  		return;  	Debug.Assert (Connected);  	Debug.Assert (!IsPending);  }  
Magic Number,bedrock.net,HttpSocket,C:\repos\meebey_jabber-net\bedrock\net\HttpSocket.cs,Execute,The following statement contains a magic number: Monitor.Wait (m_lock' (int)(m_connectRetrySec * 1000));  
Magic Number,bedrock.net,ShttpProxy,C:\repos\meebey_jabber-net\bedrock\net\ShttpProxy.cs,OnRead,The following statement contains a magic number: switch (m_state) {  case States.WaitingForAuth:  	m_headerstream.Write (buf' offset' length);  	int state = 0;  	int line = 0;  	foreach (byte b in buf) {  		// Look for \r\n\r\n for end of response header  		switch (state) {  		case 0:  			if (b == '\r')  				state++;  			break;  		case 1:  			if (b == '\n') {  				byte[] hs = m_headerstream.ToArray ();  				string s = System.Text.Encoding.UTF8.GetString (hs);  				Debug.Write ("PRECV: " + s);  				m_headers.Add (s);  				m_headerstream.SetLength (0);  				state++;  				line++;  			}  			else  				state = 0;  			break;  		case 2:  			if (b == '\r')  				state++;  			else  				state = 0;  			break;  		case 3:  			if (b == '\n') {  				Debug.WriteLine ("End of proxy headers");  				string line0 = (string)m_headers [0];  				if (line0.IndexOf ("200") == -1) {  					Debug.WriteLine ("200 response not detected.  Closing.");  					m_state = States.Error;  					this.Close ();  				}  				else {  					Debug.WriteLine ("Proxy connected");  					m_listener.OnConnect (sock);  					// tell the real listener that we're connected.  					m_state = States.Running;  				}  				// they'll call RequestRead()' so we can return false here.  				return false;  			}  			else  				state = 0;  			break;  		}  	}  	return true;  case States.Error:  	throw new InvalidOperationException ("Cannot read after error");  default:  	return base.OnRead (sock' buf' offset' length);  }  
Magic Number,bedrock.net,ShttpProxy,C:\repos\meebey_jabber-net\bedrock\net\ShttpProxy.cs,OnRead,The following statement contains a magic number: switch (m_state) {  case States.WaitingForAuth:  	m_headerstream.Write (buf' offset' length);  	int state = 0;  	int line = 0;  	foreach (byte b in buf) {  		// Look for \r\n\r\n for end of response header  		switch (state) {  		case 0:  			if (b == '\r')  				state++;  			break;  		case 1:  			if (b == '\n') {  				byte[] hs = m_headerstream.ToArray ();  				string s = System.Text.Encoding.UTF8.GetString (hs);  				Debug.Write ("PRECV: " + s);  				m_headers.Add (s);  				m_headerstream.SetLength (0);  				state++;  				line++;  			}  			else  				state = 0;  			break;  		case 2:  			if (b == '\r')  				state++;  			else  				state = 0;  			break;  		case 3:  			if (b == '\n') {  				Debug.WriteLine ("End of proxy headers");  				string line0 = (string)m_headers [0];  				if (line0.IndexOf ("200") == -1) {  					Debug.WriteLine ("200 response not detected.  Closing.");  					m_state = States.Error;  					this.Close ();  				}  				else {  					Debug.WriteLine ("Proxy connected");  					m_listener.OnConnect (sock);  					// tell the real listener that we're connected.  					m_state = States.Running;  				}  				// they'll call RequestRead()' so we can return false here.  				return false;  			}  			else  				state = 0;  			break;  		}  	}  	return true;  case States.Error:  	throw new InvalidOperationException ("Cannot read after error");  default:  	return base.OnRead (sock' buf' offset' length);  }  
Magic Number,bedrock.net,ShttpProxy,C:\repos\meebey_jabber-net\bedrock\net\ShttpProxy.cs,OnRead,The following statement contains a magic number: foreach (byte b in buf) {  	// Look for \r\n\r\n for end of response header  	switch (state) {  	case 0:  		if (b == '\r')  			state++;  		break;  	case 1:  		if (b == '\n') {  			byte[] hs = m_headerstream.ToArray ();  			string s = System.Text.Encoding.UTF8.GetString (hs);  			Debug.Write ("PRECV: " + s);  			m_headers.Add (s);  			m_headerstream.SetLength (0);  			state++;  			line++;  		}  		else  			state = 0;  		break;  	case 2:  		if (b == '\r')  			state++;  		else  			state = 0;  		break;  	case 3:  		if (b == '\n') {  			Debug.WriteLine ("End of proxy headers");  			string line0 = (string)m_headers [0];  			if (line0.IndexOf ("200") == -1) {  				Debug.WriteLine ("200 response not detected.  Closing.");  				m_state = States.Error;  				this.Close ();  			}  			else {  				Debug.WriteLine ("Proxy connected");  				m_listener.OnConnect (sock);  				// tell the real listener that we're connected.  				m_state = States.Running;  			}  			// they'll call RequestRead()' so we can return false here.  			return false;  		}  		else  			state = 0;  		break;  	}  }  
Magic Number,bedrock.net,ShttpProxy,C:\repos\meebey_jabber-net\bedrock\net\ShttpProxy.cs,OnRead,The following statement contains a magic number: foreach (byte b in buf) {  	// Look for \r\n\r\n for end of response header  	switch (state) {  	case 0:  		if (b == '\r')  			state++;  		break;  	case 1:  		if (b == '\n') {  			byte[] hs = m_headerstream.ToArray ();  			string s = System.Text.Encoding.UTF8.GetString (hs);  			Debug.Write ("PRECV: " + s);  			m_headers.Add (s);  			m_headerstream.SetLength (0);  			state++;  			line++;  		}  		else  			state = 0;  		break;  	case 2:  		if (b == '\r')  			state++;  		else  			state = 0;  		break;  	case 3:  		if (b == '\n') {  			Debug.WriteLine ("End of proxy headers");  			string line0 = (string)m_headers [0];  			if (line0.IndexOf ("200") == -1) {  				Debug.WriteLine ("200 response not detected.  Closing.");  				m_state = States.Error;  				this.Close ();  			}  			else {  				Debug.WriteLine ("Proxy connected");  				m_listener.OnConnect (sock);  				// tell the real listener that we're connected.  				m_state = States.Running;  			}  			// they'll call RequestRead()' so we can return false here.  			return false;  		}  		else  			state = 0;  		break;  	}  }  
Magic Number,bedrock.net,ShttpProxy,C:\repos\meebey_jabber-net\bedrock\net\ShttpProxy.cs,OnRead,The following statement contains a magic number: switch (state) {  case 0:  	if (b == '\r')  		state++;  	break;  case 1:  	if (b == '\n') {  		byte[] hs = m_headerstream.ToArray ();  		string s = System.Text.Encoding.UTF8.GetString (hs);  		Debug.Write ("PRECV: " + s);  		m_headers.Add (s);  		m_headerstream.SetLength (0);  		state++;  		line++;  	}  	else  		state = 0;  	break;  case 2:  	if (b == '\r')  		state++;  	else  		state = 0;  	break;  case 3:  	if (b == '\n') {  		Debug.WriteLine ("End of proxy headers");  		string line0 = (string)m_headers [0];  		if (line0.IndexOf ("200") == -1) {  			Debug.WriteLine ("200 response not detected.  Closing.");  			m_state = States.Error;  			this.Close ();  		}  		else {  			Debug.WriteLine ("Proxy connected");  			m_listener.OnConnect (sock);  			// tell the real listener that we're connected.  			m_state = States.Running;  		}  		// they'll call RequestRead()' so we can return false here.  		return false;  	}  	else  		state = 0;  	break;  }  
Magic Number,bedrock.net,ShttpProxy,C:\repos\meebey_jabber-net\bedrock\net\ShttpProxy.cs,OnRead,The following statement contains a magic number: switch (state) {  case 0:  	if (b == '\r')  		state++;  	break;  case 1:  	if (b == '\n') {  		byte[] hs = m_headerstream.ToArray ();  		string s = System.Text.Encoding.UTF8.GetString (hs);  		Debug.Write ("PRECV: " + s);  		m_headers.Add (s);  		m_headerstream.SetLength (0);  		state++;  		line++;  	}  	else  		state = 0;  	break;  case 2:  	if (b == '\r')  		state++;  	else  		state = 0;  	break;  case 3:  	if (b == '\n') {  		Debug.WriteLine ("End of proxy headers");  		string line0 = (string)m_headers [0];  		if (line0.IndexOf ("200") == -1) {  			Debug.WriteLine ("200 response not detected.  Closing.");  			m_state = States.Error;  			this.Close ();  		}  		else {  			Debug.WriteLine ("Proxy connected");  			m_listener.OnConnect (sock);  			// tell the real listener that we're connected.  			m_state = States.Running;  		}  		// they'll call RequestRead()' so we can return false here.  		return false;  	}  	else  		state = 0;  	break;  }  
Magic Number,bedrock.net,SocketWatcher,C:\repos\meebey_jabber-net\bedrock\net\SocketWatcher.cs,CreateListenSocket,The following statement contains a magic number: return CreateListenSocket (listener' addr' 5' SSL);  
Magic Number,bedrock.net,SocketWatcher,C:\repos\meebey_jabber-net\bedrock\net\SocketWatcher.cs,CreateListenSocket,The following statement contains a magic number: return CreateListenSocket (listener' addr' 5' false);  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,HandleRequestResponse,The following statement contains a magic number: if (reply != 90) {  	Debug.WriteLine ("request failed on proxy: " + reply);  	return false;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	IPHostEntry server = Dns.GetHostEntry (RemoteAddress.Hostname);  	IPAddress ip_addr = server.AddressList [0];  	byte[] addr = ip_addr.GetAddressBytes ();  	int port = RemoteAddress.Port;  	byte[] buffer = new Byte[14];  	buffer [0] = 4;  	// protocol version.  	buffer [1] = 1;  	// connect.  	buffer [2] = (byte)(port >> 8);  	buffer [3] = (byte)port;  	// TODO: test byte order!  	buffer [4] = addr [3];  	buffer [5] = addr [2];  	buffer [6] = addr [1];  	buffer [7] = addr [0];  	buffer [8] = (byte)'i';  	buffer [9] = (byte)'d';  	buffer [10] = (byte)'e';  	buffer [11] = (byte)'n';  	buffer [12] = (byte)'t';  	buffer [13] = 0;  	/*                 +----+----+----+----+----+----+----+----+----+----+....+----+                 | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|                 +----+----+----+----+----+----+----+----+----+----+....+----+     # of bytes:    1    1      2              4           variable       1                 */Write (buffer);  	RequestRead ();  	m_state = States.RequestingProxy;  }  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer [0] = 4;  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer [2] = (byte)(port >> 8);  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer [2] = (byte)(port >> 8);  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer [3] = (byte)port;  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer [4] = addr [3];  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer [4] = addr [3];  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer [5] = addr [2];  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer [5] = addr [2];  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer [6] = addr [1];  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer [7] = addr [0];  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer [8] = (byte)'i';  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer [9] = (byte)'d';  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer [10] = (byte)'e';  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer [11] = (byte)'n';  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer [12] = (byte)'t';  
Magic Number,bedrock.net,Socks4Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks4Proxy.cs,OnConnect,The following statement contains a magic number: buffer [13] = 0;  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer [0] = 5;  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer [2] = 0;  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer [3] = 3;  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer [3] = 3;  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer [4] = (byte)n;  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: host.CopyTo (buffer' 5);  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer [5 + n] = (byte)(RemoteAddress.Port >> 8);  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer [5 + n] = (byte)(RemoteAddress.Port >> 8);  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,RequestProxyConnection,The following statement contains a magic number: buffer [6 + n] = (byte)RemoteAddress.Port;  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,HandleGetMethodsResponse,The following statement contains a magic number: if (ver != 5) {  	Debug.WriteLine ("bogus version  from proxy: " + ver);  	return false;  }  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,HandleGetMethodsResponse,The following statement contains a magic number: switch (method) {  case 2:  	/*                      * +----+------+----------+------+----------+                      * |VER | ULEN |  UNAME   | PLEN |  PASSWD  |                      * +----+------+----------+------+----------+                      * | 1  |  1   | 1 to 255 |  1   | 1 to 255 |                      * +----+------+----------+------+----------+                      */m_state = States.WaitingForAuth;  	byte[] buffer = new Byte[3 + Username.Length + Password.Length];  	buffer [0] = 1;  	// version of this subnegotiation.  	buffer [1] = (byte)Username.Length;  	Encoding.ASCII.GetBytes (Username' 0' Username.Length' buffer' 2);  	int pw_offset = 2 + Username.Length;  	buffer [pw_offset] = (byte)Password.Length;  	Encoding.ASCII.GetBytes (Password' 0' Password.Length' buffer' pw_offset + 1);  	Debug.WriteLine ("sending plain auth to proxy");  	Write (buffer);  	return true;  case 0:  	RequestProxyConnection ();  	return true;  default:  	Debug.WriteLine ("bogus auth method: " + method);  	return false;  }  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,HandleGetMethodsResponse,The following statement contains a magic number: switch (method) {  case 2:  	/*                      * +----+------+----------+------+----------+                      * |VER | ULEN |  UNAME   | PLEN |  PASSWD  |                      * +----+------+----------+------+----------+                      * | 1  |  1   | 1 to 255 |  1   | 1 to 255 |                      * +----+------+----------+------+----------+                      */m_state = States.WaitingForAuth;  	byte[] buffer = new Byte[3 + Username.Length + Password.Length];  	buffer [0] = 1;  	// version of this subnegotiation.  	buffer [1] = (byte)Username.Length;  	Encoding.ASCII.GetBytes (Username' 0' Username.Length' buffer' 2);  	int pw_offset = 2 + Username.Length;  	buffer [pw_offset] = (byte)Password.Length;  	Encoding.ASCII.GetBytes (Password' 0' Password.Length' buffer' pw_offset + 1);  	Debug.WriteLine ("sending plain auth to proxy");  	Write (buffer);  	return true;  case 0:  	RequestProxyConnection ();  	return true;  default:  	Debug.WriteLine ("bogus auth method: " + method);  	return false;  }  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,HandleGetMethodsResponse,The following statement contains a magic number: switch (method) {  case 2:  	/*                      * +----+------+----------+------+----------+                      * |VER | ULEN |  UNAME   | PLEN |  PASSWD  |                      * +----+------+----------+------+----------+                      * | 1  |  1   | 1 to 255 |  1   | 1 to 255 |                      * +----+------+----------+------+----------+                      */m_state = States.WaitingForAuth;  	byte[] buffer = new Byte[3 + Username.Length + Password.Length];  	buffer [0] = 1;  	// version of this subnegotiation.  	buffer [1] = (byte)Username.Length;  	Encoding.ASCII.GetBytes (Username' 0' Username.Length' buffer' 2);  	int pw_offset = 2 + Username.Length;  	buffer [pw_offset] = (byte)Password.Length;  	Encoding.ASCII.GetBytes (Password' 0' Password.Length' buffer' pw_offset + 1);  	Debug.WriteLine ("sending plain auth to proxy");  	Write (buffer);  	return true;  case 0:  	RequestProxyConnection ();  	return true;  default:  	Debug.WriteLine ("bogus auth method: " + method);  	return false;  }  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,HandleGetMethodsResponse,The following statement contains a magic number: switch (method) {  case 2:  	/*                      * +----+------+----------+------+----------+                      * |VER | ULEN |  UNAME   | PLEN |  PASSWD  |                      * +----+------+----------+------+----------+                      * | 1  |  1   | 1 to 255 |  1   | 1 to 255 |                      * +----+------+----------+------+----------+                      */m_state = States.WaitingForAuth;  	byte[] buffer = new Byte[3 + Username.Length + Password.Length];  	buffer [0] = 1;  	// version of this subnegotiation.  	buffer [1] = (byte)Username.Length;  	Encoding.ASCII.GetBytes (Username' 0' Username.Length' buffer' 2);  	int pw_offset = 2 + Username.Length;  	buffer [pw_offset] = (byte)Password.Length;  	Encoding.ASCII.GetBytes (Password' 0' Password.Length' buffer' pw_offset + 1);  	Debug.WriteLine ("sending plain auth to proxy");  	Write (buffer);  	return true;  case 0:  	RequestProxyConnection ();  	return true;  default:  	Debug.WriteLine ("bogus auth method: " + method);  	return false;  }  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,HandleGetMethodsResponse,The following statement contains a magic number: Encoding.ASCII.GetBytes (Username' 0' Username.Length' buffer' 2);  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,HandleRequestResponse,The following statement contains a magic number: if (ver != 5) {  	Debug.WriteLine ("bogus version in reply from proxy: " + ver);  	return false;  }  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	byte[] buffer = new Byte[4];  	buffer [0] = 5;  	// protocol version.  	buffer [1] = 2;  	// number of methods.  	buffer [2] = 0;  	// no auth.  	buffer [3] = 2;  	// username password.  	Debug.WriteLine ("sending auth methods to proxy...");  	Write (buffer);  	RequestRead ();  	m_state = States.GettingMethods;  }  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	byte[] buffer = new Byte[4];  	buffer [0] = 5;  	// protocol version.  	buffer [1] = 2;  	// number of methods.  	buffer [2] = 0;  	// no auth.  	buffer [3] = 2;  	// username password.  	Debug.WriteLine ("sending auth methods to proxy...");  	Write (buffer);  	RequestRead ();  	m_state = States.GettingMethods;  }  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	byte[] buffer = new Byte[4];  	buffer [0] = 5;  	// protocol version.  	buffer [1] = 2;  	// number of methods.  	buffer [2] = 0;  	// no auth.  	buffer [3] = 2;  	// username password.  	Debug.WriteLine ("sending auth methods to proxy...");  	Write (buffer);  	RequestRead ();  	m_state = States.GettingMethods;  }  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	byte[] buffer = new Byte[4];  	buffer [0] = 5;  	// protocol version.  	buffer [1] = 2;  	// number of methods.  	buffer [2] = 0;  	// no auth.  	buffer [3] = 2;  	// username password.  	Debug.WriteLine ("sending auth methods to proxy...");  	Write (buffer);  	RequestRead ();  	m_state = States.GettingMethods;  }  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	byte[] buffer = new Byte[4];  	buffer [0] = 5;  	// protocol version.  	buffer [1] = 2;  	// number of methods.  	buffer [2] = 0;  	// no auth.  	buffer [3] = 2;  	// username password.  	Debug.WriteLine ("sending auth methods to proxy...");  	Write (buffer);  	RequestRead ();  	m_state = States.GettingMethods;  }  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: if (m_state == States.Connecting) {  	byte[] buffer = new Byte[4];  	buffer [0] = 5;  	// protocol version.  	buffer [1] = 2;  	// number of methods.  	buffer [2] = 0;  	// no auth.  	buffer [3] = 2;  	// username password.  	Debug.WriteLine ("sending auth methods to proxy...");  	Write (buffer);  	RequestRead ();  	m_state = States.GettingMethods;  }  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: buffer [0] = 5;  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: buffer [1] = 2;  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: buffer [2] = 0;  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: buffer [3] = 2;  
Magic Number,bedrock.net,Socks5Proxy,C:\repos\meebey_jabber-net\bedrock\net\Socks5Proxy.cs,OnConnect,The following statement contains a magic number: buffer [3] = 2;  
Magic Number,bedrock.net,XEP124Socket,C:\repos\meebey_jabber-net\bedrock\net\XEP124Socket.cs,OnRead,The following statement contains a magic number: if (tok == xpnet.TOK.START_TAG_WITH_ATTS) {  	// len(</body>) = 7  	start = ct.TokenEnd;  	if (m_listener.OnRead (this' buf' start' offset + length - start - 7))  		RequestRead ();  }  else  	RequestRead ();  
Magic Number,bedrock.net,XEP124Socket,C:\repos\meebey_jabber-net\bedrock\net\XEP124Socket.cs,OnRead,The following statement contains a magic number: if (m_listener.OnRead (this' buf' start' offset + length - start - 7))  	RequestRead ();  
Magic Number,bedrock.net,XEP25Socket,C:\repos\meebey_jabber-net\bedrock\net\XEP25Socket.cs,PollThread,The following statement contains a magic number: while (m_running) {  	lock (m_lock) {  		if (m_writeQ.Count == 0) {  			Monitor.Wait (m_lock' (int)(m_curPoll * 1000.0));  		}  	}  	// did we get closed?  	if (!m_running)  		break;  	if (m_id == null) {  		GenKeys ();  		start = new WriteBuf (string.Format ("0;{0}'"' m_keys [m_curKey]));  	}  	else {  		if (m_curKey == 0) {  			string k = m_keys [0];  			GenKeys ();  			start = new WriteBuf (string.Format ("{0};{1};{2}'"' m_id' k' m_keys [m_curKey]));  		}  		else {  			start = new WriteBuf (string.Format ("{0};{1}'"' m_id' m_keys [m_curKey]));  		}  	}  	m_curKey--;  	ms.SetLength (0);  	int count = start.len;  	while (m_writeQ.Count > 0) {  		WriteBuf b = (WriteBuf)m_writeQ.Dequeue ();  		count += b.len;  		ms.Write (b.buf' b.offset' b.len);  	}  	POLL:  	req = (HttpWebRequest)WebRequest.Create (m_url);  	req.CookieContainer = cookies;  	req.ContentType = CONTENT_TYPE;  	req.Method = METHOD;  	if (m_cert != null)  		req.ClientCertificates.Add (m_cert);  	req.KeepAlive = false;  	req.CachePolicy = new System.Net.Cache.HttpRequestCachePolicy (System.Net.Cache.HttpRequestCacheLevel.NoCacheNoStore);  	req.CachePolicy = new System.Net.Cache.HttpRequestCachePolicy (System.Net.Cache.HttpRequestCacheLevel.NoCacheNoStore);  	if (m_proxy != null)  		req.Proxy = m_proxy;  	req.ContentLength = count;  	try {  		ServicePointManager.ServerCertificateValidationCallback = ValidateRemoteCertificate;  		s = req.GetRequestStream ();  		s.Write (start.buf' start.offset' start.len);  		m_remote_cert = req.ServicePoint.Certificate;  		buf = ms.ToArray ();  		s.Write (buf' 0' buf.Length);  		s.Close ();  		resp = (HttpWebResponse)req.GetResponse ();  	}  	catch (WebException ex) {  		if (ex.Status != WebExceptionStatus.KeepAliveFailure) {  			m_listener.OnError (this' ex);  			return;  		}  		goto POLL;  	}  	if (resp.StatusCode != HttpStatusCode.OK) {  		m_listener.OnError (this' new WebException ("Invalid HTTP return code: " + resp.StatusCode));  		return;  	}  	CookieCollection cc = resp.Cookies;  	Debug.Assert (cc != null);  	Cookie c = cc ["ID"];  	if ((c == null) || (c.Value == null)) {  		m_listener.OnError (this' new WebException ("No ID cookie returned"));  		return;  	}  	if (m_id == null) {  		// if ID ends in :0' it's an error  		if (!c.Value.EndsWith (":0"))  			m_id = c.Value;  	}  	if (m_id != c.Value) {  		switch (c.Value) {  		case "0:0":  			m_listener.OnError (this' new XEP25Exception ("Unknown XEP25 error"));  			return;  		case "-1:0":  			m_listener.OnError (this' new XEP25Exception ("Server error"));  			return;  		case "-2:0":  			m_listener.OnError (this' new XEP25Exception ("Bad request"));  			return;  		case "-3:0":  			m_listener.OnError (this' new XEP25Exception ("Key sequence error"));  			return;  		default:  			m_listener.OnError (this' new WebException ("ID cookie changed"));  			return;  		}  	}  	if (ms.Length > 0) {  		m_listener.OnWrite (this' buf' 0' buf.Length);  	}  	ms.SetLength (0);  	rs = resp.GetResponseStream ();  	int readlen;  	while ((readlen = rs.Read (readbuf' 0' readbuf.Length)) > 0) {  		ms.Write (readbuf' 0' readlen);  	}  	rs.Close ();  	if (ms.Length > 0) {  		buf = ms.ToArray ();  		try {  			if (!m_listener.OnRead (this' buf' 0' buf.Length)) {  				Close ();  				return;  			}  		}  		catch (NullReferenceException) {  		}  		m_curPoll = m_minPoll;  	}  	else {  		m_curPoll *= 1.25;  		if (m_curPoll > m_maxPoll)  			m_curPoll = m_maxPoll;  	}  }  
Magic Number,bedrock.net,XEP25Socket,C:\repos\meebey_jabber-net\bedrock\net\XEP25Socket.cs,PollThread,The following statement contains a magic number: while (m_running) {  	lock (m_lock) {  		if (m_writeQ.Count == 0) {  			Monitor.Wait (m_lock' (int)(m_curPoll * 1000.0));  		}  	}  	// did we get closed?  	if (!m_running)  		break;  	if (m_id == null) {  		GenKeys ();  		start = new WriteBuf (string.Format ("0;{0}'"' m_keys [m_curKey]));  	}  	else {  		if (m_curKey == 0) {  			string k = m_keys [0];  			GenKeys ();  			start = new WriteBuf (string.Format ("{0};{1};{2}'"' m_id' k' m_keys [m_curKey]));  		}  		else {  			start = new WriteBuf (string.Format ("{0};{1}'"' m_id' m_keys [m_curKey]));  		}  	}  	m_curKey--;  	ms.SetLength (0);  	int count = start.len;  	while (m_writeQ.Count > 0) {  		WriteBuf b = (WriteBuf)m_writeQ.Dequeue ();  		count += b.len;  		ms.Write (b.buf' b.offset' b.len);  	}  	POLL:  	req = (HttpWebRequest)WebRequest.Create (m_url);  	req.CookieContainer = cookies;  	req.ContentType = CONTENT_TYPE;  	req.Method = METHOD;  	if (m_cert != null)  		req.ClientCertificates.Add (m_cert);  	req.KeepAlive = false;  	req.CachePolicy = new System.Net.Cache.HttpRequestCachePolicy (System.Net.Cache.HttpRequestCacheLevel.NoCacheNoStore);  	req.CachePolicy = new System.Net.Cache.HttpRequestCachePolicy (System.Net.Cache.HttpRequestCacheLevel.NoCacheNoStore);  	if (m_proxy != null)  		req.Proxy = m_proxy;  	req.ContentLength = count;  	try {  		ServicePointManager.ServerCertificateValidationCallback = ValidateRemoteCertificate;  		s = req.GetRequestStream ();  		s.Write (start.buf' start.offset' start.len);  		m_remote_cert = req.ServicePoint.Certificate;  		buf = ms.ToArray ();  		s.Write (buf' 0' buf.Length);  		s.Close ();  		resp = (HttpWebResponse)req.GetResponse ();  	}  	catch (WebException ex) {  		if (ex.Status != WebExceptionStatus.KeepAliveFailure) {  			m_listener.OnError (this' ex);  			return;  		}  		goto POLL;  	}  	if (resp.StatusCode != HttpStatusCode.OK) {  		m_listener.OnError (this' new WebException ("Invalid HTTP return code: " + resp.StatusCode));  		return;  	}  	CookieCollection cc = resp.Cookies;  	Debug.Assert (cc != null);  	Cookie c = cc ["ID"];  	if ((c == null) || (c.Value == null)) {  		m_listener.OnError (this' new WebException ("No ID cookie returned"));  		return;  	}  	if (m_id == null) {  		// if ID ends in :0' it's an error  		if (!c.Value.EndsWith (":0"))  			m_id = c.Value;  	}  	if (m_id != c.Value) {  		switch (c.Value) {  		case "0:0":  			m_listener.OnError (this' new XEP25Exception ("Unknown XEP25 error"));  			return;  		case "-1:0":  			m_listener.OnError (this' new XEP25Exception ("Server error"));  			return;  		case "-2:0":  			m_listener.OnError (this' new XEP25Exception ("Bad request"));  			return;  		case "-3:0":  			m_listener.OnError (this' new XEP25Exception ("Key sequence error"));  			return;  		default:  			m_listener.OnError (this' new WebException ("ID cookie changed"));  			return;  		}  	}  	if (ms.Length > 0) {  		m_listener.OnWrite (this' buf' 0' buf.Length);  	}  	ms.SetLength (0);  	rs = resp.GetResponseStream ();  	int readlen;  	while ((readlen = rs.Read (readbuf' 0' readbuf.Length)) > 0) {  		ms.Write (readbuf' 0' readlen);  	}  	rs.Close ();  	if (ms.Length > 0) {  		buf = ms.ToArray ();  		try {  			if (!m_listener.OnRead (this' buf' 0' buf.Length)) {  				Close ();  				return;  			}  		}  		catch (NullReferenceException) {  		}  		m_curPoll = m_minPoll;  	}  	else {  		m_curPoll *= 1.25;  		if (m_curPoll > m_maxPoll)  			m_curPoll = m_maxPoll;  	}  }  
Magic Number,bedrock.net,XEP25Socket,C:\repos\meebey_jabber-net\bedrock\net\XEP25Socket.cs,PollThread,The following statement contains a magic number: lock (m_lock) {  	if (m_writeQ.Count == 0) {  		Monitor.Wait (m_lock' (int)(m_curPoll * 1000.0));  	}  }  
Magic Number,bedrock.net,XEP25Socket,C:\repos\meebey_jabber-net\bedrock\net\XEP25Socket.cs,PollThread,The following statement contains a magic number: if (m_writeQ.Count == 0) {  	Monitor.Wait (m_lock' (int)(m_curPoll * 1000.0));  }  
Magic Number,bedrock.net,XEP25Socket,C:\repos\meebey_jabber-net\bedrock\net\XEP25Socket.cs,PollThread,The following statement contains a magic number: Monitor.Wait (m_lock' (int)(m_curPoll * 1000.0));  
Magic Number,bedrock.net,XEP25Socket,C:\repos\meebey_jabber-net\bedrock\net\XEP25Socket.cs,PollThread,The following statement contains a magic number: if (ms.Length > 0) {  	buf = ms.ToArray ();  	try {  		if (!m_listener.OnRead (this' buf' 0' buf.Length)) {  			Close ();  			return;  		}  	}  	catch (NullReferenceException) {  	}  	m_curPoll = m_minPoll;  }  else {  	m_curPoll *= 1.25;  	if (m_curPoll > m_maxPoll)  		m_curPoll = m_maxPoll;  }  
Magic Number,bedrock.net,XEP25Socket,C:\repos\meebey_jabber-net\bedrock\net\XEP25Socket.cs,PollThread,The following statement contains a magic number: m_curPoll *= 1.25;  
Magic Number,bedrock.util,GetOpt,C:\repos\meebey_jabber-net\bedrock\util\GetOptBase.cs,Process,The following statement contains a magic number: for (i = 0; i < args.Length; i++) {  	rm = FLAG_REGEX.Match (args [i]);  	if (!rm.Success)// no more flags  	 {  		break;  	}  	mi = (MemberInfo)m_flags [rm.Groups [1].ToString ()];  	if (mi == null) {  		throw new ArgumentException ("Invalid command-line argument"' args [i]);  	}  	mit = GetMemberType (mi);  	// methods return null types' for now.  	// TODO: should this be moved to SetValue?  	// Not sure what to do with bool params' then.  	if (mit == null) {  		string old_flag = args [i];  		MethodInfo meth = (MethodInfo)mi;  		ParameterInfo[] pi = meth.GetParameters ();  		object[] parms = new object[pi.Length];  		for (int j = 0; j < pi.Length; j++) {  			if (i + 1 >= args.Length) {  				throw new IndexOutOfRangeException ("Not enough parameters for: " + old_flag);  			}  			parms [j] = ConvertValue (args [++i]' pi [j].ParameterType);  		}  		meth.Invoke (m_obj' parms);  	}  	// bool flags act as toggles  	else if (mit == typeof(bool)) {  		SetValue (mi' !(bool)GetValue (mi));  	}  	else {  		// use the value after the colon' if it exists  		if (rm.Groups [3].Success) {  			SetValue (mi' rm.Groups [3].ToString ());  		}  		else {  			if (i + 1 >= args.Length) {  				throw new IndexOutOfRangeException ("Not enough parameters for: " + args [i]);  			}  			SetValue (mi' args [++i]);  		}  	}  }  
Magic Number,bedrock.util,GetOpt,C:\repos\meebey_jabber-net\bedrock\util\GetOptBase.cs,Process,The following statement contains a magic number: for (i = 0; i < args.Length; i++) {  	rm = FLAG_REGEX.Match (args [i]);  	if (!rm.Success)// no more flags  	 {  		break;  	}  	mi = (MemberInfo)m_flags [rm.Groups [1].ToString ()];  	if (mi == null) {  		throw new ArgumentException ("Invalid command-line argument"' args [i]);  	}  	mit = GetMemberType (mi);  	// methods return null types' for now.  	// TODO: should this be moved to SetValue?  	// Not sure what to do with bool params' then.  	if (mit == null) {  		string old_flag = args [i];  		MethodInfo meth = (MethodInfo)mi;  		ParameterInfo[] pi = meth.GetParameters ();  		object[] parms = new object[pi.Length];  		for (int j = 0; j < pi.Length; j++) {  			if (i + 1 >= args.Length) {  				throw new IndexOutOfRangeException ("Not enough parameters for: " + old_flag);  			}  			parms [j] = ConvertValue (args [++i]' pi [j].ParameterType);  		}  		meth.Invoke (m_obj' parms);  	}  	// bool flags act as toggles  	else if (mit == typeof(bool)) {  		SetValue (mi' !(bool)GetValue (mi));  	}  	else {  		// use the value after the colon' if it exists  		if (rm.Groups [3].Success) {  			SetValue (mi' rm.Groups [3].ToString ());  		}  		else {  			if (i + 1 >= args.Length) {  				throw new IndexOutOfRangeException ("Not enough parameters for: " + args [i]);  			}  			SetValue (mi' args [++i]);  		}  	}  }  
Magic Number,bedrock.util,GetOpt,C:\repos\meebey_jabber-net\bedrock\util\GetOptBase.cs,Process,The following statement contains a magic number: if (mit == null) {  	string old_flag = args [i];  	MethodInfo meth = (MethodInfo)mi;  	ParameterInfo[] pi = meth.GetParameters ();  	object[] parms = new object[pi.Length];  	for (int j = 0; j < pi.Length; j++) {  		if (i + 1 >= args.Length) {  			throw new IndexOutOfRangeException ("Not enough parameters for: " + old_flag);  		}  		parms [j] = ConvertValue (args [++i]' pi [j].ParameterType);  	}  	meth.Invoke (m_obj' parms);  }  // bool flags act as toggles  else if (mit == typeof(bool)) {  	SetValue (mi' !(bool)GetValue (mi));  }  else {  	// use the value after the colon' if it exists  	if (rm.Groups [3].Success) {  		SetValue (mi' rm.Groups [3].ToString ());  	}  	else {  		if (i + 1 >= args.Length) {  			throw new IndexOutOfRangeException ("Not enough parameters for: " + args [i]);  		}  		SetValue (mi' args [++i]);  	}  }  
Magic Number,bedrock.util,GetOpt,C:\repos\meebey_jabber-net\bedrock\util\GetOptBase.cs,Process,The following statement contains a magic number: if (mit == null) {  	string old_flag = args [i];  	MethodInfo meth = (MethodInfo)mi;  	ParameterInfo[] pi = meth.GetParameters ();  	object[] parms = new object[pi.Length];  	for (int j = 0; j < pi.Length; j++) {  		if (i + 1 >= args.Length) {  			throw new IndexOutOfRangeException ("Not enough parameters for: " + old_flag);  		}  		parms [j] = ConvertValue (args [++i]' pi [j].ParameterType);  	}  	meth.Invoke (m_obj' parms);  }  // bool flags act as toggles  else if (mit == typeof(bool)) {  	SetValue (mi' !(bool)GetValue (mi));  }  else {  	// use the value after the colon' if it exists  	if (rm.Groups [3].Success) {  		SetValue (mi' rm.Groups [3].ToString ());  	}  	else {  		if (i + 1 >= args.Length) {  			throw new IndexOutOfRangeException ("Not enough parameters for: " + args [i]);  		}  		SetValue (mi' args [++i]);  	}  }  
Magic Number,bedrock.util,GetOpt,C:\repos\meebey_jabber-net\bedrock\util\GetOptBase.cs,Process,The following statement contains a magic number: if (mit == typeof(bool)) {  	SetValue (mi' !(bool)GetValue (mi));  }  else {  	// use the value after the colon' if it exists  	if (rm.Groups [3].Success) {  		SetValue (mi' rm.Groups [3].ToString ());  	}  	else {  		if (i + 1 >= args.Length) {  			throw new IndexOutOfRangeException ("Not enough parameters for: " + args [i]);  		}  		SetValue (mi' args [++i]);  	}  }  
Magic Number,bedrock.util,GetOpt,C:\repos\meebey_jabber-net\bedrock\util\GetOptBase.cs,Process,The following statement contains a magic number: if (mit == typeof(bool)) {  	SetValue (mi' !(bool)GetValue (mi));  }  else {  	// use the value after the colon' if it exists  	if (rm.Groups [3].Success) {  		SetValue (mi' rm.Groups [3].ToString ());  	}  	else {  		if (i + 1 >= args.Length) {  			throw new IndexOutOfRangeException ("Not enough parameters for: " + args [i]);  		}  		SetValue (mi' args [++i]);  	}  }  
Magic Number,bedrock.util,GetOpt,C:\repos\meebey_jabber-net\bedrock\util\GetOptBase.cs,Process,The following statement contains a magic number: if (rm.Groups [3].Success) {  	SetValue (mi' rm.Groups [3].ToString ());  }  else {  	if (i + 1 >= args.Length) {  		throw new IndexOutOfRangeException ("Not enough parameters for: " + args [i]);  	}  	SetValue (mi' args [++i]);  }  
Magic Number,bedrock.util,GetOpt,C:\repos\meebey_jabber-net\bedrock\util\GetOptBase.cs,Process,The following statement contains a magic number: if (rm.Groups [3].Success) {  	SetValue (mi' rm.Groups [3].ToString ());  }  else {  	if (i + 1 >= args.Length) {  		throw new IndexOutOfRangeException ("Not enough parameters for: " + args [i]);  	}  	SetValue (mi' args [++i]);  }  
Magic Number,bedrock.util,GetOpt,C:\repos\meebey_jabber-net\bedrock\util\GetOptBase.cs,Process,The following statement contains a magic number: SetValue (mi' rm.Groups [3].ToString ());  
Magic Number,bedrock.util,GetOpt,C:\repos\meebey_jabber-net\bedrock\util\GetOptBase.cs,UsageExit,The following statement contains a magic number: Environment.Exit (64);  
Magic Number,bedrock.util,IdleTime,C:\repos\meebey_jabber-net\bedrock\util\IdleTime.cs,GetIdleTime,The following statement contains a magic number: return (Environment.TickCount - lii.dwTime) / 1000.0;  
Magic Number,bedrock.util,IdleTime,C:\repos\meebey_jabber-net\bedrock\util\IdleTime.cs,IdleTime,The following statement contains a magic number: m_timer = new System.Timers.Timer (DEFAULT_POLL * 1000.0);  
Magic Number,bedrock.util,SourceSafeAttribute,C:\repos\meebey_jabber-net\bedrock\util\Version.cs,Parse,The following statement contains a magic number: if (m.Groups ["archive"].Success) {  	m_archive = m.Groups ["archive"].ToString ();  	m_version = m.Groups ["version"].ToString ();  	m_date = DateTime.Parse (m.Groups ["date"].ToString ());  	if (m.Groups ["ampm"].ToString () == "p") {  		m_date = m_date.AddHours (12);  	}  	m_author = m.Groups ["author"].ToString ();  }  
Magic Number,bedrock.util,SourceSafeAttribute,C:\repos\meebey_jabber-net\bedrock\util\Version.cs,Parse,The following statement contains a magic number: if (m.Groups ["ampm"].ToString () == "p") {  	m_date = m_date.AddHours (12);  }  
Magic Number,bedrock.util,SourceSafeAttribute,C:\repos\meebey_jabber-net\bedrock\util\Version.cs,Parse,The following statement contains a magic number: m_date = m_date.AddHours (12);  
Magic Number,jabber.connection.sasl,MD5Processor,C:\repos\meebey_jabber-net\jabber\connection\sasl\MD5Processor.cs,generateResponseString,The following statement contains a magic number: m_ncString = m_nc.ToString ().PadLeft (8' '0');  
Magic Number,jabber.connection.sasl,MD5Processor,C:\repos\meebey_jabber-net\jabber\connection\sasl\MD5Processor.cs,generateResponseString,The following statement contains a magic number: ms.Write (H1' 0' 16);  
Magic Number,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,Push,The following statement contains a magic number: try {  	while (off < b.Length) {  		if (m_cdata)  			tok = m_enc.tokenizeCdataSection (b' off' b.Length' ct);  		else  			tok = m_enc.tokenizeContent (b' off' b.Length' ct);  		switch (tok) {  		case TOK.EMPTY_ELEMENT_NO_ATTS:  		case TOK.EMPTY_ELEMENT_WITH_ATTS:  			StartTag (b' off' ct' tok);  			EndTag (b' off' ct' tok);  			break;  		case TOK.START_TAG_NO_ATTS:  		case TOK.START_TAG_WITH_ATTS:  			StartTag (b' off' ct' tok);  			break;  		case TOK.END_TAG:  			EndTag (b' off' ct' tok);  			break;  		case TOK.DATA_CHARS:  		case TOK.DATA_NEWLINE:  			AddText (utf.GetString (b' off' ct.TokenEnd - off));  			break;  		case TOK.CHAR_REF:  		case TOK.MAGIC_ENTITY_REF:  			AddText (new string (new char[] {  				ct.RefChar1  			}));  			break;  		case TOK.CHAR_PAIR_REF:  			AddText (new string (new char[] {  				ct.RefChar1'  				ct.RefChar2  			}));  			break;  		case TOK.COMMENT:  			if (m_elem != null) {  				// <!-- 4  				//  --> 3  				int start = off + 4 * m_enc.MinBytesPerChar;  				int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  				string text = utf.GetString (b' start' end);  				m_elem.AppendChild (m_doc.CreateComment (text));  			}  			break;  		case TOK.CDATA_SECT_OPEN:  			m_cdata = true;  			break;  		case TOK.CDATA_SECT_CLOSE:  			m_cdata = false;  			break;  		case TOK.XML_DECL:  			// thou shalt use UTF8' and XML version 1.  			// i shall ignore evidence to the contrary...  			// TODO: Throw an exception if these assuptions are  			// wrong  			break;  		case TOK.ENTITY_REF:  		case TOK.PI:  			throw new System.NotImplementedException ("Token type not implemented: " + tok);  		}  		off = ct.TokenEnd;  		ct.clearAttributes ();  	}  }  catch (PartialTokenException) {  	// Console.WriteLine("PartialTokenException: " + System.Text.Encoding.UTF8.GetString(copy));  	// ignored;  }  catch (ExtensibleTokenException) {  	// ignored;  }  catch (xpnet.InvalidTokenException e) {  	throw new XMLParseException (e' this' buf' offset' length);  }  catch (Exception e) {  	throw new Exception ("Unexpected exception"' e);  }  finally {  	m_buf.Clear (off);  	ct.clearAttributes ();  }  
Magic Number,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,Push,The following statement contains a magic number: try {  	while (off < b.Length) {  		if (m_cdata)  			tok = m_enc.tokenizeCdataSection (b' off' b.Length' ct);  		else  			tok = m_enc.tokenizeContent (b' off' b.Length' ct);  		switch (tok) {  		case TOK.EMPTY_ELEMENT_NO_ATTS:  		case TOK.EMPTY_ELEMENT_WITH_ATTS:  			StartTag (b' off' ct' tok);  			EndTag (b' off' ct' tok);  			break;  		case TOK.START_TAG_NO_ATTS:  		case TOK.START_TAG_WITH_ATTS:  			StartTag (b' off' ct' tok);  			break;  		case TOK.END_TAG:  			EndTag (b' off' ct' tok);  			break;  		case TOK.DATA_CHARS:  		case TOK.DATA_NEWLINE:  			AddText (utf.GetString (b' off' ct.TokenEnd - off));  			break;  		case TOK.CHAR_REF:  		case TOK.MAGIC_ENTITY_REF:  			AddText (new string (new char[] {  				ct.RefChar1  			}));  			break;  		case TOK.CHAR_PAIR_REF:  			AddText (new string (new char[] {  				ct.RefChar1'  				ct.RefChar2  			}));  			break;  		case TOK.COMMENT:  			if (m_elem != null) {  				// <!-- 4  				//  --> 3  				int start = off + 4 * m_enc.MinBytesPerChar;  				int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  				string text = utf.GetString (b' start' end);  				m_elem.AppendChild (m_doc.CreateComment (text));  			}  			break;  		case TOK.CDATA_SECT_OPEN:  			m_cdata = true;  			break;  		case TOK.CDATA_SECT_CLOSE:  			m_cdata = false;  			break;  		case TOK.XML_DECL:  			// thou shalt use UTF8' and XML version 1.  			// i shall ignore evidence to the contrary...  			// TODO: Throw an exception if these assuptions are  			// wrong  			break;  		case TOK.ENTITY_REF:  		case TOK.PI:  			throw new System.NotImplementedException ("Token type not implemented: " + tok);  		}  		off = ct.TokenEnd;  		ct.clearAttributes ();  	}  }  catch (PartialTokenException) {  	// Console.WriteLine("PartialTokenException: " + System.Text.Encoding.UTF8.GetString(copy));  	// ignored;  }  catch (ExtensibleTokenException) {  	// ignored;  }  catch (xpnet.InvalidTokenException e) {  	throw new XMLParseException (e' this' buf' offset' length);  }  catch (Exception e) {  	throw new Exception ("Unexpected exception"' e);  }  finally {  	m_buf.Clear (off);  	ct.clearAttributes ();  }  
Magic Number,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,Push,The following statement contains a magic number: while (off < b.Length) {  	if (m_cdata)  		tok = m_enc.tokenizeCdataSection (b' off' b.Length' ct);  	else  		tok = m_enc.tokenizeContent (b' off' b.Length' ct);  	switch (tok) {  	case TOK.EMPTY_ELEMENT_NO_ATTS:  	case TOK.EMPTY_ELEMENT_WITH_ATTS:  		StartTag (b' off' ct' tok);  		EndTag (b' off' ct' tok);  		break;  	case TOK.START_TAG_NO_ATTS:  	case TOK.START_TAG_WITH_ATTS:  		StartTag (b' off' ct' tok);  		break;  	case TOK.END_TAG:  		EndTag (b' off' ct' tok);  		break;  	case TOK.DATA_CHARS:  	case TOK.DATA_NEWLINE:  		AddText (utf.GetString (b' off' ct.TokenEnd - off));  		break;  	case TOK.CHAR_REF:  	case TOK.MAGIC_ENTITY_REF:  		AddText (new string (new char[] {  			ct.RefChar1  		}));  		break;  	case TOK.CHAR_PAIR_REF:  		AddText (new string (new char[] {  			ct.RefChar1'  			ct.RefChar2  		}));  		break;  	case TOK.COMMENT:  		if (m_elem != null) {  			// <!-- 4  			//  --> 3  			int start = off + 4 * m_enc.MinBytesPerChar;  			int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  			string text = utf.GetString (b' start' end);  			m_elem.AppendChild (m_doc.CreateComment (text));  		}  		break;  	case TOK.CDATA_SECT_OPEN:  		m_cdata = true;  		break;  	case TOK.CDATA_SECT_CLOSE:  		m_cdata = false;  		break;  	case TOK.XML_DECL:  		// thou shalt use UTF8' and XML version 1.  		// i shall ignore evidence to the contrary...  		// TODO: Throw an exception if these assuptions are  		// wrong  		break;  	case TOK.ENTITY_REF:  	case TOK.PI:  		throw new System.NotImplementedException ("Token type not implemented: " + tok);  	}  	off = ct.TokenEnd;  	ct.clearAttributes ();  }  
Magic Number,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,Push,The following statement contains a magic number: while (off < b.Length) {  	if (m_cdata)  		tok = m_enc.tokenizeCdataSection (b' off' b.Length' ct);  	else  		tok = m_enc.tokenizeContent (b' off' b.Length' ct);  	switch (tok) {  	case TOK.EMPTY_ELEMENT_NO_ATTS:  	case TOK.EMPTY_ELEMENT_WITH_ATTS:  		StartTag (b' off' ct' tok);  		EndTag (b' off' ct' tok);  		break;  	case TOK.START_TAG_NO_ATTS:  	case TOK.START_TAG_WITH_ATTS:  		StartTag (b' off' ct' tok);  		break;  	case TOK.END_TAG:  		EndTag (b' off' ct' tok);  		break;  	case TOK.DATA_CHARS:  	case TOK.DATA_NEWLINE:  		AddText (utf.GetString (b' off' ct.TokenEnd - off));  		break;  	case TOK.CHAR_REF:  	case TOK.MAGIC_ENTITY_REF:  		AddText (new string (new char[] {  			ct.RefChar1  		}));  		break;  	case TOK.CHAR_PAIR_REF:  		AddText (new string (new char[] {  			ct.RefChar1'  			ct.RefChar2  		}));  		break;  	case TOK.COMMENT:  		if (m_elem != null) {  			// <!-- 4  			//  --> 3  			int start = off + 4 * m_enc.MinBytesPerChar;  			int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  			string text = utf.GetString (b' start' end);  			m_elem.AppendChild (m_doc.CreateComment (text));  		}  		break;  	case TOK.CDATA_SECT_OPEN:  		m_cdata = true;  		break;  	case TOK.CDATA_SECT_CLOSE:  		m_cdata = false;  		break;  	case TOK.XML_DECL:  		// thou shalt use UTF8' and XML version 1.  		// i shall ignore evidence to the contrary...  		// TODO: Throw an exception if these assuptions are  		// wrong  		break;  	case TOK.ENTITY_REF:  	case TOK.PI:  		throw new System.NotImplementedException ("Token type not implemented: " + tok);  	}  	off = ct.TokenEnd;  	ct.clearAttributes ();  }  
Magic Number,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,Push,The following statement contains a magic number: switch (tok) {  case TOK.EMPTY_ELEMENT_NO_ATTS:  case TOK.EMPTY_ELEMENT_WITH_ATTS:  	StartTag (b' off' ct' tok);  	EndTag (b' off' ct' tok);  	break;  case TOK.START_TAG_NO_ATTS:  case TOK.START_TAG_WITH_ATTS:  	StartTag (b' off' ct' tok);  	break;  case TOK.END_TAG:  	EndTag (b' off' ct' tok);  	break;  case TOK.DATA_CHARS:  case TOK.DATA_NEWLINE:  	AddText (utf.GetString (b' off' ct.TokenEnd - off));  	break;  case TOK.CHAR_REF:  case TOK.MAGIC_ENTITY_REF:  	AddText (new string (new char[] {  		ct.RefChar1  	}));  	break;  case TOK.CHAR_PAIR_REF:  	AddText (new string (new char[] {  		ct.RefChar1'  		ct.RefChar2  	}));  	break;  case TOK.COMMENT:  	if (m_elem != null) {  		// <!-- 4  		//  --> 3  		int start = off + 4 * m_enc.MinBytesPerChar;  		int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  		string text = utf.GetString (b' start' end);  		m_elem.AppendChild (m_doc.CreateComment (text));  	}  	break;  case TOK.CDATA_SECT_OPEN:  	m_cdata = true;  	break;  case TOK.CDATA_SECT_CLOSE:  	m_cdata = false;  	break;  case TOK.XML_DECL:  	// thou shalt use UTF8' and XML version 1.  	// i shall ignore evidence to the contrary...  	// TODO: Throw an exception if these assuptions are  	// wrong  	break;  case TOK.ENTITY_REF:  case TOK.PI:  	throw new System.NotImplementedException ("Token type not implemented: " + tok);  }  
Magic Number,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,Push,The following statement contains a magic number: switch (tok) {  case TOK.EMPTY_ELEMENT_NO_ATTS:  case TOK.EMPTY_ELEMENT_WITH_ATTS:  	StartTag (b' off' ct' tok);  	EndTag (b' off' ct' tok);  	break;  case TOK.START_TAG_NO_ATTS:  case TOK.START_TAG_WITH_ATTS:  	StartTag (b' off' ct' tok);  	break;  case TOK.END_TAG:  	EndTag (b' off' ct' tok);  	break;  case TOK.DATA_CHARS:  case TOK.DATA_NEWLINE:  	AddText (utf.GetString (b' off' ct.TokenEnd - off));  	break;  case TOK.CHAR_REF:  case TOK.MAGIC_ENTITY_REF:  	AddText (new string (new char[] {  		ct.RefChar1  	}));  	break;  case TOK.CHAR_PAIR_REF:  	AddText (new string (new char[] {  		ct.RefChar1'  		ct.RefChar2  	}));  	break;  case TOK.COMMENT:  	if (m_elem != null) {  		// <!-- 4  		//  --> 3  		int start = off + 4 * m_enc.MinBytesPerChar;  		int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  		string text = utf.GetString (b' start' end);  		m_elem.AppendChild (m_doc.CreateComment (text));  	}  	break;  case TOK.CDATA_SECT_OPEN:  	m_cdata = true;  	break;  case TOK.CDATA_SECT_CLOSE:  	m_cdata = false;  	break;  case TOK.XML_DECL:  	// thou shalt use UTF8' and XML version 1.  	// i shall ignore evidence to the contrary...  	// TODO: Throw an exception if these assuptions are  	// wrong  	break;  case TOK.ENTITY_REF:  case TOK.PI:  	throw new System.NotImplementedException ("Token type not implemented: " + tok);  }  
Magic Number,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,Push,The following statement contains a magic number: if (m_elem != null) {  	// <!-- 4  	//  --> 3  	int start = off + 4 * m_enc.MinBytesPerChar;  	int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  	string text = utf.GetString (b' start' end);  	m_elem.AppendChild (m_doc.CreateComment (text));  }  
Magic Number,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,Push,The following statement contains a magic number: if (m_elem != null) {  	// <!-- 4  	//  --> 3  	int start = off + 4 * m_enc.MinBytesPerChar;  	int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  	string text = utf.GetString (b' start' end);  	m_elem.AppendChild (m_doc.CreateComment (text));  }  
Magic Number,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,EndTag,The following statement contains a magic number: if ((tok == TOK.EMPTY_ELEMENT_WITH_ATTS) || (tok == TOK.EMPTY_ELEMENT_NO_ATTS))  	name = utf.GetString (buf' offset + m_enc.MinBytesPerChar' ct.NameEnd - offset - m_enc.MinBytesPerChar);  else  	name = utf.GetString (buf' offset + m_enc.MinBytesPerChar * 2' ct.NameEnd - offset - m_enc.MinBytesPerChar * 2);  
Magic Number,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,EndTag,The following statement contains a magic number: if ((tok == TOK.EMPTY_ELEMENT_WITH_ATTS) || (tok == TOK.EMPTY_ELEMENT_NO_ATTS))  	name = utf.GetString (buf' offset + m_enc.MinBytesPerChar' ct.NameEnd - offset - m_enc.MinBytesPerChar);  else  	name = utf.GetString (buf' offset + m_enc.MinBytesPerChar * 2' ct.NameEnd - offset - m_enc.MinBytesPerChar * 2);  
Magic Number,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,EndTag,The following statement contains a magic number: name = utf.GetString (buf' offset + m_enc.MinBytesPerChar * 2' ct.NameEnd - offset - m_enc.MinBytesPerChar * 2);  
Magic Number,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,EndTag,The following statement contains a magic number: name = utf.GetString (buf' offset + m_enc.MinBytesPerChar * 2' ct.NameEnd - offset - m_enc.MinBytesPerChar * 2);  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: try {  	return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  }  catch {  	return DateTime.MinValue;  }  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: try {  	return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  }  catch {  	return DateTime.MinValue;  }  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: try {  	return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  }  catch {  	return DateTime.MinValue;  }  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: try {  	return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  }  catch {  	return DateTime.MinValue;  }  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: try {  	return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  }  catch {  	return DateTime.MinValue;  }  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: try {  	return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  }  catch {  	return DateTime.MinValue;  }  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: try {  	return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  }  catch {  	return DateTime.MinValue;  }  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: try {  	return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  }  catch {  	return DateTime.MinValue;  }  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: try {  	return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  }  catch {  	return DateTime.MinValue;  }  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: try {  	return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  }  catch {  	return DateTime.MinValue;  }  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: try {  	return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  }  catch {  	return DateTime.MinValue;  }  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  
Magic Number,jabber.protocol,Element,C:\repos\meebey_jabber-net\jabber\protocol\Element.cs,JabberDate,The following statement contains a magic number: return new DateTime (int.Parse (dt.Substring (0' 4))' int.Parse (dt.Substring (4' 2))' int.Parse (dt.Substring (6' 2))' int.Parse (dt.Substring (9' 2))' int.Parse (dt.Substring (12' 2))' int.Parse (dt.Substring (15' 2)));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (BAD_REQUEST' new CodeType (400' ErrorType.modify));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (CONFLICT' new CodeType (409' ErrorType.cancel));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (FEATURE_NOT_IMPLEMENTED' new CodeType (501' ErrorType.cancel));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (FORBIDDEN' new CodeType (403' ErrorType.auth));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (GONE' new CodeType (302' ErrorType.modify));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (INTERNAL_SERVER_ERROR' new CodeType (500' ErrorType.wait));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (ITEM_NOT_FOUND' new CodeType (404' ErrorType.cancel));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (JID_MALFORMED' new CodeType (400' ErrorType.modify));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (NOT_ACCEPTABLE' new CodeType (406' ErrorType.modify));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (NOT_ALLOWED' new CodeType (405' ErrorType.cancel));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (NOT_AUTHORIZED' new CodeType (401' ErrorType.auth));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (PAYMENT_REQUIRED' new CodeType (402' ErrorType.auth));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (RECIPIENT_UNAVAILABLE' new CodeType (404' ErrorType.wait));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (REDIRECT' new CodeType (302' ErrorType.modify));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (REGISTRATION_REQUIRED' new CodeType (407' ErrorType.auth));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (REMOTE_SERVER_NOT_FOUND' new CodeType (404' ErrorType.cancel));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (REMOTE_SERVER_TIMEOUT' new CodeType (504' ErrorType.wait));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (RESOURCE_CONSTRAINT' new CodeType (500' ErrorType.wait));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (SERVICE_UNAVAILABLE' new CodeType (503' ErrorType.cancel));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (SUBSCRIPTION_REQUIRED' new CodeType (407' ErrorType.auth));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (UNDEFINED_CONDITION' new CodeType (500' ErrorType.NONE));  
Magic Number,jabber.protocol.client,Error,C:\repos\meebey_jabber-net\jabber\protocol\client\Error.cs,Error,The following statement contains a magic number: s_errors.Add (UNEXPECTED_REQUEST' new CodeType (400' ErrorType.wait));  
Magic Number,jabber.protocol.client,Presence,C:\repos\meebey_jabber-net\jabber\protocol\client\Presence.cs,IntShow,The following statement contains a magic number: switch (show) {  case "dnd":  	return 0;  case "xa":  	return 1;  case "away":  	return 2;  case "chat":  	return 4;  default:  	return 3;  }  
Magic Number,jabber.protocol.client,Presence,C:\repos\meebey_jabber-net\jabber\protocol\client\Presence.cs,IntShow,The following statement contains a magic number: switch (show) {  case "dnd":  	return 0;  case "xa":  	return 1;  case "away":  	return 2;  case "chat":  	return 4;  default:  	return 3;  }  
Magic Number,jabber.protocol.client,Presence,C:\repos\meebey_jabber-net\jabber\protocol\client\Presence.cs,IntShow,The following statement contains a magic number: switch (show) {  case "dnd":  	return 0;  case "xa":  	return 1;  case "away":  	return 2;  case "chat":  	return 4;  default:  	return 3;  }  
Magic Number,jabber.protocol.client,Presence,C:\repos\meebey_jabber-net\jabber\protocol\client\Presence.cs,IntShow,The following statement contains a magic number: return 2;  
Magic Number,jabber.protocol.client,Presence,C:\repos\meebey_jabber-net\jabber\protocol\client\Presence.cs,IntShow,The following statement contains a magic number: return 4;  
Magic Number,jabber.protocol.client,Presence,C:\repos\meebey_jabber-net\jabber\protocol\client\Presence.cs,IntShow,The following statement contains a magic number: return 3;  
Magic Number,jabber.protocol.client,IQException,C:\repos\meebey_jabber-net\jabber\protocol\client\ProtocolException.cs,IQException,The following statement contains a magic number: if (iq == null) {  	//timeout  	m_code = 504;  	m_message = "Request timed out";  }  else {  	Error e = iq.Error;  	m_code = e.Code;  	m_message = e.InnerText;  }  
Magic Number,jabber.protocol.client,IQException,C:\repos\meebey_jabber-net\jabber\protocol\client\ProtocolException.cs,IQException,The following statement contains a magic number: m_code = 504;  
Magic Number,stringprep.steps,MapStep,C:\repos\meebey_jabber-net\stringprep\steps\MapStep.cs,Prepare,The following statement contains a magic number: for (int i = 0; i < result.Length; i++) {  	pos = Array.BinarySearch (m_table' result [i]' m_comp);  	if (pos < 0)  		continue;  	map = m_table [pos];  	len = map.Length;  	if (len == 1) {  		result.Remove (i' 1);  		i--;  	}  	else {  		result [i] = map [1];  		if (len > 2) {  			result.Insert (i + 1' map.ToCharArray (2' len - 2));  			i += len - 2;  		}  	}  }  
Magic Number,stringprep.steps,MapStep,C:\repos\meebey_jabber-net\stringprep\steps\MapStep.cs,Prepare,The following statement contains a magic number: for (int i = 0; i < result.Length; i++) {  	pos = Array.BinarySearch (m_table' result [i]' m_comp);  	if (pos < 0)  		continue;  	map = m_table [pos];  	len = map.Length;  	if (len == 1) {  		result.Remove (i' 1);  		i--;  	}  	else {  		result [i] = map [1];  		if (len > 2) {  			result.Insert (i + 1' map.ToCharArray (2' len - 2));  			i += len - 2;  		}  	}  }  
Magic Number,stringprep.steps,MapStep,C:\repos\meebey_jabber-net\stringprep\steps\MapStep.cs,Prepare,The following statement contains a magic number: for (int i = 0; i < result.Length; i++) {  	pos = Array.BinarySearch (m_table' result [i]' m_comp);  	if (pos < 0)  		continue;  	map = m_table [pos];  	len = map.Length;  	if (len == 1) {  		result.Remove (i' 1);  		i--;  	}  	else {  		result [i] = map [1];  		if (len > 2) {  			result.Insert (i + 1' map.ToCharArray (2' len - 2));  			i += len - 2;  		}  	}  }  
Magic Number,stringprep.steps,MapStep,C:\repos\meebey_jabber-net\stringprep\steps\MapStep.cs,Prepare,The following statement contains a magic number: for (int i = 0; i < result.Length; i++) {  	pos = Array.BinarySearch (m_table' result [i]' m_comp);  	if (pos < 0)  		continue;  	map = m_table [pos];  	len = map.Length;  	if (len == 1) {  		result.Remove (i' 1);  		i--;  	}  	else {  		result [i] = map [1];  		if (len > 2) {  			result.Insert (i + 1' map.ToCharArray (2' len - 2));  			i += len - 2;  		}  	}  }  
Magic Number,stringprep.steps,MapStep,C:\repos\meebey_jabber-net\stringprep\steps\MapStep.cs,Prepare,The following statement contains a magic number: if (len == 1) {  	result.Remove (i' 1);  	i--;  }  else {  	result [i] = map [1];  	if (len > 2) {  		result.Insert (i + 1' map.ToCharArray (2' len - 2));  		i += len - 2;  	}  }  
Magic Number,stringprep.steps,MapStep,C:\repos\meebey_jabber-net\stringprep\steps\MapStep.cs,Prepare,The following statement contains a magic number: if (len == 1) {  	result.Remove (i' 1);  	i--;  }  else {  	result [i] = map [1];  	if (len > 2) {  		result.Insert (i + 1' map.ToCharArray (2' len - 2));  		i += len - 2;  	}  }  
Magic Number,stringprep.steps,MapStep,C:\repos\meebey_jabber-net\stringprep\steps\MapStep.cs,Prepare,The following statement contains a magic number: if (len == 1) {  	result.Remove (i' 1);  	i--;  }  else {  	result [i] = map [1];  	if (len > 2) {  		result.Insert (i + 1' map.ToCharArray (2' len - 2));  		i += len - 2;  	}  }  
Magic Number,stringprep.steps,MapStep,C:\repos\meebey_jabber-net\stringprep\steps\MapStep.cs,Prepare,The following statement contains a magic number: if (len == 1) {  	result.Remove (i' 1);  	i--;  }  else {  	result [i] = map [1];  	if (len > 2) {  		result.Insert (i + 1' map.ToCharArray (2' len - 2));  		i += len - 2;  	}  }  
Magic Number,stringprep.steps,MapStep,C:\repos\meebey_jabber-net\stringprep\steps\MapStep.cs,Prepare,The following statement contains a magic number: if (len > 2) {  	result.Insert (i + 1' map.ToCharArray (2' len - 2));  	i += len - 2;  }  
Magic Number,stringprep.steps,MapStep,C:\repos\meebey_jabber-net\stringprep\steps\MapStep.cs,Prepare,The following statement contains a magic number: if (len > 2) {  	result.Insert (i + 1' map.ToCharArray (2' len - 2));  	i += len - 2;  }  
Magic Number,stringprep.steps,MapStep,C:\repos\meebey_jabber-net\stringprep\steps\MapStep.cs,Prepare,The following statement contains a magic number: if (len > 2) {  	result.Insert (i + 1' map.ToCharArray (2' len - 2));  	i += len - 2;  }  
Magic Number,stringprep.steps,MapStep,C:\repos\meebey_jabber-net\stringprep\steps\MapStep.cs,Prepare,The following statement contains a magic number: if (len > 2) {  	result.Insert (i + 1' map.ToCharArray (2' len - 2));  	i += len - 2;  }  
Magic Number,stringprep.steps,MapStep,C:\repos\meebey_jabber-net\stringprep\steps\MapStep.cs,Prepare,The following statement contains a magic number: result.Insert (i + 1' map.ToCharArray (2' len - 2));  
Magic Number,stringprep.steps,MapStep,C:\repos\meebey_jabber-net\stringprep\steps\MapStep.cs,Prepare,The following statement contains a magic number: result.Insert (i + 1' map.ToCharArray (2' len - 2));  
Magic Number,stringprep.steps,MapStep,C:\repos\meebey_jabber-net\stringprep\steps\MapStep.cs,Prepare,The following statement contains a magic number: i += len - 2;  
Magic Number,stringprep.unicode,Combining,C:\repos\meebey_jabber-net\stringprep\unicode\Combining.cs,Class,The following statement contains a magic number: if (CombiningData.Pages [page] == 255)  	return 0;  else  	return CombiningData.Classes [CombiningData.Pages [page]' c & 0xff];  
Magic Number,stringprep.unicode,Compose,C:\repos\meebey_jabber-net\stringprep\unicode\Compose.cs,Index,The following statement contains a magic number: if (ComposeData.Table [p] == 255)  	return 0;  else  	return ComposeData.Data [ComposeData.Table [p]' c & 0xff];  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end) {  	checkCharMatches (buf' off' '-');  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_MINUS:  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '-')) {  				if ((off += minBPC) == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.TokenEnd = off + minBPC;  				return TOK.COMMENT;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end) {  	checkCharMatches (buf' off' '-');  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_MINUS:  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '-')) {  				if ((off += minBPC) == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.TokenEnd = off + minBPC;  				return TOK.COMMENT;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end) {  	checkCharMatches (buf' off' '-');  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_MINUS:  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '-')) {  				if ((off += minBPC) == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.TokenEnd = off + minBPC;  				return TOK.COMMENT;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end) {  	checkCharMatches (buf' off' '-');  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_MINUS:  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '-')) {  				if ((off += minBPC) == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.TokenEnd = off + minBPC;  				return TOK.COMMENT;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end) {  	checkCharMatches (buf' off' '-');  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_MINUS:  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '-')) {  				if ((off += minBPC) == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.TokenEnd = off + minBPC;  				return TOK.COMMENT;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end) {  	checkCharMatches (buf' off' '-');  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_MINUS:  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '-')) {  				if ((off += minBPC) == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.TokenEnd = off + minBPC;  				return TOK.COMMENT;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_MINUS:  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '-')) {  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.TokenEnd = off + minBPC;  			return TOK.COMMENT;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_MINUS:  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '-')) {  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.TokenEnd = off + minBPC;  			return TOK.COMMENT;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_MINUS:  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '-')) {  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.TokenEnd = off + minBPC;  			return TOK.COMMENT;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_MINUS:  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '-')) {  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.TokenEnd = off + minBPC;  			return TOK.COMMENT;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_MINUS:  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '-')) {  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.TokenEnd = off + minBPC;  			return TOK.COMMENT;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_MINUS:  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '-')) {  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.TokenEnd = off + minBPC;  			return TOK.COMMENT;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_MINUS:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '-')) {  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.COMMENT;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_MINUS:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '-')) {  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.COMMENT;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_MINUS:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '-')) {  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.COMMENT;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_MINUS:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '-')) {  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.COMMENT;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_MINUS:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '-')) {  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.COMMENT;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_MINUS:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '-')) {  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.COMMENT;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanComment,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,targetIsXml,The following statement contains a magic number: if (end - off != minBPC * 3)  	return false;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUEST:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '>')) {  			token.TokenEnd = off + minBPC;  			if (isXml)  				return TOK.XML_DECL;  			else  				return TOK.PI;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUEST:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '>')) {  			token.TokenEnd = off + minBPC;  			if (isXml)  				return TOK.XML_DECL;  			else  				return TOK.PI;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUEST:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '>')) {  			token.TokenEnd = off + minBPC;  			if (isXml)  				return TOK.XML_DECL;  			else  				return TOK.PI;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUEST:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '>')) {  			token.TokenEnd = off + minBPC;  			if (isXml)  				return TOK.XML_DECL;  			else  				return TOK.PI;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUEST:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '>')) {  			token.TokenEnd = off + minBPC;  			if (isXml)  				return TOK.XML_DECL;  			else  				return TOK.PI;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUEST:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '>')) {  			token.TokenEnd = off + minBPC;  			if (isXml)  				return TOK.XML_DECL;  			else  				return TOK.PI;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUEST:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '>')) {  		token.TokenEnd = off + minBPC;  		if (isXml)  			return TOK.XML_DECL;  		else  			return TOK.PI;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUEST:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '>')) {  		token.TokenEnd = off + minBPC;  		if (isXml)  			return TOK.XML_DECL;  		else  			return TOK.PI;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUEST:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '>')) {  		token.TokenEnd = off + minBPC;  		if (isXml)  			return TOK.XML_DECL;  		else  			return TOK.PI;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUEST:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '>')) {  		token.TokenEnd = off + minBPC;  		if (isXml)  			return TOK.XML_DECL;  		else  			return TOK.PI;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUEST:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '>')) {  		token.TokenEnd = off + minBPC;  		if (isXml)  			return TOK.XML_DECL;  		else  			return TOK.PI;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUEST:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '>')) {  		token.TokenEnd = off + minBPC;  		if (isXml)  			return TOK.XML_DECL;  		else  			return TOK.PI;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanCdataSection,The following statement contains a magic number: if (end - off < 6 * minBPC)  	throw new PartialTokenException ();  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	token.TokenEnd = off + minBPC;  	return TOK.CDATA_SECT_CLOSE;  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	token.TokenEnd = off + minBPC;  	return TOK.CDATA_SECT_CLOSE;  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	token.TokenEnd = off + minBPC;  	return TOK.CDATA_SECT_CLOSE;  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	token.TokenEnd = off + minBPC;  	return TOK.CDATA_SECT_CLOSE;  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	token.TokenEnd = off + minBPC;  	return TOK.CDATA_SECT_CLOSE;  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	token.TokenEnd = off + minBPC;  	return TOK.CDATA_SECT_CLOSE;  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: if (end - off < 2)  	return off;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: if (end - off < 3)  	return off;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: if (end - off < 4)  	return off;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		for (off += minBPC; off != end; off += minBPC) {  			switch (byteType (buf' off)) {  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.TokenEnd = off + minBPC;  				return TOK.END_TAG;  			default:  				throw new InvalidTokenException (off);  			}  		}  		throw new PartialTokenException ();  	case BT_GT:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.END_TAG;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		for (off += minBPC; off != end; off += minBPC) {  			switch (byteType (buf' off)) {  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.TokenEnd = off + minBPC;  				return TOK.END_TAG;  			default:  				throw new InvalidTokenException (off);  			}  		}  		throw new PartialTokenException ();  	case BT_GT:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.END_TAG;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		for (off += minBPC; off != end; off += minBPC) {  			switch (byteType (buf' off)) {  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.TokenEnd = off + minBPC;  				return TOK.END_TAG;  			default:  				throw new InvalidTokenException (off);  			}  		}  		throw new PartialTokenException ();  	case BT_GT:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.END_TAG;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		for (off += minBPC; off != end; off += minBPC) {  			switch (byteType (buf' off)) {  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.TokenEnd = off + minBPC;  				return TOK.END_TAG;  			default:  				throw new InvalidTokenException (off);  			}  		}  		throw new PartialTokenException ();  	case BT_GT:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.END_TAG;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		for (off += minBPC; off != end; off += minBPC) {  			switch (byteType (buf' off)) {  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.TokenEnd = off + minBPC;  				return TOK.END_TAG;  			default:  				throw new InvalidTokenException (off);  			}  		}  		throw new PartialTokenException ();  	case BT_GT:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.END_TAG;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		for (off += minBPC; off != end; off += minBPC) {  			switch (byteType (buf' off)) {  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.TokenEnd = off + minBPC;  				return TOK.END_TAG;  			default:  				throw new InvalidTokenException (off);  			}  		}  		throw new PartialTokenException ();  	case BT_GT:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.END_TAG;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	for (off += minBPC; off != end; off += minBPC) {  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.TokenEnd = off + minBPC;  			return TOK.END_TAG;  		default:  			throw new InvalidTokenException (off);  		}  	}  	throw new PartialTokenException ();  case BT_GT:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.END_TAG;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	for (off += minBPC; off != end; off += minBPC) {  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.TokenEnd = off + minBPC;  			return TOK.END_TAG;  		default:  			throw new InvalidTokenException (off);  		}  	}  	throw new PartialTokenException ();  case BT_GT:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.END_TAG;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	for (off += minBPC; off != end; off += minBPC) {  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.TokenEnd = off + minBPC;  			return TOK.END_TAG;  		default:  			throw new InvalidTokenException (off);  		}  	}  	throw new PartialTokenException ();  case BT_GT:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.END_TAG;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	for (off += minBPC; off != end; off += minBPC) {  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.TokenEnd = off + minBPC;  			return TOK.END_TAG;  		default:  			throw new InvalidTokenException (off);  		}  	}  	throw new PartialTokenException ();  case BT_GT:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.END_TAG;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	for (off += minBPC; off != end; off += minBPC) {  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.TokenEnd = off + minBPC;  			return TOK.END_TAG;  		default:  			throw new InvalidTokenException (off);  		}  	}  	throw new PartialTokenException ();  case BT_GT:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.END_TAG;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	for (off += minBPC; off != end; off += minBPC) {  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.TokenEnd = off + minBPC;  			return TOK.END_TAG;  		default:  			throw new InvalidTokenException (off);  		}  	}  	throw new PartialTokenException ();  case BT_GT:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.END_TAG;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end) {  	int c = byteToAscii (buf' off);  	int num;  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = c - ('a' - 10);  		break;  	default:  		throw new InvalidTokenException (off);  	}  	for (off += minBPC; off != end; off += minBPC) {  		c = byteToAscii (buf' off);  		switch (c) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			num = (num << 4) + c - '0';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			num = (num << 4) + c - ('A' - 10);  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			num = (num << 4) + c - ('a' - 10);  			break;  		case ';':  			token.TokenEnd = off + minBPC;  			return setRefChar (num' token);  		default:  			throw new InvalidTokenException (off);  		}  		if (num >= 0x110000)  			throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end) {  	int c = byteToAscii (buf' off);  	int num;  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = c - ('a' - 10);  		break;  	default:  		throw new InvalidTokenException (off);  	}  	for (off += minBPC; off != end; off += minBPC) {  		c = byteToAscii (buf' off);  		switch (c) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			num = (num << 4) + c - '0';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			num = (num << 4) + c - ('A' - 10);  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			num = (num << 4) + c - ('a' - 10);  			break;  		case ';':  			token.TokenEnd = off + minBPC;  			return setRefChar (num' token);  		default:  			throw new InvalidTokenException (off);  		}  		if (num >= 0x110000)  			throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end) {  	int c = byteToAscii (buf' off);  	int num;  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = c - ('a' - 10);  		break;  	default:  		throw new InvalidTokenException (off);  	}  	for (off += minBPC; off != end; off += minBPC) {  		c = byteToAscii (buf' off);  		switch (c) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			num = (num << 4) + c - '0';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			num = (num << 4) + c - ('A' - 10);  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			num = (num << 4) + c - ('a' - 10);  			break;  		case ';':  			token.TokenEnd = off + minBPC;  			return setRefChar (num' token);  		default:  			throw new InvalidTokenException (off);  		}  		if (num >= 0x110000)  			throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end) {  	int c = byteToAscii (buf' off);  	int num;  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = c - ('a' - 10);  		break;  	default:  		throw new InvalidTokenException (off);  	}  	for (off += minBPC; off != end; off += minBPC) {  		c = byteToAscii (buf' off);  		switch (c) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			num = (num << 4) + c - '0';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			num = (num << 4) + c - ('A' - 10);  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			num = (num << 4) + c - ('a' - 10);  			break;  		case ';':  			token.TokenEnd = off + minBPC;  			return setRefChar (num' token);  		default:  			throw new InvalidTokenException (off);  		}  		if (num >= 0x110000)  			throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end) {  	int c = byteToAscii (buf' off);  	int num;  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = c - ('a' - 10);  		break;  	default:  		throw new InvalidTokenException (off);  	}  	for (off += minBPC; off != end; off += minBPC) {  		c = byteToAscii (buf' off);  		switch (c) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			num = (num << 4) + c - '0';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			num = (num << 4) + c - ('A' - 10);  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			num = (num << 4) + c - ('a' - 10);  			break;  		case ';':  			token.TokenEnd = off + minBPC;  			return setRefChar (num' token);  		default:  			throw new InvalidTokenException (off);  		}  		if (num >= 0x110000)  			throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end) {  	int c = byteToAscii (buf' off);  	int num;  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = c - ('a' - 10);  		break;  	default:  		throw new InvalidTokenException (off);  	}  	for (off += minBPC; off != end; off += minBPC) {  		c = byteToAscii (buf' off);  		switch (c) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			num = (num << 4) + c - '0';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			num = (num << 4) + c - ('A' - 10);  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			num = (num << 4) + c - ('a' - 10);  			break;  		case ';':  			token.TokenEnd = off + minBPC;  			return setRefChar (num' token);  		default:  			throw new InvalidTokenException (off);  		}  		if (num >= 0x110000)  			throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end) {  	int c = byteToAscii (buf' off);  	int num;  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = c - ('a' - 10);  		break;  	default:  		throw new InvalidTokenException (off);  	}  	for (off += minBPC; off != end; off += minBPC) {  		c = byteToAscii (buf' off);  		switch (c) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			num = (num << 4) + c - '0';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			num = (num << 4) + c - ('A' - 10);  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			num = (num << 4) + c - ('a' - 10);  			break;  		case ';':  			token.TokenEnd = off + minBPC;  			return setRefChar (num' token);  		default:  			throw new InvalidTokenException (off);  		}  		if (num >= 0x110000)  			throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	num = c - '0';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	num = c - ('A' - 10);  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	num = c - ('a' - 10);  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	num = c - '0';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	num = c - ('A' - 10);  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	num = c - ('a' - 10);  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: num = c - ('A' - 10);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: num = c - ('a' - 10);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: for (off += minBPC; off != end; off += minBPC) {  	c = byteToAscii (buf' off);  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = (num << 4) + c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = (num << 4) + c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = (num << 4) + c - ('a' - 10);  		break;  	case ';':  		token.TokenEnd = off + minBPC;  		return setRefChar (num' token);  	default:  		throw new InvalidTokenException (off);  	}  	if (num >= 0x110000)  		throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: for (off += minBPC; off != end; off += minBPC) {  	c = byteToAscii (buf' off);  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = (num << 4) + c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = (num << 4) + c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = (num << 4) + c - ('a' - 10);  		break;  	case ';':  		token.TokenEnd = off + minBPC;  		return setRefChar (num' token);  	default:  		throw new InvalidTokenException (off);  	}  	if (num >= 0x110000)  		throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: for (off += minBPC; off != end; off += minBPC) {  	c = byteToAscii (buf' off);  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = (num << 4) + c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = (num << 4) + c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = (num << 4) + c - ('a' - 10);  		break;  	case ';':  		token.TokenEnd = off + minBPC;  		return setRefChar (num' token);  	default:  		throw new InvalidTokenException (off);  	}  	if (num >= 0x110000)  		throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: for (off += minBPC; off != end; off += minBPC) {  	c = byteToAscii (buf' off);  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = (num << 4) + c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = (num << 4) + c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = (num << 4) + c - ('a' - 10);  		break;  	case ';':  		token.TokenEnd = off + minBPC;  		return setRefChar (num' token);  	default:  		throw new InvalidTokenException (off);  	}  	if (num >= 0x110000)  		throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: for (off += minBPC; off != end; off += minBPC) {  	c = byteToAscii (buf' off);  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = (num << 4) + c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = (num << 4) + c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = (num << 4) + c - ('a' - 10);  		break;  	case ';':  		token.TokenEnd = off + minBPC;  		return setRefChar (num' token);  	default:  		throw new InvalidTokenException (off);  	}  	if (num >= 0x110000)  		throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	num = (num << 4) + c - '0';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	num = (num << 4) + c - ('A' - 10);  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	num = (num << 4) + c - ('a' - 10);  	break;  case ';':  	token.TokenEnd = off + minBPC;  	return setRefChar (num' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	num = (num << 4) + c - '0';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	num = (num << 4) + c - ('A' - 10);  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	num = (num << 4) + c - ('a' - 10);  	break;  case ';':  	token.TokenEnd = off + minBPC;  	return setRefChar (num' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	num = (num << 4) + c - '0';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	num = (num << 4) + c - ('A' - 10);  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	num = (num << 4) + c - ('a' - 10);  	break;  case ';':  	token.TokenEnd = off + minBPC;  	return setRefChar (num' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	num = (num << 4) + c - '0';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	num = (num << 4) + c - ('A' - 10);  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	num = (num << 4) + c - ('a' - 10);  	break;  case ';':  	token.TokenEnd = off + minBPC;  	return setRefChar (num' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	num = (num << 4) + c - '0';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	num = (num << 4) + c - ('A' - 10);  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	num = (num << 4) + c - ('a' - 10);  	break;  case ';':  	token.TokenEnd = off + minBPC;  	return setRefChar (num' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: num = (num << 4) + c - '0';  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: num = (num << 4) + c - ('A' - 10);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: num = (num << 4) + c - ('A' - 10);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: num = (num << 4) + c - ('a' - 10);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: num = (num << 4) + c - ('a' - 10);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanCharRef,The following statement contains a magic number: if (off != end) {  	int c = byteToAscii (buf' off);  	switch (c) {  	case 'x':  		return scanHexCharRef (buf' off + minBPC' end' token);  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		break;  	default:  		throw new InvalidTokenException (off);  	}  	int num = c - '0';  	for (off += minBPC; off != end; off += minBPC) {  		c = byteToAscii (buf' off);  		switch (c) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			num = num * 10 + (c - '0');  			if (num < 0x110000)  				break;  			/* fall through */goto default;  		default:  			throw new InvalidTokenException (off);  		case ';':  			token.TokenEnd = off + minBPC;  			return setRefChar (num' token);  		}  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanCharRef,The following statement contains a magic number: for (off += minBPC; off != end; off += minBPC) {  	c = byteToAscii (buf' off);  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = num * 10 + (c - '0');  		if (num < 0x110000)  			break;  		/* fall through */goto default;  	default:  		throw new InvalidTokenException (off);  	case ';':  		token.TokenEnd = off + minBPC;  		return setRefChar (num' token);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanCharRef,The following statement contains a magic number: switch (c) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	num = num * 10 + (c - '0');  	if (num < 0x110000)  		break;  	/* fall through */goto default;  default:  	throw new InvalidTokenException (off);  case ';':  	token.TokenEnd = off + minBPC;  	return setRefChar (num' token);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanCharRef,The following statement contains a magic number: num = num * 10 + (c - '0');  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setRefChar,The following statement contains a magic number: if (num < 0x10000) {  	switch (charTypeTable [num >> 8] [num & 0xFF]) {  	case BT_NONXML:  	case BT_LEAD4:  	case BT_MALFORM:  		throw new InvalidTokenException (token.TokenEnd - minBPC);  	}  	token.RefChar1 = (char)num;  	return TOK.CHAR_REF;  }  else {  	num -= 0x10000;  	token.RefChar1 = (char)((num >> 10) + 0xD800);  	token.RefChar2 = (char)((num & ((1 << 10) - 1)) + 0xDC00);  	return TOK.CHAR_PAIR_REF;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setRefChar,The following statement contains a magic number: if (num < 0x10000) {  	switch (charTypeTable [num >> 8] [num & 0xFF]) {  	case BT_NONXML:  	case BT_LEAD4:  	case BT_MALFORM:  		throw new InvalidTokenException (token.TokenEnd - minBPC);  	}  	token.RefChar1 = (char)num;  	return TOK.CHAR_REF;  }  else {  	num -= 0x10000;  	token.RefChar1 = (char)((num >> 10) + 0xD800);  	token.RefChar2 = (char)((num & ((1 << 10) - 1)) + 0xDC00);  	return TOK.CHAR_PAIR_REF;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setRefChar,The following statement contains a magic number: if (num < 0x10000) {  	switch (charTypeTable [num >> 8] [num & 0xFF]) {  	case BT_NONXML:  	case BT_LEAD4:  	case BT_MALFORM:  		throw new InvalidTokenException (token.TokenEnd - minBPC);  	}  	token.RefChar1 = (char)num;  	return TOK.CHAR_REF;  }  else {  	num -= 0x10000;  	token.RefChar1 = (char)((num >> 10) + 0xD800);  	token.RefChar2 = (char)((num & ((1 << 10) - 1)) + 0xDC00);  	return TOK.CHAR_PAIR_REF;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setRefChar,The following statement contains a magic number: switch (charTypeTable [num >> 8] [num & 0xFF]) {  case BT_NONXML:  case BT_LEAD4:  case BT_MALFORM:  	throw new InvalidTokenException (token.TokenEnd - minBPC);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setRefChar,The following statement contains a magic number: token.RefChar1 = (char)((num >> 10) + 0xD800);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setRefChar,The following statement contains a magic number: token.RefChar2 = (char)((num & ((1 << 10) - 1)) + 0xDC00);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off < minBPC * 4)  	break;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  	token.TokenEnd = off + minBPC * 4;  	token.RefChar1 = '&';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  	token.TokenEnd = off + minBPC * 4;  	token.RefChar1 = '&';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  	token.TokenEnd = off + minBPC * 4;  	token.RefChar1 = '&';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: token.TokenEnd = off + minBPC * 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '\'';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '\'';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '\'';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '\'';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '\'';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: token.TokenEnd = off + minBPC * 5;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  	token.TokenEnd = off + minBPC * 3;  	token.RefChar1 = '<';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  	token.TokenEnd = off + minBPC * 3;  	token.RefChar1 = '<';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  	token.TokenEnd = off + minBPC * 3;  	token.RefChar1 = '<';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: token.TokenEnd = off + minBPC * 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  	token.TokenEnd = off + minBPC * 3;  	token.RefChar1 = '>';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  	token.TokenEnd = off + minBPC * 3;  	token.RefChar1 = '>';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  	token.TokenEnd = off + minBPC * 3;  	token.RefChar1 = '>';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: token.TokenEnd = off + minBPC * 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '"';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '"';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '"';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '"';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '"';  	return true;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: token.TokenEnd = off + minBPC * 5;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_NUM:  	return scanCharRef (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_NUM:  	return scanCharRef (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_NUM:  	return scanCharRef (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_NUM:  	return scanCharRef (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_NUM:  	return scanCharRef (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_NUM:  	return scanCharRef (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanRef,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	if (t == open)  		break;  	switch (t) {  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_AMP: {  		normalized = false;  		int saveNameEnd = token.NameEnd;  		scanRef (buf' off + minBPC' end' token);  		token.NameEnd = saveNameEnd;  		off = token.TokenEnd;  		break;  	}  	case BT_S:  		if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  			normalized = false;  		off += minBPC;  		break;  	case BT_LT:  		throw new InvalidTokenException (off);  	case BT_LF:  	case BT_CR:  		normalized = false;  		/* fall through */goto default;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	if (t == open)  		break;  	switch (t) {  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_AMP: {  		normalized = false;  		int saveNameEnd = token.NameEnd;  		scanRef (buf' off + minBPC' end' token);  		token.NameEnd = saveNameEnd;  		off = token.TokenEnd;  		break;  	}  	case BT_S:  		if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  			normalized = false;  		off += minBPC;  		break;  	case BT_LT:  		throw new InvalidTokenException (off);  	case BT_LF:  	case BT_CR:  		normalized = false;  		/* fall through */goto default;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	if (t == open)  		break;  	switch (t) {  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_AMP: {  		normalized = false;  		int saveNameEnd = token.NameEnd;  		scanRef (buf' off + minBPC' end' token);  		token.NameEnd = saveNameEnd;  		off = token.TokenEnd;  		break;  	}  	case BT_S:  		if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  			normalized = false;  		off += minBPC;  		break;  	case BT_LT:  		throw new InvalidTokenException (off);  	case BT_LF:  	case BT_CR:  		normalized = false;  		/* fall through */goto default;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	if (t == open)  		break;  	switch (t) {  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_AMP: {  		normalized = false;  		int saveNameEnd = token.NameEnd;  		scanRef (buf' off + minBPC' end' token);  		token.NameEnd = saveNameEnd;  		off = token.TokenEnd;  		break;  	}  	case BT_S:  		if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  			normalized = false;  		off += minBPC;  		break;  	case BT_LT:  		throw new InvalidTokenException (off);  	case BT_LF:  	case BT_CR:  		normalized = false;  		/* fall through */goto default;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	if (t == open)  		break;  	switch (t) {  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_AMP: {  		normalized = false;  		int saveNameEnd = token.NameEnd;  		scanRef (buf' off + minBPC' end' token);  		token.NameEnd = saveNameEnd;  		off = token.TokenEnd;  		break;  	}  	case BT_S:  		if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  			normalized = false;  		off += minBPC;  		break;  	case BT_LT:  		throw new InvalidTokenException (off);  	case BT_LF:  	case BT_CR:  		normalized = false;  		/* fall through */goto default;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	if (t == open)  		break;  	switch (t) {  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_AMP: {  		normalized = false;  		int saveNameEnd = token.NameEnd;  		scanRef (buf' off + minBPC' end' token);  		token.NameEnd = saveNameEnd;  		off = token.TokenEnd;  		break;  	}  	case BT_S:  		if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  			normalized = false;  		off += minBPC;  		break;  	case BT_LT:  		throw new InvalidTokenException (off);  	case BT_LF:  	case BT_CR:  		normalized = false;  		/* fall through */goto default;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_AMP: {  	normalized = false;  	int saveNameEnd = token.NameEnd;  	scanRef (buf' off + minBPC' end' token);  	token.NameEnd = saveNameEnd;  	off = token.TokenEnd;  	break;  }  case BT_S:  	if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  		normalized = false;  	off += minBPC;  	break;  case BT_LT:  	throw new InvalidTokenException (off);  case BT_LF:  case BT_CR:  	normalized = false;  	/* fall through */goto default;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_AMP: {  	normalized = false;  	int saveNameEnd = token.NameEnd;  	scanRef (buf' off + minBPC' end' token);  	token.NameEnd = saveNameEnd;  	off = token.TokenEnd;  	break;  }  case BT_S:  	if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  		normalized = false;  	off += minBPC;  	break;  case BT_LT:  	throw new InvalidTokenException (off);  case BT_LF:  case BT_CR:  	normalized = false;  	/* fall through */goto default;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_AMP: {  	normalized = false;  	int saveNameEnd = token.NameEnd;  	scanRef (buf' off + minBPC' end' token);  	token.NameEnd = saveNameEnd;  	off = token.TokenEnd;  	break;  }  case BT_S:  	if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  		normalized = false;  	off += minBPC;  	break;  case BT_LT:  	throw new InvalidTokenException (off);  case BT_LF:  case BT_CR:  	normalized = false;  	/* fall through */goto default;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_AMP: {  	normalized = false;  	int saveNameEnd = token.NameEnd;  	scanRef (buf' off + minBPC' end' token);  	token.NameEnd = saveNameEnd;  	off = token.TokenEnd;  	break;  }  case BT_S:  	if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  		normalized = false;  	off += minBPC;  	break;  case BT_LT:  	throw new InvalidTokenException (off);  case BT_LF:  case BT_CR:  	normalized = false;  	/* fall through */goto default;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_AMP: {  	normalized = false;  	int saveNameEnd = token.NameEnd;  	scanRef (buf' off + minBPC' end' token);  	token.NameEnd = saveNameEnd;  	off = token.TokenEnd;  	break;  }  case BT_S:  	if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  		normalized = false;  	off += minBPC;  	break;  case BT_LT:  	throw new InvalidTokenException (off);  case BT_LF:  case BT_CR:  	normalized = false;  	/* fall through */goto default;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_AMP: {  	normalized = false;  	int saveNameEnd = token.NameEnd;  	scanRef (buf' off + minBPC' end' token);  	token.NameEnd = saveNameEnd;  	off = token.TokenEnd;  	break;  }  case BT_S:  	if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  		normalized = false;  	off += minBPC;  	break;  case BT_LT:  	throw new InvalidTokenException (off);  case BT_LF:  case BT_CR:  	normalized = false;  	/* fall through */goto default;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	switch (t) {  	case BT_NMSTRT:  		nameStart = off;  		off += minBPC;  		goto skipToName;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 2;  		goto skipToName;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 3;  		goto skipToName;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 4;  		goto skipToName;  	case BT_S:  	case BT_CR:  	case BT_LF:  		break;  	case BT_GT:  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_WITH_ATTS;  	case BT_SOL:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_WITH_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	switch (t) {  	case BT_NMSTRT:  		nameStart = off;  		off += minBPC;  		goto skipToName;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 2;  		goto skipToName;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 3;  		goto skipToName;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 4;  		goto skipToName;  	case BT_S:  	case BT_CR:  	case BT_LF:  		break;  	case BT_GT:  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_WITH_ATTS;  	case BT_SOL:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_WITH_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	switch (t) {  	case BT_NMSTRT:  		nameStart = off;  		off += minBPC;  		goto skipToName;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 2;  		goto skipToName;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 3;  		goto skipToName;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 4;  		goto skipToName;  	case BT_S:  	case BT_CR:  	case BT_LF:  		break;  	case BT_GT:  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_WITH_ATTS;  	case BT_SOL:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_WITH_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	switch (t) {  	case BT_NMSTRT:  		nameStart = off;  		off += minBPC;  		goto skipToName;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 2;  		goto skipToName;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 3;  		goto skipToName;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 4;  		goto skipToName;  	case BT_S:  	case BT_CR:  	case BT_LF:  		break;  	case BT_GT:  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_WITH_ATTS;  	case BT_SOL:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_WITH_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	switch (t) {  	case BT_NMSTRT:  		nameStart = off;  		off += minBPC;  		goto skipToName;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 2;  		goto skipToName;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 3;  		goto skipToName;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 4;  		goto skipToName;  	case BT_S:  	case BT_CR:  	case BT_LF:  		break;  	case BT_GT:  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_WITH_ATTS;  	case BT_SOL:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_WITH_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	switch (t) {  	case BT_NMSTRT:  		nameStart = off;  		off += minBPC;  		goto skipToName;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 2;  		goto skipToName;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 3;  		goto skipToName;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 4;  		goto skipToName;  	case BT_S:  	case BT_CR:  	case BT_LF:  		break;  	case BT_GT:  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_WITH_ATTS;  	case BT_SOL:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_WITH_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NMSTRT:  	nameStart = off;  	off += minBPC;  	goto skipToName;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 2;  	goto skipToName;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 3;  	goto skipToName;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 4;  	goto skipToName;  case BT_S:  case BT_CR:  case BT_LF:  	break;  case BT_GT:  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_WITH_ATTS;  case BT_SOL:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_WITH_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NMSTRT:  	nameStart = off;  	off += minBPC;  	goto skipToName;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 2;  	goto skipToName;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 3;  	goto skipToName;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 4;  	goto skipToName;  case BT_S:  case BT_CR:  case BT_LF:  	break;  case BT_GT:  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_WITH_ATTS;  case BT_SOL:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_WITH_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NMSTRT:  	nameStart = off;  	off += minBPC;  	goto skipToName;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 2;  	goto skipToName;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 3;  	goto skipToName;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 4;  	goto skipToName;  case BT_S:  case BT_CR:  case BT_LF:  	break;  case BT_GT:  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_WITH_ATTS;  case BT_SOL:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_WITH_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NMSTRT:  	nameStart = off;  	off += minBPC;  	goto skipToName;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 2;  	goto skipToName;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 3;  	goto skipToName;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 4;  	goto skipToName;  case BT_S:  case BT_CR:  case BT_LF:  	break;  case BT_GT:  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_WITH_ATTS;  case BT_SOL:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_WITH_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NMSTRT:  	nameStart = off;  	off += minBPC;  	goto skipToName;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 2;  	goto skipToName;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 3;  	goto skipToName;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 4;  	goto skipToName;  case BT_S:  case BT_CR:  case BT_LF:  	break;  case BT_GT:  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_WITH_ATTS;  case BT_SOL:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_WITH_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NMSTRT:  	nameStart = off;  	off += minBPC;  	goto skipToName;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 2;  	goto skipToName;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 3;  	goto skipToName;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 4;  	goto skipToName;  case BT_S:  case BT_CR:  case BT_LF:  	break;  case BT_GT:  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_WITH_ATTS;  case BT_SOL:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_WITH_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_EXCL:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_MINUS:  		return scanComment (buf' off + minBPC' end' token);  	case BT_LSQB:  		return scanCdataSection (buf' off + minBPC' end' token);  	}  	throw new InvalidTokenException (off);  case BT_QUEST:  	return scanPi (buf' off + minBPC' end' token);  case BT_SOL:  	return scanEndTag (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_EXCL:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_MINUS:  		return scanComment (buf' off + minBPC' end' token);  	case BT_LSQB:  		return scanCdataSection (buf' off + minBPC' end' token);  	}  	throw new InvalidTokenException (off);  case BT_QUEST:  	return scanPi (buf' off + minBPC' end' token);  case BT_SOL:  	return scanEndTag (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_EXCL:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_MINUS:  		return scanComment (buf' off + minBPC' end' token);  	case BT_LSQB:  		return scanCdataSection (buf' off + minBPC' end' token);  	}  	throw new InvalidTokenException (off);  case BT_QUEST:  	return scanPi (buf' off + minBPC' end' token);  case BT_SOL:  	return scanEndTag (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_EXCL:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_MINUS:  		return scanComment (buf' off + minBPC' end' token);  	case BT_LSQB:  		return scanCdataSection (buf' off + minBPC' end' token);  	}  	throw new InvalidTokenException (off);  case BT_QUEST:  	return scanPi (buf' off + minBPC' end' token);  case BT_SOL:  	return scanEndTag (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_EXCL:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_MINUS:  		return scanComment (buf' off + minBPC' end' token);  	case BT_LSQB:  		return scanCdataSection (buf' off + minBPC' end' token);  	}  	throw new InvalidTokenException (off);  case BT_QUEST:  	return scanPi (buf' off + minBPC' end' token);  case BT_SOL:  	return scanEndTag (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_EXCL:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_MINUS:  		return scanComment (buf' off + minBPC' end' token);  	case BT_LSQB:  		return scanCdataSection (buf' off + minBPC' end' token);  	}  	throw new InvalidTokenException (off);  case BT_QUEST:  	return scanPi (buf' off + minBPC' end' token);  case BT_SOL:  	return scanEndTag (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  		return scanAtts (off' buf' off + minBPC' end' token);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 2' end' token);  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 3' end' token);  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 4' end' token);  	case BT_GT:  	case BT_SOL:  		goto loop;  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		break;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  		return scanAtts (off' buf' off + minBPC' end' token);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 2' end' token);  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 3' end' token);  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 4' end' token);  	case BT_GT:  	case BT_SOL:  		goto loop;  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		break;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  		return scanAtts (off' buf' off + minBPC' end' token);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 2' end' token);  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 3' end' token);  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 4' end' token);  	case BT_GT:  	case BT_SOL:  		goto loop;  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		break;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  		return scanAtts (off' buf' off + minBPC' end' token);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 2' end' token);  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 3' end' token);  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 4' end' token);  	case BT_GT:  	case BT_SOL:  		goto loop;  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		break;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  		return scanAtts (off' buf' off + minBPC' end' token);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 2' end' token);  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 3' end' token);  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 4' end' token);  	case BT_GT:  	case BT_SOL:  		goto loop;  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		break;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  		return scanAtts (off' buf' off + minBPC' end' token);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 2' end' token);  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 3' end' token);  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 4' end' token);  	case BT_GT:  	case BT_SOL:  		goto loop;  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		break;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	return scanAtts (off' buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 2' end' token);  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 3' end' token);  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 4' end' token);  case BT_GT:  case BT_SOL:  	goto loop;  case BT_S:  case BT_CR:  case BT_LF:  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	return scanAtts (off' buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 2' end' token);  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 3' end' token);  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 4' end' token);  case BT_GT:  case BT_SOL:  	goto loop;  case BT_S:  case BT_CR:  case BT_LF:  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	return scanAtts (off' buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 2' end' token);  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 3' end' token);  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 4' end' token);  case BT_GT:  case BT_SOL:  	goto loop;  case BT_S:  case BT_CR:  case BT_LF:  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	return scanAtts (off' buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 2' end' token);  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 3' end' token);  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 4' end' token);  case BT_GT:  case BT_SOL:  	goto loop;  case BT_S:  case BT_CR:  case BT_LF:  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	return scanAtts (off' buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 2' end' token);  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 3' end' token);  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 4' end' token);  case BT_GT:  case BT_SOL:  	goto loop;  case BT_S:  case BT_CR:  case BT_LF:  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	return scanAtts (off' buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 2' end' token);  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 3' end' token);  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 4' end' token);  case BT_GT:  case BT_SOL:  	goto loop;  case BT_S:  case BT_CR:  case BT_LF:  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: return scanAtts (off' buf' off + 2' end' token);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: return scanAtts (off' buf' off + 3' end' token);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following statement contains a magic number: return scanAtts (off' buf' off + 4' end' token);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LT:  	return scanLt (buf' off + minBPC' end' token);  case BT_AMP:  	return scanRef (buf' off + minBPC' end' token);  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	throw new InvalidTokenException (off);  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LT:  	return scanLt (buf' off + minBPC' end' token);  case BT_AMP:  	return scanRef (buf' off + minBPC' end' token);  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	throw new InvalidTokenException (off);  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LT:  	return scanLt (buf' off + minBPC' end' token);  case BT_AMP:  	return scanRef (buf' off + minBPC' end' token);  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	throw new InvalidTokenException (off);  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LT:  	return scanLt (buf' off + minBPC' end' token);  case BT_AMP:  	return scanRef (buf' off + minBPC' end' token);  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	throw new InvalidTokenException (off);  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LT:  	return scanLt (buf' off + minBPC' end' token);  case BT_AMP:  	return scanRef (buf' off + minBPC' end' token);  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	throw new InvalidTokenException (off);  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LT:  	return scanLt (buf' off + minBPC' end' token);  case BT_AMP:  	return scanRef (buf' off + minBPC' end' token);  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	throw new InvalidTokenException (off);  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_AMP:  	case BT_LT:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_AMP:  	case BT_LT:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_AMP:  	case BT_LT:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_AMP:  	case BT_LT:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_AMP:  	case BT_LT:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_AMP:  	case BT_LT:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_AMP:  case BT_LT:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_AMP:  case BT_LT:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_AMP:  case BT_LT:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_AMP:  case BT_LT:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_AMP:  case BT_LT:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_AMP:  case BT_LT:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: if (end - off < 2)  	return off;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: if (end - off < 3)  	return off;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: if (end - off < 4)  	return off;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,extendData,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_LF:  case BT_CR:  case BT_PERCNT:  	token.TokenEnd = off;  	return TOK.PERCENT;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_LF:  case BT_CR:  case BT_PERCNT:  	token.TokenEnd = off;  	return TOK.PERCENT;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_LF:  case BT_CR:  case BT_PERCNT:  	token.TokenEnd = off;  	return TOK.PERCENT;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_LF:  case BT_CR:  case BT_PERCNT:  	token.TokenEnd = off;  	return TOK.PERCENT;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_LF:  case BT_CR:  case BT_PERCNT:  	token.TokenEnd = off;  	return TOK.PERCENT;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_LF:  case BT_CR:  case BT_PERCNT:  	token.TokenEnd = off;  	return TOK.PERCENT;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.PARAM_ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.PARAM_ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.PARAM_ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.PARAM_ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.PARAM_ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.PARAM_ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.PARAM_ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.PARAM_ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.PARAM_ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.PARAM_ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.PARAM_ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.PARAM_ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_RPAR:  	case BT_GT:  	case BT_PERCNT:  	case BT_VERBAR:  		token.TokenEnd = off;  		return TOK.POUND_NAME;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_RPAR:  	case BT_GT:  	case BT_PERCNT:  	case BT_VERBAR:  		token.TokenEnd = off;  		return TOK.POUND_NAME;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_RPAR:  	case BT_GT:  	case BT_PERCNT:  	case BT_VERBAR:  		token.TokenEnd = off;  		return TOK.POUND_NAME;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_RPAR:  	case BT_GT:  	case BT_PERCNT:  	case BT_VERBAR:  		token.TokenEnd = off;  		return TOK.POUND_NAME;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_RPAR:  	case BT_GT:  	case BT_PERCNT:  	case BT_VERBAR:  		token.TokenEnd = off;  		return TOK.POUND_NAME;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_RPAR:  	case BT_GT:  	case BT_PERCNT:  	case BT_VERBAR:  		token.TokenEnd = off;  		return TOK.POUND_NAME;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_CR:  case BT_LF:  case BT_S:  case BT_RPAR:  case BT_GT:  case BT_PERCNT:  case BT_VERBAR:  	token.TokenEnd = off;  	return TOK.POUND_NAME;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_CR:  case BT_LF:  case BT_S:  case BT_RPAR:  case BT_GT:  case BT_PERCNT:  case BT_VERBAR:  	token.TokenEnd = off;  	return TOK.POUND_NAME;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_CR:  case BT_LF:  case BT_S:  case BT_RPAR:  case BT_GT:  case BT_PERCNT:  case BT_VERBAR:  	token.TokenEnd = off;  	return TOK.POUND_NAME;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_CR:  case BT_LF:  case BT_S:  case BT_RPAR:  case BT_GT:  case BT_PERCNT:  case BT_VERBAR:  	token.TokenEnd = off;  	return TOK.POUND_NAME;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_CR:  case BT_LF:  case BT_S:  case BT_RPAR:  case BT_GT:  case BT_PERCNT:  case BT_VERBAR:  	token.TokenEnd = off;  	return TOK.POUND_NAME;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_CR:  case BT_LF:  case BT_S:  case BT_RPAR:  case BT_GT:  case BT_PERCNT:  case BT_VERBAR:  	token.TokenEnd = off;  	return TOK.POUND_NAME;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end) {  	int t = byteType (buf' off);  	switch (t) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialTokenException ();  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialTokenException ();  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialTokenException ();  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUOT:  	case BT_APOS:  		off += minBPC;  		if (t != open)  			break;  		if (off == end)  			throw new ExtensibleTokenException (TOK.LITERAL);  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  		case BT_GT:  		case BT_PERCNT:  		case BT_LSQB:  			token.TokenEnd = off;  			return TOK.LITERAL;  		default:  			throw new InvalidTokenException (off);  		}  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end) {  	int t = byteType (buf' off);  	switch (t) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialTokenException ();  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialTokenException ();  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialTokenException ();  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUOT:  	case BT_APOS:  		off += minBPC;  		if (t != open)  			break;  		if (off == end)  			throw new ExtensibleTokenException (TOK.LITERAL);  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  		case BT_GT:  		case BT_PERCNT:  		case BT_LSQB:  			token.TokenEnd = off;  			return TOK.LITERAL;  		default:  			throw new InvalidTokenException (off);  		}  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end) {  	int t = byteType (buf' off);  	switch (t) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialTokenException ();  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialTokenException ();  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialTokenException ();  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUOT:  	case BT_APOS:  		off += minBPC;  		if (t != open)  			break;  		if (off == end)  			throw new ExtensibleTokenException (TOK.LITERAL);  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  		case BT_GT:  		case BT_PERCNT:  		case BT_LSQB:  			token.TokenEnd = off;  			return TOK.LITERAL;  		default:  			throw new InvalidTokenException (off);  		}  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end) {  	int t = byteType (buf' off);  	switch (t) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialTokenException ();  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialTokenException ();  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialTokenException ();  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUOT:  	case BT_APOS:  		off += minBPC;  		if (t != open)  			break;  		if (off == end)  			throw new ExtensibleTokenException (TOK.LITERAL);  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  		case BT_GT:  		case BT_PERCNT:  		case BT_LSQB:  			token.TokenEnd = off;  			return TOK.LITERAL;  		default:  			throw new InvalidTokenException (off);  		}  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end) {  	int t = byteType (buf' off);  	switch (t) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialTokenException ();  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialTokenException ();  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialTokenException ();  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUOT:  	case BT_APOS:  		off += minBPC;  		if (t != open)  			break;  		if (off == end)  			throw new ExtensibleTokenException (TOK.LITERAL);  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  		case BT_GT:  		case BT_PERCNT:  		case BT_LSQB:  			token.TokenEnd = off;  			return TOK.LITERAL;  		default:  			throw new InvalidTokenException (off);  		}  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end) {  	int t = byteType (buf' off);  	switch (t) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialTokenException ();  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialTokenException ();  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialTokenException ();  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUOT:  	case BT_APOS:  		off += minBPC;  		if (t != open)  			break;  		if (off == end)  			throw new ExtensibleTokenException (TOK.LITERAL);  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  		case BT_GT:  		case BT_PERCNT:  		case BT_LSQB:  			token.TokenEnd = off;  			return TOK.LITERAL;  		default:  			throw new InvalidTokenException (off);  		}  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialTokenException ();  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialTokenException ();  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialTokenException ();  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUOT:  case BT_APOS:  	off += minBPC;  	if (t != open)  		break;  	if (off == end)  		throw new ExtensibleTokenException (TOK.LITERAL);  	switch (byteType (buf' off)) {  	case BT_S:  	case BT_CR:  	case BT_LF:  	case BT_GT:  	case BT_PERCNT:  	case BT_LSQB:  		token.TokenEnd = off;  		return TOK.LITERAL;  	default:  		throw new InvalidTokenException (off);  	}  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialTokenException ();  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialTokenException ();  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialTokenException ();  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUOT:  case BT_APOS:  	off += minBPC;  	if (t != open)  		break;  	if (off == end)  		throw new ExtensibleTokenException (TOK.LITERAL);  	switch (byteType (buf' off)) {  	case BT_S:  	case BT_CR:  	case BT_LF:  	case BT_GT:  	case BT_PERCNT:  	case BT_LSQB:  		token.TokenEnd = off;  		return TOK.LITERAL;  	default:  		throw new InvalidTokenException (off);  	}  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialTokenException ();  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialTokenException ();  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialTokenException ();  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUOT:  case BT_APOS:  	off += minBPC;  	if (t != open)  		break;  	if (off == end)  		throw new ExtensibleTokenException (TOK.LITERAL);  	switch (byteType (buf' off)) {  	case BT_S:  	case BT_CR:  	case BT_LF:  	case BT_GT:  	case BT_PERCNT:  	case BT_LSQB:  		token.TokenEnd = off;  		return TOK.LITERAL;  	default:  		throw new InvalidTokenException (off);  	}  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialTokenException ();  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialTokenException ();  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialTokenException ();  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUOT:  case BT_APOS:  	off += minBPC;  	if (t != open)  		break;  	if (off == end)  		throw new ExtensibleTokenException (TOK.LITERAL);  	switch (byteType (buf' off)) {  	case BT_S:  	case BT_CR:  	case BT_LF:  	case BT_GT:  	case BT_PERCNT:  	case BT_LSQB:  		token.TokenEnd = off;  		return TOK.LITERAL;  	default:  		throw new InvalidTokenException (off);  	}  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialTokenException ();  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialTokenException ();  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialTokenException ();  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUOT:  case BT_APOS:  	off += minBPC;  	if (t != open)  		break;  	if (off == end)  		throw new ExtensibleTokenException (TOK.LITERAL);  	switch (byteType (buf' off)) {  	case BT_S:  	case BT_CR:  	case BT_LF:  	case BT_GT:  	case BT_PERCNT:  	case BT_LSQB:  		token.TokenEnd = off;  		return TOK.LITERAL;  	default:  		throw new InvalidTokenException (off);  	}  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialTokenException ();  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialTokenException ();  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialTokenException ();  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUOT:  case BT_APOS:  	off += minBPC;  	if (t != open)  		break;  	if (off == end)  		throw new ExtensibleTokenException (TOK.LITERAL);  	switch (byteType (buf' off)) {  	case BT_S:  	case BT_CR:  	case BT_LF:  	case BT_GT:  	case BT_PERCNT:  	case BT_LSQB:  		token.TokenEnd = off;  		return TOK.LITERAL;  	default:  		throw new InvalidTokenException (off);  	}  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: if (end - off < 2)  	throw new PartialTokenException ();  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: if (end - off < 3)  	throw new PartialTokenException ();  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: if (end - off < 4)  	throw new PartialTokenException ();  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLit,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off) {  case 0:  	break;  case 1:  	if (buf [off] > 127)  		return null;  	break;  default:  	int b0 = buf [off] & 0xFF;  	int b1 = buf [off + 1] & 0xFF;  	switch ((b0 << 8) | b1) {  	case 0xFEFF:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<';  	case '<':  		/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  	case 0xFFFE:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<' << 8;  	case '<' << 8:  		/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off) {  case 0:  	break;  case 1:  	if (buf [off] > 127)  		return null;  	break;  default:  	int b0 = buf [off] & 0xFF;  	int b1 = buf [off + 1] & 0xFF;  	switch ((b0 << 8) | b1) {  	case 0xFEFF:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<';  	case '<':  		/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  	case 0xFFFE:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<' << 8;  	case '<' << 8:  		/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off) {  case 0:  	break;  case 1:  	if (buf [off] > 127)  		return null;  	break;  default:  	int b0 = buf [off] & 0xFF;  	int b1 = buf [off + 1] & 0xFF;  	switch ((b0 << 8) | b1) {  	case 0xFEFF:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<';  	case '<':  		/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  	case 0xFFFE:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<' << 8;  	case '<' << 8:  		/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off) {  case 0:  	break;  case 1:  	if (buf [off] > 127)  		return null;  	break;  default:  	int b0 = buf [off] & 0xFF;  	int b1 = buf [off + 1] & 0xFF;  	switch ((b0 << 8) | b1) {  	case 0xFEFF:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<';  	case '<':  		/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  	case 0xFFFE:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<' << 8;  	case '<' << 8:  		/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off) {  case 0:  	break;  case 1:  	if (buf [off] > 127)  		return null;  	break;  default:  	int b0 = buf [off] & 0xFF;  	int b1 = buf [off + 1] & 0xFF;  	switch ((b0 << 8) | b1) {  	case 0xFEFF:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<';  	case '<':  		/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  	case 0xFFFE:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<' << 8;  	case '<' << 8:  		/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off) {  case 0:  	break;  case 1:  	if (buf [off] > 127)  		return null;  	break;  default:  	int b0 = buf [off] & 0xFF;  	int b1 = buf [off + 1] & 0xFF;  	switch ((b0 << 8) | b1) {  	case 0xFEFF:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<';  	case '<':  		/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  	case 0xFFFE:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<' << 8;  	case '<' << 8:  		/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  	}  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: if (buf [off] > 127)  	return null;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch ((b0 << 8) | b1) {  case 0xFEFF:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<';  case '<':  	/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  case 0xFFFE:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<' << 8;  case '<' << 8:  	/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch ((b0 << 8) | b1) {  case 0xFEFF:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<';  case '<':  	/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  case 0xFFFE:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<' << 8;  case '<' << 8:  	/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch ((b0 << 8) | b1) {  case 0xFEFF:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<';  case '<':  	/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  case 0xFFFE:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<' << 8;  case '<' << 8:  	/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch ((b0 << 8) | b1) {  case 0xFEFF:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<';  case '<':  	/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  case 0xFFFE:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<' << 8;  case '<' << 8:  	/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch ((b0 << 8) | b1) {  case 0xFEFF:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<';  case '<':  	/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  case 0xFFFE:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<' << 8;  case '<' << 8:  	/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: token.TokenEnd = off + 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: token.TokenEnd = off + 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: goto case '<' << 8;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: if (charMatches (buf' off' ']')) {  	if (off + minBPC == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off + minBPC' '>')) {  		token.TokenEnd = off + 2 * minBPC;  		return TOK.COND_SECT_CLOSE;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: if (charMatches (buf' off + minBPC' '>')) {  	token.TokenEnd = off + 2 * minBPC;  	return TOK.COND_SECT_CLOSE;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: token.TokenEnd = off + 2 * minBPC;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType2 (buf' off)) {  case BT_NMSTRT:  	off += 2;  	tok = TOK.NAME;  	break;  case BT_NAME:  	off += 2;  	tok = TOK.NMTOKEN;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType2 (buf' off)) {  case BT_NMSTRT:  	off += 2;  	tok = TOK.NAME;  	break;  case BT_NAME:  	off += 2;  	tok = TOK.NMTOKEN;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType3 (buf' off)) {  case BT_NMSTRT:  	off += 3;  	tok = TOK.NAME;  	break;  case BT_NAME:  	off += 3;  	tok = TOK.NMTOKEN;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType3 (buf' off)) {  case BT_NMSTRT:  	off += 3;  	tok = TOK.NAME;  	break;  case BT_NAME:  	off += 3;  	tok = TOK.NMTOKEN;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType4 (buf' off)) {  case BT_NMSTRT:  	off += 4;  	tok = TOK.NAME;  	break;  case BT_NAME:  	off += 4;  	tok = TOK.NMTOKEN;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType4 (buf' off)) {  case BT_NMSTRT:  	off += 4;  	tok = TOK.NAME;  	break;  case BT_NAME:  	off += 4;  	tok = TOK.NMTOKEN;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_GT:  	case BT_RPAR:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_LSQB:  	case BT_PERCNT:  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.TokenEnd = off;  		return tok;  	case BT_PLUS:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_PLUS;  	case BT_AST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_ASTERISK;  	case BT_QUEST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_QUESTION;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_GT:  	case BT_RPAR:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_LSQB:  	case BT_PERCNT:  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.TokenEnd = off;  		return tok;  	case BT_PLUS:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_PLUS;  	case BT_AST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_ASTERISK;  	case BT_QUEST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_QUESTION;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_GT:  	case BT_RPAR:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_LSQB:  	case BT_PERCNT:  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.TokenEnd = off;  		return tok;  	case BT_PLUS:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_PLUS;  	case BT_AST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_ASTERISK;  	case BT_QUEST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_QUESTION;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_GT:  	case BT_RPAR:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_LSQB:  	case BT_PERCNT:  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.TokenEnd = off;  		return tok;  	case BT_PLUS:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_PLUS;  	case BT_AST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_ASTERISK;  	case BT_QUEST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_QUESTION;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_GT:  	case BT_RPAR:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_LSQB:  	case BT_PERCNT:  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.TokenEnd = off;  		return tok;  	case BT_PLUS:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_PLUS;  	case BT_AST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_ASTERISK;  	case BT_QUEST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_QUESTION;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_GT:  	case BT_RPAR:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_LSQB:  	case BT_PERCNT:  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.TokenEnd = off;  		return tok;  	case BT_PLUS:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_PLUS;  	case BT_AST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_ASTERISK;  	case BT_QUEST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_QUESTION;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_GT:  case BT_RPAR:  case BT_COMMA:  case BT_VERBAR:  case BT_LSQB:  case BT_PERCNT:  case BT_S:  case BT_CR:  case BT_LF:  	token.TokenEnd = off;  	return tok;  case BT_PLUS:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_PLUS;  case BT_AST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_ASTERISK;  case BT_QUEST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_QUESTION;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_GT:  case BT_RPAR:  case BT_COMMA:  case BT_VERBAR:  case BT_LSQB:  case BT_PERCNT:  case BT_S:  case BT_CR:  case BT_LF:  	token.TokenEnd = off;  	return tok;  case BT_PLUS:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_PLUS;  case BT_AST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_ASTERISK;  case BT_QUEST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_QUESTION;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_GT:  case BT_RPAR:  case BT_COMMA:  case BT_VERBAR:  case BT_LSQB:  case BT_PERCNT:  case BT_S:  case BT_CR:  case BT_LF:  	token.TokenEnd = off;  	return tok;  case BT_PLUS:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_PLUS;  case BT_AST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_ASTERISK;  case BT_QUEST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_QUESTION;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_GT:  case BT_RPAR:  case BT_COMMA:  case BT_VERBAR:  case BT_LSQB:  case BT_PERCNT:  case BT_S:  case BT_CR:  case BT_LF:  	token.TokenEnd = off;  	return tok;  case BT_PLUS:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_PLUS;  case BT_AST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_ASTERISK;  case BT_QUEST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_QUESTION;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_GT:  case BT_RPAR:  case BT_COMMA:  case BT_VERBAR:  case BT_LSQB:  case BT_PERCNT:  case BT_S:  case BT_CR:  case BT_LF:  	token.TokenEnd = off;  	return tok;  case BT_PLUS:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_PLUS;  case BT_AST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_ASTERISK;  case BT_QUEST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_QUESTION;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_GT:  case BT_RPAR:  case BT_COMMA:  case BT_VERBAR:  case BT_LSQB:  case BT_PERCNT:  case BT_S:  case BT_CR:  case BT_LF:  	token.TokenEnd = off;  	return tok;  case BT_PLUS:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_PLUS;  case BT_AST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_ASTERISK;  case BT_QUEST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_QUESTION;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LT:  		/* this is for inside entity references */throw new InvalidTokenException (off);  	case BT_S:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.ATTRIBUTE_VALUE_S;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LT:  		/* this is for inside entity references */throw new InvalidTokenException (off);  	case BT_S:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.ATTRIBUTE_VALUE_S;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LT:  		/* this is for inside entity references */throw new InvalidTokenException (off);  	case BT_S:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.ATTRIBUTE_VALUE_S;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LT:  		/* this is for inside entity references */throw new InvalidTokenException (off);  	case BT_S:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.ATTRIBUTE_VALUE_S;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LT:  		/* this is for inside entity references */throw new InvalidTokenException (off);  	case BT_S:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.ATTRIBUTE_VALUE_S;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LT:  		/* this is for inside entity references */throw new InvalidTokenException (off);  	case BT_S:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.ATTRIBUTE_VALUE_S;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LT:  	/* this is for inside entity references */throw new InvalidTokenException (off);  case BT_S:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.ATTRIBUTE_VALUE_S;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LT:  	/* this is for inside entity references */throw new InvalidTokenException (off);  case BT_S:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.ATTRIBUTE_VALUE_S;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LT:  	/* this is for inside entity references */throw new InvalidTokenException (off);  case BT_S:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.ATTRIBUTE_VALUE_S;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LT:  	/* this is for inside entity references */throw new InvalidTokenException (off);  case BT_S:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.ATTRIBUTE_VALUE_S;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LT:  	/* this is for inside entity references */throw new InvalidTokenException (off);  case BT_S:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.ATTRIBUTE_VALUE_S;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LT:  	/* this is for inside entity references */throw new InvalidTokenException (off);  case BT_S:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.ATTRIBUTE_VALUE_S;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_PERCNT:  		if (off == start)  			return scanPercent (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_PERCNT:  		if (off == start)  			return scanPercent (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_PERCNT:  		if (off == start)  			return scanPercent (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_PERCNT:  		if (off == start)  			return scanPercent (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_PERCNT:  		if (off == start)  			return scanPercent (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_PERCNT:  		if (off == start)  			return scanPercent (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_PERCNT:  	if (off == start)  		return scanPercent (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_PERCNT:  	if (off == start)  		return scanPercent (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_PERCNT:  	if (off == start)  		return scanPercent (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_PERCNT:  	if (off == start)  		return scanPercent (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_PERCNT:  	if (off == start)  		return scanPercent (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_PERCNT:  	if (off == start)  		return scanPercent (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LT:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '!'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '['))  			break;  		level++;  		off += minBPC;  		break;  	case BT_RSQB:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' ']'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (charMatches (buf' off' '>')) {  			if (level == 0)  				return off + minBPC;  			level--;  		}  		else if (charMatches (buf' off' ']'))  			break;  		off += minBPC;  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LT:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '!'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '['))  			break;  		level++;  		off += minBPC;  		break;  	case BT_RSQB:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' ']'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (charMatches (buf' off' '>')) {  			if (level == 0)  				return off + minBPC;  			level--;  		}  		else if (charMatches (buf' off' ']'))  			break;  		off += minBPC;  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LT:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '!'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '['))  			break;  		level++;  		off += minBPC;  		break;  	case BT_RSQB:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' ']'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (charMatches (buf' off' '>')) {  			if (level == 0)  				return off + minBPC;  			level--;  		}  		else if (charMatches (buf' off' ']'))  			break;  		off += minBPC;  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LT:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '!'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '['))  			break;  		level++;  		off += minBPC;  		break;  	case BT_RSQB:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' ']'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (charMatches (buf' off' '>')) {  			if (level == 0)  				return off + minBPC;  			level--;  		}  		else if (charMatches (buf' off' ']'))  			break;  		off += minBPC;  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LT:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '!'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '['))  			break;  		level++;  		off += minBPC;  		break;  	case BT_RSQB:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' ']'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (charMatches (buf' off' '>')) {  			if (level == 0)  				return off + minBPC;  			level--;  		}  		else if (charMatches (buf' off' ']'))  			break;  		off += minBPC;  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LT:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '!'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '['))  			break;  		level++;  		off += minBPC;  		break;  	case BT_RSQB:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' ']'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (charMatches (buf' off' '>')) {  			if (level == 0)  				return off + minBPC;  			level--;  		}  		else if (charMatches (buf' off' ']'))  			break;  		off += minBPC;  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LT:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '!'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '['))  		break;  	level++;  	off += minBPC;  	break;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (charMatches (buf' off' '>')) {  		if (level == 0)  			return off + minBPC;  		level--;  	}  	else if (charMatches (buf' off' ']'))  		break;  	off += minBPC;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LT:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '!'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '['))  		break;  	level++;  	off += minBPC;  	break;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (charMatches (buf' off' '>')) {  		if (level == 0)  			return off + minBPC;  		level--;  	}  	else if (charMatches (buf' off' ']'))  		break;  	off += minBPC;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LT:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '!'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '['))  		break;  	level++;  	off += minBPC;  	break;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (charMatches (buf' off' '>')) {  		if (level == 0)  			return off + minBPC;  		level--;  	}  	else if (charMatches (buf' off' ']'))  		break;  	off += minBPC;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LT:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '!'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '['))  		break;  	level++;  	off += minBPC;  	break;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (charMatches (buf' off' '>')) {  		if (level == 0)  			return off + minBPC;  		level--;  	}  	else if (charMatches (buf' off' ']'))  		break;  	off += minBPC;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LT:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '!'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '['))  		break;  	level++;  	off += minBPC;  	break;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (charMatches (buf' off' '>')) {  		if (level == 0)  			return off + minBPC;  		level--;  	}  	else if (charMatches (buf' off' ']'))  		break;  	off += minBPC;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LT:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '!'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '['))  		break;  	level++;  	off += minBPC;  	break;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (charMatches (buf' off' '>')) {  		if (level == 0)  			return off + minBPC;  		level--;  	}  	else if (charMatches (buf' off' ']'))  		break;  	off += minBPC;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: if (charTypeTable [hi] == null) {  	charTypeTable [hi] = new int[256];  	for (int i = 0; i < 256; i++)  		charTypeTable [hi] [i] = BT_OTHER;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: if (charTypeTable [hi] == null) {  	charTypeTable [hi] = new int[256];  	for (int i = 0; i < 256; i++)  		charTypeTable [hi] [i] = BT_OTHER;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: charTypeTable [hi] = new int[256];  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	charTypeTable [hi] [i] = BT_OTHER;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: do {  	if ((min & 0xFF) == 0) {  		for (; min + (char)0xFF <= max; min += (char)0x100) {  			if (shared == null) {  				shared = new int[256];  				for (int i = 0; i < 256; i++)  					shared [i] = type;  			}  			charTypeTable [min >> 8] = shared;  			if (min + 0xFF == max)  				return;  		}  	}  	setCharType (min' type);  }  while (min++ != max);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: do {  	if ((min & 0xFF) == 0) {  		for (; min + (char)0xFF <= max; min += (char)0x100) {  			if (shared == null) {  				shared = new int[256];  				for (int i = 0; i < 256; i++)  					shared [i] = type;  			}  			charTypeTable [min >> 8] = shared;  			if (min + 0xFF == max)  				return;  		}  	}  	setCharType (min' type);  }  while (min++ != max);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: do {  	if ((min & 0xFF) == 0) {  		for (; min + (char)0xFF <= max; min += (char)0x100) {  			if (shared == null) {  				shared = new int[256];  				for (int i = 0; i < 256; i++)  					shared [i] = type;  			}  			charTypeTable [min >> 8] = shared;  			if (min + 0xFF == max)  				return;  		}  	}  	setCharType (min' type);  }  while (min++ != max);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: if ((min & 0xFF) == 0) {  	for (; min + (char)0xFF <= max; min += (char)0x100) {  		if (shared == null) {  			shared = new int[256];  			for (int i = 0; i < 256; i++)  				shared [i] = type;  		}  		charTypeTable [min >> 8] = shared;  		if (min + 0xFF == max)  			return;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: if ((min & 0xFF) == 0) {  	for (; min + (char)0xFF <= max; min += (char)0x100) {  		if (shared == null) {  			shared = new int[256];  			for (int i = 0; i < 256; i++)  				shared [i] = type;  		}  		charTypeTable [min >> 8] = shared;  		if (min + 0xFF == max)  			return;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: if ((min & 0xFF) == 0) {  	for (; min + (char)0xFF <= max; min += (char)0x100) {  		if (shared == null) {  			shared = new int[256];  			for (int i = 0; i < 256; i++)  				shared [i] = type;  		}  		charTypeTable [min >> 8] = shared;  		if (min + 0xFF == max)  			return;  	}  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: for (; min + (char)0xFF <= max; min += (char)0x100) {  	if (shared == null) {  		shared = new int[256];  		for (int i = 0; i < 256; i++)  			shared [i] = type;  	}  	charTypeTable [min >> 8] = shared;  	if (min + 0xFF == max)  		return;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: for (; min + (char)0xFF <= max; min += (char)0x100) {  	if (shared == null) {  		shared = new int[256];  		for (int i = 0; i < 256; i++)  			shared [i] = type;  	}  	charTypeTable [min >> 8] = shared;  	if (min + 0xFF == max)  		return;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: for (; min + (char)0xFF <= max; min += (char)0x100) {  	if (shared == null) {  		shared = new int[256];  		for (int i = 0; i < 256; i++)  			shared [i] = type;  	}  	charTypeTable [min >> 8] = shared;  	if (min + 0xFF == max)  		return;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: if (shared == null) {  	shared = new int[256];  	for (int i = 0; i < 256; i++)  		shared [i] = type;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: if (shared == null) {  	shared = new int[256];  	for (int i = 0; i < 256; i++)  		shared [i] = type;  }  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: shared = new int[256];  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	shared [i] = type;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setCharType,The following statement contains a magic number: charTypeTable [min >> 8] = shared;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,Encoding,The following statement contains a magic number: charTypeTable = new int[256][];  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,Encoding,The following statement contains a magic number: for (int i = 0; i < nameRanges.Length; i += 2)  	setCharType (nameRanges [i]' nameRanges [i + 1]' BT_NAME);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,Encoding,The following statement contains a magic number: i += 2
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,Encoding,The following statement contains a magic number: for (int i = 0; i < nameStartRanges.Length; i += 2)  	setCharType (nameStartRanges [i]' nameStartRanges [i + 1]' BT_NMSTRT);  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,Encoding,The following statement contains a magic number: i += 2
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,Encoding,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	other [i] = BT_OTHER;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,Encoding,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	if (charTypeTable [i] == null)  		charTypeTable [i] = other;  
Magic Number,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,Encoding,The following statement contains a magic number: System.Array.Copy (asciiTypeTable' 0' charTypeTable [0]' 0' 128);  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,UTF8Encoding,The following statement contains a magic number: System.Array.Copy (asciiTypeTable' 0' utf8TypeTable' 0' 128);  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,UTF8Encoding,The following statement contains a magic number: System.Array.Copy (utf8HiTypeTable' 0' utf8TypeTable' 128' 128);  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,UTF8Encoding,The following statement contains a magic number: System.Array.Copy (utf8HiTypeTable' 0' utf8TypeTable' 128' 128);  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,byteType2,The following statement contains a magic number: return page [((buf [off] & 3) << 6) | (buf [off + 1] & 0x3F)];  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,byteType2,The following statement contains a magic number: return page [((buf [off] & 3) << 6) | (buf [off + 1] & 0x3F)];  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd) {  	byte b = sourceBuf [sourceStart++];  	if (b >= 0)  		targetBuf [targetStart++] = (char)b;  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		case BT_LEAD2:  			/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  			break;  		case BT_LEAD3:  			/* 4' 6' 6 */c = (b & 0xF) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			targetBuf [targetStart++] = (char)c;  			break;  		case BT_LEAD4:  			/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			c -= 0x10000;  			targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  			targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  			break;  		}  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd) {  	byte b = sourceBuf [sourceStart++];  	if (b >= 0)  		targetBuf [targetStart++] = (char)b;  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		case BT_LEAD2:  			/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  			break;  		case BT_LEAD3:  			/* 4' 6' 6 */c = (b & 0xF) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			targetBuf [targetStart++] = (char)c;  			break;  		case BT_LEAD4:  			/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			c -= 0x10000;  			targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  			targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  			break;  		}  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd) {  	byte b = sourceBuf [sourceStart++];  	if (b >= 0)  		targetBuf [targetStart++] = (char)b;  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		case BT_LEAD2:  			/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  			break;  		case BT_LEAD3:  			/* 4' 6' 6 */c = (b & 0xF) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			targetBuf [targetStart++] = (char)c;  			break;  		case BT_LEAD4:  			/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			c -= 0x10000;  			targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  			targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  			break;  		}  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd) {  	byte b = sourceBuf [sourceStart++];  	if (b >= 0)  		targetBuf [targetStart++] = (char)b;  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		case BT_LEAD2:  			/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  			break;  		case BT_LEAD3:  			/* 4' 6' 6 */c = (b & 0xF) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			targetBuf [targetStart++] = (char)c;  			break;  		case BT_LEAD4:  			/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			c -= 0x10000;  			targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  			targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  			break;  		}  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd) {  	byte b = sourceBuf [sourceStart++];  	if (b >= 0)  		targetBuf [targetStart++] = (char)b;  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		case BT_LEAD2:  			/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  			break;  		case BT_LEAD3:  			/* 4' 6' 6 */c = (b & 0xF) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			targetBuf [targetStart++] = (char)c;  			break;  		case BT_LEAD4:  			/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			c -= 0x10000;  			targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  			targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  			break;  		}  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd) {  	byte b = sourceBuf [sourceStart++];  	if (b >= 0)  		targetBuf [targetStart++] = (char)b;  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		case BT_LEAD2:  			/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  			break;  		case BT_LEAD3:  			/* 4' 6' 6 */c = (b & 0xF) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			targetBuf [targetStart++] = (char)c;  			break;  		case BT_LEAD4:  			/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			c -= 0x10000;  			targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  			targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  			break;  		}  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd) {  	byte b = sourceBuf [sourceStart++];  	if (b >= 0)  		targetBuf [targetStart++] = (char)b;  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		case BT_LEAD2:  			/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  			break;  		case BT_LEAD3:  			/* 4' 6' 6 */c = (b & 0xF) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			targetBuf [targetStart++] = (char)c;  			break;  		case BT_LEAD4:  			/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			c -= 0x10000;  			targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  			targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  			break;  		}  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd) {  	byte b = sourceBuf [sourceStart++];  	if (b >= 0)  		targetBuf [targetStart++] = (char)b;  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		case BT_LEAD2:  			/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  			break;  		case BT_LEAD3:  			/* 4' 6' 6 */c = (b & 0xF) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			targetBuf [targetStart++] = (char)c;  			break;  		case BT_LEAD4:  			/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			c -= 0x10000;  			targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  			targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  			break;  		}  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: if (b >= 0)  	targetBuf [targetStart++] = (char)b;  else {  	switch (utf8TypeTable [b & 0xFF]) {  	case BT_LEAD2:  		/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  		break;  	case BT_LEAD3:  		/* 4' 6' 6 */c = (b & 0xF) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		targetBuf [targetStart++] = (char)c;  		break;  	case BT_LEAD4:  		/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		c -= 0x10000;  		targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  		targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  		break;  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: if (b >= 0)  	targetBuf [targetStart++] = (char)b;  else {  	switch (utf8TypeTable [b & 0xFF]) {  	case BT_LEAD2:  		/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  		break;  	case BT_LEAD3:  		/* 4' 6' 6 */c = (b & 0xF) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		targetBuf [targetStart++] = (char)c;  		break;  	case BT_LEAD4:  		/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		c -= 0x10000;  		targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  		targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  		break;  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: if (b >= 0)  	targetBuf [targetStart++] = (char)b;  else {  	switch (utf8TypeTable [b & 0xFF]) {  	case BT_LEAD2:  		/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  		break;  	case BT_LEAD3:  		/* 4' 6' 6 */c = (b & 0xF) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		targetBuf [targetStart++] = (char)c;  		break;  	case BT_LEAD4:  		/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		c -= 0x10000;  		targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  		targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  		break;  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: if (b >= 0)  	targetBuf [targetStart++] = (char)b;  else {  	switch (utf8TypeTable [b & 0xFF]) {  	case BT_LEAD2:  		/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  		break;  	case BT_LEAD3:  		/* 4' 6' 6 */c = (b & 0xF) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		targetBuf [targetStart++] = (char)c;  		break;  	case BT_LEAD4:  		/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		c -= 0x10000;  		targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  		targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  		break;  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: if (b >= 0)  	targetBuf [targetStart++] = (char)b;  else {  	switch (utf8TypeTable [b & 0xFF]) {  	case BT_LEAD2:  		/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  		break;  	case BT_LEAD3:  		/* 4' 6' 6 */c = (b & 0xF) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		targetBuf [targetStart++] = (char)c;  		break;  	case BT_LEAD4:  		/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		c -= 0x10000;  		targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  		targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  		break;  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: if (b >= 0)  	targetBuf [targetStart++] = (char)b;  else {  	switch (utf8TypeTable [b & 0xFF]) {  	case BT_LEAD2:  		/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  		break;  	case BT_LEAD3:  		/* 4' 6' 6 */c = (b & 0xF) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		targetBuf [targetStart++] = (char)c;  		break;  	case BT_LEAD4:  		/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		c -= 0x10000;  		targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  		targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  		break;  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: if (b >= 0)  	targetBuf [targetStart++] = (char)b;  else {  	switch (utf8TypeTable [b & 0xFF]) {  	case BT_LEAD2:  		/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  		break;  	case BT_LEAD3:  		/* 4' 6' 6 */c = (b & 0xF) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		targetBuf [targetStart++] = (char)c;  		break;  	case BT_LEAD4:  		/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		c -= 0x10000;  		targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  		targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  		break;  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: if (b >= 0)  	targetBuf [targetStart++] = (char)b;  else {  	switch (utf8TypeTable [b & 0xFF]) {  	case BT_LEAD2:  		/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  		break;  	case BT_LEAD3:  		/* 4' 6' 6 */c = (b & 0xF) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		targetBuf [targetStart++] = (char)c;  		break;  	case BT_LEAD4:  		/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		c -= 0x10000;  		targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  		targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  		break;  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: c = (b & 0xF) << 12;  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: c = (b & 0x7) << 18;  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: while (off != end) {  	byte b = buf [off];  	if (b >= 0) {  		++off;  		switch (b) {  		case (byte)'\n':  			lineNumber += 1;  			colDiff = off;  			break;  		case (byte)'\r':  			lineNumber += 1;  			if (off != end && buf [off] == '\n')  				off++;  			colDiff = off;  			break;  		}  	}  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		default:  			off += 1;  			break;  		case BT_LEAD2:  			off += 2;  			colDiff++;  			break;  		case BT_LEAD3:  			off += 3;  			colDiff += 2;  			break;  		case BT_LEAD4:  			off += 4;  			colDiff += 3;  			break;  		}  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: while (off != end) {  	byte b = buf [off];  	if (b >= 0) {  		++off;  		switch (b) {  		case (byte)'\n':  			lineNumber += 1;  			colDiff = off;  			break;  		case (byte)'\r':  			lineNumber += 1;  			if (off != end && buf [off] == '\n')  				off++;  			colDiff = off;  			break;  		}  	}  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		default:  			off += 1;  			break;  		case BT_LEAD2:  			off += 2;  			colDiff++;  			break;  		case BT_LEAD3:  			off += 3;  			colDiff += 2;  			break;  		case BT_LEAD4:  			off += 4;  			colDiff += 3;  			break;  		}  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: while (off != end) {  	byte b = buf [off];  	if (b >= 0) {  		++off;  		switch (b) {  		case (byte)'\n':  			lineNumber += 1;  			colDiff = off;  			break;  		case (byte)'\r':  			lineNumber += 1;  			if (off != end && buf [off] == '\n')  				off++;  			colDiff = off;  			break;  		}  	}  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		default:  			off += 1;  			break;  		case BT_LEAD2:  			off += 2;  			colDiff++;  			break;  		case BT_LEAD3:  			off += 3;  			colDiff += 2;  			break;  		case BT_LEAD4:  			off += 4;  			colDiff += 3;  			break;  		}  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: while (off != end) {  	byte b = buf [off];  	if (b >= 0) {  		++off;  		switch (b) {  		case (byte)'\n':  			lineNumber += 1;  			colDiff = off;  			break;  		case (byte)'\r':  			lineNumber += 1;  			if (off != end && buf [off] == '\n')  				off++;  			colDiff = off;  			break;  		}  	}  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		default:  			off += 1;  			break;  		case BT_LEAD2:  			off += 2;  			colDiff++;  			break;  		case BT_LEAD3:  			off += 3;  			colDiff += 2;  			break;  		case BT_LEAD4:  			off += 4;  			colDiff += 3;  			break;  		}  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: while (off != end) {  	byte b = buf [off];  	if (b >= 0) {  		++off;  		switch (b) {  		case (byte)'\n':  			lineNumber += 1;  			colDiff = off;  			break;  		case (byte)'\r':  			lineNumber += 1;  			if (off != end && buf [off] == '\n')  				off++;  			colDiff = off;  			break;  		}  	}  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		default:  			off += 1;  			break;  		case BT_LEAD2:  			off += 2;  			colDiff++;  			break;  		case BT_LEAD3:  			off += 3;  			colDiff += 2;  			break;  		case BT_LEAD4:  			off += 4;  			colDiff += 3;  			break;  		}  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: if (b >= 0) {  	++off;  	switch (b) {  	case (byte)'\n':  		lineNumber += 1;  		colDiff = off;  		break;  	case (byte)'\r':  		lineNumber += 1;  		if (off != end && buf [off] == '\n')  			off++;  		colDiff = off;  		break;  	}  }  else {  	switch (utf8TypeTable [b & 0xFF]) {  	default:  		off += 1;  		break;  	case BT_LEAD2:  		off += 2;  		colDiff++;  		break;  	case BT_LEAD3:  		off += 3;  		colDiff += 2;  		break;  	case BT_LEAD4:  		off += 4;  		colDiff += 3;  		break;  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: if (b >= 0) {  	++off;  	switch (b) {  	case (byte)'\n':  		lineNumber += 1;  		colDiff = off;  		break;  	case (byte)'\r':  		lineNumber += 1;  		if (off != end && buf [off] == '\n')  			off++;  		colDiff = off;  		break;  	}  }  else {  	switch (utf8TypeTable [b & 0xFF]) {  	default:  		off += 1;  		break;  	case BT_LEAD2:  		off += 2;  		colDiff++;  		break;  	case BT_LEAD3:  		off += 3;  		colDiff += 2;  		break;  	case BT_LEAD4:  		off += 4;  		colDiff += 3;  		break;  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: if (b >= 0) {  	++off;  	switch (b) {  	case (byte)'\n':  		lineNumber += 1;  		colDiff = off;  		break;  	case (byte)'\r':  		lineNumber += 1;  		if (off != end && buf [off] == '\n')  			off++;  		colDiff = off;  		break;  	}  }  else {  	switch (utf8TypeTable [b & 0xFF]) {  	default:  		off += 1;  		break;  	case BT_LEAD2:  		off += 2;  		colDiff++;  		break;  	case BT_LEAD3:  		off += 3;  		colDiff += 2;  		break;  	case BT_LEAD4:  		off += 4;  		colDiff += 3;  		break;  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: if (b >= 0) {  	++off;  	switch (b) {  	case (byte)'\n':  		lineNumber += 1;  		colDiff = off;  		break;  	case (byte)'\r':  		lineNumber += 1;  		if (off != end && buf [off] == '\n')  			off++;  		colDiff = off;  		break;  	}  }  else {  	switch (utf8TypeTable [b & 0xFF]) {  	default:  		off += 1;  		break;  	case BT_LEAD2:  		off += 2;  		colDiff++;  		break;  	case BT_LEAD3:  		off += 3;  		colDiff += 2;  		break;  	case BT_LEAD4:  		off += 4;  		colDiff += 3;  		break;  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: if (b >= 0) {  	++off;  	switch (b) {  	case (byte)'\n':  		lineNumber += 1;  		colDiff = off;  		break;  	case (byte)'\r':  		lineNumber += 1;  		if (off != end && buf [off] == '\n')  			off++;  		colDiff = off;  		break;  	}  }  else {  	switch (utf8TypeTable [b & 0xFF]) {  	default:  		off += 1;  		break;  	case BT_LEAD2:  		off += 2;  		colDiff++;  		break;  	case BT_LEAD3:  		off += 3;  		colDiff += 2;  		break;  	case BT_LEAD4:  		off += 4;  		colDiff += 3;  		break;  	}  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  default:  	off += 1;  	break;  case BT_LEAD2:  	off += 2;  	colDiff++;  	break;  case BT_LEAD3:  	off += 3;  	colDiff += 2;  	break;  case BT_LEAD4:  	off += 4;  	colDiff += 3;  	break;  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  default:  	off += 1;  	break;  case BT_LEAD2:  	off += 2;  	colDiff++;  	break;  case BT_LEAD3:  	off += 3;  	colDiff += 2;  	break;  case BT_LEAD4:  	off += 4;  	colDiff += 3;  	break;  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  default:  	off += 1;  	break;  case BT_LEAD2:  	off += 2;  	colDiff++;  	break;  case BT_LEAD3:  	off += 3;  	colDiff += 2;  	break;  case BT_LEAD4:  	off += 4;  	colDiff += 3;  	break;  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  default:  	off += 1;  	break;  case BT_LEAD2:  	off += 2;  	colDiff++;  	break;  case BT_LEAD3:  	off += 3;  	colDiff += 2;  	break;  case BT_LEAD4:  	off += 4;  	colDiff += 3;  	break;  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  default:  	off += 1;  	break;  case BT_LEAD2:  	off += 2;  	colDiff++;  	break;  case BT_LEAD3:  	off += 3;  	colDiff += 2;  	break;  case BT_LEAD4:  	off += 4;  	colDiff += 3;  	break;  }  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: off += 2;  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: off += 3;  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: colDiff += 2;  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: off += 4;  
Magic Number,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: colDiff += 3;  
Missing Default,jabber.client,RosterManager,C:\repos\meebey_jabber-net\jabber\client\RosterManager.cs,cli_OnPresence,The following switch statement is missing a default case: switch (typ) {  case PresenceType.available:  case PresenceType.unavailable:  case PresenceType.error:  case PresenceType.probe:  	return;  case PresenceType.subscribe:  	switch (m_autoAllow) {  	case AutoSubscriptionHanding.AllowAll:  		ReplyAllow (pres);  		return;  	case AutoSubscriptionHanding.DenyAll:  		ReplyDeny (pres);  		return;  	case AutoSubscriptionHanding.NONE:  		if (OnSubscription != null)  			OnSubscription (this' this [pres.From]' pres);  		return;  	case AutoSubscriptionHanding.AllowIfSubscribed:  		Item ri = this [pres.From];  		if (ri != null) {  			switch (ri.Subscription) {  			case Subscription.to:  				ReplyAllow (pres);  				return;  			case Subscription.from:  			case Subscription.both:  				// Almost an assert  				throw new InvalidOperationException ("Server sent a presence subscribe for an already-subscribed contact");  			case Subscription.none:  				if (ri.Ask == Ask.subscribe) {  					ReplyAllow (pres);  					return;  				}  				break;  			}  		}  		if (OnSubscription != null)  			OnSubscription (this' ri' pres);  		break;  	}  	break;  case PresenceType.subscribed:  	// the contact has given us permission to see presence updates  	break;  case PresenceType.unsubscribe:  	// the contact does not wish to see our presence updates anymore  	// that's fine' who cares?  	break;  case PresenceType.unsubscribed:  	bool remove = true;  	if (OnUnsubscription != null)  		OnUnsubscription (this' pres' ref remove);  	if (remove)  		Remove (pres.From);  	// the contact has taken away our permission to see presence updates  	break;  }  
Missing Default,jabber.client,RosterManager,C:\repos\meebey_jabber-net\jabber\client\RosterManager.cs,cli_OnPresence,The following switch statement is missing a default case: switch (m_autoAllow) {  case AutoSubscriptionHanding.AllowAll:  	ReplyAllow (pres);  	return;  case AutoSubscriptionHanding.DenyAll:  	ReplyDeny (pres);  	return;  case AutoSubscriptionHanding.NONE:  	if (OnSubscription != null)  		OnSubscription (this' this [pres.From]' pres);  	return;  case AutoSubscriptionHanding.AllowIfSubscribed:  	Item ri = this [pres.From];  	if (ri != null) {  		switch (ri.Subscription) {  		case Subscription.to:  			ReplyAllow (pres);  			return;  		case Subscription.from:  		case Subscription.both:  			// Almost an assert  			throw new InvalidOperationException ("Server sent a presence subscribe for an already-subscribed contact");  		case Subscription.none:  			if (ri.Ask == Ask.subscribe) {  				ReplyAllow (pres);  				return;  			}  			break;  		}  	}  	if (OnSubscription != null)  		OnSubscription (this' ri' pres);  	break;  }  
Missing Default,jabber.client,RosterManager,C:\repos\meebey_jabber-net\jabber\client\RosterManager.cs,cli_OnPresence,The following switch statement is missing a default case: switch (ri.Subscription) {  case Subscription.to:  	ReplyAllow (pres);  	return;  case Subscription.from:  case Subscription.both:  	// Almost an assert  	throw new InvalidOperationException ("Server sent a presence subscribe for an already-subscribed contact");  case Subscription.none:  	if (ri.Ask == Ask.subscribe) {  		ReplyAllow (pres);  		return;  	}  	break;  }  
Missing Default,jabber.connection,CapsManager,C:\repos\meebey_jabber-net\jabber\connection\CapsManager.cs,GetHasher,The following switch statement is missing a default case: switch (name) {  case null:  	return null;  case "sha-1":  	return SHA1.Create ();  case "sha-256":  	return SHA256.Create ();  case "sha-512":  	return SHA512.Create ();  case "sha-384":  	return SHA384.Create ();  case "md5":  	return MD5.Create ();  }  
Missing Default,jabber.connection,Room,C:\repos\meebey_jabber-net\jabber\connection\ConferenceManager.cs,m_stream_OnProtocol,The following switch statement is missing a default case: switch (rp.LocalName) {  case "presence":  	Presence p = (Presence)rp;  	if (p.Error != null) {  		m_state = STATE.error;  		if (OnPresenceError != null)  			OnPresenceError (this' p);  		return;  	}  	ParticipantCollection.Modification mod = ParticipantCollection.Modification.NONE;  	RoomParticipant party = m_participants.Modify (p' out mod);  	// if this is ours  	if (p.From == m_jid) {  		switch (m_state) {  		case STATE.join:  			OnJoinPresence (p);  			break;  		case STATE.leaving:  			OnLeavePresence (p);  			break;  		case STATE.running:  			if (p.Type == PresenceType.unavailable)  				OnLeavePresence (p);  			break;  		}  	}  	else {  		switch (mod) {  		case ParticipantCollection.Modification.NONE:  			if (OnParticipantPresenceChange != null)  				OnParticipantPresenceChange (this' party);  			break;  		case ParticipantCollection.Modification.JOIN:  			if (OnParticipantJoin != null)  				OnParticipantJoin (this' party);  			break;  		case ParticipantCollection.Modification.LEAVE:  			if (OnParticipantLeave != null)  				OnParticipantLeave (this' party);  			break;  		}  	}  	break;  case "message":  	Message m = (Message)rp;  	if (m.Type == MessageType.groupchat) {  		if (m.Subject != null) {  			if (OnSubjectChange != null)  				OnSubjectChange (this' m);  			m_subject = m;  		}  		else if (m.From == m_jid) {  			if (OnSelfMessage != null)  				OnSelfMessage (this' m);  		}  		else {  			if (OnRoomMessage != null)  				OnRoomMessage (this' m);  		}  	}  	else {  		if (m.From.Resource == null) {  			// room notification of some kind  			if (OnAdminMessage != null)  				OnAdminMessage (this' m);  		}  		else {  			if (OnPrivateMessage != null)  				OnPrivateMessage (this' m);  		}  	}  	break;  case "iq":  	// TODO: IQs the room sends to us.  	break;  }  
Missing Default,jabber.connection,Room,C:\repos\meebey_jabber-net\jabber\connection\ConferenceManager.cs,m_stream_OnProtocol,The following switch statement is missing a default case: switch (m_state) {  case STATE.join:  	OnJoinPresence (p);  	break;  case STATE.leaving:  	OnLeavePresence (p);  	break;  case STATE.running:  	if (p.Type == PresenceType.unavailable)  		OnLeavePresence (p);  	break;  }  
Missing Default,jabber.connection,Room,C:\repos\meebey_jabber-net\jabber\connection\ConferenceManager.cs,m_stream_OnProtocol,The following switch statement is missing a default case: switch (mod) {  case ParticipantCollection.Modification.NONE:  	if (OnParticipantPresenceChange != null)  		OnParticipantPresenceChange (this' party);  	break;  case ParticipantCollection.Modification.JOIN:  	if (OnParticipantJoin != null)  		OnParticipantJoin (this' party);  	break;  case ParticipantCollection.Modification.LEAVE:  	if (OnParticipantLeave != null)  		OnParticipantLeave (this' party);  	break;  }  
Missing Default,jabber.connection,PubSubNode,C:\repos\meebey_jabber-net\jabber\connection\PubSubManager.cs,NeedsAsking,The following switch statement is missing a default case: switch (state) {  case STATE.Start:  case STATE.Pending:  	return true;  case STATE.Asking:  case STATE.Running:  	return false;  case STATE.Error:  	Debug.WriteLine ("Retrying create after error.  Hope you've changed perms or something in the mean time.");  	return true;  }  
Missing Default,jabber.connection,PubSubNode,C:\repos\meebey_jabber-net\jabber\connection\PubSubManager.cs,GotSubscribed,The following switch statement is missing a default case: switch (subType) {  case PubSubSubscriptionType.NONE_SPECIFIED:  case PubSubSubscriptionType.subscribed:  	break;  case PubSubSubscriptionType.pending:  	FireError (Op.SUBSCRIBE' "Subscription pending authorization"' iq);  	return;  case PubSubSubscriptionType.unconfigured:  	FireError (Op.SUBSCRIBE' "Subscription configuration required.  Not implemented yet."' iq);  	return;  }  
Missing Default,jabber.connection,XmppStream,C:\repos\meebey_jabber-net\jabber\connection\XmppStream.cs,OnElement,The following switch statement is missing a default case: switch (tag.Name) {  case "proceed":  	if (!StartTLS ())  		return;  	SendNewStreamHeader ();  	break;  case "failure":  	FireOnError (new AuthenticationFailedException ());  	return;  }  
Missing Default,jabber.connection,XmppStream,C:\repos\meebey_jabber-net\jabber\connection\XmppStream.cs,OnElement,The following switch statement is missing a default case: switch (tag.Name) {  case "compressed":  	if (!StartCompression ())  		return;  	SendNewStreamHeader ();  	break;  case "failure":  	CompressionFailure fail = tag as CompressionFailure;  	#if ZLIB_NET  	                    FireOnError(new bedrock.io.CompressionFailedException(fail.Error)); #else  	FireOnError (new IOException (fail.Error));  	#endif  	return;  }  
Missing Default,bedrock.net,ShttpProxy,C:\repos\meebey_jabber-net\bedrock\net\ShttpProxy.cs,OnRead,The following switch statement is missing a default case: switch (state) {  case 0:  	if (b == '\r')  		state++;  	break;  case 1:  	if (b == '\n') {  		byte[] hs = m_headerstream.ToArray ();  		string s = System.Text.Encoding.UTF8.GetString (hs);  		Debug.Write ("PRECV: " + s);  		m_headers.Add (s);  		m_headerstream.SetLength (0);  		state++;  		line++;  	}  	else  		state = 0;  	break;  case 2:  	if (b == '\r')  		state++;  	else  		state = 0;  	break;  case 3:  	if (b == '\n') {  		Debug.WriteLine ("End of proxy headers");  		string line0 = (string)m_headers [0];  		if (line0.IndexOf ("200") == -1) {  			Debug.WriteLine ("200 response not detected.  Closing.");  			m_state = States.Error;  			this.Close ();  		}  		else {  			Debug.WriteLine ("Proxy connected");  			m_listener.OnConnect (sock);  			// tell the real listener that we're connected.  			m_state = States.Running;  		}  		// they'll call RequestRead()' so we can return false here.  		return false;  	}  	else  		state = 0;  	break;  }  
Missing Default,jabber.protocol,AsynchElementStream,C:\repos\meebey_jabber-net\jabber\protocol\AsynchElementStream.cs,Push,The following switch statement is missing a default case: switch (tok) {  case TOK.EMPTY_ELEMENT_NO_ATTS:  case TOK.EMPTY_ELEMENT_WITH_ATTS:  	StartTag (b' off' ct' tok);  	EndTag (b' off' ct' tok);  	break;  case TOK.START_TAG_NO_ATTS:  case TOK.START_TAG_WITH_ATTS:  	StartTag (b' off' ct' tok);  	break;  case TOK.END_TAG:  	EndTag (b' off' ct' tok);  	break;  case TOK.DATA_CHARS:  case TOK.DATA_NEWLINE:  	AddText (utf.GetString (b' off' ct.TokenEnd - off));  	break;  case TOK.CHAR_REF:  case TOK.MAGIC_ENTITY_REF:  	AddText (new string (new char[] {  		ct.RefChar1  	}));  	break;  case TOK.CHAR_PAIR_REF:  	AddText (new string (new char[] {  		ct.RefChar1'  		ct.RefChar2  	}));  	break;  case TOK.COMMENT:  	if (m_elem != null) {  		// <!-- 4  		//  --> 3  		int start = off + 4 * m_enc.MinBytesPerChar;  		int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  		string text = utf.GetString (b' start' end);  		m_elem.AppendChild (m_doc.CreateComment (text));  	}  	break;  case TOK.CDATA_SECT_OPEN:  	m_cdata = true;  	break;  case TOK.CDATA_SECT_CLOSE:  	m_cdata = false;  	break;  case TOK.XML_DECL:  	// thou shalt use UTF8' and XML version 1.  	// i shall ignore evidence to the contrary...  	// TODO: Throw an exception if these assuptions are  	// wrong  	break;  case TOK.ENTITY_REF:  case TOK.PI:  	throw new System.NotImplementedException ("Token type not implemented: " + tok);  }  
Missing Default,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getEncoding,The following switch statement is missing a default case: switch (enc) {  case UTF8_ENCODING:  	if (utf8Encoding == null)  		utf8Encoding = new UTF8Encoding ();  	return utf8Encoding;  /*                 case UTF16_LITTLE_ENDIAN_ENCODING:                     if (utf16LittleEndianEncoding == null)                         utf16LittleEndianEncoding = new UTF16LittleEndianEncoding();                     return utf16LittleEndianEncoding;                 case UTF16_BIG_ENDIAN_ENCODING:                     if (utf16BigEndianEncoding == null)                         utf16BigEndianEncoding = new UTF16BigEndianEncoding();                     return utf16BigEndianEncoding;                 case INTERNAL_ENCODING:                     if (internalEncoding == null)                         internalEncoding = new InternalEncoding();                     return internalEncoding;                 case ISO8859_1_ENCODING:                     if (iso8859_1Encoding == null)                         iso8859_1Encoding = new ISO8859_1Encoding();                     return iso8859_1Encoding;                 case ASCII_ENCODING:                     if (asciiEncoding == null)                         asciiEncoding = new ASCIIEncoding();                     return asciiEncoding;                     */}  
Missing Default,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanDecl,The following switch statement is missing a default case: switch (byteType (buf' off + minBPC)) {  case BT_S:  case BT_CR:  case BT_LF:  case BT_PERCNT:  	throw new InvalidTokenException (off);  }  
Missing Default,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,setRefChar,The following switch statement is missing a default case: switch (charTypeTable [num >> 8] [num & 0xFF]) {  case BT_NONXML:  case BT_LEAD4:  case BT_MALFORM:  	throw new InvalidTokenException (token.TokenEnd - minBPC);  }  
Missing Default,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following switch statement is missing a default case: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Missing Default,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,isMagicEntityRef,The following switch statement is missing a default case: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Missing Default,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,scanLt,The following switch statement is missing a default case: switch (byteType (buf' off)) {  case BT_MINUS:  	return scanComment (buf' off + minBPC' end' token);  case BT_LSQB:  	return scanCdataSection (buf' off + minBPC' end' token);  }  
Missing Default,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getInitialEncoding,The following switch statement is missing a default case: switch ((b0 << 8) | b1) {  case 0xFEFF:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<';  case '<':  	/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  case 0xFFFE:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<' << 8;  case '<' << 8:  	/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  }  
Missing Default,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,getEncoding,The following switch statement is missing a default case: switch (name.ToUpper ()) {  case "UTF-8":  	return getEncoding (UTF8_ENCODING);  /*                 case "UTF-16":                     return getUTF16Encoding();                 case "ISO-8859-1":                     return getEncoding(ISO8859_1_ENCODING);                 case "US-ASCII":                     return getEncoding(ASCII_ENCODING);                     */}  
Missing Default,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following switch statement is missing a default case: switch (byteType (buf' off)) {  case BT_EXCL:  	return scanDecl (buf' off + minBPC' end' token);  case BT_QUEST:  	return scanPi (buf' off + minBPC' end' token);  case BT_NMSTRT:  case BT_LEAD2:  case BT_LEAD3:  case BT_LEAD4:  	token.TokenEnd = off - minBPC;  	throw new EndOfPrologException ();  }  
Missing Default,xpnet,Encoding,C:\repos\meebey_jabber-net\xpnet\Encoding.cs,tokenizeProlog,The following switch statement is missing a default case: switch (byteType (buf' off)) {  case BT_AST:  	token.TokenEnd = off + minBPC;  	return TOK.CLOSE_PAREN_ASTERISK;  case BT_QUEST:  	token.TokenEnd = off + minBPC;  	return TOK.CLOSE_PAREN_QUESTION;  case BT_PLUS:  	token.TokenEnd = off + minBPC;  	return TOK.CLOSE_PAREN_PLUS;  case BT_CR:  case BT_LF:  case BT_S:  case BT_GT:  case BT_COMMA:  case BT_VERBAR:  case BT_RPAR:  	token.TokenEnd = off;  	return TOK.CLOSE_PAREN;  }  
Missing Default,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,convert,The following switch statement is missing a default case: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Missing Default,xpnet,UTF8Encoding,C:\repos\meebey_jabber-net\xpnet\UTF8Encoding.cs,movePosition,The following switch statement is missing a default case: switch (b) {  case (byte)'\n':  	lineNumber += 1;  	colDiff = off;  	break;  case (byte)'\r':  	lineNumber += 1;  	if (off != end && buf [off] == '\n')  		off++;  	colDiff = off;  	break;  }  
