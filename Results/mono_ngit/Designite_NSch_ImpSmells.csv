Implementation smell,Namespace,Class,File,Method,Description
Long Method,NSch,ChannelAgentForwarding,C:\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,Write,The method has 193 lines of code.
Long Method,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Put,The method has 136 lines of code.
Long Method,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_put,The method has 171 lines of code.
Long Method,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Get,The method has 129 lines of code.
Long Method,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_get,The method has 136 lines of code.
Long Method,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Ls,The method has 167 lines of code.
Long Method,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Glob_remote,The method has 124 lines of code.
Long Method,NSch,_InputStream_1195,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Read,The method has 133 lines of code.
Long Method,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The method has 176 lines of code.
Long Method,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The method has 219 lines of code.
Long Method,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The method has 407 lines of code.
Long Method,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The method has 218 lines of code.
Long Method,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The method has 168 lines of code.
Long Method,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The method has 435 lines of code.
Long Method,NSch,KeyPairDSA,C:\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,The method has 133 lines of code.
Long Method,NSch,KeyPairRSA,C:\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The method has 173 lines of code.
Long Method,NSch,KnownHosts,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,SetKnownHosts,The method has 168 lines of code.
Long Method,NSch,ProxyHTTP,C:\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,The method has 123 lines of code.
Long Method,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The method has 161 lines of code.
Long Method,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The method has 404 lines of code.
Long Method,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,CheckHost,The method has 126 lines of code.
Long Method,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Read,The method has 166 lines of code.
Long Method,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Write,The method has 105 lines of code.
Long Method,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Run,The method has 383 lines of code.
Long Method,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,GetPermissionsString,The method has 105 lines of code.
Long Method,NSch,UserAuthGSSAPIWithMIC,C:\repos\mono_ngit\NSch\NSch\UserAuthGSSAPIWithMIC.cs,Start,The method has 187 lines of code.
Long Method,NSch,UserAuthKeyboardInteractive,C:\repos\mono_ngit\NSch\NSch\UserAuthKeyboardInteractive.cs,Start,The method has 177 lines of code.
Long Method,NSch,UserAuthPassword,C:\repos\mono_ngit\NSch\NSch\UserAuthPassword.cs,Start,The method has 164 lines of code.
Long Method,NSch,UserAuthPublicKey,C:\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The method has 233 lines of code.
Long Method,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,Glob,The method has 139 lines of code.
Long Method,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The method has 172 lines of code.
Long Method,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The method has 546 lines of code.
Long Method,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The method has 410 lines of code.
Long Method,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The method has 281 lines of code.
Long Method,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The method has 268 lines of code.
Long Method,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The method has 240 lines of code.
Long Method,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The method has 125 lines of code.
Long Method,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_fast,The method has 117 lines of code.
Long Method,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_slow,The method has 147 lines of code.
Long Method,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The method has 174 lines of code.
Complex Method,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,GetChannel,Cyclomatic complexity of the method is 10
Complex Method,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Put,Cyclomatic complexity of the method is 16
Complex Method,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_put,Cyclomatic complexity of the method is 23
Complex Method,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Get,Cyclomatic complexity of the method is 14
Complex Method,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_get,Cyclomatic complexity of the method is 20
Complex Method,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Ls,Cyclomatic complexity of the method is 15
Complex Method,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Glob_remote,Cyclomatic complexity of the method is 19
Complex Method,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Glob_local,Cyclomatic complexity of the method is 12
Complex Method,NSch,_OutputStream_686,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Write,Cyclomatic complexity of the method is 9
Complex Method,NSch,_InputStream_1195,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Read,Cyclomatic complexity of the method is 25
Complex Method,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,Cyclomatic complexity of the method is 46
Complex Method,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,Cyclomatic complexity of the method is 27
Complex Method,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,Cyclomatic complexity of the method is 21
Complex Method,NSch,KeyExchange,C:\repos\mono_ngit\NSch\NSch\KeyExchange.cs,Guess,Cyclomatic complexity of the method is 11
Complex Method,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,Cyclomatic complexity of the method is 52
Complex Method,NSch,KeyPairDSA,C:\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,Cyclomatic complexity of the method is 19
Complex Method,NSch,KeyPairRSA,C:\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,Cyclomatic complexity of the method is 24
Complex Method,NSch,KnownHosts,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,SetKnownHosts,Cyclomatic complexity of the method is 25
Complex Method,NSch,KnownHosts,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,Add,Cyclomatic complexity of the method is 9
Complex Method,NSch,ProxyHTTP,C:\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,Cyclomatic complexity of the method is 15
Complex Method,NSch,ProxySOCKS4,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Connect,Cyclomatic complexity of the method is 9
Complex Method,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Connect,Cyclomatic complexity of the method is 45
Complex Method,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,CheckHost,Cyclomatic complexity of the method is 17
Complex Method,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Read,Cyclomatic complexity of the method is 15
Complex Method,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Disconnect,Cyclomatic complexity of the method is 9
Complex Method,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,CheckCiphers,Cyclomatic complexity of the method is 8
Complex Method,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,CheckKexes,Cyclomatic complexity of the method is 8
Complex Method,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,GetPermissionsString,Cyclomatic complexity of the method is 11
Complex Method,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,GetATTR,Cyclomatic complexity of the method is 9
Complex Method,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,Cyclomatic complexity of the method is 8
Complex Method,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Dump,Cyclomatic complexity of the method is 9
Complex Method,NSch,UserAuthGSSAPIWithMIC,C:\repos\mono_ngit\NSch\NSch\UserAuthGSSAPIWithMIC.cs,Start,Cyclomatic complexity of the method is 17
Complex Method,NSch,UserAuthKeyboardInteractive,C:\repos\mono_ngit\NSch\NSch\UserAuthKeyboardInteractive.cs,Start,Cyclomatic complexity of the method is 20
Complex Method,NSch,UserAuthNone,C:\repos\mono_ngit\NSch\NSch\UserAuthNone.cs,Start,Cyclomatic complexity of the method is 9
Complex Method,NSch,UserAuthPassword,C:\repos\mono_ngit\NSch\NSch\UserAuthPassword.cs,Start,Cyclomatic complexity of the method is 19
Complex Method,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,Glob,Cyclomatic complexity of the method is 25
Complex Method,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Inflate_flush,Cyclomatic complexity of the method is 9
Complex Method,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,Cyclomatic complexity of the method is 25
Complex Method,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,Cyclomatic complexity of the method is 12
Complex Method,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_stored,Cyclomatic complexity of the method is 11
Complex Method,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_fast,Cyclomatic complexity of the method is 14
Complex Method,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_slow,Cyclomatic complexity of the method is 15
Complex Method,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,Cyclomatic complexity of the method is 21
Long Parameter List,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The method has 6 parameters. Parameters: session' _address_to_bind' port' target' lport' factory
Long Parameter List,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The method has 5 parameters. Parameters: session' _address_to_bind' port' daemon' arg
Long Parameter List,NSch,ChannelSession,C:\repos\mono_ngit\NSch\NSch\ChannelSession.cs,SetPtyType,The method has 5 parameters. Parameters: ttype' col' row' wp' hp
Long Parameter List,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Get,The method has 5 parameters. Parameters: src' dst' monitor' mode' skip
Long Parameter List,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_get,The method has 5 parameters. Parameters: src' dst' monitor' mode' skip
Long Parameter List,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendWRITE,The method has 5 parameters. Parameters: handle' offset' data' start' length
Long Parameter List,NSch,Cipher,C:\repos\mono_ngit\NSch\NSch\Cipher.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch,CipherNone,C:\repos\mono_ngit\NSch\NSch\CipherNone.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Init,The method has 5 parameters. Parameters: session' V_S' V_C' I_S' I_C
Long Parameter List,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Init,The method has 5 parameters. Parameters: session' V_S' V_C' I_S' I_C
Long Parameter List,NSch,KeyExchange,C:\repos\mono_ngit\NSch\NSch\KeyExchange.cs,Init,The method has 5 parameters. Parameters: session' V_S' V_C' I_S' I_C
Long Parameter List,NSch,PortWatcher,C:\repos\mono_ngit\NSch\NSch\PortWatcher.cs,AddPort,The method has 6 parameters. Parameters: session' address' lport' host' rport' ssf
Long Parameter List,NSch,PortWatcher,C:\repos\mono_ngit\NSch\NSch\PortWatcher.cs,PortWatcher,The method has 6 parameters. Parameters: session' address' lport' host' rport' factory
Long Parameter List,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Start_discard,The method has 5 parameters. Parameters: buf' cipher' mac' packet_length' discard
Long Parameter List,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,SetPortForwardingL,The method has 5 parameters. Parameters: boundaddress' lport' host' rport' ssf
Long Parameter List,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,SetPortForwardingR,The method has 5 parameters. Parameters: bind_address' rport' host' lport' sf
Long Parameter List,NSch,UIKeyboardInteractive,C:\repos\mono_ngit\NSch\NSch\UIKeyboardInteractive.cs,PromptKeyboardInteractive,The method has 5 parameters. Parameters: destination' name' instruction' prompt' echo
Long Parameter List,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Init,The method has 5 parameters. Parameters: session' V_S' V_C' I_S' I_C
Long Parameter List,NSch.Jce,AES128CBC,C:\repos\mono_ngit\NSch\NSch.Jce\AES128CBC.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,AES128CTR,C:\repos\mono_ngit\NSch\NSch.Jce\AES128CTR.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,AES192CBC,C:\repos\mono_ngit\NSch\NSch.Jce\AES192CBC.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,AES192CTR,C:\repos\mono_ngit\NSch\NSch.Jce\AES192CTR.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,AES256CBC,C:\repos\mono_ngit\NSch\NSch.Jce\AES256CBC.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,AES256CTR,C:\repos\mono_ngit\NSch\NSch.Jce\AES256CTR.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,ARCFOUR,C:\repos\mono_ngit\NSch\NSch.Jce\ARCFOUR.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,ARCFOUR128,C:\repos\mono_ngit\NSch\NSch.Jce\ARCFOUR128.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,ARCFOUR256,C:\repos\mono_ngit\NSch\NSch.Jce\ARCFOUR256.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,BlowfishCBC,C:\repos\mono_ngit\NSch\NSch.Jce\BlowfishCBC.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,TripleDESCBC,C:\repos\mono_ngit\NSch\NSch.Jce\TripleDESCBC.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.Jce,TripleDESCTR,C:\repos\mono_ngit\NSch\NSch.Jce\TripleDESCTR.cs,Update,The method has 5 parameters. Parameters: foo' s1' len' bar' s2
Long Parameter List,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Init,The method has 7 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' z
Long Parameter List,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,NSch.ZLib,StaticTree,C:\repos\mono_ngit\NSch\NSch.ZLib\StaticTree.cs,StaticTree,The method has 5 parameters. Parameters: static_tree' extra_bits' extra_base' elems' max_length
Long Parameter List,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The method has 6 parameters. Parameters: strm' level' method' windowBits' memLevel' strategy
Long Parameter List,NSch.ZLib,Config,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Config,The method has 5 parameters. Parameters: good_length' max_lazy' nice_length' max_chain' func
Long Parameter List,Sharpen,Cipher,C:\repos\mono_ngit\NSch\NSch\Sharpen\Cipher.cs,Update,The method has 5 parameters. Parameters: input' inputOffset' inputLen' output' outputOffset
Long Parameter List,Sharpen,R4Cipher,C:\repos\mono_ngit\NSch\NSch\Sharpen\Cipher.cs,Update,The method has 5 parameters. Parameters: input' inputOffset' inputLen' output' outputOffset
Long Parameter List,Sharpen,AesCipher,C:\repos\mono_ngit\NSch\NSch\Sharpen\Cipher.cs,Update,The method has 5 parameters. Parameters: input' inputOffset' inputLen' output' outputOffset
Long Parameter List,Sharpen,DESedeCipher,C:\repos\mono_ngit\NSch\NSch\Sharpen\Cipher.cs,Update,The method has 5 parameters. Parameters: input' inputOffset' inputLen' output' outputOffset
Long Identifier,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,,The length of the parameter SSH_MSG_CHANNEL_OPEN_CONFIRMATION is 33.
Long Identifier,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,,The length of the parameter SSH_OPEN_ADMINISTRATIVELY_PROHIBITED is 36.
Long Identifier,NSch,ChannelAgentForwarding,C:\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,,The length of the parameter SSH_AGENTC_REQUEST_RSA_IDENTITIES is 33.
Long Identifier,NSch,ChannelAgentForwarding,C:\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,,The length of the parameter SSH_AGENT_RSA_IDENTITIES_ANSWER is 31.
Long Identifier,NSch,ChannelAgentForwarding,C:\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,,The length of the parameter SSH_AGENTC_REMOVE_RSA_IDENTITY is 30.
Long Identifier,NSch,ChannelAgentForwarding,C:\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,,The length of the parameter SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES is 36.
Long Identifier,NSch,ChannelAgentForwarding,C:\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,,The length of the parameter SSH2_AGENTC_REQUEST_IDENTITIES is 30.
Long Identifier,NSch,ChannelAgentForwarding,C:\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,,The length of the parameter SSH2_AGENTC_REMOVE_ALL_IDENTITIES is 33.
Long Identifier,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,,The length of the parameter SSH_MSG_CHANNEL_OPEN_CONFIRMATION is 33.
Long Identifier,NSch,UserAuth,C:\repos\mono_ngit\NSch\NSch\UserAuth.cs,,The length of the parameter SSH_MSG_USERAUTH_INFO_RESPONSE is 30.
Long Identifier,NSch,UserAuthGSSAPIWithMIC,C:\repos\mono_ngit\NSch\NSch\UserAuthGSSAPIWithMIC.cs,,The length of the parameter SSH_MSG_USERAUTH_GSSAPI_RESPONSE is 32.
Long Identifier,NSch,UserAuthGSSAPIWithMIC,C:\repos\mono_ngit\NSch\NSch\UserAuthGSSAPIWithMIC.cs,,The length of the parameter SSH_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE is 41.
Long Identifier,NSch,UserAuthGSSAPIWithMIC,C:\repos\mono_ngit\NSch\NSch\UserAuthGSSAPIWithMIC.cs,,The length of the parameter SSH_MSG_USERAUTH_GSSAPI_ERRTOK is 30.
Long Identifier,NSch,UserAuthPassword,C:\repos\mono_ngit\NSch\NSch\UserAuthPassword.cs,,The length of the parameter SSH_MSG_USERAUTH_PASSWD_CHANGEREQ is 33.
Long Statement,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,CheckHost,The length of the statement  "					string message = "WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!\n" + "IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\n" " is 129.
Complex Conditional,NSch,ChannelDirectTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,Run,The conditional expression  "IsConnected() && thread != null && io != null && io.@in != null"  is complex.
Complex Conditional,NSch,ChannelSession,C:\repos\mono_ngit\NSch\NSch\ChannelSession.cs,Run,The conditional expression  "IsConnected() && thread != null && io != null && io.@in != null"  is complex.
Complex Conditional,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "pubkey == null && prvkey != null && (prvkey.Length > 11 && prvkey[0] == 0 &&   				prvkey[1] == 0 && prvkey[2] == 0 && prvkey[3] == 7)"  is complex.
Complex Conditional,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-'"  is complex.
Complex Conditional,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I'"  is complex.
Complex Conditional,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-'"  is complex.
Complex Conditional,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-'"  is complex.
Complex Conditional,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-'"  is complex.
Complex Conditional,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == '''"  is complex.
Complex Conditional,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb)))"  is complex.
Complex Conditional,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-'"  is complex.
Complex Conditional,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The conditional expression  "buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-'"  is complex.
Complex Conditional,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-'"  is complex.
Complex Conditional,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I'"  is complex.
Complex Conditional,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-'"  is complex.
Complex Conditional,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-'"  is complex.
Complex Conditional,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-'"  is complex.
Complex Conditional,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == '''"  is complex.
Complex Conditional,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb)))"  is complex.
Complex Conditional,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-'"  is complex.
Complex Conditional,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The conditional expression  "buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-'"  is complex.
Complex Conditional,NSch,KnownHosts,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,GetHostKey,The conditional expression  "host == null || (hk.IsMatched(host) && (type == null || hk.GetType().Equals(type  						)))"  is complex.
Complex Conditional,NSch,KnownHosts,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,GetHostKey,The conditional expression  "host == null || (hk.IsMatched(host) && (type == null || hk.GetType().Equals(type  						)))"  is complex.
Complex Conditional,NSch,KnownHosts,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,Remove,The conditional expression  "host == null || (hk.IsMatched(host) && (type == null || (hk.GetType().Equals(  						type) && (key == null || Util.Array_equals(key' hk.key)))))"  is complex.
Complex Conditional,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The conditional expression  "i <= 3 || ((i != buf.buffer.Length) && (buf.buffer[0] != 'S' || buf.buffer[1]  						 != 'S' || buf.buffer[2] != 'H' || buf.buffer[3] != '-'))"  is complex.
Complex Conditional,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The conditional expression  "i == buf.buffer.Length || i < 7 || (buf.buffer[4] == '1' && buf.buffer[6] !=   						'9')"  is complex.
Complex Conditional,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,CheckHost,The conditional expression  "(shkc.Equals("ask") || shkc.Equals("yes")) && (i != HostKeyRepository.OK) &&   				!insert"  is complex.
Complex Conditional,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Write,The conditional expression  "command == SSH_MSG_KEXINIT || command == SSH_MSG_NEWKEYS || command == SSH_MSG_KEXDH_INIT  					 || command == SSH_MSG_KEXDH_REPLY || command == SSH_MSG_KEX_DH_GEX_GROUP || command  					 == SSH_MSG_KEX_DH_GEX_INIT || command == SSH_MSG_KEX_DH_GEX_REPLY || command ==  					 SSH_MSG_KEX_DH_GEX_REQUEST || command == SSH_MSG_DISCONNECT"  is complex.
Complex Conditional,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Run,The conditional expression  "!"forwarded-tcpip".Equals(ctyp) && !("x11".Equals(ctyp) && x11_forwarding) &&  								 !("auth-agent@openssh.com".Equals(ctyp) && agent_forwarding)"  is complex.
Complex Conditional,NSch,UserAuthKeyboardInteractive,C:\repos\mono_ngit\NSch\NSch\UserAuthKeyboardInteractive.cs,Start,The conditional expression  "password != null && prompt.Length == 1 && !echo[0] && prompt[0].ToLower().StartsWith  							("password:")"  is complex.
Complex Conditional,NSch.ZLib,ZStream,C:\repos\mono_ngit\NSch\NSch.ZLib\ZStream.cs,Flush_pending,The conditional expression  "dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index  				 || dstate.pending_buf.Length < (dstate.pending_out + len) || next_out.Length <   				(next_out_index + len)"  is complex.
Complex Conditional,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_slow,The conditional expression  "match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH &&  						 strstart - match_start > 4096))"  is complex.
Complex Conditional,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Longest_match,The conditional expression  "window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1  					 || window[match] != window[scan] || window[++match] != window[scan + 1]"  is complex.
Complex Conditional,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The conditional expression  "memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits  				 < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy >   				Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateParams,The conditional expression  "_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The conditional expression  "strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) || (status  				 == FINISH_STATE && flush != Z_FINISH)"  is complex.
Complex Conditional,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The conditional expression  "strm.avail_in != 0 || lookahead != 0 || (flush != Z_NO_FLUSH && status != FINISH_STATE  				)"  is complex.
Virtual Method Call from Constructor,NSch,ChannelAgentForwarding,C:\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,ChannelAgentForwarding,The constructor "ChannelAgentForwarding" calls a virtual method "SetLocalWindowSizeMax".
Virtual Method Call from Constructor,NSch,ChannelAgentForwarding,C:\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,ChannelAgentForwarding,The constructor "ChannelAgentForwarding" calls a virtual method "SetLocalWindowSize".
Virtual Method Call from Constructor,NSch,ChannelAgentForwarding,C:\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,ChannelAgentForwarding,The constructor "ChannelAgentForwarding" calls a virtual method "SetLocalPacketSize".
Virtual Method Call from Constructor,NSch,ChannelAgentForwarding,C:\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,ChannelAgentForwarding,The constructor "ChannelAgentForwarding" calls a virtual method "Reset".
Virtual Method Call from Constructor,NSch,ChannelDirectTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,ChannelDirectTCPIP,The constructor "ChannelDirectTCPIP" calls a virtual method "SetLocalWindowSizeMax".
Virtual Method Call from Constructor,NSch,ChannelDirectTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,ChannelDirectTCPIP,The constructor "ChannelDirectTCPIP" calls a virtual method "SetLocalWindowSize".
Virtual Method Call from Constructor,NSch,ChannelDirectTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,ChannelDirectTCPIP,The constructor "ChannelDirectTCPIP" calls a virtual method "SetLocalPacketSize".
Virtual Method Call from Constructor,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,ChannelForwardedTCPIP,The constructor "ChannelForwardedTCPIP" calls a virtual method "SetLocalWindowSizeMax".
Virtual Method Call from Constructor,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,ChannelForwardedTCPIP,The constructor "ChannelForwardedTCPIP" calls a virtual method "SetLocalWindowSize".
Virtual Method Call from Constructor,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,ChannelForwardedTCPIP,The constructor "ChannelForwardedTCPIP" calls a virtual method "SetLocalPacketSize".
Virtual Method Call from Constructor,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,ChannelSftp,The constructor "ChannelSftp" calls a virtual method "SetLocalWindowSizeMax".
Virtual Method Call from Constructor,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,ChannelSftp,The constructor "ChannelSftp" calls a virtual method "SetLocalWindowSize".
Virtual Method Call from Constructor,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,ChannelSftp,The constructor "ChannelSftp" calls a virtual method "SetLocalPacketSize".
Virtual Method Call from Constructor,NSch,RequestQueue,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,RequestQueue,The constructor "RequestQueue" calls a virtual method "Init".
Virtual Method Call from Constructor,NSch,LsEntry,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,LsEntry,The constructor "LsEntry" calls a virtual method "SetFilename".
Virtual Method Call from Constructor,NSch,LsEntry,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,LsEntry,The constructor "LsEntry" calls a virtual method "SetLongname".
Virtual Method Call from Constructor,NSch,LsEntry,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,LsEntry,The constructor "LsEntry" calls a virtual method "SetAttrs".
Virtual Method Call from Constructor,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,ChannelX11,The constructor "ChannelX11" calls a virtual method "SetLocalWindowSizeMax".
Virtual Method Call from Constructor,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,ChannelX11,The constructor "ChannelX11" calls a virtual method "SetLocalWindowSize".
Virtual Method Call from Constructor,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,ChannelX11,The constructor "ChannelX11" calls a virtual method "SetLocalPacketSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetBlockSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetIVSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetBlockSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetIVSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetBlockSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetIVSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetBlockSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetIVSize".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetInt".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetInt".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetString".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetInt".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetOffSet".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetByte".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetInt".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetOffSet".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "GetByte".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "IsEnabled".
Virtual Method Call from Constructor,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The constructor "IdentityFile" calls a virtual method "Log".
Virtual Method Call from Constructor,NSch,RequestSftp,C:\repos\mono_ngit\NSch\NSch\RequestSftp.cs,RequestSftp,The constructor "RequestSftp" calls a virtual method "SetReply".
Virtual Method Call from Constructor,NSch.Jcraft,HMACMD5,C:\repos\mono_ngit\NSch\NSch.Jcraft\HMACMD5.cs,HMACMD5,The constructor "HMACMD5" calls a virtual method "SetH".
Virtual Method Call from Constructor,NSch.Jcraft,HMACSHA1,C:\repos\mono_ngit\NSch\NSch.Jcraft\HMACSHA1.cs,HMACSHA1,The constructor "HMACSHA1" calls a virtual method "SetH".
Empty Catch Block,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,Write,The method has an empty catch block.
Empty Catch Block,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,Write_ext,The method has an empty catch block.
Empty Catch Block,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,Eof_remote,The method has an empty catch block.
Empty Catch Block,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,Eof,The method has an empty catch block.
Empty Catch Block,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,Close,The method has an empty catch block.
Empty Catch Block,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,SendOpenFailure,The method has an empty catch block.
Empty Catch Block,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,SendChannelOpen,The method has an empty catch block.
Empty Catch Block,NSch,ChannelAgentForwarding,C:\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,Send,The method has an empty catch block.
Empty Catch Block,NSch,ChannelDirectTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetData,The method has an empty catch block.
Empty Catch Block,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,DelPort,The method has an empty catch block.
Empty Catch Block,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,DelPort,The method has an empty catch block.
Empty Catch Block,NSch,ChannelSession,C:\repos\mono_ngit\NSch\NSch\ChannelSession.cs,SetPtySize,The method has an empty catch block.
Empty Catch Block,NSch,ChannelSession,C:\repos\mono_ngit\NSch\NSch\ChannelSession.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Lcd,The method has an empty catch block.
Empty Catch Block,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Put,The method has an empty catch block.
Empty Catch Block,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_put,The method has an empty catch block.
Empty Catch Block,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Put,The method has an empty catch block.
Empty Catch Block,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,IsRemoteDir,The method has an empty catch block.
Empty Catch Block,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Glob_local,The method has an empty catch block.
Empty Catch Block,NSch,Request,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Write,The method has an empty catch block.
Empty Catch Block,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch,IO,C:\repos\mono_ngit\NSch\NSch\IO.cs,Out_close,The method has an empty catch block.
Empty Catch Block,NSch,IO,C:\repos\mono_ngit\NSch\NSch\IO.cs,Close,The method has an empty catch block.
Empty Catch Block,NSch,IO,C:\repos\mono_ngit\NSch\NSch\IO.cs,Close,The method has an empty catch block.
Empty Catch Block,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,NewInstance,The method has an empty catch block.
Empty Catch Block,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,NewInstance,The method has an empty catch block.
Empty Catch Block,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetSignature_rsa,The method has an empty catch block.
Empty Catch Block,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetSignature_dss,The method has an empty catch block.
Empty Catch Block,NSch,JSch,C:\repos\mono_ngit\NSch\NSch\JSch.cs,JSch,The method has an empty catch block.
Empty Catch Block,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,WritePrivateKey,The method has an empty catch block.
Empty Catch Block,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,WritePublicKey,The method has an empty catch block.
Empty Catch Block,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,WriteSECSHPublicKey,The method has an empty catch block.
Empty Catch Block,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Encrypt,The method has an empty catch block.
Empty Catch Block,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Decrypt,The method has an empty catch block.
Empty Catch Block,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,GenHash,The method has an empty catch block.
Empty Catch Block,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,GenCipher,The method has an empty catch block.
Empty Catch Block,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The method has an empty catch block.
Empty Catch Block,NSch,KnownHosts,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,SetKnownHosts,The method has an empty catch block.
Empty Catch Block,NSch,KnownHosts,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,Remove,The method has an empty catch block.
Empty Catch Block,NSch,HashedHostKey,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,Hash,The method has an empty catch block.
Empty Catch Block,NSch,PortWatcher,C:\repos\mono_ngit\NSch\NSch\PortWatcher.cs,PortWatcher,The method has an empty catch block.
Empty Catch Block,NSch,PortWatcher,C:\repos\mono_ngit\NSch\NSch\PortWatcher.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch,PortWatcher,C:\repos\mono_ngit\NSch\NSch\PortWatcher.cs,Delete,The method has an empty catch block.
Empty Catch Block,NSch,ProxyHTTP,C:\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,ProxyHTTP,The method has an empty catch block.
Empty Catch Block,NSch,ProxyHTTP,C:\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,The method has an empty catch block.
Empty Catch Block,NSch,ProxyHTTP,C:\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,The method has an empty catch block.
Empty Catch Block,NSch,ProxyHTTP,C:\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Close,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS4,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,ProxySOCKS4,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS4,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Connect,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS4,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Connect,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS4,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Close,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,ProxySOCKS5,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The method has an empty catch block.
Empty Catch Block,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Close,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,OpenChannel,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Write,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Write,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Write,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,SetPortForwarding,The method has an empty catch block.
Empty Catch Block,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,InitDeflater,The method has an empty catch block.
Empty Catch Block,NSch,UserAuthNone,C:\repos\mono_ngit\NSch\NSch\UserAuthNone.cs,Start,The method has an empty catch block.
Empty Catch Block,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,CreateSocket,The method has an empty catch block.
Empty Catch Block,NSch,_Runnable_350,C:\repos\mono_ngit\NSch\NSch\Util.cs,Run,The method has an empty catch block.
Empty Catch Block,NSch.Jce,HMACMD5,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD5.cs,DoFinal,The method has an empty catch block.
Empty Catch Block,NSch.Jce,HMACMD596,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,DoFinal,The method has an empty catch block.
Empty Catch Block,NSch.Jce,HMACSHA1,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA1.cs,DoFinal,The method has an empty catch block.
Empty Catch Block,NSch.Jce,HMACSHA196,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,DoFinal,The method has an empty catch block.
Empty Catch Block,NSch.Jcraft,HMAC,C:\repos\mono_ngit\NSch\NSch.Jcraft\HMAC.cs,DoFinal,The method has an empty catch block.
Empty Catch Block,NSch.Jgss,GSSContextKrb5,C:\repos\mono_ngit\NSch\NSch.Jgss\GSSContextKrb5.cs,Create,The method has an empty catch block.
Empty Catch Block,NSch.Jgss,GSSContextKrb5,C:\repos\mono_ngit\NSch\NSch.Jgss\GSSContextKrb5.cs,Dispose,The method has an empty catch block.
Empty Catch Block,NSch.Jgss,GSSContextKrb5,C:\repos\mono_ngit\NSch\NSch.Jgss\GSSContextKrb5.cs,SetSystemProperty,The method has an empty catch block.
Empty Catch Block,NSch.ZLib,ZOutputStream,C:\repos\mono_ngit\NSch\NSch.ZLib\ZOutputStream.cs,Close,The method has an empty catch block.
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutInt,The following statement contains a magic number: tmp[0] = unchecked((byte)((int)(((uint)val) >> 24)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutInt,The following statement contains a magic number: tmp[1] = unchecked((byte)((int)(((uint)val) >> 16)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutInt,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)val) >> 8)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutInt,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)val) >> 8)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutInt,The following statement contains a magic number: tmp[3] = unchecked((byte)(val));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutInt,The following statement contains a magic number: System.Array.Copy(tmp' 0' buffer' index' 4);
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutInt,The following statement contains a magic number: index += 4;
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[0] = unchecked((byte)((long)(((ulong)val) >> 56)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[1] = unchecked((byte)((long)(((ulong)val) >> 48)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[2] = unchecked((byte)((long)(((ulong)val) >> 40)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[2] = unchecked((byte)((long)(((ulong)val) >> 40)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[3] = unchecked((byte)((long)(((ulong)val) >> 32)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[3] = unchecked((byte)((long)(((ulong)val) >> 32)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: System.Array.Copy(tmp' 0' buffer' index' 4);
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[0] = unchecked((byte)((long)(((ulong)val) >> 24)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[1] = unchecked((byte)((long)(((ulong)val) >> 16)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[2] = unchecked((byte)((long)(((ulong)val) >> 8)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[2] = unchecked((byte)((long)(((ulong)val) >> 8)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: tmp[3] = unchecked((byte)(val));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: System.Array.Copy(tmp' 0' buffer' index + 4' 4);
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: System.Array.Copy(tmp' 0' buffer' index + 4' 4);
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,PutLong,The following statement contains a magic number: index += 8;
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetLong,The following statement contains a magic number: foo = ((foo << 32)) | (GetInt() & unchecked((long)(0xffffffffL)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetInt,The following statement contains a magic number: foo = ((foo << 16) & unchecked((int)(0xffff0000))) | (GetShort() & unchecked((int  				)(0xffff)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetUInt,The following statement contains a magic number: foo = ((foo << 8) & unchecked((int)(0xff00))) | (GetByte() & unchecked((int)(0xff  				)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetUInt,The following statement contains a magic number: bar = ((bar << 8) & unchecked((int)(0xff00))) | (GetByte() & unchecked((int)(0xff  				)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetUInt,The following statement contains a magic number: foo = ((foo << 16) & unchecked((int)(0xffff0000))) | (bar & unchecked((int)(0xffff  				)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetShort,The following statement contains a magic number: foo = ((foo << 8) & unchecked((int)(0xff00))) | (GetByte() & unchecked((int)(0xff  				)));
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetMPInt,The following statement contains a magic number: if (i < 0 || i > 8 * 1024)  			{  				// bigger than 0x7fffffff  				// TODO: an exception should be thrown.  				i = 8 * 1024;  			}
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetMPInt,The following statement contains a magic number: if (i < 0 || i > 8 * 1024)  			{  				// bigger than 0x7fffffff  				// TODO: an exception should be thrown.  				i = 8 * 1024;  			}
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetMPInt,The following statement contains a magic number: if (i < 0 || i > 8 * 1024)  			{  				// bigger than 0x7fffffff  				// TODO: an exception should be thrown.  				i = 8 * 1024;  			}
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetMPInt,The following statement contains a magic number: if (i < 0 || i > 8 * 1024)  			{  				// bigger than 0x7fffffff  				// TODO: an exception should be thrown.  				i = 8 * 1024;  			}
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetMPIntBits,The following statement contains a magic number: int bytes = (bits + 7) / 8;
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetMPIntBits,The following statement contains a magic number: int bytes = (bits + 7) / 8;
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetString,The following statement contains a magic number: if (i < 0 || i > 256 * 1024)  			{  				// bigger than 0x7fffffff  				// TODO: an exception should be thrown.  				i = 256 * 1024;  			}
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetString,The following statement contains a magic number: if (i < 0 || i > 256 * 1024)  			{  				// bigger than 0x7fffffff  				// TODO: an exception should be thrown.  				i = 256 * 1024;  			}
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetString,The following statement contains a magic number: if (i < 0 || i > 256 * 1024)  			{  				// bigger than 0x7fffffff  				// TODO: an exception should be thrown.  				i = 256 * 1024;  			}
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetString,The following statement contains a magic number: if (i < 0 || i > 256 * 1024)  			{  				// bigger than 0x7fffffff  				// TODO: an exception should be thrown.  				i = 256 * 1024;  			}
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,GetCommand,The following statement contains a magic number: return buffer[5];
Magic Number,NSch,Buffer,C:\repos\mono_ngit\NSch\NSch\Buffer.cs,CheckFreeSize,The following statement contains a magic number: if (buffer.Length < index + n)  			{  				byte[] tmp = new byte[buffer.Length * 2];  				System.Array.Copy(buffer' 0' tmp' 0' index);  				buffer = tmp;  			}
Magic Number,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,GetInputStream,The following statement contains a magic number: PipedInputStream @in = new Channel.MyPipedInputStream(this' 32 * 1024);
Magic Number,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,GetInputStream,The following statement contains a magic number: PipedInputStream @in = new Channel.MyPipedInputStream(this' 32 * 1024);
Magic Number,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,GetExtInputStream,The following statement contains a magic number: PipedInputStream @in = new Channel.MyPipedInputStream(this' 32 * 1024);
Magic Number,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,GetExtInputStream,The following statement contains a magic number: PipedInputStream @in = new Channel.MyPipedInputStream(this' 32 * 1024);
Magic Number,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,Eof,The following statement contains a magic number: try  			{  				Buffer buf = new Buffer(100);  				Packet packet = new Packet(buf);  				packet.Reset();  				buf.PutByte(unchecked((byte)Session.SSH_MSG_CHANNEL_EOF));  				buf.PutInt(GetRecipient());  				lock (this)  				{  					if (!close)  					{  						GetSession().Write(packet);  					}  				}  			}  			catch (Exception)  			{  			}
Magic Number,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,Close,The following statement contains a magic number: try  			{  				Buffer buf = new Buffer(100);  				Packet packet = new Packet(buf);  				packet.Reset();  				buf.PutByte(unchecked((byte)Session.SSH_MSG_CHANNEL_CLOSE));  				buf.PutInt(GetRecipient());  				lock (this)  				{  					GetSession().Write(packet);  				}  			}  			catch (Exception)  			{  			}
Magic Number,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,SendOpenConfirmation,The following statement contains a magic number: Buffer buf = new Buffer(100);
Magic Number,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,SendOpenFailure,The following statement contains a magic number: try  			{  				Buffer buf = new Buffer(100);  				Packet packet = new Packet(buf);  				packet.Reset();  				buf.PutByte(unchecked((byte)SSH_MSG_CHANNEL_OPEN_FAILURE));  				buf.PutInt(GetRecipient());  				buf.PutInt(reasoncode);  				buf.PutString(Util.Str2byte("open failed"));  				buf.PutString(Util.empty);  				GetSession().Write(packet);  			}  			catch (Exception)  			{  			}
Magic Number,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,GenChannelOpenPacket,The following statement contains a magic number: Buffer buf = new Buffer(100);
Magic Number,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,GenChannelOpenPacket,The following statement contains a magic number: buf.PutByte(unchecked((byte)90));
Magic Number,NSch,Channel,C:\repos\mono_ngit\NSch\NSch\Channel.cs,SendChannelOpen,The following statement contains a magic number: int retry = 10;
Magic Number,NSch,_OutputStream_220,C:\repos\mono_ngit\NSch\NSch\Channel.cs,Init,The following statement contains a magic number: lock (this)  				{  					this.buffer = new Buffer(this._enclosing.rmpsize);  					this.packet = new Packet(this.buffer);  					byte[] _buf = this.buffer.buffer;  					if (_buf.Length - (14 + 0) - Session.buffer_margin <= 0)  					{  						this.buffer = null;  						this.packet = null;  						throw new IOException("failed to initialize the channel.");  					}  				}
Magic Number,NSch,_OutputStream_220,C:\repos\mono_ngit\NSch\NSch\Channel.cs,Write,The following statement contains a magic number: while (l > 0)  				{  					int _l = l;  					if (l > _bufl - (14 + this.dataLen) - Session.buffer_margin)  					{  						_l = _bufl - (14 + this.dataLen) - Session.buffer_margin;  					}  					if (_l <= 0)  					{  						this.Flush();  						continue;  					}  					System.Array.Copy(buf' s' _buf' 14 + this.dataLen' _l);  					this.dataLen += _l;  					s += _l;  					l -= _l;  				}
Magic Number,NSch,_OutputStream_220,C:\repos\mono_ngit\NSch\NSch\Channel.cs,Write,The following statement contains a magic number: while (l > 0)  				{  					int _l = l;  					if (l > _bufl - (14 + this.dataLen) - Session.buffer_margin)  					{  						_l = _bufl - (14 + this.dataLen) - Session.buffer_margin;  					}  					if (_l <= 0)  					{  						this.Flush();  						continue;  					}  					System.Array.Copy(buf' s' _buf' 14 + this.dataLen' _l);  					this.dataLen += _l;  					s += _l;  					l -= _l;  				}
Magic Number,NSch,_OutputStream_220,C:\repos\mono_ngit\NSch\NSch\Channel.cs,Write,The following statement contains a magic number: while (l > 0)  				{  					int _l = l;  					if (l > _bufl - (14 + this.dataLen) - Session.buffer_margin)  					{  						_l = _bufl - (14 + this.dataLen) - Session.buffer_margin;  					}  					if (_l <= 0)  					{  						this.Flush();  						continue;  					}  					System.Array.Copy(buf' s' _buf' 14 + this.dataLen' _l);  					this.dataLen += _l;  					s += _l;  					l -= _l;  				}
Magic Number,NSch,ChannelAgentForwarding,C:\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,Write,The following statement contains a magic number: if (mlen > rbuf.GetLength())  			{  				rbuf.s -= 4;  				return;  			}
Magic Number,NSch,ChannelAgentForwarding,C:\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,Send,The following statement contains a magic number: wbuf.PutInt(4 + message.Length);
Magic Number,NSch,ChannelAgentForwarding,C:\repos\mono_ngit\NSch\NSch\ChannelAgentForwarding.cs,Send,The following statement contains a magic number: try  			{  				GetSession().Write(packet' this' 4 + message.Length);  			}  			catch (Exception)  			{  			}
Magic Number,NSch,ChannelDirectTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,Run,The following statement contains a magic number: try  			{  				SendChannelOpen();  				Buffer buf = new Buffer(rmpsize);  				Packet packet = new Packet(buf);  				Session _session = GetSession();  				int i = 0;  				while (IsConnected() && thread != null && io != null && io.@in != null)  				{  					i = io.@in.Read(buf.buffer' 14' buf.buffer.Length - 14 - Session.buffer_margin);  					if (i <= 0)  					{  						Eof();  						break;  					}  					packet.Reset();  					buf.PutByte(unchecked((byte)Session.SSH_MSG_CHANNEL_DATA));  					buf.PutInt(recipient);  					buf.PutInt(i);  					buf.Skip(i);  					lock (this)  					{  						if (close)  						{  							break;  						}  						_session.Write(packet' this' i);  					}  				}  			}  			catch (Exception)  			{  			}
Magic Number,NSch,ChannelDirectTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,Run,The following statement contains a magic number: try  			{  				SendChannelOpen();  				Buffer buf = new Buffer(rmpsize);  				Packet packet = new Packet(buf);  				Session _session = GetSession();  				int i = 0;  				while (IsConnected() && thread != null && io != null && io.@in != null)  				{  					i = io.@in.Read(buf.buffer' 14' buf.buffer.Length - 14 - Session.buffer_margin);  					if (i <= 0)  					{  						Eof();  						break;  					}  					packet.Reset();  					buf.PutByte(unchecked((byte)Session.SSH_MSG_CHANNEL_DATA));  					buf.PutInt(recipient);  					buf.PutInt(i);  					buf.Skip(i);  					lock (this)  					{  						if (close)  						{  							break;  						}  						_session.Write(packet' this' i);  					}  				}  			}  			catch (Exception)  			{  			}
Magic Number,NSch,ChannelDirectTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,GenChannelOpenPacket,The following statement contains a magic number: Buffer buf = new Buffer(150);
Magic Number,NSch,ChannelDirectTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelDirectTCPIP.cs,GenChannelOpenPacket,The following statement contains a magic number: buf.PutByte(unchecked((byte)90));
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,Run,The following statement contains a magic number: try  			{  				if (lport == -1)  				{  					Type c = Sharpen.Runtime.GetType(target);  					daemon = (ForwardedTCPIPDaemon)System.Activator.CreateInstance(c);  					PipedOutputStream @out = new PipedOutputStream();  					io.SetInputStream(new Channel.PassiveInputStream(this' @out' 32 * 1024)' false);  					daemon.SetChannel(this' GetInputStream()' @out);  					object[] foo = GetPort(GetSession()' rport);  					daemon.SetArg((object[])foo[3]);  					new Sharpen.Thread(daemon).Start();  				}  				else  				{  					socket = (factory == null) ? Util.CreateSocket(target' lport' TIMEOUT) : factory.  						CreateSocket(target' lport);  					socket.NoDelay = true;  					io.SetInputStream(socket.GetInputStream());  					io.SetOutputStream(socket.GetOutputStream());  				}  				SendOpenConfirmation();  			}  			catch (Exception)  			{  				SendOpenFailure(SSH_OPEN_ADMINISTRATIVELY_PROHIBITED);  				close = true;  				Disconnect();  				return;  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,Run,The following statement contains a magic number: try  			{  				if (lport == -1)  				{  					Type c = Sharpen.Runtime.GetType(target);  					daemon = (ForwardedTCPIPDaemon)System.Activator.CreateInstance(c);  					PipedOutputStream @out = new PipedOutputStream();  					io.SetInputStream(new Channel.PassiveInputStream(this' @out' 32 * 1024)' false);  					daemon.SetChannel(this' GetInputStream()' @out);  					object[] foo = GetPort(GetSession()' rport);  					daemon.SetArg((object[])foo[3]);  					new Sharpen.Thread(daemon).Start();  				}  				else  				{  					socket = (factory == null) ? Util.CreateSocket(target' lport' TIMEOUT) : factory.  						CreateSocket(target' lport);  					socket.NoDelay = true;  					io.SetInputStream(socket.GetInputStream());  					io.SetOutputStream(socket.GetOutputStream());  				}  				SendOpenConfirmation();  			}  			catch (Exception)  			{  				SendOpenFailure(SSH_OPEN_ADMINISTRATIVELY_PROHIBITED);  				close = true;  				Disconnect();  				return;  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,Run,The following statement contains a magic number: try  			{  				if (lport == -1)  				{  					Type c = Sharpen.Runtime.GetType(target);  					daemon = (ForwardedTCPIPDaemon)System.Activator.CreateInstance(c);  					PipedOutputStream @out = new PipedOutputStream();  					io.SetInputStream(new Channel.PassiveInputStream(this' @out' 32 * 1024)' false);  					daemon.SetChannel(this' GetInputStream()' @out);  					object[] foo = GetPort(GetSession()' rport);  					daemon.SetArg((object[])foo[3]);  					new Sharpen.Thread(daemon).Start();  				}  				else  				{  					socket = (factory == null) ? Util.CreateSocket(target' lport' TIMEOUT) : factory.  						CreateSocket(target' lport);  					socket.NoDelay = true;  					io.SetInputStream(socket.GetInputStream());  					io.SetOutputStream(socket.GetOutputStream());  				}  				SendOpenConfirmation();  			}  			catch (Exception)  			{  				SendOpenFailure(SSH_OPEN_ADMINISTRATIVELY_PROHIBITED);  				close = true;  				Disconnect();  				return;  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,Run,The following statement contains a magic number: try  			{  				Session _session = GetSession();  				while (thread != null && io != null && io.@in != null)  				{  					i = io.@in.Read(buf.buffer' 14' buf.buffer.Length - 14 - Session.buffer_margin);  					if (i <= 0)  					{  						Eof();  						break;  					}  					packet.Reset();  					buf.PutByte(unchecked((byte)Session.SSH_MSG_CHANNEL_DATA));  					buf.PutInt(recipient);  					buf.PutInt(i);  					buf.Skip(i);  					lock (this)  					{  						if (close)  						{  							break;  						}  						_session.Write(packet' this' i);  					}  				}  			}  			catch (Exception)  			{  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,Run,The following statement contains a magic number: try  			{  				Session _session = GetSession();  				while (thread != null && io != null && io.@in != null)  				{  					i = io.@in.Read(buf.buffer' 14' buf.buffer.Length - 14 - Session.buffer_margin);  					if (i <= 0)  					{  						Eof();  						break;  					}  					packet.Reset();  					buf.PutByte(unchecked((byte)Session.SSH_MSG_CHANNEL_DATA));  					buf.PutInt(recipient);  					buf.PutInt(i);  					buf.Skip(i);  					lock (this)  					{  						if (close)  						{  							break;  						}  						_session.Write(packet' this' i);  					}  				}  			}  			catch (Exception)  			{  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetData,The following statement contains a magic number: lock (pool)  			{  				for (int i = 0; i < pool.Count; i++)  				{  					object[] foo = (object[])(pool[i]);  					if (foo[0] != _session)  					{  						continue;  					}  					if (((int)foo[1]) != port)  					{  						continue;  					}  					this.rport = port;  					this.target = (string)foo[2];  					if (foo[3] == null || (foo[3] is object[]))  					{  						this.lport = -1;  					}  					else  					{  						this.lport = ((int)foo[3]);  					}  					if (foo.Length >= 6)  					{  						this.factory = ((SocketFactory)foo[5]);  					}  					break;  				}  				if (target == null)  				{  				}  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetData,The following statement contains a magic number: lock (pool)  			{  				for (int i = 0; i < pool.Count; i++)  				{  					object[] foo = (object[])(pool[i]);  					if (foo[0] != _session)  					{  						continue;  					}  					if (((int)foo[1]) != port)  					{  						continue;  					}  					this.rport = port;  					this.target = (string)foo[2];  					if (foo[3] == null || (foo[3] is object[]))  					{  						this.lport = -1;  					}  					else  					{  						this.lport = ((int)foo[3]);  					}  					if (foo.Length >= 6)  					{  						this.factory = ((SocketFactory)foo[5]);  					}  					break;  				}  				if (target == null)  				{  				}  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetData,The following statement contains a magic number: lock (pool)  			{  				for (int i = 0; i < pool.Count; i++)  				{  					object[] foo = (object[])(pool[i]);  					if (foo[0] != _session)  					{  						continue;  					}  					if (((int)foo[1]) != port)  					{  						continue;  					}  					this.rport = port;  					this.target = (string)foo[2];  					if (foo[3] == null || (foo[3] is object[]))  					{  						this.lport = -1;  					}  					else  					{  						this.lport = ((int)foo[3]);  					}  					if (foo.Length >= 6)  					{  						this.factory = ((SocketFactory)foo[5]);  					}  					break;  				}  				if (target == null)  				{  				}  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetData,The following statement contains a magic number: lock (pool)  			{  				for (int i = 0; i < pool.Count; i++)  				{  					object[] foo = (object[])(pool[i]);  					if (foo[0] != _session)  					{  						continue;  					}  					if (((int)foo[1]) != port)  					{  						continue;  					}  					this.rport = port;  					this.target = (string)foo[2];  					if (foo[3] == null || (foo[3] is object[]))  					{  						this.lport = -1;  					}  					else  					{  						this.lport = ((int)foo[3]);  					}  					if (foo.Length >= 6)  					{  						this.factory = ((SocketFactory)foo[5]);  					}  					break;  				}  				if (target == null)  				{  				}  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetData,The following statement contains a magic number: lock (pool)  			{  				for (int i = 0; i < pool.Count; i++)  				{  					object[] foo = (object[])(pool[i]);  					if (foo[0] != _session)  					{  						continue;  					}  					if (((int)foo[1]) != port)  					{  						continue;  					}  					this.rport = port;  					this.target = (string)foo[2];  					if (foo[3] == null || (foo[3] is object[]))  					{  						this.lport = -1;  					}  					else  					{  						this.lport = ((int)foo[3]);  					}  					if (foo.Length >= 6)  					{  						this.factory = ((SocketFactory)foo[5]);  					}  					break;  				}  				if (target == null)  				{  				}  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetData,The following statement contains a magic number: lock (pool)  			{  				for (int i = 0; i < pool.Count; i++)  				{  					object[] foo = (object[])(pool[i]);  					if (foo[0] != _session)  					{  						continue;  					}  					if (((int)foo[1]) != port)  					{  						continue;  					}  					this.rport = port;  					this.target = (string)foo[2];  					if (foo[3] == null || (foo[3] is object[]))  					{  						this.lport = -1;  					}  					else  					{  						this.lport = ((int)foo[3]);  					}  					if (foo.Length >= 6)  					{  						this.factory = ((SocketFactory)foo[5]);  					}  					break;  				}  				if (target == null)  				{  				}  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetPortForwarding,The following statement contains a magic number: lock (pool)  			{  				for (int i = 0; i < pool.Count; i++)  				{  					object[] bar = (object[])(pool[i]);  					if (bar[0] != session)  					{  						continue;  					}  					if (bar[3] == null)  					{  						foo.Add(bar[1] + ":" + bar[2] + ":");  					}  					else  					{  						foo.Add(bar[1] + ":" + bar[2] + ":" + bar[3]);  					}  				}  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetPortForwarding,The following statement contains a magic number: lock (pool)  			{  				for (int i = 0; i < pool.Count; i++)  				{  					object[] bar = (object[])(pool[i]);  					if (bar[0] != session)  					{  						continue;  					}  					if (bar[3] == null)  					{  						foo.Add(bar[1] + ":" + bar[2] + ":");  					}  					else  					{  						foo.Add(bar[1] + ":" + bar[2] + ":" + bar[3]);  					}  				}  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetPortForwarding,The following statement contains a magic number: lock (pool)  			{  				for (int i = 0; i < pool.Count; i++)  				{  					object[] bar = (object[])(pool[i]);  					if (bar[0] != session)  					{  						continue;  					}  					if (bar[3] == null)  					{  						foo.Add(bar[1] + ":" + bar[2] + ":");  					}  					else  					{  						foo.Add(bar[1] + ":" + bar[2] + ":" + bar[3]);  					}  				}  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,GetPortForwarding,The following statement contains a magic number: lock (pool)  			{  				for (int i = 0; i < pool.Count; i++)  				{  					object[] bar = (object[])(pool[i]);  					if (bar[0] != session)  					{  						continue;  					}  					if (bar[3] == null)  					{  						foo.Add(bar[1] + ":" + bar[2] + ":");  					}  					else  					{  						foo.Add(bar[1] + ":" + bar[2] + ":" + bar[3]);  					}  				}  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: lock (pool)  			{  				if (GetPort(session' port) != null)  				{  					throw new JSchException("PortForwardingR: remote port " + port + " is already registered."  						);  				}  				object[] foo = new object[6];  				foo[0] = session;  				foo[1] = port;  				foo[2] = target;  				foo[3] = lport;  				foo[4] = address_to_bind;  				foo[5] = factory;  				pool.Add(foo);  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: lock (pool)  			{  				if (GetPort(session' port) != null)  				{  					throw new JSchException("PortForwardingR: remote port " + port + " is already registered."  						);  				}  				object[] foo = new object[6];  				foo[0] = session;  				foo[1] = port;  				foo[2] = target;  				foo[3] = lport;  				foo[4] = address_to_bind;  				foo[5] = factory;  				pool.Add(foo);  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: lock (pool)  			{  				if (GetPort(session' port) != null)  				{  					throw new JSchException("PortForwardingR: remote port " + port + " is already registered."  						);  				}  				object[] foo = new object[6];  				foo[0] = session;  				foo[1] = port;  				foo[2] = target;  				foo[3] = lport;  				foo[4] = address_to_bind;  				foo[5] = factory;  				pool.Add(foo);  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: lock (pool)  			{  				if (GetPort(session' port) != null)  				{  					throw new JSchException("PortForwardingR: remote port " + port + " is already registered."  						);  				}  				object[] foo = new object[6];  				foo[0] = session;  				foo[1] = port;  				foo[2] = target;  				foo[3] = lport;  				foo[4] = address_to_bind;  				foo[5] = factory;  				pool.Add(foo);  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: lock (pool)  			{  				if (GetPort(session' port) != null)  				{  					throw new JSchException("PortForwardingR: remote port " + port + " is already registered."  						);  				}  				object[] foo = new object[6];  				foo[0] = session;  				foo[1] = port;  				foo[2] = target;  				foo[3] = lport;  				foo[4] = address_to_bind;  				foo[5] = factory;  				pool.Add(foo);  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: lock (pool)  			{  				if (GetPort(session' port) != null)  				{  					throw new JSchException("PortForwardingR: remote port " + port + " is already registered."  						);  				}  				object[] foo = new object[5];  				foo[0] = session;  				foo[1] = port;  				foo[2] = daemon;  				foo[3] = arg;  				foo[4] = address_to_bind;  				pool.Add(foo);  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: lock (pool)  			{  				if (GetPort(session' port) != null)  				{  					throw new JSchException("PortForwardingR: remote port " + port + " is already registered."  						);  				}  				object[] foo = new object[5];  				foo[0] = session;  				foo[1] = port;  				foo[2] = daemon;  				foo[3] = arg;  				foo[4] = address_to_bind;  				pool.Add(foo);  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: lock (pool)  			{  				if (GetPort(session' port) != null)  				{  					throw new JSchException("PortForwardingR: remote port " + port + " is already registered."  						);  				}  				object[] foo = new object[5];  				foo[0] = session;  				foo[1] = port;  				foo[2] = daemon;  				foo[3] = arg;  				foo[4] = address_to_bind;  				pool.Add(foo);  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,AddPort,The following statement contains a magic number: lock (pool)  			{  				if (GetPort(session' port) != null)  				{  					throw new JSchException("PortForwardingR: remote port " + port + " is already registered."  						);  				}  				object[] foo = new object[5];  				foo[0] = session;  				foo[1] = port;  				foo[2] = daemon;  				foo[3] = arg;  				foo[4] = address_to_bind;  				pool.Add(foo);  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,DelPort,The following statement contains a magic number: lock (pool)  			{  				object[] foo = null;  				for (int i = 0; i < pool.Count; i++)  				{  					object[] bar = (object[])(pool[i]);  					if (bar[0] != session)  					{  						continue;  					}  					if (((int)bar[1]) != rport)  					{  						continue;  					}  					foo = bar;  					break;  				}  				if (foo == null)  				{  					return;  				}  				pool.RemoveElement(foo);  				if (address_to_bind == null)  				{  					address_to_bind = (string)foo[4];  				}  				if (address_to_bind == null)  				{  					address_to_bind = "0.0.0.0";  				}  			}
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,DelPort,The following statement contains a magic number: Buffer buf = new Buffer(100);
Magic Number,NSch,ChannelForwardedTCPIP,C:\repos\mono_ngit\NSch\NSch\ChannelForwardedTCPIP.cs,DelPort,The following statement contains a magic number: try  			{  				// byte SSH_MSG_GLOBAL_REQUEST 80  				// string "cancel-tcpip-forward"  				// boolean want_reply  				// string  address_to_bind (e.g. "127.0.0.1")  				// uint32  port number to bind  				packet.Reset();  				buf.PutByte(unchecked((byte)80));  				buf.PutString(Util.Str2byte("cancel-tcpip-forward"));  				buf.PutByte(unchecked((byte)0));  				buf.PutString(Util.Str2byte(address_to_bind));  				buf.PutInt(rport);  				session.Write(packet);  			}  			catch (Exception)  			{  			}
Magic Number,NSch,ChannelSession,C:\repos\mono_ngit\NSch\NSch\ChannelSession.cs,SetPtyType,The following statement contains a magic number: SetPtyType(ttype' 80' 24' 640' 480);
Magic Number,NSch,ChannelSession,C:\repos\mono_ngit\NSch\NSch\ChannelSession.cs,SetPtyType,The following statement contains a magic number: SetPtyType(ttype' 80' 24' 640' 480);
Magic Number,NSch,ChannelSession,C:\repos\mono_ngit\NSch\NSch\ChannelSession.cs,SetPtyType,The following statement contains a magic number: SetPtyType(ttype' 80' 24' 640' 480);
Magic Number,NSch,ChannelSession,C:\repos\mono_ngit\NSch\NSch\ChannelSession.cs,SetPtyType,The following statement contains a magic number: SetPtyType(ttype' 80' 24' 640' 480);
Magic Number,NSch,ChannelSession,C:\repos\mono_ngit\NSch\NSch\ChannelSession.cs,Run,The following statement contains a magic number: try  			{  				while (IsConnected() && thread != null && io != null && io.@in != null)  				{  					i = io.@in.Read(buf.buffer' 14' buf.buffer.Length - 14 - Session.buffer_margin);  					if (i == 0)  					{  						continue;  					}  					if (i == -1)  					{  						Eof();  						break;  					}  					if (close)  					{  						break;  					}  					//System.out.println("write: "+i);  					packet.Reset();  					buf.PutByte(unchecked((byte)Session.SSH_MSG_CHANNEL_DATA));  					buf.PutInt(recipient);  					buf.PutInt(i);  					buf.Skip(i);  					GetSession().Write(packet' this' i);  				}  			}  			catch (Exception)  			{  			}
Magic Number,NSch,ChannelSession,C:\repos\mono_ngit\NSch\NSch\ChannelSession.cs,Run,The following statement contains a magic number: try  			{  				while (IsConnected() && thread != null && io != null && io.@in != null)  				{  					i = io.@in.Read(buf.buffer' 14' buf.buffer.Length - 14 - Session.buffer_margin);  					if (i == 0)  					{  						continue;  					}  					if (i == -1)  					{  						Eof();  						break;  					}  					if (close)  					{  						break;  					}  					//System.out.println("write: "+i);  					packet.Reset();  					buf.PutByte(unchecked((byte)Session.SSH_MSG_CHANNEL_DATA));  					buf.PutInt(recipient);  					buf.PutInt(i);  					buf.Skip(i);  					GetSession().Write(packet' this' i);  				}  			}  			catch (Exception)  			{  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,ChannelSftp,The following statement contains a magic number: rq = new ChannelSftp.RequestQueue(this' 10);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Start,The following statement contains a magic number: try  			{  				PipedOutputStream pos = new PipedOutputStream();  				io.SetOutputStream(pos);  				PipedInputStream pis = new Channel.MyPipedInputStream(this' pos' rmpsize);  				io.SetInputStream(pis);  				io_in = io.@in;  				if (io_in == null)  				{  					throw new JSchException("channel is down");  				}  				Request request = new RequestSftp();  				request.DoRequest(GetSession()' this);  				buf = new Buffer(lmpsize);  				packet = new Packet(buf);  				obuf = new Buffer(rmpsize);  				opacket = new Packet(obuf);  				int i = 0;  				int length;  				int type;  				byte[] str;  				// send SSH_FXP_INIT  				SendINIT();  				// receive SSH_FXP_VERSION  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				length = header.length;  				if (length > MAX_MSG_LENGTH)  				{  					throw new SftpException(SSH_FX_FAILURE' "Received message is too long: " + length  						);  				}  				type = header.type;  				// 2 -> SSH_FXP_VERSION  				server_version = header.rid;  				//System.err.println("SFTP protocol server-version="+server_version);  				if (length > 0)  				{  					extensions = new Hashtable();  					// extension data  					Fill(buf' length);  					byte[] extension_name = null;  					byte[] extension_data = null;  					while (length > 0)  					{  						extension_name = buf.GetString();  						length -= (4 + extension_name.Length);  						extension_data = buf.GetString();  						length -= (4 + extension_data.Length);  						extensions.Put(Util.Byte2str(extension_name)' Util.Byte2str(extension_data));  					}  				}  				lcwd = new FilePath(".").GetCanonicalPath();  			}  			catch (Exception e)  			{  				//System.err.println(e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Start,The following statement contains a magic number: try  			{  				PipedOutputStream pos = new PipedOutputStream();  				io.SetOutputStream(pos);  				PipedInputStream pis = new Channel.MyPipedInputStream(this' pos' rmpsize);  				io.SetInputStream(pis);  				io_in = io.@in;  				if (io_in == null)  				{  					throw new JSchException("channel is down");  				}  				Request request = new RequestSftp();  				request.DoRequest(GetSession()' this);  				buf = new Buffer(lmpsize);  				packet = new Packet(buf);  				obuf = new Buffer(rmpsize);  				opacket = new Packet(obuf);  				int i = 0;  				int length;  				int type;  				byte[] str;  				// send SSH_FXP_INIT  				SendINIT();  				// receive SSH_FXP_VERSION  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				length = header.length;  				if (length > MAX_MSG_LENGTH)  				{  					throw new SftpException(SSH_FX_FAILURE' "Received message is too long: " + length  						);  				}  				type = header.type;  				// 2 -> SSH_FXP_VERSION  				server_version = header.rid;  				//System.err.println("SFTP protocol server-version="+server_version);  				if (length > 0)  				{  					extensions = new Hashtable();  					// extension data  					Fill(buf' length);  					byte[] extension_name = null;  					byte[] extension_data = null;  					while (length > 0)  					{  						extension_name = buf.GetString();  						length -= (4 + extension_name.Length);  						extension_data = buf.GetString();  						length -= (4 + extension_data.Length);  						extensions.Put(Util.Byte2str(extension_name)' Util.Byte2str(extension_data));  					}  				}  				lcwd = new FilePath(".").GetCanonicalPath();  			}  			catch (Exception e)  			{  				//System.err.println(e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_put,The following statement contains a magic number: try  			{  				((Channel.MyPipedInputStream)io_in).UpdateReadSide();  				byte[] dstb = Util.Str2byte(dst' fEncoding);  				long skip = 0;  				if (mode == RESUME || mode == APPEND)  				{  					try  					{  						SftpATTRS attr = _stat(dstb);  						skip = attr.GetSize();  					}  					catch (Exception)  					{  					}  				}  				//System.err.println(eee);  				if (mode == RESUME && skip > 0)  				{  					long skipped = src.Skip(skip);  					if (skipped < skip)  					{  						throw new SftpException(SSH_FX_FAILURE' "failed to resume for " + dst);  					}  				}  				if (mode == OVERWRITE)  				{  					SendOPENW(dstb);  				}  				else  				{  					SendOPENA(dstb);  				}  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				int length = header.length;  				int type = header.type;  				Fill(buf' length);  				if (type != SSH_FXP_STATUS && type != SSH_FXP_HANDLE)  				{  					throw new SftpException(SSH_FX_FAILURE' "invalid type=" + type);  				}  				if (type == SSH_FXP_STATUS)  				{  					int i = buf.GetInt();  					ThrowStatusError(buf' i);  				}  				byte[] handle = buf.GetString();  				// handle  				byte[] data = null;  				bool dontcopy = true;  				if (!dontcopy)  				{  					// This case will not work anymore.  					data = new byte[obuf.buffer.Length - (5 + 13 + 21 + handle.Length + Session.buffer_margin  						)];  				}  				long offset = 0;  				if (mode == RESUME || mode == APPEND)  				{  					offset += skip;  				}  				int startid = seq;  				int ackcount = 0;  				int _s = 0;  				int _datalen = 0;  				if (!dontcopy)  				{  					// This case will not work anymore.  					_datalen = data.Length;  				}  				else  				{  					data = obuf.buffer;  					_s = 5 + 13 + 21 + handle.Length;  					_datalen = obuf.buffer.Length - _s - Session.buffer_margin;  				}  				int bulk_requests = rq.Size();  				while (true)  				{  					int nread = 0;  					int count = 0;  					int s = _s;  					int datalen = _datalen;  					do  					{  						nread = src.Read(data' s' datalen);  						if (nread > 0)  						{  							s += nread;  							datalen -= nread;  							count += nread;  						}  					}  					while (datalen > 0 && nread > 0);  					if (count <= 0)  					{  						break;  					}  					int foo = count;  					while (foo > 0)  					{  						if ((seq - 1) == startid || ((seq - startid) - ackcount) >= bulk_requests)  						{  							while (((seq - startid) - ackcount) >= bulk_requests)  							{  								if (this.rwsize >= foo)  								{  									break;  								}  								if (CheckStatus(ackid' header))  								{  									int _ackid = ackid[0];  									if (startid > _ackid || _ackid > seq - 1)  									{  										if (_ackid == seq)  										{  											System.Console.Error.WriteLine("ack error: startid=" + startid + " seq=" + seq +   												" _ackid=" + _ackid);  										}  										else  										{  											throw new SftpException(SSH_FX_FAILURE' "ack error: startid=" + startid + " seq="  												 + seq + " _ackid=" + _ackid);  										}  									}  									ackcount++;  								}  								else  								{  									break;  								}  							}  						}  						foo -= SendWRITE(handle' offset' data' 0' foo);  					}  					offset += count;  					if (monitor != null && !monitor.Count(count))  					{  						break;  					}  				}  				int _ackcount = seq - startid;  				while (_ackcount > ackcount)  				{  					if (!CheckStatus(null' header))  					{  						break;  					}  					ackcount++;  				}  				if (monitor != null)  				{  					monitor.End();  				}  				_sendCLOSE(handle' header);  			}  			catch (Exception e)  			{  				if (e is SftpException)  				{  					throw (SftpException)e;  				}  				if (e is Exception)  				{  					throw new SftpException(SSH_FX_FAILURE' e.ToString()' (Exception)e);  				}  				throw new SftpException(SSH_FX_FAILURE' e.ToString());  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_put,The following statement contains a magic number: try  			{  				((Channel.MyPipedInputStream)io_in).UpdateReadSide();  				byte[] dstb = Util.Str2byte(dst' fEncoding);  				long skip = 0;  				if (mode == RESUME || mode == APPEND)  				{  					try  					{  						SftpATTRS attr = _stat(dstb);  						skip = attr.GetSize();  					}  					catch (Exception)  					{  					}  				}  				//System.err.println(eee);  				if (mode == RESUME && skip > 0)  				{  					long skipped = src.Skip(skip);  					if (skipped < skip)  					{  						throw new SftpException(SSH_FX_FAILURE' "failed to resume for " + dst);  					}  				}  				if (mode == OVERWRITE)  				{  					SendOPENW(dstb);  				}  				else  				{  					SendOPENA(dstb);  				}  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				int length = header.length;  				int type = header.type;  				Fill(buf' length);  				if (type != SSH_FXP_STATUS && type != SSH_FXP_HANDLE)  				{  					throw new SftpException(SSH_FX_FAILURE' "invalid type=" + type);  				}  				if (type == SSH_FXP_STATUS)  				{  					int i = buf.GetInt();  					ThrowStatusError(buf' i);  				}  				byte[] handle = buf.GetString();  				// handle  				byte[] data = null;  				bool dontcopy = true;  				if (!dontcopy)  				{  					// This case will not work anymore.  					data = new byte[obuf.buffer.Length - (5 + 13 + 21 + handle.Length + Session.buffer_margin  						)];  				}  				long offset = 0;  				if (mode == RESUME || mode == APPEND)  				{  					offset += skip;  				}  				int startid = seq;  				int ackcount = 0;  				int _s = 0;  				int _datalen = 0;  				if (!dontcopy)  				{  					// This case will not work anymore.  					_datalen = data.Length;  				}  				else  				{  					data = obuf.buffer;  					_s = 5 + 13 + 21 + handle.Length;  					_datalen = obuf.buffer.Length - _s - Session.buffer_margin;  				}  				int bulk_requests = rq.Size();  				while (true)  				{  					int nread = 0;  					int count = 0;  					int s = _s;  					int datalen = _datalen;  					do  					{  						nread = src.Read(data' s' datalen);  						if (nread > 0)  						{  							s += nread;  							datalen -= nread;  							count += nread;  						}  					}  					while (datalen > 0 && nread > 0);  					if (count <= 0)  					{  						break;  					}  					int foo = count;  					while (foo > 0)  					{  						if ((seq - 1) == startid || ((seq - startid) - ackcount) >= bulk_requests)  						{  							while (((seq - startid) - ackcount) >= bulk_requests)  							{  								if (this.rwsize >= foo)  								{  									break;  								}  								if (CheckStatus(ackid' header))  								{  									int _ackid = ackid[0];  									if (startid > _ackid || _ackid > seq - 1)  									{  										if (_ackid == seq)  										{  											System.Console.Error.WriteLine("ack error: startid=" + startid + " seq=" + seq +   												" _ackid=" + _ackid);  										}  										else  										{  											throw new SftpException(SSH_FX_FAILURE' "ack error: startid=" + startid + " seq="  												 + seq + " _ackid=" + _ackid);  										}  									}  									ackcount++;  								}  								else  								{  									break;  								}  							}  						}  						foo -= SendWRITE(handle' offset' data' 0' foo);  					}  					offset += count;  					if (monitor != null && !monitor.Count(count))  					{  						break;  					}  				}  				int _ackcount = seq - startid;  				while (_ackcount > ackcount)  				{  					if (!CheckStatus(null' header))  					{  						break;  					}  					ackcount++;  				}  				if (monitor != null)  				{  					monitor.End();  				}  				_sendCLOSE(handle' header);  			}  			catch (Exception e)  			{  				if (e is SftpException)  				{  					throw (SftpException)e;  				}  				if (e is Exception)  				{  					throw new SftpException(SSH_FX_FAILURE' e.ToString()' (Exception)e);  				}  				throw new SftpException(SSH_FX_FAILURE' e.ToString());  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_put,The following statement contains a magic number: try  			{  				((Channel.MyPipedInputStream)io_in).UpdateReadSide();  				byte[] dstb = Util.Str2byte(dst' fEncoding);  				long skip = 0;  				if (mode == RESUME || mode == APPEND)  				{  					try  					{  						SftpATTRS attr = _stat(dstb);  						skip = attr.GetSize();  					}  					catch (Exception)  					{  					}  				}  				//System.err.println(eee);  				if (mode == RESUME && skip > 0)  				{  					long skipped = src.Skip(skip);  					if (skipped < skip)  					{  						throw new SftpException(SSH_FX_FAILURE' "failed to resume for " + dst);  					}  				}  				if (mode == OVERWRITE)  				{  					SendOPENW(dstb);  				}  				else  				{  					SendOPENA(dstb);  				}  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				int length = header.length;  				int type = header.type;  				Fill(buf' length);  				if (type != SSH_FXP_STATUS && type != SSH_FXP_HANDLE)  				{  					throw new SftpException(SSH_FX_FAILURE' "invalid type=" + type);  				}  				if (type == SSH_FXP_STATUS)  				{  					int i = buf.GetInt();  					ThrowStatusError(buf' i);  				}  				byte[] handle = buf.GetString();  				// handle  				byte[] data = null;  				bool dontcopy = true;  				if (!dontcopy)  				{  					// This case will not work anymore.  					data = new byte[obuf.buffer.Length - (5 + 13 + 21 + handle.Length + Session.buffer_margin  						)];  				}  				long offset = 0;  				if (mode == RESUME || mode == APPEND)  				{  					offset += skip;  				}  				int startid = seq;  				int ackcount = 0;  				int _s = 0;  				int _datalen = 0;  				if (!dontcopy)  				{  					// This case will not work anymore.  					_datalen = data.Length;  				}  				else  				{  					data = obuf.buffer;  					_s = 5 + 13 + 21 + handle.Length;  					_datalen = obuf.buffer.Length - _s - Session.buffer_margin;  				}  				int bulk_requests = rq.Size();  				while (true)  				{  					int nread = 0;  					int count = 0;  					int s = _s;  					int datalen = _datalen;  					do  					{  						nread = src.Read(data' s' datalen);  						if (nread > 0)  						{  							s += nread;  							datalen -= nread;  							count += nread;  						}  					}  					while (datalen > 0 && nread > 0);  					if (count <= 0)  					{  						break;  					}  					int foo = count;  					while (foo > 0)  					{  						if ((seq - 1) == startid || ((seq - startid) - ackcount) >= bulk_requests)  						{  							while (((seq - startid) - ackcount) >= bulk_requests)  							{  								if (this.rwsize >= foo)  								{  									break;  								}  								if (CheckStatus(ackid' header))  								{  									int _ackid = ackid[0];  									if (startid > _ackid || _ackid > seq - 1)  									{  										if (_ackid == seq)  										{  											System.Console.Error.WriteLine("ack error: startid=" + startid + " seq=" + seq +   												" _ackid=" + _ackid);  										}  										else  										{  											throw new SftpException(SSH_FX_FAILURE' "ack error: startid=" + startid + " seq="  												 + seq + " _ackid=" + _ackid);  										}  									}  									ackcount++;  								}  								else  								{  									break;  								}  							}  						}  						foo -= SendWRITE(handle' offset' data' 0' foo);  					}  					offset += count;  					if (monitor != null && !monitor.Count(count))  					{  						break;  					}  				}  				int _ackcount = seq - startid;  				while (_ackcount > ackcount)  				{  					if (!CheckStatus(null' header))  					{  						break;  					}  					ackcount++;  				}  				if (monitor != null)  				{  					monitor.End();  				}  				_sendCLOSE(handle' header);  			}  			catch (Exception e)  			{  				if (e is SftpException)  				{  					throw (SftpException)e;  				}  				if (e is Exception)  				{  					throw new SftpException(SSH_FX_FAILURE' e.ToString()' (Exception)e);  				}  				throw new SftpException(SSH_FX_FAILURE' e.ToString());  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_put,The following statement contains a magic number: try  			{  				((Channel.MyPipedInputStream)io_in).UpdateReadSide();  				byte[] dstb = Util.Str2byte(dst' fEncoding);  				long skip = 0;  				if (mode == RESUME || mode == APPEND)  				{  					try  					{  						SftpATTRS attr = _stat(dstb);  						skip = attr.GetSize();  					}  					catch (Exception)  					{  					}  				}  				//System.err.println(eee);  				if (mode == RESUME && skip > 0)  				{  					long skipped = src.Skip(skip);  					if (skipped < skip)  					{  						throw new SftpException(SSH_FX_FAILURE' "failed to resume for " + dst);  					}  				}  				if (mode == OVERWRITE)  				{  					SendOPENW(dstb);  				}  				else  				{  					SendOPENA(dstb);  				}  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				int length = header.length;  				int type = header.type;  				Fill(buf' length);  				if (type != SSH_FXP_STATUS && type != SSH_FXP_HANDLE)  				{  					throw new SftpException(SSH_FX_FAILURE' "invalid type=" + type);  				}  				if (type == SSH_FXP_STATUS)  				{  					int i = buf.GetInt();  					ThrowStatusError(buf' i);  				}  				byte[] handle = buf.GetString();  				// handle  				byte[] data = null;  				bool dontcopy = true;  				if (!dontcopy)  				{  					// This case will not work anymore.  					data = new byte[obuf.buffer.Length - (5 + 13 + 21 + handle.Length + Session.buffer_margin  						)];  				}  				long offset = 0;  				if (mode == RESUME || mode == APPEND)  				{  					offset += skip;  				}  				int startid = seq;  				int ackcount = 0;  				int _s = 0;  				int _datalen = 0;  				if (!dontcopy)  				{  					// This case will not work anymore.  					_datalen = data.Length;  				}  				else  				{  					data = obuf.buffer;  					_s = 5 + 13 + 21 + handle.Length;  					_datalen = obuf.buffer.Length - _s - Session.buffer_margin;  				}  				int bulk_requests = rq.Size();  				while (true)  				{  					int nread = 0;  					int count = 0;  					int s = _s;  					int datalen = _datalen;  					do  					{  						nread = src.Read(data' s' datalen);  						if (nread > 0)  						{  							s += nread;  							datalen -= nread;  							count += nread;  						}  					}  					while (datalen > 0 && nread > 0);  					if (count <= 0)  					{  						break;  					}  					int foo = count;  					while (foo > 0)  					{  						if ((seq - 1) == startid || ((seq - startid) - ackcount) >= bulk_requests)  						{  							while (((seq - startid) - ackcount) >= bulk_requests)  							{  								if (this.rwsize >= foo)  								{  									break;  								}  								if (CheckStatus(ackid' header))  								{  									int _ackid = ackid[0];  									if (startid > _ackid || _ackid > seq - 1)  									{  										if (_ackid == seq)  										{  											System.Console.Error.WriteLine("ack error: startid=" + startid + " seq=" + seq +   												" _ackid=" + _ackid);  										}  										else  										{  											throw new SftpException(SSH_FX_FAILURE' "ack error: startid=" + startid + " seq="  												 + seq + " _ackid=" + _ackid);  										}  									}  									ackcount++;  								}  								else  								{  									break;  								}  							}  						}  						foo -= SendWRITE(handle' offset' data' 0' foo);  					}  					offset += count;  					if (monitor != null && !monitor.Count(count))  					{  						break;  					}  				}  				int _ackcount = seq - startid;  				while (_ackcount > ackcount)  				{  					if (!CheckStatus(null' header))  					{  						break;  					}  					ackcount++;  				}  				if (monitor != null)  				{  					monitor.End();  				}  				_sendCLOSE(handle' header);  			}  			catch (Exception e)  			{  				if (e is SftpException)  				{  					throw (SftpException)e;  				}  				if (e is Exception)  				{  					throw new SftpException(SSH_FX_FAILURE' e.ToString()' (Exception)e);  				}  				throw new SftpException(SSH_FX_FAILURE' e.ToString());  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_put,The following statement contains a magic number: try  			{  				((Channel.MyPipedInputStream)io_in).UpdateReadSide();  				byte[] dstb = Util.Str2byte(dst' fEncoding);  				long skip = 0;  				if (mode == RESUME || mode == APPEND)  				{  					try  					{  						SftpATTRS attr = _stat(dstb);  						skip = attr.GetSize();  					}  					catch (Exception)  					{  					}  				}  				//System.err.println(eee);  				if (mode == RESUME && skip > 0)  				{  					long skipped = src.Skip(skip);  					if (skipped < skip)  					{  						throw new SftpException(SSH_FX_FAILURE' "failed to resume for " + dst);  					}  				}  				if (mode == OVERWRITE)  				{  					SendOPENW(dstb);  				}  				else  				{  					SendOPENA(dstb);  				}  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				int length = header.length;  				int type = header.type;  				Fill(buf' length);  				if (type != SSH_FXP_STATUS && type != SSH_FXP_HANDLE)  				{  					throw new SftpException(SSH_FX_FAILURE' "invalid type=" + type);  				}  				if (type == SSH_FXP_STATUS)  				{  					int i = buf.GetInt();  					ThrowStatusError(buf' i);  				}  				byte[] handle = buf.GetString();  				// handle  				byte[] data = null;  				bool dontcopy = true;  				if (!dontcopy)  				{  					// This case will not work anymore.  					data = new byte[obuf.buffer.Length - (5 + 13 + 21 + handle.Length + Session.buffer_margin  						)];  				}  				long offset = 0;  				if (mode == RESUME || mode == APPEND)  				{  					offset += skip;  				}  				int startid = seq;  				int ackcount = 0;  				int _s = 0;  				int _datalen = 0;  				if (!dontcopy)  				{  					// This case will not work anymore.  					_datalen = data.Length;  				}  				else  				{  					data = obuf.buffer;  					_s = 5 + 13 + 21 + handle.Length;  					_datalen = obuf.buffer.Length - _s - Session.buffer_margin;  				}  				int bulk_requests = rq.Size();  				while (true)  				{  					int nread = 0;  					int count = 0;  					int s = _s;  					int datalen = _datalen;  					do  					{  						nread = src.Read(data' s' datalen);  						if (nread > 0)  						{  							s += nread;  							datalen -= nread;  							count += nread;  						}  					}  					while (datalen > 0 && nread > 0);  					if (count <= 0)  					{  						break;  					}  					int foo = count;  					while (foo > 0)  					{  						if ((seq - 1) == startid || ((seq - startid) - ackcount) >= bulk_requests)  						{  							while (((seq - startid) - ackcount) >= bulk_requests)  							{  								if (this.rwsize >= foo)  								{  									break;  								}  								if (CheckStatus(ackid' header))  								{  									int _ackid = ackid[0];  									if (startid > _ackid || _ackid > seq - 1)  									{  										if (_ackid == seq)  										{  											System.Console.Error.WriteLine("ack error: startid=" + startid + " seq=" + seq +   												" _ackid=" + _ackid);  										}  										else  										{  											throw new SftpException(SSH_FX_FAILURE' "ack error: startid=" + startid + " seq="  												 + seq + " _ackid=" + _ackid);  										}  									}  									ackcount++;  								}  								else  								{  									break;  								}  							}  						}  						foo -= SendWRITE(handle' offset' data' 0' foo);  					}  					offset += count;  					if (monitor != null && !monitor.Count(count))  					{  						break;  					}  				}  				int _ackcount = seq - startid;  				while (_ackcount > ackcount)  				{  					if (!CheckStatus(null' header))  					{  						break;  					}  					ackcount++;  				}  				if (monitor != null)  				{  					monitor.End();  				}  				_sendCLOSE(handle' header);  			}  			catch (Exception e)  			{  				if (e is SftpException)  				{  					throw (SftpException)e;  				}  				if (e is Exception)  				{  					throw new SftpException(SSH_FX_FAILURE' e.ToString()' (Exception)e);  				}  				throw new SftpException(SSH_FX_FAILURE' e.ToString());  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_put,The following statement contains a magic number: try  			{  				((Channel.MyPipedInputStream)io_in).UpdateReadSide();  				byte[] dstb = Util.Str2byte(dst' fEncoding);  				long skip = 0;  				if (mode == RESUME || mode == APPEND)  				{  					try  					{  						SftpATTRS attr = _stat(dstb);  						skip = attr.GetSize();  					}  					catch (Exception)  					{  					}  				}  				//System.err.println(eee);  				if (mode == RESUME && skip > 0)  				{  					long skipped = src.Skip(skip);  					if (skipped < skip)  					{  						throw new SftpException(SSH_FX_FAILURE' "failed to resume for " + dst);  					}  				}  				if (mode == OVERWRITE)  				{  					SendOPENW(dstb);  				}  				else  				{  					SendOPENA(dstb);  				}  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				int length = header.length;  				int type = header.type;  				Fill(buf' length);  				if (type != SSH_FXP_STATUS && type != SSH_FXP_HANDLE)  				{  					throw new SftpException(SSH_FX_FAILURE' "invalid type=" + type);  				}  				if (type == SSH_FXP_STATUS)  				{  					int i = buf.GetInt();  					ThrowStatusError(buf' i);  				}  				byte[] handle = buf.GetString();  				// handle  				byte[] data = null;  				bool dontcopy = true;  				if (!dontcopy)  				{  					// This case will not work anymore.  					data = new byte[obuf.buffer.Length - (5 + 13 + 21 + handle.Length + Session.buffer_margin  						)];  				}  				long offset = 0;  				if (mode == RESUME || mode == APPEND)  				{  					offset += skip;  				}  				int startid = seq;  				int ackcount = 0;  				int _s = 0;  				int _datalen = 0;  				if (!dontcopy)  				{  					// This case will not work anymore.  					_datalen = data.Length;  				}  				else  				{  					data = obuf.buffer;  					_s = 5 + 13 + 21 + handle.Length;  					_datalen = obuf.buffer.Length - _s - Session.buffer_margin;  				}  				int bulk_requests = rq.Size();  				while (true)  				{  					int nread = 0;  					int count = 0;  					int s = _s;  					int datalen = _datalen;  					do  					{  						nread = src.Read(data' s' datalen);  						if (nread > 0)  						{  							s += nread;  							datalen -= nread;  							count += nread;  						}  					}  					while (datalen > 0 && nread > 0);  					if (count <= 0)  					{  						break;  					}  					int foo = count;  					while (foo > 0)  					{  						if ((seq - 1) == startid || ((seq - startid) - ackcount) >= bulk_requests)  						{  							while (((seq - startid) - ackcount) >= bulk_requests)  							{  								if (this.rwsize >= foo)  								{  									break;  								}  								if (CheckStatus(ackid' header))  								{  									int _ackid = ackid[0];  									if (startid > _ackid || _ackid > seq - 1)  									{  										if (_ackid == seq)  										{  											System.Console.Error.WriteLine("ack error: startid=" + startid + " seq=" + seq +   												" _ackid=" + _ackid);  										}  										else  										{  											throw new SftpException(SSH_FX_FAILURE' "ack error: startid=" + startid + " seq="  												 + seq + " _ackid=" + _ackid);  										}  									}  									ackcount++;  								}  								else  								{  									break;  								}  							}  						}  						foo -= SendWRITE(handle' offset' data' 0' foo);  					}  					offset += count;  					if (monitor != null && !monitor.Count(count))  					{  						break;  					}  				}  				int _ackcount = seq - startid;  				while (_ackcount > ackcount)  				{  					if (!CheckStatus(null' header))  					{  						break;  					}  					ackcount++;  				}  				if (monitor != null)  				{  					monitor.End();  				}  				_sendCLOSE(handle' header);  			}  			catch (Exception e)  			{  				if (e is SftpException)  				{  					throw (SftpException)e;  				}  				if (e is Exception)  				{  					throw new SftpException(SSH_FX_FAILURE' e.ToString()' (Exception)e);  				}  				throw new SftpException(SSH_FX_FAILURE' e.ToString());  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_get,The following statement contains a magic number: try  			{  				SendOPENR(srcb);  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				int length = header.length;  				int type = header.type;  				Fill(buf' length);  				if (type != SSH_FXP_STATUS && type != SSH_FXP_HANDLE)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty);  				}  				if (type == SSH_FXP_STATUS)  				{  					int i = buf.GetInt();  					ThrowStatusError(buf' i);  				}  				byte[] handle = buf.GetString();  				// filename  				long offset = 0;  				if (mode == RESUME)  				{  					offset += skip;  				}  				int request_max = 1;  				rq.Init();  				long request_offset = offset;  				int request_len = buf.buffer.Length - 13;  				if (server_version == 0)  				{  					request_len = 1024;  				}  				while (true)  				{  					while (rq.Count() < request_max)  					{  						SendREAD(handle' request_offset' request_len' rq);  						request_offset += request_len;  					}  					header = Header(buf' header);  					length = header.length;  					type = header.type;  					ChannelSftp.RequestQueue.Request rr = rq.Get(header.rid);  					if (type == SSH_FXP_STATUS)  					{  						Fill(buf' length);  						int i = buf.GetInt();  						if (i == SSH_FX_EOF)  						{  							goto loop_break;  						}  						ThrowStatusError(buf' i);  					}  					if (type != SSH_FXP_DATA)  					{  						goto loop_break;  					}  					buf.Rewind();  					Fill(buf.buffer' 0' 4);  					length -= 4;  					int length_of_data = buf.GetInt();  					// length of data   					int optional_data = length - length_of_data;  					int foo = length_of_data;  					while (foo > 0)  					{  						int bar = foo;  						if (bar > buf.buffer.Length)  						{  							bar = buf.buffer.Length;  						}  						int data_len = io_in.Read(buf.buffer' 0' bar);  						if (data_len < 0)  						{  							goto loop_break;  						}  						dst.Write(buf.buffer' 0' data_len);  						offset += data_len;  						foo -= data_len;  						if (monitor != null)  						{  							if (!monitor.Count(data_len))  							{  								Skip(foo);  								if (optional_data > 0)  								{  									Skip(optional_data);  								}  								goto loop_break;  							}  						}  					}  					//System.err.println("length: "+length);  // length should be 0  					if (optional_data > 0)  					{  						Skip(optional_data);  					}  					if (length_of_data < rr.length)  					{  						//  						rq.Cancel(header' buf);  						SendREAD(handle' rr.offset + length_of_data' (int)(rr.length - length_of_data)' rq  							);  						request_offset = rr.offset + rr.length;  					}  					if (request_max < rq.Size())  					{  						request_max++;  					}  loop_continue: ;  				}  loop_break: ;  				dst.Flush();  				if (monitor != null)  				{  					monitor.End();  				}  				rq.Cancel(header' buf);  				_sendCLOSE(handle' header);  			}  			catch (Exception e)  			{  				if (e is SftpException)  				{  					throw (SftpException)e;  				}  				if (e is Exception)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty' (Exception)e);  				}  				throw new SftpException(SSH_FX_FAILURE' string.Empty);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_get,The following statement contains a magic number: try  			{  				SendOPENR(srcb);  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				int length = header.length;  				int type = header.type;  				Fill(buf' length);  				if (type != SSH_FXP_STATUS && type != SSH_FXP_HANDLE)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty);  				}  				if (type == SSH_FXP_STATUS)  				{  					int i = buf.GetInt();  					ThrowStatusError(buf' i);  				}  				byte[] handle = buf.GetString();  				// filename  				long offset = 0;  				if (mode == RESUME)  				{  					offset += skip;  				}  				int request_max = 1;  				rq.Init();  				long request_offset = offset;  				int request_len = buf.buffer.Length - 13;  				if (server_version == 0)  				{  					request_len = 1024;  				}  				while (true)  				{  					while (rq.Count() < request_max)  					{  						SendREAD(handle' request_offset' request_len' rq);  						request_offset += request_len;  					}  					header = Header(buf' header);  					length = header.length;  					type = header.type;  					ChannelSftp.RequestQueue.Request rr = rq.Get(header.rid);  					if (type == SSH_FXP_STATUS)  					{  						Fill(buf' length);  						int i = buf.GetInt();  						if (i == SSH_FX_EOF)  						{  							goto loop_break;  						}  						ThrowStatusError(buf' i);  					}  					if (type != SSH_FXP_DATA)  					{  						goto loop_break;  					}  					buf.Rewind();  					Fill(buf.buffer' 0' 4);  					length -= 4;  					int length_of_data = buf.GetInt();  					// length of data   					int optional_data = length - length_of_data;  					int foo = length_of_data;  					while (foo > 0)  					{  						int bar = foo;  						if (bar > buf.buffer.Length)  						{  							bar = buf.buffer.Length;  						}  						int data_len = io_in.Read(buf.buffer' 0' bar);  						if (data_len < 0)  						{  							goto loop_break;  						}  						dst.Write(buf.buffer' 0' data_len);  						offset += data_len;  						foo -= data_len;  						if (monitor != null)  						{  							if (!monitor.Count(data_len))  							{  								Skip(foo);  								if (optional_data > 0)  								{  									Skip(optional_data);  								}  								goto loop_break;  							}  						}  					}  					//System.err.println("length: "+length);  // length should be 0  					if (optional_data > 0)  					{  						Skip(optional_data);  					}  					if (length_of_data < rr.length)  					{  						//  						rq.Cancel(header' buf);  						SendREAD(handle' rr.offset + length_of_data' (int)(rr.length - length_of_data)' rq  							);  						request_offset = rr.offset + rr.length;  					}  					if (request_max < rq.Size())  					{  						request_max++;  					}  loop_continue: ;  				}  loop_break: ;  				dst.Flush();  				if (monitor != null)  				{  					monitor.End();  				}  				rq.Cancel(header' buf);  				_sendCLOSE(handle' header);  			}  			catch (Exception e)  			{  				if (e is SftpException)  				{  					throw (SftpException)e;  				}  				if (e is Exception)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty' (Exception)e);  				}  				throw new SftpException(SSH_FX_FAILURE' string.Empty);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_get,The following statement contains a magic number: try  			{  				SendOPENR(srcb);  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				int length = header.length;  				int type = header.type;  				Fill(buf' length);  				if (type != SSH_FXP_STATUS && type != SSH_FXP_HANDLE)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty);  				}  				if (type == SSH_FXP_STATUS)  				{  					int i = buf.GetInt();  					ThrowStatusError(buf' i);  				}  				byte[] handle = buf.GetString();  				// filename  				long offset = 0;  				if (mode == RESUME)  				{  					offset += skip;  				}  				int request_max = 1;  				rq.Init();  				long request_offset = offset;  				int request_len = buf.buffer.Length - 13;  				if (server_version == 0)  				{  					request_len = 1024;  				}  				while (true)  				{  					while (rq.Count() < request_max)  					{  						SendREAD(handle' request_offset' request_len' rq);  						request_offset += request_len;  					}  					header = Header(buf' header);  					length = header.length;  					type = header.type;  					ChannelSftp.RequestQueue.Request rr = rq.Get(header.rid);  					if (type == SSH_FXP_STATUS)  					{  						Fill(buf' length);  						int i = buf.GetInt();  						if (i == SSH_FX_EOF)  						{  							goto loop_break;  						}  						ThrowStatusError(buf' i);  					}  					if (type != SSH_FXP_DATA)  					{  						goto loop_break;  					}  					buf.Rewind();  					Fill(buf.buffer' 0' 4);  					length -= 4;  					int length_of_data = buf.GetInt();  					// length of data   					int optional_data = length - length_of_data;  					int foo = length_of_data;  					while (foo > 0)  					{  						int bar = foo;  						if (bar > buf.buffer.Length)  						{  							bar = buf.buffer.Length;  						}  						int data_len = io_in.Read(buf.buffer' 0' bar);  						if (data_len < 0)  						{  							goto loop_break;  						}  						dst.Write(buf.buffer' 0' data_len);  						offset += data_len;  						foo -= data_len;  						if (monitor != null)  						{  							if (!monitor.Count(data_len))  							{  								Skip(foo);  								if (optional_data > 0)  								{  									Skip(optional_data);  								}  								goto loop_break;  							}  						}  					}  					//System.err.println("length: "+length);  // length should be 0  					if (optional_data > 0)  					{  						Skip(optional_data);  					}  					if (length_of_data < rr.length)  					{  						//  						rq.Cancel(header' buf);  						SendREAD(handle' rr.offset + length_of_data' (int)(rr.length - length_of_data)' rq  							);  						request_offset = rr.offset + rr.length;  					}  					if (request_max < rq.Size())  					{  						request_max++;  					}  loop_continue: ;  				}  loop_break: ;  				dst.Flush();  				if (monitor != null)  				{  					monitor.End();  				}  				rq.Cancel(header' buf);  				_sendCLOSE(handle' header);  			}  			catch (Exception e)  			{  				if (e is SftpException)  				{  					throw (SftpException)e;  				}  				if (e is Exception)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty' (Exception)e);  				}  				throw new SftpException(SSH_FX_FAILURE' string.Empty);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_get,The following statement contains a magic number: try  			{  				SendOPENR(srcb);  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				int length = header.length;  				int type = header.type;  				Fill(buf' length);  				if (type != SSH_FXP_STATUS && type != SSH_FXP_HANDLE)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty);  				}  				if (type == SSH_FXP_STATUS)  				{  					int i = buf.GetInt();  					ThrowStatusError(buf' i);  				}  				byte[] handle = buf.GetString();  				// filename  				long offset = 0;  				if (mode == RESUME)  				{  					offset += skip;  				}  				int request_max = 1;  				rq.Init();  				long request_offset = offset;  				int request_len = buf.buffer.Length - 13;  				if (server_version == 0)  				{  					request_len = 1024;  				}  				while (true)  				{  					while (rq.Count() < request_max)  					{  						SendREAD(handle' request_offset' request_len' rq);  						request_offset += request_len;  					}  					header = Header(buf' header);  					length = header.length;  					type = header.type;  					ChannelSftp.RequestQueue.Request rr = rq.Get(header.rid);  					if (type == SSH_FXP_STATUS)  					{  						Fill(buf' length);  						int i = buf.GetInt();  						if (i == SSH_FX_EOF)  						{  							goto loop_break;  						}  						ThrowStatusError(buf' i);  					}  					if (type != SSH_FXP_DATA)  					{  						goto loop_break;  					}  					buf.Rewind();  					Fill(buf.buffer' 0' 4);  					length -= 4;  					int length_of_data = buf.GetInt();  					// length of data   					int optional_data = length - length_of_data;  					int foo = length_of_data;  					while (foo > 0)  					{  						int bar = foo;  						if (bar > buf.buffer.Length)  						{  							bar = buf.buffer.Length;  						}  						int data_len = io_in.Read(buf.buffer' 0' bar);  						if (data_len < 0)  						{  							goto loop_break;  						}  						dst.Write(buf.buffer' 0' data_len);  						offset += data_len;  						foo -= data_len;  						if (monitor != null)  						{  							if (!monitor.Count(data_len))  							{  								Skip(foo);  								if (optional_data > 0)  								{  									Skip(optional_data);  								}  								goto loop_break;  							}  						}  					}  					//System.err.println("length: "+length);  // length should be 0  					if (optional_data > 0)  					{  						Skip(optional_data);  					}  					if (length_of_data < rr.length)  					{  						//  						rq.Cancel(header' buf);  						SendREAD(handle' rr.offset + length_of_data' (int)(rr.length - length_of_data)' rq  							);  						request_offset = rr.offset + rr.length;  					}  					if (request_max < rq.Size())  					{  						request_max++;  					}  loop_continue: ;  				}  loop_break: ;  				dst.Flush();  				if (monitor != null)  				{  					monitor.End();  				}  				rq.Cancel(header' buf);  				_sendCLOSE(handle' header);  			}  			catch (Exception e)  			{  				if (e is SftpException)  				{  					throw (SftpException)e;  				}  				if (e is Exception)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty' (Exception)e);  				}  				throw new SftpException(SSH_FX_FAILURE' string.Empty);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Ls,The following statement contains a magic number: try  			{  				((Channel.MyPipedInputStream)io_in).UpdateReadSide();  				path = RemoteAbsolutePath(path);  				byte[] pattern = null;  				ArrayList v = new ArrayList();  				int foo = path.LastIndexOf('/');  				string dir = Sharpen.Runtime.Substring(path' 0' ((foo == 0) ? 1 : foo));  				string _pattern = Sharpen.Runtime.Substring(path' foo + 1);  				dir = Util.Unquote(dir);  				// If pattern has included '*' or '?'' we need to convert  				// to UTF-8 string before globbing.  				byte[][] _pattern_utf8 = new byte[1][];  				bool pattern_has_wildcard = IsPattern(_pattern' _pattern_utf8);  				if (pattern_has_wildcard)  				{  					pattern = _pattern_utf8[0];  				}  				else  				{  					string upath = Util.Unquote(path);  					//SftpATTRS attr=_lstat(upath);  					SftpATTRS attr = _stat(upath);  					if (attr.IsDir())  					{  						pattern = null;  						dir = upath;  					}  					else  					{  						if (fEncoding_is_utf8)  						{  							pattern = _pattern_utf8[0];  							pattern = Util.Unquote(pattern);  						}  						else  						{  							_pattern = Util.Unquote(_pattern);  							pattern = Util.Str2byte(_pattern' fEncoding);  						}  					}  				}  				SendOPENDIR(Util.Str2byte(dir' fEncoding));  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				int length = header.length;  				int type = header.type;  				Fill(buf' length);  				if (type != SSH_FXP_STATUS && type != SSH_FXP_HANDLE)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty);  				}  				if (type == SSH_FXP_STATUS)  				{  					int i = buf.GetInt();  					ThrowStatusError(buf' i);  				}  				byte[] handle = buf.GetString();  				// handle  				while (true)  				{  					SendREADDIR(handle);  					header = Header(buf' header);  					length = header.length;  					type = header.type;  					if (type != SSH_FXP_STATUS && type != SSH_FXP_NAME)  					{  						throw new SftpException(SSH_FX_FAILURE' string.Empty);  					}  					if (type == SSH_FXP_STATUS)  					{  						Fill(buf' length);  						int i = buf.GetInt();  						if (i == SSH_FX_EOF)  						{  							break;  						}  						ThrowStatusError(buf' i);  					}  					buf.Rewind();  					Fill(buf.buffer' 0' 4);  					length -= 4;  					int count = buf.GetInt();  					byte[] str;  					int flags;  					buf.Reset();  					while (count > 0)  					{  						if (length > 0)  						{  							buf.Shift();  							int j = (buf.buffer.Length > (buf.index + length)) ? length : (buf.buffer.Length   								- buf.index);  							int i = Fill(buf.buffer' buf.index' j);  							buf.index += i;  							length -= i;  						}  						byte[] filename = buf.GetString();  						byte[] longname = null;  						if (server_version <= 3)  						{  							longname = buf.GetString();  						}  						SftpATTRS attrs = SftpATTRS.GetATTR(buf);  						bool find = false;  						string f = null;  						if (pattern == null)  						{  							find = true;  						}  						else  						{  							if (!pattern_has_wildcard)  							{  								find = Util.Array_equals(pattern' filename);  							}  							else  							{  								byte[] _filename = filename;  								if (!fEncoding_is_utf8)  								{  									f = Util.Byte2str(_filename' fEncoding);  									_filename = Util.Str2byte(f' UTF8);  								}  								find = Util.Glob(pattern' _filename);  							}  						}  						if (find)  						{  							if (f == null)  							{  								f = Util.Byte2str(filename' fEncoding);  							}  							string l = null;  							if (longname == null)  							{  								// TODO: we need to generate long name from attrs  								//       for the sftp protocol 4(and later).  								l = attrs.ToString() + " " + f;  							}  							else  							{  								l = Util.Byte2str(longname' fEncoding);  							}  							v.Add(new ChannelSftp.LsEntry(this' f' l' attrs));  						}  						count--;  					}  				}  				_sendCLOSE(handle' header);  				return v;  			}  			catch (Exception e)  			{  				if (e is SftpException)  				{  					throw (SftpException)e;  				}  				if (e is Exception)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty' (Exception)e);  				}  				throw new SftpException(SSH_FX_FAILURE' string.Empty);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Ls,The following statement contains a magic number: try  			{  				((Channel.MyPipedInputStream)io_in).UpdateReadSide();  				path = RemoteAbsolutePath(path);  				byte[] pattern = null;  				ArrayList v = new ArrayList();  				int foo = path.LastIndexOf('/');  				string dir = Sharpen.Runtime.Substring(path' 0' ((foo == 0) ? 1 : foo));  				string _pattern = Sharpen.Runtime.Substring(path' foo + 1);  				dir = Util.Unquote(dir);  				// If pattern has included '*' or '?'' we need to convert  				// to UTF-8 string before globbing.  				byte[][] _pattern_utf8 = new byte[1][];  				bool pattern_has_wildcard = IsPattern(_pattern' _pattern_utf8);  				if (pattern_has_wildcard)  				{  					pattern = _pattern_utf8[0];  				}  				else  				{  					string upath = Util.Unquote(path);  					//SftpATTRS attr=_lstat(upath);  					SftpATTRS attr = _stat(upath);  					if (attr.IsDir())  					{  						pattern = null;  						dir = upath;  					}  					else  					{  						if (fEncoding_is_utf8)  						{  							pattern = _pattern_utf8[0];  							pattern = Util.Unquote(pattern);  						}  						else  						{  							_pattern = Util.Unquote(_pattern);  							pattern = Util.Str2byte(_pattern' fEncoding);  						}  					}  				}  				SendOPENDIR(Util.Str2byte(dir' fEncoding));  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				int length = header.length;  				int type = header.type;  				Fill(buf' length);  				if (type != SSH_FXP_STATUS && type != SSH_FXP_HANDLE)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty);  				}  				if (type == SSH_FXP_STATUS)  				{  					int i = buf.GetInt();  					ThrowStatusError(buf' i);  				}  				byte[] handle = buf.GetString();  				// handle  				while (true)  				{  					SendREADDIR(handle);  					header = Header(buf' header);  					length = header.length;  					type = header.type;  					if (type != SSH_FXP_STATUS && type != SSH_FXP_NAME)  					{  						throw new SftpException(SSH_FX_FAILURE' string.Empty);  					}  					if (type == SSH_FXP_STATUS)  					{  						Fill(buf' length);  						int i = buf.GetInt();  						if (i == SSH_FX_EOF)  						{  							break;  						}  						ThrowStatusError(buf' i);  					}  					buf.Rewind();  					Fill(buf.buffer' 0' 4);  					length -= 4;  					int count = buf.GetInt();  					byte[] str;  					int flags;  					buf.Reset();  					while (count > 0)  					{  						if (length > 0)  						{  							buf.Shift();  							int j = (buf.buffer.Length > (buf.index + length)) ? length : (buf.buffer.Length   								- buf.index);  							int i = Fill(buf.buffer' buf.index' j);  							buf.index += i;  							length -= i;  						}  						byte[] filename = buf.GetString();  						byte[] longname = null;  						if (server_version <= 3)  						{  							longname = buf.GetString();  						}  						SftpATTRS attrs = SftpATTRS.GetATTR(buf);  						bool find = false;  						string f = null;  						if (pattern == null)  						{  							find = true;  						}  						else  						{  							if (!pattern_has_wildcard)  							{  								find = Util.Array_equals(pattern' filename);  							}  							else  							{  								byte[] _filename = filename;  								if (!fEncoding_is_utf8)  								{  									f = Util.Byte2str(_filename' fEncoding);  									_filename = Util.Str2byte(f' UTF8);  								}  								find = Util.Glob(pattern' _filename);  							}  						}  						if (find)  						{  							if (f == null)  							{  								f = Util.Byte2str(filename' fEncoding);  							}  							string l = null;  							if (longname == null)  							{  								// TODO: we need to generate long name from attrs  								//       for the sftp protocol 4(and later).  								l = attrs.ToString() + " " + f;  							}  							else  							{  								l = Util.Byte2str(longname' fEncoding);  							}  							v.Add(new ChannelSftp.LsEntry(this' f' l' attrs));  						}  						count--;  					}  				}  				_sendCLOSE(handle' header);  				return v;  			}  			catch (Exception e)  			{  				if (e is SftpException)  				{  					throw (SftpException)e;  				}  				if (e is Exception)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty' (Exception)e);  				}  				throw new SftpException(SSH_FX_FAILURE' string.Empty);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Ls,The following statement contains a magic number: try  			{  				((Channel.MyPipedInputStream)io_in).UpdateReadSide();  				path = RemoteAbsolutePath(path);  				byte[] pattern = null;  				ArrayList v = new ArrayList();  				int foo = path.LastIndexOf('/');  				string dir = Sharpen.Runtime.Substring(path' 0' ((foo == 0) ? 1 : foo));  				string _pattern = Sharpen.Runtime.Substring(path' foo + 1);  				dir = Util.Unquote(dir);  				// If pattern has included '*' or '?'' we need to convert  				// to UTF-8 string before globbing.  				byte[][] _pattern_utf8 = new byte[1][];  				bool pattern_has_wildcard = IsPattern(_pattern' _pattern_utf8);  				if (pattern_has_wildcard)  				{  					pattern = _pattern_utf8[0];  				}  				else  				{  					string upath = Util.Unquote(path);  					//SftpATTRS attr=_lstat(upath);  					SftpATTRS attr = _stat(upath);  					if (attr.IsDir())  					{  						pattern = null;  						dir = upath;  					}  					else  					{  						if (fEncoding_is_utf8)  						{  							pattern = _pattern_utf8[0];  							pattern = Util.Unquote(pattern);  						}  						else  						{  							_pattern = Util.Unquote(_pattern);  							pattern = Util.Str2byte(_pattern' fEncoding);  						}  					}  				}  				SendOPENDIR(Util.Str2byte(dir' fEncoding));  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				int length = header.length;  				int type = header.type;  				Fill(buf' length);  				if (type != SSH_FXP_STATUS && type != SSH_FXP_HANDLE)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty);  				}  				if (type == SSH_FXP_STATUS)  				{  					int i = buf.GetInt();  					ThrowStatusError(buf' i);  				}  				byte[] handle = buf.GetString();  				// handle  				while (true)  				{  					SendREADDIR(handle);  					header = Header(buf' header);  					length = header.length;  					type = header.type;  					if (type != SSH_FXP_STATUS && type != SSH_FXP_NAME)  					{  						throw new SftpException(SSH_FX_FAILURE' string.Empty);  					}  					if (type == SSH_FXP_STATUS)  					{  						Fill(buf' length);  						int i = buf.GetInt();  						if (i == SSH_FX_EOF)  						{  							break;  						}  						ThrowStatusError(buf' i);  					}  					buf.Rewind();  					Fill(buf.buffer' 0' 4);  					length -= 4;  					int count = buf.GetInt();  					byte[] str;  					int flags;  					buf.Reset();  					while (count > 0)  					{  						if (length > 0)  						{  							buf.Shift();  							int j = (buf.buffer.Length > (buf.index + length)) ? length : (buf.buffer.Length   								- buf.index);  							int i = Fill(buf.buffer' buf.index' j);  							buf.index += i;  							length -= i;  						}  						byte[] filename = buf.GetString();  						byte[] longname = null;  						if (server_version <= 3)  						{  							longname = buf.GetString();  						}  						SftpATTRS attrs = SftpATTRS.GetATTR(buf);  						bool find = false;  						string f = null;  						if (pattern == null)  						{  							find = true;  						}  						else  						{  							if (!pattern_has_wildcard)  							{  								find = Util.Array_equals(pattern' filename);  							}  							else  							{  								byte[] _filename = filename;  								if (!fEncoding_is_utf8)  								{  									f = Util.Byte2str(_filename' fEncoding);  									_filename = Util.Str2byte(f' UTF8);  								}  								find = Util.Glob(pattern' _filename);  							}  						}  						if (find)  						{  							if (f == null)  							{  								f = Util.Byte2str(filename' fEncoding);  							}  							string l = null;  							if (longname == null)  							{  								// TODO: we need to generate long name from attrs  								//       for the sftp protocol 4(and later).  								l = attrs.ToString() + " " + f;  							}  							else  							{  								l = Util.Byte2str(longname' fEncoding);  							}  							v.Add(new ChannelSftp.LsEntry(this' f' l' attrs));  						}  						count--;  					}  				}  				_sendCLOSE(handle' header);  				return v;  			}  			catch (Exception e)  			{  				if (e is SftpException)  				{  					throw (SftpException)e;  				}  				if (e is Exception)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty' (Exception)e);  				}  				throw new SftpException(SSH_FX_FAILURE' string.Empty);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Readlink,The following statement contains a magic number: try  			{  				if (server_version < 3)  				{  					throw new SftpException(SSH_FX_OP_UNSUPPORTED' "The remote sshd is too old to support symlink operation."  						);  				}  				((Channel.MyPipedInputStream)io_in).UpdateReadSide();  				path = RemoteAbsolutePath(path);  				path = IsUnique(path);  				SendREADLINK(Util.Str2byte(path' fEncoding));  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				int length = header.length;  				int type = header.type;  				Fill(buf' length);  				if (type != SSH_FXP_STATUS && type != SSH_FXP_NAME)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty);  				}  				if (type == SSH_FXP_NAME)  				{  					int count = buf.GetInt();  					// count  					byte[] filename = null;  					for (int i = 0; i < count; i++)  					{  						filename = buf.GetString();  						if (server_version <= 3)  						{  							byte[] longname = buf.GetString();  						}  						SftpATTRS.GetATTR(buf);  					}  					return Util.Byte2str(filename' fEncoding);  				}  				int i_1 = buf.GetInt();  				ThrowStatusError(buf' i_1);  			}  			catch (Exception e)  			{  				if (e is SftpException)  				{  					throw (SftpException)e;  				}  				if (e is Exception)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty' (Exception)e);  				}  				throw new SftpException(SSH_FX_FAILURE' string.Empty);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Readlink,The following statement contains a magic number: try  			{  				if (server_version < 3)  				{  					throw new SftpException(SSH_FX_OP_UNSUPPORTED' "The remote sshd is too old to support symlink operation."  						);  				}  				((Channel.MyPipedInputStream)io_in).UpdateReadSide();  				path = RemoteAbsolutePath(path);  				path = IsUnique(path);  				SendREADLINK(Util.Str2byte(path' fEncoding));  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				int length = header.length;  				int type = header.type;  				Fill(buf' length);  				if (type != SSH_FXP_STATUS && type != SSH_FXP_NAME)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty);  				}  				if (type == SSH_FXP_NAME)  				{  					int count = buf.GetInt();  					// count  					byte[] filename = null;  					for (int i = 0; i < count; i++)  					{  						filename = buf.GetString();  						if (server_version <= 3)  						{  							byte[] longname = buf.GetString();  						}  						SftpATTRS.GetATTR(buf);  					}  					return Util.Byte2str(filename' fEncoding);  				}  				int i_1 = buf.GetInt();  				ThrowStatusError(buf' i_1);  			}  			catch (Exception e)  			{  				if (e is SftpException)  				{  					throw (SftpException)e;  				}  				if (e is Exception)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty' (Exception)e);  				}  				throw new SftpException(SSH_FX_FAILURE' string.Empty);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Symlink,The following statement contains a magic number: if (server_version < 3)  			{  				throw new SftpException(SSH_FX_OP_UNSUPPORTED' "The remote sshd is too old to support symlink operation."  					);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Rename,The following statement contains a magic number: if (server_version < 2)  			{  				throw new SftpException(SSH_FX_OP_UNSUPPORTED' "The remote sshd is too old to support rename operation."  					);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Rename,The following statement contains a magic number: try  			{  				((Channel.MyPipedInputStream)io_in).UpdateReadSide();  				oldpath = RemoteAbsolutePath(oldpath);  				newpath = RemoteAbsolutePath(newpath);  				oldpath = IsUnique(oldpath);  				ArrayList v = Glob_remote(newpath);  				int vsize = v.Count;  				if (vsize >= 2)  				{  					throw new SftpException(SSH_FX_FAILURE' v.ToString());  				}  				if (vsize == 1)  				{  					newpath = (string)(v[0]);  				}  				else  				{  					// vsize==0  					if (IsPattern(newpath))  					{  						throw new SftpException(SSH_FX_FAILURE' newpath);  					}  					newpath = Util.Unquote(newpath);  				}  				SendRENAME(Util.Str2byte(oldpath' fEncoding)' Util.Str2byte(newpath' fEncoding));  				ChannelHeader header = new ChannelHeader(this);  				header = Header(buf' header);  				int length = header.length;  				int type = header.type;  				Fill(buf' length);  				if (type != SSH_FXP_STATUS)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty);  				}  				int i = buf.GetInt();  				if (i == SSH_FX_OK)  				{  					return;  				}  				ThrowStatusError(buf' i);  			}  			catch (Exception e)  			{  				if (e is SftpException)  				{  					throw (SftpException)e;  				}  				if (e is Exception)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty' (Exception)e);  				}  				throw new SftpException(SSH_FX_FAILURE' string.Empty);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_realpath,The following statement contains a magic number: while (i-- > 0)  			{  				str = buf.GetString();  				// absolute path;  				if (server_version <= 3)  				{  					byte[] lname = buf.GetString();  				}  				// long filename  				SftpATTRS attr = SftpATTRS.GetATTR(buf);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendINIT,The following statement contains a magic number: PutHEAD(SSH_FXP_INIT' 5);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendINIT,The following statement contains a magic number: buf.PutInt(3);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendINIT,The following statement contains a magic number: GetSession().Write(packet' this' 5 + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendINIT,The following statement contains a magic number: GetSession().Write(packet' this' 5 + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendSETSTAT,The following statement contains a magic number: PutHEAD(SSH_FXP_SETSTAT' 9 + path.Length + attr.Length());
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendSETSTAT,The following statement contains a magic number: GetSession().Write(packet' this' 9 + path.Length + attr.Length() + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendSETSTAT,The following statement contains a magic number: GetSession().Write(packet' this' 9 + path.Length + attr.Length() + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendMKDIR,The following statement contains a magic number: PutHEAD(SSH_FXP_MKDIR' 9 + path.Length + (attr != null ? attr.Length() : 4));
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendMKDIR,The following statement contains a magic number: PutHEAD(SSH_FXP_MKDIR' 9 + path.Length + (attr != null ? attr.Length() : 4));
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendMKDIR,The following statement contains a magic number: GetSession().Write(packet' this' 9 + path.Length + (attr != null ? attr.Length() :   				4) + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendMKDIR,The following statement contains a magic number: GetSession().Write(packet' this' 9 + path.Length + (attr != null ? attr.Length() :   				4) + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendMKDIR,The following statement contains a magic number: GetSession().Write(packet' this' 9 + path.Length + (attr != null ? attr.Length() :   				4) + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendOPEN,The following statement contains a magic number: PutHEAD(SSH_FXP_OPEN' 17 + path.Length);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendOPEN,The following statement contains a magic number: GetSession().Write(packet' this' 17 + path.Length + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendOPEN,The following statement contains a magic number: GetSession().Write(packet' this' 17 + path.Length + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendPacketPath,The following statement contains a magic number: PutHEAD(fxp' 9 + path.Length);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendPacketPath,The following statement contains a magic number: GetSession().Write(packet' this' 9 + path.Length + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendPacketPath,The following statement contains a magic number: GetSession().Write(packet' this' 9 + path.Length + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendPacketPath,The following statement contains a magic number: PutHEAD(fxp' 13 + p1.Length + p2.Length);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendPacketPath,The following statement contains a magic number: GetSession().Write(packet' this' 13 + p1.Length + p2.Length + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendPacketPath,The following statement contains a magic number: GetSession().Write(packet' this' 13 + p1.Length + p2.Length + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendWRITE,The following statement contains a magic number: if (obuf.buffer.Length < obuf.index + 13 + 21 + handle.Length + length + Session.  				buffer_margin)  			{  				_length = obuf.buffer.Length - (obuf.index + 13 + 21 + handle.Length + Session.buffer_margin  					);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendWRITE,The following statement contains a magic number: if (obuf.buffer.Length < obuf.index + 13 + 21 + handle.Length + length + Session.  				buffer_margin)  			{  				_length = obuf.buffer.Length - (obuf.index + 13 + 21 + handle.Length + Session.buffer_margin  					);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendWRITE,The following statement contains a magic number: if (obuf.buffer.Length < obuf.index + 13 + 21 + handle.Length + length + Session.  				buffer_margin)  			{  				_length = obuf.buffer.Length - (obuf.index + 13 + 21 + handle.Length + Session.buffer_margin  					);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendWRITE,The following statement contains a magic number: if (obuf.buffer.Length < obuf.index + 13 + 21 + handle.Length + length + Session.  				buffer_margin)  			{  				_length = obuf.buffer.Length - (obuf.index + 13 + 21 + handle.Length + Session.buffer_margin  					);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendWRITE,The following statement contains a magic number: PutHEAD(obuf' SSH_FXP_WRITE' 21 + handle.Length + _length);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendWRITE,The following statement contains a magic number: GetSession().Write(opacket' this' 21 + handle.Length + _length + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendWRITE,The following statement contains a magic number: GetSession().Write(opacket' this' 21 + handle.Length + _length + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendREAD,The following statement contains a magic number: PutHEAD(SSH_FXP_READ' 21 + handle.Length);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendREAD,The following statement contains a magic number: GetSession().Write(packet' this' 21 + handle.Length + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SendREAD,The following statement contains a magic number: GetSession().Write(packet' this' 21 + handle.Length + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,PutHEAD,The following statement contains a magic number: buf.PutInt(length + 4);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Glob_remote,The following statement contains a magic number: while (true)  			{  				SendREADDIR(handle);  				header = Header(buf' header);  				length = header.length;  				type = header.type;  				if (type != SSH_FXP_STATUS && type != SSH_FXP_NAME)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty);  				}  				if (type == SSH_FXP_STATUS)  				{  					Fill(buf' length);  					break;  				}  				buf.Rewind();  				Fill(buf.buffer' 0' 4);  				length -= 4;  				int count = buf.GetInt();  				byte[] str;  				int flags;  				buf.Reset();  				while (count > 0)  				{  					if (length > 0)  					{  						buf.Shift();  						int j = (buf.buffer.Length > (buf.index + length)) ? length : (buf.buffer.Length   							- buf.index);  						i = io_in.Read(buf.buffer' buf.index' j);  						if (i <= 0)  						{  							break;  						}  						buf.index += i;  						length -= i;  					}  					byte[] filename = buf.GetString();  					//System.err.println("filename: "+new String(filename));  					if (server_version <= 3)  					{  						str = buf.GetString();  					}  					// longname  					SftpATTRS attrs = SftpATTRS.GetATTR(buf);  					byte[] _filename = filename;  					string f = null;  					bool found = false;  					if (!fEncoding_is_utf8)  					{  						f = Util.Byte2str(filename' fEncoding);  						_filename = Util.Str2byte(f' UTF8);  					}  					found = Util.Glob(pattern' _filename);  					if (found)  					{  						if (f == null)  						{  							f = Util.Byte2str(filename' fEncoding);  						}  						if (pdir == null)  						{  							pdir = dir;  							if (!pdir.EndsWith("/"))  							{  								pdir += "/";  							}  						}  						v.Add(pdir + f);  					}  					count--;  				}  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Glob_remote,The following statement contains a magic number: while (true)  			{  				SendREADDIR(handle);  				header = Header(buf' header);  				length = header.length;  				type = header.type;  				if (type != SSH_FXP_STATUS && type != SSH_FXP_NAME)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty);  				}  				if (type == SSH_FXP_STATUS)  				{  					Fill(buf' length);  					break;  				}  				buf.Rewind();  				Fill(buf.buffer' 0' 4);  				length -= 4;  				int count = buf.GetInt();  				byte[] str;  				int flags;  				buf.Reset();  				while (count > 0)  				{  					if (length > 0)  					{  						buf.Shift();  						int j = (buf.buffer.Length > (buf.index + length)) ? length : (buf.buffer.Length   							- buf.index);  						i = io_in.Read(buf.buffer' buf.index' j);  						if (i <= 0)  						{  							break;  						}  						buf.index += i;  						length -= i;  					}  					byte[] filename = buf.GetString();  					//System.err.println("filename: "+new String(filename));  					if (server_version <= 3)  					{  						str = buf.GetString();  					}  					// longname  					SftpATTRS attrs = SftpATTRS.GetATTR(buf);  					byte[] _filename = filename;  					string f = null;  					bool found = false;  					if (!fEncoding_is_utf8)  					{  						f = Util.Byte2str(filename' fEncoding);  						_filename = Util.Str2byte(f' UTF8);  					}  					found = Util.Glob(pattern' _filename);  					if (found)  					{  						if (f == null)  						{  							f = Util.Byte2str(filename' fEncoding);  						}  						if (pdir == null)  						{  							pdir = dir;  							if (!pdir.EndsWith("/"))  							{  								pdir += "/";  							}  						}  						v.Add(pdir + f);  					}  					count--;  				}  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Glob_remote,The following statement contains a magic number: while (true)  			{  				SendREADDIR(handle);  				header = Header(buf' header);  				length = header.length;  				type = header.type;  				if (type != SSH_FXP_STATUS && type != SSH_FXP_NAME)  				{  					throw new SftpException(SSH_FX_FAILURE' string.Empty);  				}  				if (type == SSH_FXP_STATUS)  				{  					Fill(buf' length);  					break;  				}  				buf.Rewind();  				Fill(buf.buffer' 0' 4);  				length -= 4;  				int count = buf.GetInt();  				byte[] str;  				int flags;  				buf.Reset();  				while (count > 0)  				{  					if (length > 0)  					{  						buf.Shift();  						int j = (buf.buffer.Length > (buf.index + length)) ? length : (buf.buffer.Length   							- buf.index);  						i = io_in.Read(buf.buffer' buf.index' j);  						if (i <= 0)  						{  							break;  						}  						buf.index += i;  						length -= i;  					}  					byte[] filename = buf.GetString();  					//System.err.println("filename: "+new String(filename));  					if (server_version <= 3)  					{  						str = buf.GetString();  					}  					// longname  					SftpATTRS attrs = SftpATTRS.GetATTR(buf);  					byte[] _filename = filename;  					string f = null;  					bool found = false;  					if (!fEncoding_is_utf8)  					{  						f = Util.Byte2str(filename' fEncoding);  						_filename = Util.Str2byte(f' UTF8);  					}  					found = Util.Glob(pattern' _filename);  					if (found)  					{  						if (f == null)  						{  							f = Util.Byte2str(filename' fEncoding);  						}  						if (pdir == null)  						{  							pdir = dir;  							if (!pdir.EndsWith("/"))  							{  								pdir += "/";  							}  						}  						v.Add(pdir + f);  					}  					count--;  				}  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,ThrowStatusError,The following statement contains a magic number: if (server_version >= 3 && buf.GetLength() >= 4)  			{  				// WindRiver's sftp will send invalid   				// SSH_FXP_STATUS packet.  				byte[] str = buf.GetString();  				//byte[] tag=buf.getString();  				throw new SftpException(i' Util.Byte2str(str' UTF8));  			}  			else  			{  				throw new SftpException(i' "Failure");  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,ThrowStatusError,The following statement contains a magic number: if (server_version >= 3 && buf.GetLength() >= 4)  			{  				// WindRiver's sftp will send invalid   				// SSH_FXP_STATUS packet.  				byte[] str = buf.GetString();  				//byte[] tag=buf.getString();  				throw new SftpException(i' Util.Byte2str(str' UTF8));  			}  			else  			{  				throw new SftpException(i' "Failure");  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Header,The following statement contains a magic number: int i = Fill(buf.buffer' 0' 9);
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Header,The following statement contains a magic number: header.length = buf.GetInt() - 5;
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SetFilenameEncoding,The following statement contains a magic number: if (3 <= sversion && sversion <= 5 && !encoding.Equals(UTF8))  			{  				throw new SftpException(SSH_FX_FAILURE' "The encoding can not be changed for this sftp server."  					);  			}
Magic Number,NSch,ChannelSftp,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,SetFilenameEncoding,The following statement contains a magic number: if (3 <= sversion && sversion <= 5 && !encoding.Equals(UTF8))  			{  				throw new SftpException(SSH_FX_FAILURE' "The encoding can not be changed for this sftp server."  					);  			}
Magic Number,NSch,_OutputStream_686,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Write,The following statement contains a magic number: try  				{  					int _len = len;  					while (_len > 0)  					{  						int sent = this._enclosing.SendWRITE(handle' _offset[0]' d' s' _len);  						this.writecount++;  						_offset[0] += sent;  						s += sent;  						_len -= sent;  						if ((this._enclosing.seq - 1) == this.startid || this._enclosing.io_in.Available(  							) >= 1024)  						{  							while (this._enclosing.io_in.Available() > 0)  							{  								if (this._enclosing.CheckStatus(this.ackid' this.header))  								{  									this._ackid = this.ackid[0];  									if (this.startid > this._ackid || this._ackid > this._enclosing.seq - 1)  									{  										throw new SftpException(NSch.ChannelSftp.SSH_FX_FAILURE' string.Empty);  									}  									this.ackcount++;  								}  								else  								{  									break;  								}  							}  						}  					}  					if (monitor != null && !monitor.Count(len))  					{  						this.Close();  						throw new IOException("canceled");  					}  				}  				catch (IOException e)  				{  					throw;  				}  				catch (Exception e)  				{  					throw new IOException(e.ToString());  				}
Magic Number,NSch,Request,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Write,The following statement contains a magic number: if (reply)  			{  				long start = Runtime.CurrentTimeMillis();  				long timeout = channel.connectTimeout;  				while (channel.IsConnected() && channel.reply == -1)  				{  					try  					{  						Sharpen.Thread.Sleep(10);  					}  					catch (Exception)  					{  					}  					if (timeout > 0L && (Runtime.CurrentTimeMillis() - start) > timeout)  					{  						channel.reply = 0;  						throw new JSchException("channel request: timeout");  					}  				}  				if (channel.reply == 0)  				{  					throw new JSchException("failed to send channel request");  				}  			}
Magic Number,NSch,_InputStream_1195,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,_InputStream_1195,The following statement contains a magic number: this.rest_byte = new byte[1024];
Magic Number,NSch,_InputStream_1195,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Read,The following statement contains a magic number: if (this._enclosing.buf.buffer.Length - 13 < len)  				{  					len = this._enclosing.buf.buffer.Length - 13;  				}
Magic Number,NSch,_InputStream_1195,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Read,The following statement contains a magic number: if (this._enclosing.buf.buffer.Length - 13 < len)  				{  					len = this._enclosing.buf.buffer.Length - 13;  				}
Magic Number,NSch,_InputStream_1195,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Read,The following statement contains a magic number: if (this._enclosing.server_version == 0 && len > 1024)  				{  					len = 1024;  				}
Magic Number,NSch,_InputStream_1195,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Read,The following statement contains a magic number: if (this._enclosing.server_version == 0 && len > 1024)  				{  					len = 1024;  				}
Magic Number,NSch,_InputStream_1195,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Read,The following statement contains a magic number: this._enclosing.Fill(this._enclosing.buf.buffer' 0' 4);
Magic Number,NSch,_InputStream_1195,C:\repos\mono_ngit\NSch\NSch\ChannelSftp.cs,Read,The following statement contains a magic number: this.rest_length -= 4;
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,SetCookie,The following statement contains a magic number: cookie = new byte[16];
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,SetCookie,The following statement contains a magic number: for (int i = 0; i < 16; i++)  			{  				cookie[i] = unchecked((byte)(((Revtable(cookie_hex[i * 2]) << 4) & unchecked((int  					)(0xf0))) | ((Revtable(cookie_hex[i * 2 + 1])) & unchecked((int)(0xf)))));  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,SetCookie,The following statement contains a magic number: for (int i = 0; i < 16; i++)  			{  				cookie[i] = unchecked((byte)(((Revtable(cookie_hex[i * 2]) << 4) & unchecked((int  					)(0xf0))) | ((Revtable(cookie_hex[i * 2 + 1])) & unchecked((int)(0xf)))));  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,SetCookie,The following statement contains a magic number: for (int i = 0; i < 16; i++)  			{  				cookie[i] = unchecked((byte)(((Revtable(cookie_hex[i * 2]) << 4) & unchecked((int  					)(0xf0))) | ((Revtable(cookie_hex[i * 2 + 1])) & unchecked((int)(0xf)))));  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,SetCookie,The following statement contains a magic number: for (int i = 0; i < 16; i++)  			{  				cookie[i] = unchecked((byte)(((Revtable(cookie_hex[i * 2]) << 4) & unchecked((int  					)(0xf0))) | ((Revtable(cookie_hex[i * 2 + 1])) & unchecked((int)(0xf)))));  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,GetFakedCookie,The following statement contains a magic number: lock (faked_cookie_hex_pool)  			{  				byte[] foo = (byte[])faked_cookie_hex_pool[session];  				if (foo == null)  				{  					Random random = Session.random;  					foo = new byte[16];  					lock (random)  					{  						random.Fill(foo' 0' 16);  					}  					faked_cookie_pool.Put(session' foo);  					byte[] bar = new byte[32];  					for (int i = 0; i < 16; i++)  					{  						bar[2 * i] = table[(foo[i] >> 4) & unchecked((int)(0xf))];  						bar[2 * i + 1] = table[(foo[i]) & unchecked((int)(0xf))];  					}  					faked_cookie_hex_pool.Put(session' bar);  					foo = bar;  				}  				return foo;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,GetFakedCookie,The following statement contains a magic number: lock (faked_cookie_hex_pool)  			{  				byte[] foo = (byte[])faked_cookie_hex_pool[session];  				if (foo == null)  				{  					Random random = Session.random;  					foo = new byte[16];  					lock (random)  					{  						random.Fill(foo' 0' 16);  					}  					faked_cookie_pool.Put(session' foo);  					byte[] bar = new byte[32];  					for (int i = 0; i < 16; i++)  					{  						bar[2 * i] = table[(foo[i] >> 4) & unchecked((int)(0xf))];  						bar[2 * i + 1] = table[(foo[i]) & unchecked((int)(0xf))];  					}  					faked_cookie_hex_pool.Put(session' bar);  					foo = bar;  				}  				return foo;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,GetFakedCookie,The following statement contains a magic number: lock (faked_cookie_hex_pool)  			{  				byte[] foo = (byte[])faked_cookie_hex_pool[session];  				if (foo == null)  				{  					Random random = Session.random;  					foo = new byte[16];  					lock (random)  					{  						random.Fill(foo' 0' 16);  					}  					faked_cookie_pool.Put(session' foo);  					byte[] bar = new byte[32];  					for (int i = 0; i < 16; i++)  					{  						bar[2 * i] = table[(foo[i] >> 4) & unchecked((int)(0xf))];  						bar[2 * i + 1] = table[(foo[i]) & unchecked((int)(0xf))];  					}  					faked_cookie_hex_pool.Put(session' bar);  					foo = bar;  				}  				return foo;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,GetFakedCookie,The following statement contains a magic number: lock (faked_cookie_hex_pool)  			{  				byte[] foo = (byte[])faked_cookie_hex_pool[session];  				if (foo == null)  				{  					Random random = Session.random;  					foo = new byte[16];  					lock (random)  					{  						random.Fill(foo' 0' 16);  					}  					faked_cookie_pool.Put(session' foo);  					byte[] bar = new byte[32];  					for (int i = 0; i < 16; i++)  					{  						bar[2 * i] = table[(foo[i] >> 4) & unchecked((int)(0xf))];  						bar[2 * i + 1] = table[(foo[i]) & unchecked((int)(0xf))];  					}  					faked_cookie_hex_pool.Put(session' bar);  					foo = bar;  				}  				return foo;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,GetFakedCookie,The following statement contains a magic number: lock (faked_cookie_hex_pool)  			{  				byte[] foo = (byte[])faked_cookie_hex_pool[session];  				if (foo == null)  				{  					Random random = Session.random;  					foo = new byte[16];  					lock (random)  					{  						random.Fill(foo' 0' 16);  					}  					faked_cookie_pool.Put(session' foo);  					byte[] bar = new byte[32];  					for (int i = 0; i < 16; i++)  					{  						bar[2 * i] = table[(foo[i] >> 4) & unchecked((int)(0xf))];  						bar[2 * i + 1] = table[(foo[i]) & unchecked((int)(0xf))];  					}  					faked_cookie_hex_pool.Put(session' bar);  					foo = bar;  				}  				return foo;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,GetFakedCookie,The following statement contains a magic number: lock (faked_cookie_hex_pool)  			{  				byte[] foo = (byte[])faked_cookie_hex_pool[session];  				if (foo == null)  				{  					Random random = Session.random;  					foo = new byte[16];  					lock (random)  					{  						random.Fill(foo' 0' 16);  					}  					faked_cookie_pool.Put(session' foo);  					byte[] bar = new byte[32];  					for (int i = 0; i < 16; i++)  					{  						bar[2 * i] = table[(foo[i] >> 4) & unchecked((int)(0xf))];  						bar[2 * i + 1] = table[(foo[i]) & unchecked((int)(0xf))];  					}  					faked_cookie_hex_pool.Put(session' bar);  					foo = bar;  				}  				return foo;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,GetFakedCookie,The following statement contains a magic number: lock (faked_cookie_hex_pool)  			{  				byte[] foo = (byte[])faked_cookie_hex_pool[session];  				if (foo == null)  				{  					Random random = Session.random;  					foo = new byte[16];  					lock (random)  					{  						random.Fill(foo' 0' 16);  					}  					faked_cookie_pool.Put(session' foo);  					byte[] bar = new byte[32];  					for (int i = 0; i < 16; i++)  					{  						bar[2 * i] = table[(foo[i] >> 4) & unchecked((int)(0xf))];  						bar[2 * i + 1] = table[(foo[i]) & unchecked((int)(0xf))];  					}  					faked_cookie_hex_pool.Put(session' bar);  					foo = bar;  				}  				return foo;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Run,The following statement contains a magic number: try  			{  				while (thread != null && io != null && io.@in != null)  				{  					i = io.@in.Read(buf.buffer' 14' buf.buffer.Length - 14 - Session.buffer_margin);  					if (i <= 0)  					{  						Eof();  						break;  					}  					if (close)  					{  						break;  					}  					packet.Reset();  					buf.PutByte(unchecked((byte)Session.SSH_MSG_CHANNEL_DATA));  					buf.PutInt(recipient);  					buf.PutInt(i);  					buf.Skip(i);  					GetSession().Write(packet' this' i);  				}  			}  			catch (Exception)  			{  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Run,The following statement contains a magic number: try  			{  				while (thread != null && io != null && io.@in != null)  				{  					i = io.@in.Read(buf.buffer' 14' buf.buffer.Length - 14 - Session.buffer_margin);  					if (i <= 0)  					{  						Eof();  						break;  					}  					if (close)  					{  						break;  					}  					packet.Reset();  					buf.PutByte(unchecked((byte)Session.SSH_MSG_CHANNEL_DATA));  					buf.PutInt(recipient);  					buf.PutInt(i);  					buf.Skip(i);  					GetSession().Write(packet' this' i);  				}  			}  			catch (Exception)  			{  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,ChannelX11,C:\repos\mono_ngit\NSch\NSch\ChannelX11.cs,Write,The following statement contains a magic number: if (init)  			{  				Session _session = null;  				try  				{  					_session = GetSession();  				}  				catch (JSchException e)  				{  					throw new IOException(e.ToString());  				}  				foo = AddCache(foo' s' l);  				s = 0;  				l = foo.Length;  				if (l < 9)  				{  					return;  				}  				int plen = (foo[s + 6] & unchecked((int)(0xff))) * 256 + (foo[s + 7] & unchecked(  					(int)(0xff)));  				int dlen = (foo[s + 8] & unchecked((int)(0xff))) * 256 + (foo[s + 9] & unchecked(  					(int)(0xff)));  				if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x42)))  				{  				}  				else  				{  					if ((foo[s] & unchecked((int)(0xff))) == unchecked((int)(0x6c)))  					{  						plen = (((int)(((uint)plen) >> 8)) & unchecked((int)(0xff))) | ((plen << 8) & unchecked(  							(int)(0xff00)));  						dlen = (((int)(((uint)dlen) >> 8)) & unchecked((int)(0xff))) | ((dlen << 8) & unchecked(  							(int)(0xff00)));  					}  				}  				// ??  				if (l < 12 + plen + ((-plen) & 3) + dlen)  				{  					return;  				}  				byte[] bar = new byte[dlen];  				System.Array.Copy(foo' s + 12 + plen + ((-plen) & 3)' bar' 0' dlen);  				byte[] faked_cookie = null;  				lock (faked_cookie_pool)  				{  					faked_cookie = (byte[])faked_cookie_pool[_session];  				}  				if (Equals(bar' faked_cookie))  				{  					if (cookie != null)  					{  						System.Array.Copy(cookie' 0' foo' s + 12 + plen + ((-plen) & 3)' dlen);  					}  				}  				else  				{  					//System.err.println("wrong cookie");  					thread = null;  					Eof();  					io.Close();  					Disconnect();  				}  				init = false;  				io.Put(foo' s' l);  				cache = null;  				return;  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,HostKey,C:\repos\mono_ngit\NSch\NSch\HostKey.cs,HostKey,The following statement contains a magic number: if (type == GUESS)  			{  				if (key[8] == 'd')  				{  					this.type = SSHDSS;  				}  				else  				{  					if (key[8] == 'r')  					{  						this.type = SSHRSA;  					}  					else  					{  						throw new JSchException("invalid key type");  					}  				}  			}  			else  			{  				this.type = type;  			}
Magic Number,NSch,HostKey,C:\repos\mono_ngit\NSch\NSch\HostKey.cs,HostKey,The following statement contains a magic number: if (type == GUESS)  			{  				if (key[8] == 'd')  				{  					this.type = SSHDSS;  				}  				else  				{  					if (key[8] == 'r')  					{  						this.type = SSHRSA;  					}  					else  					{  						throw new JSchException("invalid key type");  					}  				}  			}  			else  			{  				this.type = type;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: if (pubkey == null && prvkey != null && (prvkey.Length > 11 && prvkey[0] == 0 &&   				prvkey[1] == 0 && prvkey[2] == 0 && prvkey[3] == 7))  			{  				Buffer buf = new Buffer(prvkey);  				string _type = Sharpen.Runtime.GetStringForBytes(buf.GetString());  				// ssh-rsa  				if (_type.Equals("ssh-rsa"))  				{  					type = RSA;  					n_array = buf.GetString();  					e_array = buf.GetString();  					d_array = buf.GetString();  					buf.GetString();  					buf.GetString();  					buf.GetString();  					this.identity += Sharpen.Runtime.GetStringForBytes(buf.GetString());  				}  				else  				{  					if (_type.Equals("ssh-dss"))  					{  						type = DSS;  						P_array = buf.GetString();  						Q_array = buf.GetString();  						G_array = buf.GetString();  						pub_array = buf.GetString();  						prv_array = buf.GetString();  						this.identity += Sharpen.Runtime.GetStringForBytes(buf.GetString());  					}  					else  					{  						throw new JSchException("privatekey: invalid key " + Sharpen.Runtime.GetStringForBytes  							(prvkey' 4' 7));  					}  				}  				encoded_data = prvkey;  				encrypted = false;  				keytype = OPENSSH;  				return;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: if (pubkey == null && prvkey != null && (prvkey.Length > 11 && prvkey[0] == 0 &&   				prvkey[1] == 0 && prvkey[2] == 0 && prvkey[3] == 7))  			{  				Buffer buf = new Buffer(prvkey);  				string _type = Sharpen.Runtime.GetStringForBytes(buf.GetString());  				// ssh-rsa  				if (_type.Equals("ssh-rsa"))  				{  					type = RSA;  					n_array = buf.GetString();  					e_array = buf.GetString();  					d_array = buf.GetString();  					buf.GetString();  					buf.GetString();  					buf.GetString();  					this.identity += Sharpen.Runtime.GetStringForBytes(buf.GetString());  				}  				else  				{  					if (_type.Equals("ssh-dss"))  					{  						type = DSS;  						P_array = buf.GetString();  						Q_array = buf.GetString();  						G_array = buf.GetString();  						pub_array = buf.GetString();  						prv_array = buf.GetString();  						this.identity += Sharpen.Runtime.GetStringForBytes(buf.GetString());  					}  					else  					{  						throw new JSchException("privatekey: invalid key " + Sharpen.Runtime.GetStringForBytes  							(prvkey' 4' 7));  					}  				}  				encoded_data = prvkey;  				encrypted = false;  				keytype = OPENSSH;  				return;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: if (pubkey == null && prvkey != null && (prvkey.Length > 11 && prvkey[0] == 0 &&   				prvkey[1] == 0 && prvkey[2] == 0 && prvkey[3] == 7))  			{  				Buffer buf = new Buffer(prvkey);  				string _type = Sharpen.Runtime.GetStringForBytes(buf.GetString());  				// ssh-rsa  				if (_type.Equals("ssh-rsa"))  				{  					type = RSA;  					n_array = buf.GetString();  					e_array = buf.GetString();  					d_array = buf.GetString();  					buf.GetString();  					buf.GetString();  					buf.GetString();  					this.identity += Sharpen.Runtime.GetStringForBytes(buf.GetString());  				}  				else  				{  					if (_type.Equals("ssh-dss"))  					{  						type = DSS;  						P_array = buf.GetString();  						Q_array = buf.GetString();  						G_array = buf.GetString();  						pub_array = buf.GetString();  						prv_array = buf.GetString();  						this.identity += Sharpen.Runtime.GetStringForBytes(buf.GetString());  					}  					else  					{  						throw new JSchException("privatekey: invalid key " + Sharpen.Runtime.GetStringForBytes  							(prvkey' 4' 7));  					}  				}  				encoded_data = prvkey;  				encrypted = false;  				keytype = OPENSSH;  				return;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: if (pubkey == null && prvkey != null && (prvkey.Length > 11 && prvkey[0] == 0 &&   				prvkey[1] == 0 && prvkey[2] == 0 && prvkey[3] == 7))  			{  				Buffer buf = new Buffer(prvkey);  				string _type = Sharpen.Runtime.GetStringForBytes(buf.GetString());  				// ssh-rsa  				if (_type.Equals("ssh-rsa"))  				{  					type = RSA;  					n_array = buf.GetString();  					e_array = buf.GetString();  					d_array = buf.GetString();  					buf.GetString();  					buf.GetString();  					buf.GetString();  					this.identity += Sharpen.Runtime.GetStringForBytes(buf.GetString());  				}  				else  				{  					if (_type.Equals("ssh-dss"))  					{  						type = DSS;  						P_array = buf.GetString();  						Q_array = buf.GetString();  						G_array = buf.GetString();  						pub_array = buf.GetString();  						prv_array = buf.GetString();  						this.identity += Sharpen.Runtime.GetStringForBytes(buf.GetString());  					}  					else  					{  						throw new JSchException("privatekey: invalid key " + Sharpen.Runtime.GetStringForBytes  							(prvkey' 4' 7));  					}  				}  				encoded_data = prvkey;  				encrypted = false;  				keytype = OPENSSH;  				return;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: if (pubkey == null && prvkey != null && (prvkey.Length > 11 && prvkey[0] == 0 &&   				prvkey[1] == 0 && prvkey[2] == 0 && prvkey[3] == 7))  			{  				Buffer buf = new Buffer(prvkey);  				string _type = Sharpen.Runtime.GetStringForBytes(buf.GetString());  				// ssh-rsa  				if (_type.Equals("ssh-rsa"))  				{  					type = RSA;  					n_array = buf.GetString();  					e_array = buf.GetString();  					d_array = buf.GetString();  					buf.GetString();  					buf.GetString();  					buf.GetString();  					this.identity += Sharpen.Runtime.GetStringForBytes(buf.GetString());  				}  				else  				{  					if (_type.Equals("ssh-dss"))  					{  						type = DSS;  						P_array = buf.GetString();  						Q_array = buf.GetString();  						G_array = buf.GetString();  						pub_array = buf.GetString();  						prv_array = buf.GetString();  						this.identity += Sharpen.Runtime.GetStringForBytes(buf.GetString());  					}  					else  					{  						throw new JSchException("privatekey: invalid key " + Sharpen.Runtime.GetStringForBytes  							(prvkey' 4' 7));  					}  				}  				encoded_data = prvkey;  				encrypted = false;  				keytype = OPENSSH;  				return;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: if (pubkey == null && prvkey != null && (prvkey.Length > 11 && prvkey[0] == 0 &&   				prvkey[1] == 0 && prvkey[2] == 0 && prvkey[3] == 7))  			{  				Buffer buf = new Buffer(prvkey);  				string _type = Sharpen.Runtime.GetStringForBytes(buf.GetString());  				// ssh-rsa  				if (_type.Equals("ssh-rsa"))  				{  					type = RSA;  					n_array = buf.GetString();  					e_array = buf.GetString();  					d_array = buf.GetString();  					buf.GetString();  					buf.GetString();  					buf.GetString();  					this.identity += Sharpen.Runtime.GetStringForBytes(buf.GetString());  				}  				else  				{  					if (_type.Equals("ssh-dss"))  					{  						type = DSS;  						P_array = buf.GetString();  						Q_array = buf.GetString();  						G_array = buf.GetString();  						pub_array = buf.GetString();  						prv_array = buf.GetString();  						this.identity += Sharpen.Runtime.GetStringForBytes(buf.GetString());  					}  					else  					{  						throw new JSchException("privatekey: invalid key " + Sharpen.Runtime.GetStringForBytes  							(prvkey' 4' 7));  					}  				}  				encoded_data = prvkey;  				encrypted = false;  				keytype = OPENSSH;  				return;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,IdentityFile,The following statement contains a magic number: try  			{  				Type c;  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("3des-cbc"));  				cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  				key = new byte[cipher.GetBlockSize()];  				// 24  				iv = new byte[cipher.GetIVSize()];  				// 8  				c = Sharpen.Runtime.GetType((string)JSch.GetConfig("md5"));  				hash = (HASH)(System.Activator.CreateInstance(c));  				hash.Init();  				byte[] buf = prvkey;  				int len = buf.Length;  				int i = 0;  				while (i < len)  				{  					if (buf[i] == '-' && i + 4 < len && buf[i + 1] == '-' && buf[i + 2] == '-' && buf  						[i + 3] == '-' && buf[i + 4] == '-')  					{  						break;  					}  					i++;  				}  				while (i < len)  				{  					if (buf[i] == 'B' && i + 3 < len && buf[i + 1] == 'E' && buf[i + 2] == 'G' && buf  						[i + 3] == 'I')  					{  						i += 6;  						if (buf[i] == 'D' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  						{  							type = DSS;  						}  						else  						{  							if (buf[i] == 'R' && buf[i + 1] == 'S' && buf[i + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i] == 'S' && buf[i + 1] == 'S' && buf[i + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									keytype = FSECURE;  								}  								else  								{  									//System.err.println("invalid format: "+identity);  									throw new JSchException("invalid privatekey: " + identity);  								}  							}  						}  						i += 3;  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '2' && buf[i + 5] == '5' && buf[i + 6] == '6' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '9' && buf[i + 6] == '2' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'A' && i + 7 < len && buf[i + 1] == 'E' && buf[i + 2] == 'S' && buf  						[i + 3] == '-' && buf[i + 4] == '1' && buf[i + 5] == '2' && buf[i + 6] == '8' &&  						 buf[i + 7] == '-')  					{  						i += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							key = new byte[cipher.GetBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + identity);  						}  						continue;  					}  					if (buf[i] == 'C' && i + 3 < len && buf[i + 1] == 'B' && buf[i + 2] == 'C' && buf  						[i + 3] == ''')  					{  						i += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i++]) << 4) & unchecked((int)(0xf0))) + (A2b(  								buf[i++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i] == unchecked((int)(0x0d)) && i + 1 < len && buf[i + 1] == unchecked((int  						)(0x0a)))  					{  						i++;  						continue;  					}  					if (buf[i] == unchecked((int)(0x0a)) && i + 1 < len)  					{  						if (buf[i + 1] == unchecked((int)(0x0a)))  						{  							i += 2;  							break;  						}  						if (buf[i + 1] == unchecked((int)(0x0d)) && i + 2 < len && buf[i + 2] == unchecked(  							(int)(0x0a)))  						{  							i += 3;  							break;  						}  						bool inheader = false;  						for (int j = i + 1; j < len; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + identity);  				}  				int start = i;  				while (i < len)  				{  					if (buf[i] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i + 1' buf' i - (xd ? 1 : 0)' len - i - 1 - (xd ? 1 : 0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i] == '-')  					{  						break;  					}  					i++;  				}  				encoded_data = Util.FromBase64(buf' start' i - start);  				if (encoded_data.Length > 4 && encoded_data[0] == unchecked((byte)unchecked((int)  					(0x3f))) && encoded_data[1] == unchecked((byte)unchecked((int)(0x6f))) && encoded_data  					[2] == unchecked((byte)unchecked((int)(0xf9))) && encoded_data[3] == unchecked((  					byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(encoded_data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					byte[] _cipher = _buf.GetString();  					string cipherStr = Util.Byte2str(_cipher);  					//System.err.println("cipher: "+cipher);   					if (cipherStr.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						encoded_data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + identity);  					}  					else  					{  						if (cipherStr.Equals("none"))  						{  							_buf.GetInt();  							//_buf.getInt();  							encrypted = false;  							byte[] foo = new byte[encoded_data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							encoded_data = foo;  						}  					}  				}  				if (pubkey == null)  				{  					return;  				}  				buf = pubkey;  				len = buf.Length;  				if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  					 '-')  				{  					// FSecure's public key  					i = 0;  					do  					{  						i++;  					}  					while (len > i && buf[i] != unchecked((int)(0x0a)));  					if (len <= i)  					{  						return;  					}  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							bool inheader = false;  							for (int j = i + 1; j < len; j++)  							{  								if (buf[j] == unchecked((int)(0x0a)))  								{  									break;  								}  								if (buf[j] == ':')  								{  									inheader = true;  									break;  								}  							}  							if (!inheader)  							{  								i++;  								break;  							}  						}  						i++;  					}  					if (len <= i)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == unchecked((int)(0x0a)))  						{  							System.Array.Copy(buf' i + 1' buf' i' len - i - 1);  							len--;  							continue;  						}  						if (buf[i] == '-')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (type == UNKNOWN && publickeyblob.Length > 8)  					{  						if (publickeyblob[8] == 'd')  						{  							type = DSS;  						}  						else  						{  							if (publickeyblob[8] == 'r')  							{  								type = RSA;  							}  						}  					}  				}  				else  				{  					if (buf[0] != 's' || buf[1] != 's' || buf[2] != 'h' || buf[3] != '-')  					{  						return;  					}  					i = 0;  					while (i < len)  					{  						if (buf[i] == ' ')  						{  							break;  						}  						i++;  					}  					i++;  					if (i >= len)  					{  						return;  					}  					start = i;  					while (i < len)  					{  						if (buf[i] == ' ' || buf[i] == '\n')  						{  							break;  						}  						i++;  					}  					publickeyblob = Util.FromBase64(buf' start' i - start);  					if (publickeyblob.Length < 4 + 7)  					{  						// It must start with "ssh-XXX".  						if (JSch.GetLogger().IsEnabled(Logger.WARN))  						{  							JSch.GetLogger().Log(Logger.WARN' "failed to parse the public key");  						}  						publickeyblob = null;  					}  				}  			}  			catch (Exception e)  			{  				//System.err.println("IdentityFile: "+e);  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,SetPassphrase,The following statement contains a magic number: try  			{  				if (encrypted)  				{  					if (_passphrase == null)  					{  						return false;  					}  					byte[] passphrase = _passphrase;  					int hsize = hash.GetBlockSize();  					byte[] hn = new byte[key.Length / hsize * hsize + (key.Length % hsize == 0 ? 0 :   						hsize)];  					byte[] tmp = null;  					if (keytype == OPENSSH)  					{  						for (int index = 0; index + hsize <= hn.Length; )  						{  							if (tmp != null)  							{  								hash.Update(tmp' 0' tmp.Length);  							}  							hash.Update(passphrase' 0' passphrase.Length);  							hash.Update(iv' 0' iv.Length > 8 ? 8 : iv.Length);  							tmp = hash.Digest();  							System.Array.Copy(tmp' 0' hn' index' tmp.Length);  							index += tmp.Length;  						}  						System.Array.Copy(hn' 0' key' 0' key.Length);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int index = 0; index + hsize <= hn.Length; )  							{  								if (tmp != null)  								{  									hash.Update(tmp' 0' tmp.Length);  								}  								hash.Update(passphrase' 0' passphrase.Length);  								tmp = hash.Digest();  								System.Array.Copy(tmp' 0' hn' index' tmp.Length);  								index += tmp.Length;  							}  							System.Array.Copy(hn' 0' key' 0' key.Length);  						}  					}  					Util.Bzero(passphrase);  				}  				if (Decrypt())  				{  					encrypted = false;  					return true;  				}  				P_array = Q_array = G_array = pub_array = prv_array = null;  				return false;  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,SetPassphrase,The following statement contains a magic number: try  			{  				if (encrypted)  				{  					if (_passphrase == null)  					{  						return false;  					}  					byte[] passphrase = _passphrase;  					int hsize = hash.GetBlockSize();  					byte[] hn = new byte[key.Length / hsize * hsize + (key.Length % hsize == 0 ? 0 :   						hsize)];  					byte[] tmp = null;  					if (keytype == OPENSSH)  					{  						for (int index = 0; index + hsize <= hn.Length; )  						{  							if (tmp != null)  							{  								hash.Update(tmp' 0' tmp.Length);  							}  							hash.Update(passphrase' 0' passphrase.Length);  							hash.Update(iv' 0' iv.Length > 8 ? 8 : iv.Length);  							tmp = hash.Digest();  							System.Array.Copy(tmp' 0' hn' index' tmp.Length);  							index += tmp.Length;  						}  						System.Array.Copy(hn' 0' key' 0' key.Length);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int index = 0; index + hsize <= hn.Length; )  							{  								if (tmp != null)  								{  									hash.Update(tmp' 0' tmp.Length);  								}  								hash.Update(passphrase' 0' passphrase.Length);  								tmp = hash.Digest();  								System.Array.Copy(tmp' 0' hn' index' tmp.Length);  								index += tmp.Length;  							}  							System.Array.Copy(hn' 0' key' 0' key.Length);  						}  					}  					Util.Bzero(passphrase);  				}  				if (Decrypt())  				{  					encrypted = false;  					return true;  				}  				P_array = Q_array = G_array = pub_array = prv_array = null;  				return false;  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetPublicKeyBlob_rsa,The following statement contains a magic number: Buffer buf = new Buffer("ssh-rsa".Length + 4 + e_array.Length + 4 + n_array.Length  				 + 4);
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetPublicKeyBlob_rsa,The following statement contains a magic number: Buffer buf = new Buffer("ssh-rsa".Length + 4 + e_array.Length + 4 + n_array.Length  				 + 4);
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetPublicKeyBlob_rsa,The following statement contains a magic number: Buffer buf = new Buffer("ssh-rsa".Length + 4 + e_array.Length + 4 + n_array.Length  				 + 4);
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetPublicKeyBlob_dss,The following statement contains a magic number: Buffer buf = new Buffer("ssh-dss".Length + 4 + P_array.Length + 4 + Q_array.Length  				 + 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetPublicKeyBlob_dss,The following statement contains a magic number: Buffer buf = new Buffer("ssh-dss".Length + 4 + P_array.Length + 4 + Q_array.Length  				 + 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetPublicKeyBlob_dss,The following statement contains a magic number: Buffer buf = new Buffer("ssh-dss".Length + 4 + P_array.Length + 4 + Q_array.Length  				 + 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetPublicKeyBlob_dss,The following statement contains a magic number: Buffer buf = new Buffer("ssh-dss".Length + 4 + P_array.Length + 4 + Q_array.Length  				 + 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetPublicKeyBlob_dss,The following statement contains a magic number: Buffer buf = new Buffer("ssh-dss".Length + 4 + P_array.Length + 4 + Q_array.Length  				 + 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetSignature_rsa,The following statement contains a magic number: try  			{  				Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("signature.rsa"));  				NSch.SignatureRSA rsa = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  				rsa.Init();  				rsa.SetPrvKey(d_array' n_array' e_array);  				rsa.Update(data);  				byte[] sig = rsa.Sign();  				Buffer buf = new Buffer("ssh-rsa".Length + 4 + sig.Length + 4);  				buf.PutString(Util.Str2byte("ssh-rsa"));  				buf.PutString(sig);  				return buf.buffer;  			}  			catch (Exception)  			{  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetSignature_rsa,The following statement contains a magic number: try  			{  				Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("signature.rsa"));  				NSch.SignatureRSA rsa = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  				rsa.Init();  				rsa.SetPrvKey(d_array' n_array' e_array);  				rsa.Update(data);  				byte[] sig = rsa.Sign();  				Buffer buf = new Buffer("ssh-rsa".Length + 4 + sig.Length + 4);  				buf.PutString(Util.Str2byte("ssh-rsa"));  				buf.PutString(sig);  				return buf.buffer;  			}  			catch (Exception)  			{  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetSignature_dss,The following statement contains a magic number: try  			{  				Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("signature.dss"));  				NSch.SignatureDSA dsa = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  				dsa.Init();  				dsa.SetPrvKey(prv_array' P_array' Q_array' G_array);  				dsa.Update(data);  				byte[] sig = dsa.Sign();  				Buffer buf = new Buffer("ssh-dss".Length + 4 + sig.Length + 4);  				buf.PutString(Util.Str2byte("ssh-dss"));  				buf.PutString(sig);  				return buf.buffer;  			}  			catch (Exception)  			{  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,GetSignature_dss,The following statement contains a magic number: try  			{  				Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("signature.dss"));  				NSch.SignatureDSA dsa = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  				dsa.Init();  				dsa.SetPrvKey(prv_array' P_array' Q_array' G_array);  				dsa.Update(data);  				byte[] sig = dsa.Sign();  				Buffer buf = new Buffer("ssh-dss".Length + 4 + sig.Length + 4);  				buf.PutString(Util.Str2byte("ssh-dss"));  				buf.PutString(sig);  				return buf.buffer;  			}  			catch (Exception)  			{  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (n_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					e_array = buf.GetMPIntBits();  					d_array = buf.GetMPIntBits();  					n_array = buf.GetMPIntBits();  					byte[] u_array = buf.GetMPIntBits();  					p_array = buf.GetMPIntBits();  					q_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				e_array = new byte[length];  				System.Array.Copy(plain' index' e_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				d_array = new byte[length];  				System.Array.Copy(plain' index' d_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmp1_array = new byte[length];  				System.Array.Copy(plain' index' dmp1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmq1_array = new byte[length];  				System.Array.Copy(plain' index' dmq1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				iqmp_array = new byte[length];  				System.Array.Copy(plain' index' iqmp_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (n_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					e_array = buf.GetMPIntBits();  					d_array = buf.GetMPIntBits();  					n_array = buf.GetMPIntBits();  					byte[] u_array = buf.GetMPIntBits();  					p_array = buf.GetMPIntBits();  					q_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				e_array = new byte[length];  				System.Array.Copy(plain' index' e_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				d_array = new byte[length];  				System.Array.Copy(plain' index' d_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmp1_array = new byte[length];  				System.Array.Copy(plain' index' dmp1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmq1_array = new byte[length];  				System.Array.Copy(plain' index' dmq1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				iqmp_array = new byte[length];  				System.Array.Copy(plain' index' iqmp_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (n_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					e_array = buf.GetMPIntBits();  					d_array = buf.GetMPIntBits();  					n_array = buf.GetMPIntBits();  					byte[] u_array = buf.GetMPIntBits();  					p_array = buf.GetMPIntBits();  					q_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				e_array = new byte[length];  				System.Array.Copy(plain' index' e_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				d_array = new byte[length];  				System.Array.Copy(plain' index' d_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmp1_array = new byte[length];  				System.Array.Copy(plain' index' dmp1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmq1_array = new byte[length];  				System.Array.Copy(plain' index' dmq1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				iqmp_array = new byte[length];  				System.Array.Copy(plain' index' iqmp_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (n_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					e_array = buf.GetMPIntBits();  					d_array = buf.GetMPIntBits();  					n_array = buf.GetMPIntBits();  					byte[] u_array = buf.GetMPIntBits();  					p_array = buf.GetMPIntBits();  					q_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				e_array = new byte[length];  				System.Array.Copy(plain' index' e_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				d_array = new byte[length];  				System.Array.Copy(plain' index' d_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmp1_array = new byte[length];  				System.Array.Copy(plain' index' dmp1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmq1_array = new byte[length];  				System.Array.Copy(plain' index' dmq1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				iqmp_array = new byte[length];  				System.Array.Copy(plain' index' iqmp_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (n_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					e_array = buf.GetMPIntBits();  					d_array = buf.GetMPIntBits();  					n_array = buf.GetMPIntBits();  					byte[] u_array = buf.GetMPIntBits();  					p_array = buf.GetMPIntBits();  					q_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				e_array = new byte[length];  				System.Array.Copy(plain' index' e_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				d_array = new byte[length];  				System.Array.Copy(plain' index' d_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmp1_array = new byte[length];  				System.Array.Copy(plain' index' dmp1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmq1_array = new byte[length];  				System.Array.Copy(plain' index' dmq1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				iqmp_array = new byte[length];  				System.Array.Copy(plain' index' iqmp_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (n_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					e_array = buf.GetMPIntBits();  					d_array = buf.GetMPIntBits();  					n_array = buf.GetMPIntBits();  					byte[] u_array = buf.GetMPIntBits();  					p_array = buf.GetMPIntBits();  					q_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				e_array = new byte[length];  				System.Array.Copy(plain' index' e_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				d_array = new byte[length];  				System.Array.Copy(plain' index' d_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmp1_array = new byte[length];  				System.Array.Copy(plain' index' dmp1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmq1_array = new byte[length];  				System.Array.Copy(plain' index' dmq1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				iqmp_array = new byte[length];  				System.Array.Copy(plain' index' iqmp_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (n_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					e_array = buf.GetMPIntBits();  					d_array = buf.GetMPIntBits();  					n_array = buf.GetMPIntBits();  					byte[] u_array = buf.GetMPIntBits();  					p_array = buf.GetMPIntBits();  					q_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				e_array = new byte[length];  				System.Array.Copy(plain' index' e_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				d_array = new byte[length];  				System.Array.Copy(plain' index' d_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmp1_array = new byte[length];  				System.Array.Copy(plain' index' dmp1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmq1_array = new byte[length];  				System.Array.Copy(plain' index' dmq1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				iqmp_array = new byte[length];  				System.Array.Copy(plain' index' iqmp_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (n_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					e_array = buf.GetMPIntBits();  					d_array = buf.GetMPIntBits();  					n_array = buf.GetMPIntBits();  					byte[] u_array = buf.GetMPIntBits();  					p_array = buf.GetMPIntBits();  					q_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				e_array = new byte[length];  				System.Array.Copy(plain' index' e_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				d_array = new byte[length];  				System.Array.Copy(plain' index' d_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmp1_array = new byte[length];  				System.Array.Copy(plain' index' dmp1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmq1_array = new byte[length];  				System.Array.Copy(plain' index' dmq1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				iqmp_array = new byte[length];  				System.Array.Copy(plain' index' iqmp_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (n_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					e_array = buf.GetMPIntBits();  					d_array = buf.GetMPIntBits();  					n_array = buf.GetMPIntBits();  					byte[] u_array = buf.GetMPIntBits();  					p_array = buf.GetMPIntBits();  					q_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				e_array = new byte[length];  				System.Array.Copy(plain' index' e_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				d_array = new byte[length];  				System.Array.Copy(plain' index' d_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmp1_array = new byte[length];  				System.Array.Copy(plain' index' dmp1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmq1_array = new byte[length];  				System.Array.Copy(plain' index' dmq1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				iqmp_array = new byte[length];  				System.Array.Copy(plain' index' iqmp_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (n_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					e_array = buf.GetMPIntBits();  					d_array = buf.GetMPIntBits();  					n_array = buf.GetMPIntBits();  					byte[] u_array = buf.GetMPIntBits();  					p_array = buf.GetMPIntBits();  					q_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				e_array = new byte[length];  				System.Array.Copy(plain' index' e_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				d_array = new byte[length];  				System.Array.Copy(plain' index' d_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmp1_array = new byte[length];  				System.Array.Copy(plain' index' dmp1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmq1_array = new byte[length];  				System.Array.Copy(plain' index' dmq1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				iqmp_array = new byte[length];  				System.Array.Copy(plain' index' iqmp_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_rsa,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (n_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					e_array = buf.GetMPIntBits();  					d_array = buf.GetMPIntBits();  					n_array = buf.GetMPIntBits();  					byte[] u_array = buf.GetMPIntBits();  					p_array = buf.GetMPIntBits();  					q_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				e_array = new byte[length];  				System.Array.Copy(plain' index' e_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				d_array = new byte[length];  				System.Array.Copy(plain' index' d_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmp1_array = new byte[length];  				System.Array.Copy(plain' index' dmp1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				dmq1_array = new byte[length];  				System.Array.Copy(plain' index' dmq1_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				iqmp_array = new byte[length];  				System.Array.Copy(plain' index' iqmp_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (P_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					P_array = buf.GetMPIntBits();  					G_array = buf.GetMPIntBits();  					Q_array = buf.GetMPIntBits();  					pub_array = buf.GetMPIntBits();  					prv_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				P_array = new byte[length];  				System.Array.Copy(plain' index' P_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				Q_array = new byte[length];  				System.Array.Copy(plain' index' Q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				G_array = new byte[length];  				System.Array.Copy(plain' index' G_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				//e.printStackTrace();  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (P_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					P_array = buf.GetMPIntBits();  					G_array = buf.GetMPIntBits();  					Q_array = buf.GetMPIntBits();  					pub_array = buf.GetMPIntBits();  					prv_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				P_array = new byte[length];  				System.Array.Copy(plain' index' P_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				Q_array = new byte[length];  				System.Array.Copy(plain' index' Q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				G_array = new byte[length];  				System.Array.Copy(plain' index' G_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				//e.printStackTrace();  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (P_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					P_array = buf.GetMPIntBits();  					G_array = buf.GetMPIntBits();  					Q_array = buf.GetMPIntBits();  					pub_array = buf.GetMPIntBits();  					prv_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				P_array = new byte[length];  				System.Array.Copy(plain' index' P_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				Q_array = new byte[length];  				System.Array.Copy(plain' index' Q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				G_array = new byte[length];  				System.Array.Copy(plain' index' G_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				//e.printStackTrace();  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (P_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					P_array = buf.GetMPIntBits();  					G_array = buf.GetMPIntBits();  					Q_array = buf.GetMPIntBits();  					pub_array = buf.GetMPIntBits();  					prv_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				P_array = new byte[length];  				System.Array.Copy(plain' index' P_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				Q_array = new byte[length];  				System.Array.Copy(plain' index' Q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				G_array = new byte[length];  				System.Array.Copy(plain' index' G_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				//e.printStackTrace();  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (P_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					P_array = buf.GetMPIntBits();  					G_array = buf.GetMPIntBits();  					Q_array = buf.GetMPIntBits();  					pub_array = buf.GetMPIntBits();  					prv_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				P_array = new byte[length];  				System.Array.Copy(plain' index' P_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				Q_array = new byte[length];  				System.Array.Copy(plain' index' Q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				G_array = new byte[length];  				System.Array.Copy(plain' index' G_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				//e.printStackTrace();  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (P_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					P_array = buf.GetMPIntBits();  					G_array = buf.GetMPIntBits();  					Q_array = buf.GetMPIntBits();  					pub_array = buf.GetMPIntBits();  					prv_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				P_array = new byte[length];  				System.Array.Copy(plain' index' P_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				Q_array = new byte[length];  				System.Array.Copy(plain' index' Q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				G_array = new byte[length];  				System.Array.Copy(plain' index' G_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				//e.printStackTrace();  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (P_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					P_array = buf.GetMPIntBits();  					G_array = buf.GetMPIntBits();  					Q_array = buf.GetMPIntBits();  					pub_array = buf.GetMPIntBits();  					prv_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				P_array = new byte[length];  				System.Array.Copy(plain' index' P_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				Q_array = new byte[length];  				System.Array.Copy(plain' index' Q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				G_array = new byte[length];  				System.Array.Copy(plain' index' G_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				//e.printStackTrace();  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,Decrypt_dss,The following statement contains a magic number: try  			{  				byte[] plain;  				if (encrypted)  				{  					if (keytype == OPENSSH)  					{  						cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  						plain = new byte[encoded_data.Length];  						cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  					}  					else  					{  						if (keytype == FSECURE)  						{  							for (int i = 0; i < iv.Length; i++)  							{  								iv[i] = 0;  							}  							cipher.Init(NSch.Cipher.DECRYPT_MODE' key' iv);  							plain = new byte[encoded_data.Length];  							cipher.Update(encoded_data' 0' encoded_data.Length' plain' 0);  						}  						else  						{  							return false;  						}  					}  				}  				else  				{  					if (P_array != null)  					{  						return true;  					}  					plain = encoded_data;  				}  				if (keytype == FSECURE)  				{  					// FSecure     					Buffer buf = new Buffer(plain);  					int foo = buf.GetInt();  					if (plain.Length != foo + 4)  					{  						return false;  					}  					P_array = buf.GetMPIntBits();  					G_array = buf.GetMPIntBits();  					Q_array = buf.GetMPIntBits();  					pub_array = buf.GetMPIntBits();  					prv_array = buf.GetMPIntBits();  					return true;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				P_array = new byte[length];  				System.Array.Copy(plain' index' P_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				Q_array = new byte[length];  				System.Array.Copy(plain' index' Q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				G_array = new byte[length];  				System.Array.Copy(plain' index' G_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				//e.printStackTrace();  				return false;  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,A2b,The following statement contains a magic number: if ('a' <= c && ((sbyte)c) <= 'z')  			{  				return unchecked((byte)(c - 'a' + 10));  			}
Magic Number,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,A2b,The following statement contains a magic number: return unchecked((byte)(c - 'A' + 10));
Magic Number,NSch,JSch,C:\repos\mono_ngit\NSch\NSch\JSch.cs,GetSession,The following statement contains a magic number: return GetSession(username' host' 22);
Magic Number,NSch,KeyExchange,C:\repos\mono_ngit\NSch\NSch\KeyExchange.cs,Guess,The following statement contains a magic number: sb.SetOffSet(17);
Magic Number,NSch,KeyExchange,C:\repos\mono_ngit\NSch\NSch\KeyExchange.cs,Guess,The following statement contains a magic number: cb.SetOffSet(17);
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,GenKeyPair,The following statement contains a magic number: return GenKeyPair(jsch' type' 1024);
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,WritePrivateKey,The following statement contains a magic number: try  			{  				@out.Write(GetBegin());  				@out.Write(cr);  				if (passphrase != null)  				{  					@out.Write(header[0]);  					@out.Write(cr);  					@out.Write(header[1]);  					for (int i = 0; i < iv.Length; i++)  					{  						@out.Write(B2a(unchecked((byte)((iv[i] >> 4) & unchecked((int)(0x0f))))));  						@out.Write(B2a(unchecked((byte)(iv[i] & unchecked((int)(0x0f))))));  					}  					@out.Write(cr);  					@out.Write(cr);  				}  				int i_1 = 0;  				while (i_1 < prv.Length)  				{  					if (i_1 + 64 < prv.Length)  					{  						@out.Write(prv' i_1' 64);  						@out.Write(cr);  						i_1 += 64;  						continue;  					}  					@out.Write(prv' i_1' prv.Length - i_1);  					@out.Write(cr);  					break;  				}  				@out.Write(GetEnd());  				@out.Write(cr);  			}  			catch (Exception)  			{  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,WritePrivateKey,The following statement contains a magic number: try  			{  				@out.Write(GetBegin());  				@out.Write(cr);  				if (passphrase != null)  				{  					@out.Write(header[0]);  					@out.Write(cr);  					@out.Write(header[1]);  					for (int i = 0; i < iv.Length; i++)  					{  						@out.Write(B2a(unchecked((byte)((iv[i] >> 4) & unchecked((int)(0x0f))))));  						@out.Write(B2a(unchecked((byte)(iv[i] & unchecked((int)(0x0f))))));  					}  					@out.Write(cr);  					@out.Write(cr);  				}  				int i_1 = 0;  				while (i_1 < prv.Length)  				{  					if (i_1 + 64 < prv.Length)  					{  						@out.Write(prv' i_1' 64);  						@out.Write(cr);  						i_1 += 64;  						continue;  					}  					@out.Write(prv' i_1' prv.Length - i_1);  					@out.Write(cr);  					break;  				}  				@out.Write(GetEnd());  				@out.Write(cr);  			}  			catch (Exception)  			{  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,WritePrivateKey,The following statement contains a magic number: try  			{  				@out.Write(GetBegin());  				@out.Write(cr);  				if (passphrase != null)  				{  					@out.Write(header[0]);  					@out.Write(cr);  					@out.Write(header[1]);  					for (int i = 0; i < iv.Length; i++)  					{  						@out.Write(B2a(unchecked((byte)((iv[i] >> 4) & unchecked((int)(0x0f))))));  						@out.Write(B2a(unchecked((byte)(iv[i] & unchecked((int)(0x0f))))));  					}  					@out.Write(cr);  					@out.Write(cr);  				}  				int i_1 = 0;  				while (i_1 < prv.Length)  				{  					if (i_1 + 64 < prv.Length)  					{  						@out.Write(prv' i_1' 64);  						@out.Write(cr);  						i_1 += 64;  						continue;  					}  					@out.Write(prv' i_1' prv.Length - i_1);  					@out.Write(cr);  					break;  				}  				@out.Write(GetEnd());  				@out.Write(cr);  			}  			catch (Exception)  			{  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,WritePrivateKey,The following statement contains a magic number: try  			{  				@out.Write(GetBegin());  				@out.Write(cr);  				if (passphrase != null)  				{  					@out.Write(header[0]);  					@out.Write(cr);  					@out.Write(header[1]);  					for (int i = 0; i < iv.Length; i++)  					{  						@out.Write(B2a(unchecked((byte)((iv[i] >> 4) & unchecked((int)(0x0f))))));  						@out.Write(B2a(unchecked((byte)(iv[i] & unchecked((int)(0x0f))))));  					}  					@out.Write(cr);  					@out.Write(cr);  				}  				int i_1 = 0;  				while (i_1 < prv.Length)  				{  					if (i_1 + 64 < prv.Length)  					{  						@out.Write(prv' i_1' 64);  						@out.Write(cr);  						i_1 += 64;  						continue;  					}  					@out.Write(prv' i_1' prv.Length - i_1);  					@out.Write(cr);  					break;  				}  				@out.Write(GetEnd());  				@out.Write(cr);  			}  			catch (Exception)  			{  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,WriteSECSHPublicKey,The following statement contains a magic number: try  			{  				@out.Write(Util.Str2byte("---- BEGIN SSH2 PUBLIC KEY ----"));  				@out.Write(cr);  				@out.Write(Util.Str2byte("Comment: \"" + comment + "\""));  				@out.Write(cr);  				int index = 0;  				while (index < pub.Length)  				{  					int len = 70;  					if ((pub.Length - index) < len)  					{  						len = pub.Length - index;  					}  					@out.Write(pub' index' len);  					@out.Write(cr);  					index += len;  				}  				@out.Write(Util.Str2byte("---- END SSH2 PUBLIC KEY ----"));  				@out.Write(cr);  			}  			catch (Exception)  			{  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,CountLength,The following statement contains a magic number: while (len > 0)  			{  				len = (int)(((uint)len) >> 8);  				i++;  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,WriteLength,The following statement contains a magic number: while (i > 0)  			{  				data[index + i - 1] = unchecked((byte)(len & unchecked((int)(0xff))));  				len = (int)(((uint)len) >> 8);  				i--;  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,GenKey,The following statement contains a magic number: lock (this)  			{  				if (cipher == null)  				{  					cipher = GenCipher();  				}  				if (hash == null)  				{  					hash = GenHash();  				}  				byte[] key = new byte[cipher.GetBlockSize()];  				int hsize = hash.GetBlockSize();  				byte[] hn = new byte[key.Length / hsize * hsize + (key.Length % hsize == 0 ? 0 :   					hsize)];  				try  				{  					byte[] tmp = null;  					if (vendor == VENDOR_OPENSSH)  					{  						for (int index = 0; index + hsize <= hn.Length; )  						{  							if (tmp != null)  							{  								hash.Update(tmp' 0' tmp.Length);  							}  							hash.Update(passphrase' 0' passphrase.Length);  							hash.Update(iv' 0' iv.Length > 8 ? 8 : iv.Length);  							tmp = hash.Digest();  							System.Array.Copy(tmp' 0' hn' index' tmp.Length);  							index += tmp.Length;  						}  						System.Array.Copy(hn' 0' key' 0' key.Length);  					}  					else  					{  						if (vendor == VENDOR_FSECURE)  						{  							for (int index = 0; index + hsize <= hn.Length; )  							{  								if (tmp != null)  								{  									hash.Update(tmp' 0' tmp.Length);  								}  								hash.Update(passphrase' 0' passphrase.Length);  								tmp = hash.Digest();  								System.Array.Copy(tmp' 0' hn' index' tmp.Length);  								index += tmp.Length;  							}  							System.Array.Copy(hn' 0' key' 0' key.Length);  						}  					}  				}  				catch (Exception e)  				{  					System.Console.Error.WriteLine(e);  				}  				return key;  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,GenKey,The following statement contains a magic number: lock (this)  			{  				if (cipher == null)  				{  					cipher = GenCipher();  				}  				if (hash == null)  				{  					hash = GenHash();  				}  				byte[] key = new byte[cipher.GetBlockSize()];  				int hsize = hash.GetBlockSize();  				byte[] hn = new byte[key.Length / hsize * hsize + (key.Length % hsize == 0 ? 0 :   					hsize)];  				try  				{  					byte[] tmp = null;  					if (vendor == VENDOR_OPENSSH)  					{  						for (int index = 0; index + hsize <= hn.Length; )  						{  							if (tmp != null)  							{  								hash.Update(tmp' 0' tmp.Length);  							}  							hash.Update(passphrase' 0' passphrase.Length);  							hash.Update(iv' 0' iv.Length > 8 ? 8 : iv.Length);  							tmp = hash.Digest();  							System.Array.Copy(tmp' 0' hn' index' tmp.Length);  							index += tmp.Length;  						}  						System.Array.Copy(hn' 0' key' 0' key.Length);  					}  					else  					{  						if (vendor == VENDOR_FSECURE)  						{  							for (int index = 0; index + hsize <= hn.Length; )  							{  								if (tmp != null)  								{  									hash.Update(tmp' 0' tmp.Length);  								}  								hash.Update(passphrase' 0' passphrase.Length);  								tmp = hash.Digest();  								System.Array.Copy(tmp' 0' hn' index' tmp.Length);  								index += tmp.Length;  							}  							System.Array.Copy(hn' 0' key' 0' key.Length);  						}  					}  				}  				catch (Exception e)  				{  					System.Console.Error.WriteLine(e);  				}  				return key;  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: byte[] iv = new byte[8];
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,Load,The following statement contains a magic number: try  			{  				FilePath file = new FilePath(prvkey);  				FileInputStream fis = new FileInputStream(prvkey);  				byte[] buf = new byte[(int)(file.Length())];  				int len = 0;  				while (true)  				{  					int i = fis.Read(buf' len' buf.Length - len);  					if (i <= 0)  					{  						break;  					}  					len += i;  				}  				fis.Close();  				int i_1 = 0;  				while (i_1 < len)  				{  					if (buf[i_1] == '-' && i_1 + 4 < len && buf[i_1 + 1] == '-' && buf[i_1 + 2] == '-'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '-')  					{  						break;  					}  					i_1++;  				}  				while (i_1 < len)  				{  					if (buf[i_1] == 'B' && i_1 + 3 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'G'  						 && buf[i_1 + 3] == 'I')  					{  						i_1 += 6;  						if (buf[i_1] == 'D' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  						{  							type = DSA;  						}  						else  						{  							if (buf[i_1] == 'R' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'A')  							{  								type = RSA;  							}  							else  							{  								if (buf[i_1] == 'S' && buf[i_1 + 1] == 'S' && buf[i_1 + 2] == 'H')  								{  									// FSecure  									type = UNKNOWN;  									vendor = VENDOR_FSECURE;  								}  								else  								{  									throw new JSchException("invalid privatekey: " + prvkey);  								}  							}  						}  						i_1 += 3;  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '2' && buf[i_1 + 5] == '5' && buf[i_1  						 + 6] == '6' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes256-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes256-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes256-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '9' && buf[i_1  						 + 6] == '2' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes192-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes192-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes192-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'A' && i_1 + 7 < len && buf[i_1 + 1] == 'E' && buf[i_1 + 2] == 'S'  						 && buf[i_1 + 3] == '-' && buf[i_1 + 4] == '1' && buf[i_1 + 5] == '2' && buf[i_1  						 + 6] == '8' && buf[i_1 + 7] == '-')  					{  						i_1 += 8;  						if (Session.CheckCipher((string)JSch.GetConfig("aes128-cbc")))  						{  							Type c = Sharpen.Runtime.GetType((string)JSch.GetConfig("aes128-cbc"));  							cipher = (NSch.Cipher)(System.Activator.CreateInstance(c));  							// key=new byte[cipher.getBlockSize()];  							iv = new byte[cipher.GetIVSize()];  						}  						else  						{  							throw new JSchException("privatekey: aes128-cbc is not available " + prvkey);  						}  						continue;  					}  					if (buf[i_1] == 'C' && i_1 + 3 < len && buf[i_1 + 1] == 'B' && buf[i_1 + 2] == 'C'  						 && buf[i_1 + 3] == ''')  					{  						i_1 += 4;  						for (int ii = 0; ii < iv.Length; ii++)  						{  							iv[ii] = unchecked((byte)(((A2b(buf[i_1++]) << 4) & unchecked((int)(0xf0))) + (A2b  								(buf[i_1++]) & unchecked((int)(0xf)))));  						}  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0d)) && i_1 + 1 < buf.Length && buf[i_1 + 1] ==  						 unchecked((int)(0x0a)))  					{  						i_1++;  						continue;  					}  					if (buf[i_1] == unchecked((int)(0x0a)) && i_1 + 1 < buf.Length)  					{  						if (buf[i_1 + 1] == unchecked((int)(0x0a)))  						{  							i_1 += 2;  							break;  						}  						if (buf[i_1 + 1] == unchecked((int)(0x0d)) && i_1 + 2 < buf.Length && buf[i_1 + 2  							] == unchecked((int)(0x0a)))  						{  							i_1 += 3;  							break;  						}  						bool inheader = false;  						for (int j = i_1 + 1; j < buf.Length; j++)  						{  							if (buf[j] == unchecked((int)(0x0a)))  							{  								break;  							}  							//if(buf[j]==0x0d) break;  							if (buf[j] == ':')  							{  								inheader = true;  								break;  							}  						}  						if (!inheader)  						{  							i_1++;  							encrypted = false;  							// no passphrase  							break;  						}  					}  					i_1++;  				}  				if (type == ERROR)  				{  					throw new JSchException("invalid privatekey: " + prvkey);  				}  				int start = i_1;  				while (i_1 < len)  				{  					if (buf[i_1] == unchecked((int)(0x0a)))  					{  						bool xd = (buf[i_1 - 1] == unchecked((int)(0x0d)));  						System.Array.Copy(buf' i_1 + 1' buf' i_1 - (xd ? 1 : 0)' len - i_1 - 1 - (xd ? 1 :   							0));  						if (xd)  						{  							len--;  						}  						len--;  						continue;  					}  					if (buf[i_1] == '-')  					{  						break;  					}  					i_1++;  				}  				data = Util.FromBase64(buf' start' i_1 - start);  				if (data.Length > 4 && data[0] == unchecked((byte)unchecked((int)(0x3f))) && data  					[1] == unchecked((byte)unchecked((int)(0x6f))) && data[2] == unchecked((byte)unchecked(  					(int)(0xf9))) && data[3] == unchecked((byte)unchecked((int)(0xeb))))  				{  					// FSecure  					Buffer _buf = new Buffer(data);  					_buf.GetInt();  					// 0x3f6ff9be  					_buf.GetInt();  					byte[] _type = _buf.GetString();  					//System.err.println("type: "+new String(_type));   					string _cipher = Util.Byte2str(_buf.GetString());  					//System.err.println("cipher: "+_cipher);   					if (_cipher.Equals("3des-cbc"))  					{  						_buf.GetInt();  						byte[] foo = new byte[data.Length - _buf.GetOffSet()];  						_buf.GetByte(foo);  						data = foo;  						encrypted = true;  						throw new JSchException("unknown privatekey format: " + prvkey);  					}  					else  					{  						if (_cipher.Equals("none"))  						{  							_buf.GetInt();  							_buf.GetInt();  							encrypted = false;  							byte[] foo = new byte[data.Length - _buf.GetOffSet()];  							_buf.GetByte(foo);  							data = foo;  						}  					}  				}  				if (pubkey != null)  				{  					try  					{  						file = new FilePath(pubkey);  						fis = new FileInputStream(pubkey);  						buf = new byte[(int)(file.Length())];  						len = 0;  						while (true)  						{  							i_1 = fis.Read(buf' len' buf.Length - len);  							if (i_1 <= 0)  							{  								break;  							}  							len += i_1;  						}  						fis.Close();  						if (buf.Length > 4 && buf[0] == '-' && buf[1] == '-' && buf[2] == '-' && buf[3] ==  							 '-')  						{  							// FSecure's public key  							bool valid = true;  							i_1 = 0;  							do  							{  								i_1++;  							}  							while (buf.Length > i_1 && buf[i_1] != unchecked((int)(0x0a)));  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							while (valid)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									bool inheader = false;  									for (int j = i_1 + 1; j < buf.Length; j++)  									{  										if (buf[j] == unchecked((int)(0x0a)))  										{  											break;  										}  										if (buf[j] == ':')  										{  											inheader = true;  											break;  										}  									}  									if (!inheader)  									{  										i_1++;  										break;  									}  								}  								i_1++;  							}  							if (buf.Length <= i_1)  							{  								valid = false;  							}  							start = i_1;  							while (valid && i_1 < len)  							{  								if (buf[i_1] == unchecked((int)(0x0a)))  								{  									System.Array.Copy(buf' i_1 + 1' buf' i_1' len - i_1 - 1);  									len--;  									continue;  								}  								if (buf[i_1] == '-')  								{  									break;  								}  								i_1++;  							}  							if (valid)  							{  								publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								if (type == UNKNOWN)  								{  									if (publickeyblob[8] == 'd')  									{  										type = DSA;  									}  									else  									{  										if (publickeyblob[8] == 'r')  										{  											type = RSA;  										}  									}  								}  							}  						}  						else  						{  							if (buf[0] == 's' && buf[1] == 's' && buf[2] == 'h' && buf[3] == '-')  							{  								i_1 = 0;  								while (i_1 < len)  								{  									if (buf[i_1] == ' ')  									{  										break;  									}  									i_1++;  								}  								i_1++;  								if (i_1 < len)  								{  									start = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == ' ')  										{  											break;  										}  										i_1++;  									}  									publickeyblob = Util.FromBase64(buf' start' i_1 - start);  								}  								if (i_1++ < len)  								{  									int s = i_1;  									while (i_1 < len)  									{  										if (buf[i_1] == '\n')  										{  											break;  										}  										i_1++;  									}  									if (i_1 < len)  									{  										publicKeyComment = Sharpen.Runtime.GetStringForBytes(buf' s' i_1 - s);  									}  								}  							}  						}  					}  					catch (Exception)  					{  					}  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,A2b,The following statement contains a magic number: return unchecked((byte)(c - 'a' + 10));
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,B2a,The following statement contains a magic number: if (0 <= c && ((sbyte)c) <= 9)  			{  				return unchecked((byte)(c + '0'));  			}
Magic Number,NSch,KeyPair,C:\repos\mono_ngit\NSch\NSch\KeyPair.cs,B2a,The following statement contains a magic number: return unchecked((byte)(c - 10 + 'A'));
Magic Number,NSch,KeyPairDSA,C:\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,The following statement contains a magic number: try  			{  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[0] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						buf.GetInt();  						P_array = buf.GetMPIntBits();  						G_array = buf.GetMPIntBits();  						Q_array = buf.GetMPIntBits();  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				P_array = new byte[length];  				System.Array.Copy(plain' index' P_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				Q_array = new byte[length];  				System.Array.Copy(plain' index' Q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				G_array = new byte[length];  				System.Array.Copy(plain' index' G_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				//e.printStackTrace();  				return false;  			}
Magic Number,NSch,KeyPairDSA,C:\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,The following statement contains a magic number: try  			{  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[0] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						buf.GetInt();  						P_array = buf.GetMPIntBits();  						G_array = buf.GetMPIntBits();  						Q_array = buf.GetMPIntBits();  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				P_array = new byte[length];  				System.Array.Copy(plain' index' P_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				Q_array = new byte[length];  				System.Array.Copy(plain' index' Q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				G_array = new byte[length];  				System.Array.Copy(plain' index' G_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				//e.printStackTrace();  				return false;  			}
Magic Number,NSch,KeyPairDSA,C:\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,The following statement contains a magic number: try  			{  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[0] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						buf.GetInt();  						P_array = buf.GetMPIntBits();  						G_array = buf.GetMPIntBits();  						Q_array = buf.GetMPIntBits();  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				P_array = new byte[length];  				System.Array.Copy(plain' index' P_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				Q_array = new byte[length];  				System.Array.Copy(plain' index' Q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				G_array = new byte[length];  				System.Array.Copy(plain' index' G_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				//e.printStackTrace();  				return false;  			}
Magic Number,NSch,KeyPairDSA,C:\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,The following statement contains a magic number: try  			{  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[0] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						buf.GetInt();  						P_array = buf.GetMPIntBits();  						G_array = buf.GetMPIntBits();  						Q_array = buf.GetMPIntBits();  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				P_array = new byte[length];  				System.Array.Copy(plain' index' P_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				Q_array = new byte[length];  				System.Array.Copy(plain' index' Q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				G_array = new byte[length];  				System.Array.Copy(plain' index' G_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				//e.printStackTrace();  				return false;  			}
Magic Number,NSch,KeyPairDSA,C:\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,The following statement contains a magic number: try  			{  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[0] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						buf.GetInt();  						P_array = buf.GetMPIntBits();  						G_array = buf.GetMPIntBits();  						Q_array = buf.GetMPIntBits();  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				P_array = new byte[length];  				System.Array.Copy(plain' index' P_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				Q_array = new byte[length];  				System.Array.Copy(plain' index' Q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				G_array = new byte[length];  				System.Array.Copy(plain' index' G_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				//e.printStackTrace();  				return false;  			}
Magic Number,NSch,KeyPairDSA,C:\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,The following statement contains a magic number: try  			{  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[0] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						buf.GetInt();  						P_array = buf.GetMPIntBits();  						G_array = buf.GetMPIntBits();  						Q_array = buf.GetMPIntBits();  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				P_array = new byte[length];  				System.Array.Copy(plain' index' P_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				Q_array = new byte[length];  				System.Array.Copy(plain' index' Q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				G_array = new byte[length];  				System.Array.Copy(plain' index' G_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				//e.printStackTrace();  				return false;  			}
Magic Number,NSch,KeyPairDSA,C:\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,Parse,The following statement contains a magic number: try  			{  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[0] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						buf.GetInt();  						P_array = buf.GetMPIntBits();  						G_array = buf.GetMPIntBits();  						Q_array = buf.GetMPIntBits();  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				int index = 0;  				int length = 0;  				if (plain[index] != unchecked((int)(0x30)))  				{  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				P_array = new byte[length];  				System.Array.Copy(plain' index' P_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				Q_array = new byte[length];  				System.Array.Copy(plain' index' Q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				G_array = new byte[length];  				System.Array.Copy(plain' index' G_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				//e.printStackTrace();  				return false;  			}
Magic Number,NSch,KeyPairDSA,C:\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,GetPublicKeyBlob,The following statement contains a magic number: Buffer buf = new Buffer(sshdss.Length + 4 + P_array.Length + 4 + Q_array.Length +  				 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,KeyPairDSA,C:\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,GetPublicKeyBlob,The following statement contains a magic number: Buffer buf = new Buffer(sshdss.Length + 4 + P_array.Length + 4 + Q_array.Length +  				 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,KeyPairDSA,C:\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,GetPublicKeyBlob,The following statement contains a magic number: Buffer buf = new Buffer(sshdss.Length + 4 + P_array.Length + 4 + Q_array.Length +  				 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,KeyPairDSA,C:\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,GetPublicKeyBlob,The following statement contains a magic number: Buffer buf = new Buffer(sshdss.Length + 4 + P_array.Length + 4 + Q_array.Length +  				 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,KeyPairDSA,C:\repos\mono_ngit\NSch\NSch\KeyPairDSA.cs,GetPublicKeyBlob,The following statement contains a magic number: Buffer buf = new Buffer(sshdss.Length + 4 + P_array.Length + 4 + Q_array.Length +  				 4 + G_array.Length + 4 + pub_array.Length + 4);
Magic Number,NSch,KeyPairRSA,C:\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: try  			{  				int index = 0;  				int length = 0;  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[index] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						n_array = buf.GetMPIntBits();  						byte[] u_array = buf.GetMPIntBits();  						p_array = buf.GetMPIntBits();  						q_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				ep_array = new byte[length];  				System.Array.Copy(plain' index' ep_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				eq_array = new byte[length];  				System.Array.Copy(plain' index' eq_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				c_array = new byte[length];  				System.Array.Copy(plain' index' c_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,KeyPairRSA,C:\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: try  			{  				int index = 0;  				int length = 0;  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[index] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						n_array = buf.GetMPIntBits();  						byte[] u_array = buf.GetMPIntBits();  						p_array = buf.GetMPIntBits();  						q_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				ep_array = new byte[length];  				System.Array.Copy(plain' index' ep_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				eq_array = new byte[length];  				System.Array.Copy(plain' index' eq_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				c_array = new byte[length];  				System.Array.Copy(plain' index' c_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,KeyPairRSA,C:\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: try  			{  				int index = 0;  				int length = 0;  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[index] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						n_array = buf.GetMPIntBits();  						byte[] u_array = buf.GetMPIntBits();  						p_array = buf.GetMPIntBits();  						q_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				ep_array = new byte[length];  				System.Array.Copy(plain' index' ep_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				eq_array = new byte[length];  				System.Array.Copy(plain' index' eq_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				c_array = new byte[length];  				System.Array.Copy(plain' index' c_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,KeyPairRSA,C:\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: try  			{  				int index = 0;  				int length = 0;  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[index] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						n_array = buf.GetMPIntBits();  						byte[] u_array = buf.GetMPIntBits();  						p_array = buf.GetMPIntBits();  						q_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				ep_array = new byte[length];  				System.Array.Copy(plain' index' ep_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				eq_array = new byte[length];  				System.Array.Copy(plain' index' eq_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				c_array = new byte[length];  				System.Array.Copy(plain' index' c_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,KeyPairRSA,C:\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: try  			{  				int index = 0;  				int length = 0;  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[index] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						n_array = buf.GetMPIntBits();  						byte[] u_array = buf.GetMPIntBits();  						p_array = buf.GetMPIntBits();  						q_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				ep_array = new byte[length];  				System.Array.Copy(plain' index' ep_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				eq_array = new byte[length];  				System.Array.Copy(plain' index' eq_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				c_array = new byte[length];  				System.Array.Copy(plain' index' c_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,KeyPairRSA,C:\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: try  			{  				int index = 0;  				int length = 0;  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[index] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						n_array = buf.GetMPIntBits();  						byte[] u_array = buf.GetMPIntBits();  						p_array = buf.GetMPIntBits();  						q_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				ep_array = new byte[length];  				System.Array.Copy(plain' index' ep_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				eq_array = new byte[length];  				System.Array.Copy(plain' index' eq_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				c_array = new byte[length];  				System.Array.Copy(plain' index' c_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,KeyPairRSA,C:\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: try  			{  				int index = 0;  				int length = 0;  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[index] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						n_array = buf.GetMPIntBits();  						byte[] u_array = buf.GetMPIntBits();  						p_array = buf.GetMPIntBits();  						q_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				ep_array = new byte[length];  				System.Array.Copy(plain' index' ep_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				eq_array = new byte[length];  				System.Array.Copy(plain' index' eq_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				c_array = new byte[length];  				System.Array.Copy(plain' index' c_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,KeyPairRSA,C:\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: try  			{  				int index = 0;  				int length = 0;  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[index] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						n_array = buf.GetMPIntBits();  						byte[] u_array = buf.GetMPIntBits();  						p_array = buf.GetMPIntBits();  						q_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				ep_array = new byte[length];  				System.Array.Copy(plain' index' ep_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				eq_array = new byte[length];  				System.Array.Copy(plain' index' eq_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				c_array = new byte[length];  				System.Array.Copy(plain' index' c_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,KeyPairRSA,C:\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: try  			{  				int index = 0;  				int length = 0;  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[index] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						n_array = buf.GetMPIntBits();  						byte[] u_array = buf.GetMPIntBits();  						p_array = buf.GetMPIntBits();  						q_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				ep_array = new byte[length];  				System.Array.Copy(plain' index' ep_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				eq_array = new byte[length];  				System.Array.Copy(plain' index' eq_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				c_array = new byte[length];  				System.Array.Copy(plain' index' c_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,KeyPairRSA,C:\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,Parse,The following statement contains a magic number: try  			{  				int index = 0;  				int length = 0;  				if (vendor == VENDOR_FSECURE)  				{  					if (plain[index] != unchecked((int)(0x30)))  					{  						// FSecure  						Buffer buf = new Buffer(plain);  						pub_array = buf.GetMPIntBits();  						prv_array = buf.GetMPIntBits();  						n_array = buf.GetMPIntBits();  						byte[] u_array = buf.GetMPIntBits();  						p_array = buf.GetMPIntBits();  						q_array = buf.GetMPIntBits();  						return true;  					}  					return false;  				}  				index++;  				// SEQUENCE  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				if (plain[index] != unchecked((int)(0x02)))  				{  					return false;  				}  				index++;  				// INTEGER  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				index += length;  				//System.err.println("int: len="+length);  				//System.err.print(Integer.toHexString(plain[index-1]&0xff)+":");  				//System.err.println("");  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				n_array = new byte[length];  				System.Array.Copy(plain' index' n_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				pub_array = new byte[length];  				System.Array.Copy(plain' index' pub_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				prv_array = new byte[length];  				System.Array.Copy(plain' index' prv_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				p_array = new byte[length];  				System.Array.Copy(plain' index' p_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				q_array = new byte[length];  				System.Array.Copy(plain' index' q_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				ep_array = new byte[length];  				System.Array.Copy(plain' index' ep_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				eq_array = new byte[length];  				System.Array.Copy(plain' index' eq_array' 0' length);  				index += length;  				index++;  				length = plain[index++] & unchecked((int)(0xff));  				if ((length & unchecked((int)(0x80))) != 0)  				{  					int foo = length & unchecked((int)(0x7f));  					length = 0;  					while (foo-- > 0)  					{  						length = (length << 8) + (plain[index++] & unchecked((int)(0xff)));  					}  				}  				c_array = new byte[length];  				System.Array.Copy(plain' index' c_array' 0' length);  				index += length;  			}  			catch (Exception)  			{  				//System.err.println(e);  				return false;  			}
Magic Number,NSch,KeyPairRSA,C:\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,GetPublicKeyBlob,The following statement contains a magic number: Buffer buf = new Buffer(sshrsa.Length + 4 + pub_array.Length + 4 + n_array.Length  				 + 4);
Magic Number,NSch,KeyPairRSA,C:\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,GetPublicKeyBlob,The following statement contains a magic number: Buffer buf = new Buffer(sshrsa.Length + 4 + pub_array.Length + 4 + n_array.Length  				 + 4);
Magic Number,NSch,KeyPairRSA,C:\repos\mono_ngit\NSch\NSch\KeyPairRSA.cs,GetPublicKeyBlob,The following statement contains a magic number: Buffer buf = new Buffer(sshrsa.Length + 4 + pub_array.Length + 4 + n_array.Length  				 + 4);
Magic Number,NSch,KnownHosts,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,SetKnownHosts,The following statement contains a magic number: try  			{  				InputStream fis = foo;  				string host;  				string key = null;  				int type;  				byte[] buf = new byte[1024];  				int bufl = 0;  				while (true)  				{  					bufl = 0;  					while (true)  					{  						j = fis.Read();  						if (j == -1)  						{  							if (bufl == 0)  							{  								goto loop_break;  							}  							else  							{  								break;  							}  						}  						if (j == unchecked((int)(0x0d)))  						{  							continue;  						}  						if (j == unchecked((int)(0x0a)))  						{  							break;  						}  						if (buf.Length <= bufl)  						{  							if (bufl > 1024 * 10)  							{  								break;  							}  							// too long...  							byte[] newbuf = new byte[buf.Length * 2];  							System.Array.Copy(buf' 0' newbuf' 0' buf.Length);  							buf = newbuf;  						}  						buf[bufl++] = unchecked((byte)j);  					}  					j = 0;  					while (j < bufl)  					{  						i = buf[j];  						if (i == ' ' || i == '\t')  						{  							j++;  							continue;  						}  						if (i == '#')  						{  							AddInvalidLine(Util.Byte2str(buf' 0' bufl));  							goto loop_continue;  						}  						break;  					}  					if (j >= bufl)  					{  						AddInvalidLine(Util.Byte2str(buf' 0' bufl));  						goto loop_continue;  					}  					sb.Length = 0;  					while (j < bufl)  					{  						i = buf[j++];  						if (i == unchecked((int)(0x20)) || i == '\t')  						{  							break;  						}  						sb.Append((char)i);  					}  					host = sb.ToString();  					if (j >= bufl || host.Length == 0)  					{  						AddInvalidLine(Util.Byte2str(buf' 0' bufl));  						goto loop_continue;  					}  					sb.Length = 0;  					type = -1;  					while (j < bufl)  					{  						i = buf[j++];  						if (i == unchecked((int)(0x20)) || i == '\t')  						{  							break;  						}  						sb.Append((char)i);  					}  					if (sb.ToString().Equals("ssh-dss"))  					{  						type = HostKey.SSHDSS;  					}  					else  					{  						if (sb.ToString().Equals("ssh-rsa"))  						{  							type = HostKey.SSHRSA;  						}  						else  						{  							j = bufl;  						}  					}  					if (j >= bufl)  					{  						AddInvalidLine(Util.Byte2str(buf' 0' bufl));  						goto loop_continue;  					}  					sb.Length = 0;  					while (j < bufl)  					{  						i = buf[j++];  						if (i == unchecked((int)(0x0d)))  						{  							continue;  						}  						if (i == unchecked((int)(0x0a)))  						{  							break;  						}  						sb.Append((char)i);  					}  					key = sb.ToString();  					if (key.Length == 0)  					{  						AddInvalidLine(Util.Byte2str(buf' 0' bufl));  						goto loop_continue;  					}  					//System.err.println(host);  					//System.err.println("|"+key+"|");  					HostKey hk = null;  					hk = new KnownHosts.HashedHostKey(this' host' type' Util.FromBase64(Util.Str2byte  						(key)' 0' key.Length));  					pool.Add(hk);  loop_continue: ;  				}  loop_break: ;  				fis.Close();  				if (error)  				{  					throw new JSchException("KnownHosts: invalid format");  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KnownHosts,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,SetKnownHosts,The following statement contains a magic number: try  			{  				InputStream fis = foo;  				string host;  				string key = null;  				int type;  				byte[] buf = new byte[1024];  				int bufl = 0;  				while (true)  				{  					bufl = 0;  					while (true)  					{  						j = fis.Read();  						if (j == -1)  						{  							if (bufl == 0)  							{  								goto loop_break;  							}  							else  							{  								break;  							}  						}  						if (j == unchecked((int)(0x0d)))  						{  							continue;  						}  						if (j == unchecked((int)(0x0a)))  						{  							break;  						}  						if (buf.Length <= bufl)  						{  							if (bufl > 1024 * 10)  							{  								break;  							}  							// too long...  							byte[] newbuf = new byte[buf.Length * 2];  							System.Array.Copy(buf' 0' newbuf' 0' buf.Length);  							buf = newbuf;  						}  						buf[bufl++] = unchecked((byte)j);  					}  					j = 0;  					while (j < bufl)  					{  						i = buf[j];  						if (i == ' ' || i == '\t')  						{  							j++;  							continue;  						}  						if (i == '#')  						{  							AddInvalidLine(Util.Byte2str(buf' 0' bufl));  							goto loop_continue;  						}  						break;  					}  					if (j >= bufl)  					{  						AddInvalidLine(Util.Byte2str(buf' 0' bufl));  						goto loop_continue;  					}  					sb.Length = 0;  					while (j < bufl)  					{  						i = buf[j++];  						if (i == unchecked((int)(0x20)) || i == '\t')  						{  							break;  						}  						sb.Append((char)i);  					}  					host = sb.ToString();  					if (j >= bufl || host.Length == 0)  					{  						AddInvalidLine(Util.Byte2str(buf' 0' bufl));  						goto loop_continue;  					}  					sb.Length = 0;  					type = -1;  					while (j < bufl)  					{  						i = buf[j++];  						if (i == unchecked((int)(0x20)) || i == '\t')  						{  							break;  						}  						sb.Append((char)i);  					}  					if (sb.ToString().Equals("ssh-dss"))  					{  						type = HostKey.SSHDSS;  					}  					else  					{  						if (sb.ToString().Equals("ssh-rsa"))  						{  							type = HostKey.SSHRSA;  						}  						else  						{  							j = bufl;  						}  					}  					if (j >= bufl)  					{  						AddInvalidLine(Util.Byte2str(buf' 0' bufl));  						goto loop_continue;  					}  					sb.Length = 0;  					while (j < bufl)  					{  						i = buf[j++];  						if (i == unchecked((int)(0x0d)))  						{  							continue;  						}  						if (i == unchecked((int)(0x0a)))  						{  							break;  						}  						sb.Append((char)i);  					}  					key = sb.ToString();  					if (key.Length == 0)  					{  						AddInvalidLine(Util.Byte2str(buf' 0' bufl));  						goto loop_continue;  					}  					//System.err.println(host);  					//System.err.println("|"+key+"|");  					HostKey hk = null;  					hk = new KnownHosts.HashedHostKey(this' host' type' Util.FromBase64(Util.Str2byte  						(key)' 0' key.Length));  					pool.Add(hk);  loop_continue: ;  				}  loop_break: ;  				fis.Close();  				if (error)  				{  					throw new JSchException("KnownHosts: invalid format");  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KnownHosts,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,SetKnownHosts,The following statement contains a magic number: try  			{  				InputStream fis = foo;  				string host;  				string key = null;  				int type;  				byte[] buf = new byte[1024];  				int bufl = 0;  				while (true)  				{  					bufl = 0;  					while (true)  					{  						j = fis.Read();  						if (j == -1)  						{  							if (bufl == 0)  							{  								goto loop_break;  							}  							else  							{  								break;  							}  						}  						if (j == unchecked((int)(0x0d)))  						{  							continue;  						}  						if (j == unchecked((int)(0x0a)))  						{  							break;  						}  						if (buf.Length <= bufl)  						{  							if (bufl > 1024 * 10)  							{  								break;  							}  							// too long...  							byte[] newbuf = new byte[buf.Length * 2];  							System.Array.Copy(buf' 0' newbuf' 0' buf.Length);  							buf = newbuf;  						}  						buf[bufl++] = unchecked((byte)j);  					}  					j = 0;  					while (j < bufl)  					{  						i = buf[j];  						if (i == ' ' || i == '\t')  						{  							j++;  							continue;  						}  						if (i == '#')  						{  							AddInvalidLine(Util.Byte2str(buf' 0' bufl));  							goto loop_continue;  						}  						break;  					}  					if (j >= bufl)  					{  						AddInvalidLine(Util.Byte2str(buf' 0' bufl));  						goto loop_continue;  					}  					sb.Length = 0;  					while (j < bufl)  					{  						i = buf[j++];  						if (i == unchecked((int)(0x20)) || i == '\t')  						{  							break;  						}  						sb.Append((char)i);  					}  					host = sb.ToString();  					if (j >= bufl || host.Length == 0)  					{  						AddInvalidLine(Util.Byte2str(buf' 0' bufl));  						goto loop_continue;  					}  					sb.Length = 0;  					type = -1;  					while (j < bufl)  					{  						i = buf[j++];  						if (i == unchecked((int)(0x20)) || i == '\t')  						{  							break;  						}  						sb.Append((char)i);  					}  					if (sb.ToString().Equals("ssh-dss"))  					{  						type = HostKey.SSHDSS;  					}  					else  					{  						if (sb.ToString().Equals("ssh-rsa"))  						{  							type = HostKey.SSHRSA;  						}  						else  						{  							j = bufl;  						}  					}  					if (j >= bufl)  					{  						AddInvalidLine(Util.Byte2str(buf' 0' bufl));  						goto loop_continue;  					}  					sb.Length = 0;  					while (j < bufl)  					{  						i = buf[j++];  						if (i == unchecked((int)(0x0d)))  						{  							continue;  						}  						if (i == unchecked((int)(0x0a)))  						{  							break;  						}  						sb.Append((char)i);  					}  					key = sb.ToString();  					if (key.Length == 0)  					{  						AddInvalidLine(Util.Byte2str(buf' 0' bufl));  						goto loop_continue;  					}  					//System.err.println(host);  					//System.err.println("|"+key+"|");  					HostKey hk = null;  					hk = new KnownHosts.HashedHostKey(this' host' type' Util.FromBase64(Util.Str2byte  						(key)' 0' key.Length));  					pool.Add(hk);  loop_continue: ;  				}  loop_break: ;  				fis.Close();  				if (error)  				{  					throw new JSchException("KnownHosts: invalid format");  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KnownHosts,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,SetKnownHosts,The following statement contains a magic number: try  			{  				InputStream fis = foo;  				string host;  				string key = null;  				int type;  				byte[] buf = new byte[1024];  				int bufl = 0;  				while (true)  				{  					bufl = 0;  					while (true)  					{  						j = fis.Read();  						if (j == -1)  						{  							if (bufl == 0)  							{  								goto loop_break;  							}  							else  							{  								break;  							}  						}  						if (j == unchecked((int)(0x0d)))  						{  							continue;  						}  						if (j == unchecked((int)(0x0a)))  						{  							break;  						}  						if (buf.Length <= bufl)  						{  							if (bufl > 1024 * 10)  							{  								break;  							}  							// too long...  							byte[] newbuf = new byte[buf.Length * 2];  							System.Array.Copy(buf' 0' newbuf' 0' buf.Length);  							buf = newbuf;  						}  						buf[bufl++] = unchecked((byte)j);  					}  					j = 0;  					while (j < bufl)  					{  						i = buf[j];  						if (i == ' ' || i == '\t')  						{  							j++;  							continue;  						}  						if (i == '#')  						{  							AddInvalidLine(Util.Byte2str(buf' 0' bufl));  							goto loop_continue;  						}  						break;  					}  					if (j >= bufl)  					{  						AddInvalidLine(Util.Byte2str(buf' 0' bufl));  						goto loop_continue;  					}  					sb.Length = 0;  					while (j < bufl)  					{  						i = buf[j++];  						if (i == unchecked((int)(0x20)) || i == '\t')  						{  							break;  						}  						sb.Append((char)i);  					}  					host = sb.ToString();  					if (j >= bufl || host.Length == 0)  					{  						AddInvalidLine(Util.Byte2str(buf' 0' bufl));  						goto loop_continue;  					}  					sb.Length = 0;  					type = -1;  					while (j < bufl)  					{  						i = buf[j++];  						if (i == unchecked((int)(0x20)) || i == '\t')  						{  							break;  						}  						sb.Append((char)i);  					}  					if (sb.ToString().Equals("ssh-dss"))  					{  						type = HostKey.SSHDSS;  					}  					else  					{  						if (sb.ToString().Equals("ssh-rsa"))  						{  							type = HostKey.SSHRSA;  						}  						else  						{  							j = bufl;  						}  					}  					if (j >= bufl)  					{  						AddInvalidLine(Util.Byte2str(buf' 0' bufl));  						goto loop_continue;  					}  					sb.Length = 0;  					while (j < bufl)  					{  						i = buf[j++];  						if (i == unchecked((int)(0x0d)))  						{  							continue;  						}  						if (i == unchecked((int)(0x0a)))  						{  							break;  						}  						sb.Append((char)i);  					}  					key = sb.ToString();  					if (key.Length == 0)  					{  						AddInvalidLine(Util.Byte2str(buf' 0' bufl));  						goto loop_continue;  					}  					//System.err.println(host);  					//System.err.println("|"+key+"|");  					HostKey hk = null;  					hk = new KnownHosts.HashedHostKey(this' host' type' Util.FromBase64(Util.Str2byte  						(key)' 0' key.Length));  					pool.Add(hk);  loop_continue: ;  				}  loop_break: ;  				fis.Close();  				if (error)  				{  					throw new JSchException("KnownHosts: invalid format");  				}  			}  			catch (Exception e)  			{  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				if (e is Exception)  				{  					throw new JSchException(e.ToString()' (Exception)e);  				}  				throw new JSchException(e.ToString());  			}
Magic Number,NSch,KnownHosts,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,GetType,The following statement contains a magic number: if (key[8] == 'd')  			{  				return HostKey.SSHDSS;  			}
Magic Number,NSch,KnownHosts,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,GetType,The following statement contains a magic number: if (key[8] == 'r')  			{  				return HostKey.SSHRSA;  			}
Magic Number,NSch,HashedHostKey,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,HashedHostKey,The following statement contains a magic number: if (this.host.StartsWith(KnownHosts.HashedHostKey.HASH_MAGIC) && Sharpen.Runtime.Substring  					(this.host' KnownHosts.HashedHostKey.HASH_MAGIC.Length).IndexOf(KnownHosts.HashedHostKey  					.HASH_DELIM) > 0)  				{  					string data = Sharpen.Runtime.Substring(this.host' KnownHosts.HashedHostKey.HASH_MAGIC  						.Length);  					string _salt = Sharpen.Runtime.Substring(data' 0' data.IndexOf(KnownHosts.HashedHostKey  						.HASH_DELIM));  					string _hash = Sharpen.Runtime.Substring(data' data.IndexOf(KnownHosts.HashedHostKey  						.HASH_DELIM) + 1);  					this.salt = Util.FromBase64(Util.Str2byte(_salt)' 0' _salt.Length);  					this.hash = Util.FromBase64(Util.Str2byte(_hash)' 0' _hash.Length);  					if (this.salt.Length != 20 || this.hash.Length != 20)  					{  						// block size of hmac-sha1  						this.salt = null;  						this.hash = null;  						return;  					}  					this.hashed = true;  				}
Magic Number,NSch,HashedHostKey,C:\repos\mono_ngit\NSch\NSch\KnownHosts.cs,HashedHostKey,The following statement contains a magic number: if (this.host.StartsWith(KnownHosts.HashedHostKey.HASH_MAGIC) && Sharpen.Runtime.Substring  					(this.host' KnownHosts.HashedHostKey.HASH_MAGIC.Length).IndexOf(KnownHosts.HashedHostKey  					.HASH_DELIM) > 0)  				{  					string data = Sharpen.Runtime.Substring(this.host' KnownHosts.HashedHostKey.HASH_MAGIC  						.Length);  					string _salt = Sharpen.Runtime.Substring(data' 0' data.IndexOf(KnownHosts.HashedHostKey  						.HASH_DELIM));  					string _hash = Sharpen.Runtime.Substring(data' data.IndexOf(KnownHosts.HashedHostKey  						.HASH_DELIM) + 1);  					this.salt = Util.FromBase64(Util.Str2byte(_salt)' 0' _salt.Length);  					this.hash = Util.FromBase64(Util.Str2byte(_hash)' 0' _hash.Length);  					if (this.salt.Length != 20 || this.hash.Length != 20)  					{  						// block size of hmac-sha1  						this.salt = null;  						this.hash = null;  						return;  					}  					this.hashed = true;  				}
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Reset,The following statement contains a magic number: buffer.index = 5;
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Padding,The following statement contains a magic number: len = len + pad - 4;
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Padding,The following statement contains a magic number: ba4[0] = unchecked((byte)((int)(((uint)len) >> 24)));
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Padding,The following statement contains a magic number: ba4[1] = unchecked((byte)((int)(((uint)len) >> 16)));
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Padding,The following statement contains a magic number: ba4[2] = unchecked((byte)((int)(((uint)len) >> 8)));
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Padding,The following statement contains a magic number: ba4[2] = unchecked((byte)((int)(((uint)len) >> 8)));
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Padding,The following statement contains a magic number: ba4[3] = unchecked((byte)(len));
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Padding,The following statement contains a magic number: System.Array.Copy(ba4' 0' buffer.buffer' 0' 4);
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Padding,The following statement contains a magic number: buffer.buffer[4] = unchecked((byte)pad);
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: int s = len + 5 + 9;
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: int s = len + 5 + 9;
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: s += 32;
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: if (buffer.buffer.Length < s + buffer.index - 5 - 9 - len)  			{  				byte[] foo = new byte[s + buffer.index - 5 - 9 - len];  				System.Array.Copy(buffer.buffer' 0' foo' 0' buffer.buffer.Length);  				buffer.buffer = foo;  			}
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: if (buffer.buffer.Length < s + buffer.index - 5 - 9 - len)  			{  				byte[] foo = new byte[s + buffer.index - 5 - 9 - len];  				System.Array.Copy(buffer.buffer' 0' foo' 0' buffer.buffer.Length);  				buffer.buffer = foo;  			}
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: if (buffer.buffer.Length < s + buffer.index - 5 - 9 - len)  			{  				byte[] foo = new byte[s + buffer.index - 5 - 9 - len];  				System.Array.Copy(buffer.buffer' 0' foo' 0' buffer.buffer.Length);  				buffer.buffer = foo;  			}
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: if (buffer.buffer.Length < s + buffer.index - 5 - 9 - len)  			{  				byte[] foo = new byte[s + buffer.index - 5 - 9 - len];  				System.Array.Copy(buffer.buffer' 0' foo' 0' buffer.buffer.Length);  				buffer.buffer = foo;  			}
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: System.Array.Copy(buffer.buffer' len + 5 + 9' buffer.buffer' s' buffer.index - 5   				- 9 - len);
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: System.Array.Copy(buffer.buffer' len + 5 + 9' buffer.buffer' s' buffer.index - 5   				- 9 - len);
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: System.Array.Copy(buffer.buffer' len + 5 + 9' buffer.buffer' s' buffer.index - 5   				- 9 - len);
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: System.Array.Copy(buffer.buffer' len + 5 + 9' buffer.buffer' s' buffer.index - 5   				- 9 - len);
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: buffer.index = 10;
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: buffer.index = len + 5 + 9;
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Shift,The following statement contains a magic number: buffer.index = len + 5 + 9;
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Unshift,The following statement contains a magic number: System.Array.Copy(buffer.buffer' s' buffer.buffer' 5 + 9' len);
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Unshift,The following statement contains a magic number: System.Array.Copy(buffer.buffer' s' buffer.buffer' 5 + 9' len);
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Unshift,The following statement contains a magic number: buffer.buffer[5] = command;
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Unshift,The following statement contains a magic number: buffer.index = 6;
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Unshift,The following statement contains a magic number: buffer.index = len + 5 + 9;
Magic Number,NSch,Packet,C:\repos\mono_ngit\NSch\NSch\Packet.cs,Unshift,The following statement contains a magic number: buffer.index = len + 5 + 9;
Magic Number,NSch,ProxyHTTP,C:\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				@out.Write(Util.Str2byte("CONNECT " + host + ":" + port + " HTTP/1.0\r\n"));  				if (user != null && passwd != null)  				{  					byte[] code = Util.Str2byte(user + ":" + passwd);  					code = Util.ToBase64(code' 0' code.Length);  					@out.Write(Util.Str2byte("Proxy-Authorization: Basic "));  					@out.Write(code);  					@out.Write(Util.Str2byte("\r\n"));  				}  				@out.Write(Util.Str2byte("\r\n"));  				@out.Flush();  				int foo = 0;  				StringBuilder sb = new StringBuilder();  				while (foo >= 0)  				{  					foo = @in.Read();  					if (foo != 13)  					{  						sb.Append((char)foo);  						continue;  					}  					foo = @in.Read();  					if (foo != 10)  					{  						continue;  					}  					break;  				}  				if (foo < 0)  				{  					throw new IOException();  				}  				string response = sb.ToString();  				string reason = "Unknow reason";  				int code_1 = -1;  				try  				{  					foo = response.IndexOf(' ');  					int bar = response.IndexOf(' '' foo + 1);  					code_1 = System.Convert.ToInt32(Sharpen.Runtime.Substring(response' foo + 1' bar)  						);  					reason = Sharpen.Runtime.Substring(response' bar + 1);  				}  				catch (Exception)  				{  				}  				if (code_1 != 200)  				{  					throw new IOException("proxy error: " + reason);  				}  				int count = 0;  				while (true)  				{  					count = 0;  					while (foo >= 0)  					{  						foo = @in.Read();  						if (foo != 13)  						{  							count++;  							continue;  						}  						foo = @in.Read();  						if (foo != 10)  						{  							continue;  						}  						break;  					}  					if (foo < 0)  					{  						throw new IOException();  					}  					if (count == 0)  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxyHTTP: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxyHTTP,C:\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				@out.Write(Util.Str2byte("CONNECT " + host + ":" + port + " HTTP/1.0\r\n"));  				if (user != null && passwd != null)  				{  					byte[] code = Util.Str2byte(user + ":" + passwd);  					code = Util.ToBase64(code' 0' code.Length);  					@out.Write(Util.Str2byte("Proxy-Authorization: Basic "));  					@out.Write(code);  					@out.Write(Util.Str2byte("\r\n"));  				}  				@out.Write(Util.Str2byte("\r\n"));  				@out.Flush();  				int foo = 0;  				StringBuilder sb = new StringBuilder();  				while (foo >= 0)  				{  					foo = @in.Read();  					if (foo != 13)  					{  						sb.Append((char)foo);  						continue;  					}  					foo = @in.Read();  					if (foo != 10)  					{  						continue;  					}  					break;  				}  				if (foo < 0)  				{  					throw new IOException();  				}  				string response = sb.ToString();  				string reason = "Unknow reason";  				int code_1 = -1;  				try  				{  					foo = response.IndexOf(' ');  					int bar = response.IndexOf(' '' foo + 1);  					code_1 = System.Convert.ToInt32(Sharpen.Runtime.Substring(response' foo + 1' bar)  						);  					reason = Sharpen.Runtime.Substring(response' bar + 1);  				}  				catch (Exception)  				{  				}  				if (code_1 != 200)  				{  					throw new IOException("proxy error: " + reason);  				}  				int count = 0;  				while (true)  				{  					count = 0;  					while (foo >= 0)  					{  						foo = @in.Read();  						if (foo != 13)  						{  							count++;  							continue;  						}  						foo = @in.Read();  						if (foo != 10)  						{  							continue;  						}  						break;  					}  					if (foo < 0)  					{  						throw new IOException();  					}  					if (count == 0)  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxyHTTP: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxyHTTP,C:\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				@out.Write(Util.Str2byte("CONNECT " + host + ":" + port + " HTTP/1.0\r\n"));  				if (user != null && passwd != null)  				{  					byte[] code = Util.Str2byte(user + ":" + passwd);  					code = Util.ToBase64(code' 0' code.Length);  					@out.Write(Util.Str2byte("Proxy-Authorization: Basic "));  					@out.Write(code);  					@out.Write(Util.Str2byte("\r\n"));  				}  				@out.Write(Util.Str2byte("\r\n"));  				@out.Flush();  				int foo = 0;  				StringBuilder sb = new StringBuilder();  				while (foo >= 0)  				{  					foo = @in.Read();  					if (foo != 13)  					{  						sb.Append((char)foo);  						continue;  					}  					foo = @in.Read();  					if (foo != 10)  					{  						continue;  					}  					break;  				}  				if (foo < 0)  				{  					throw new IOException();  				}  				string response = sb.ToString();  				string reason = "Unknow reason";  				int code_1 = -1;  				try  				{  					foo = response.IndexOf(' ');  					int bar = response.IndexOf(' '' foo + 1);  					code_1 = System.Convert.ToInt32(Sharpen.Runtime.Substring(response' foo + 1' bar)  						);  					reason = Sharpen.Runtime.Substring(response' bar + 1);  				}  				catch (Exception)  				{  				}  				if (code_1 != 200)  				{  					throw new IOException("proxy error: " + reason);  				}  				int count = 0;  				while (true)  				{  					count = 0;  					while (foo >= 0)  					{  						foo = @in.Read();  						if (foo != 13)  						{  							count++;  							continue;  						}  						foo = @in.Read();  						if (foo != 10)  						{  							continue;  						}  						break;  					}  					if (foo < 0)  					{  						throw new IOException();  					}  					if (count == 0)  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxyHTTP: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxyHTTP,C:\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				@out.Write(Util.Str2byte("CONNECT " + host + ":" + port + " HTTP/1.0\r\n"));  				if (user != null && passwd != null)  				{  					byte[] code = Util.Str2byte(user + ":" + passwd);  					code = Util.ToBase64(code' 0' code.Length);  					@out.Write(Util.Str2byte("Proxy-Authorization: Basic "));  					@out.Write(code);  					@out.Write(Util.Str2byte("\r\n"));  				}  				@out.Write(Util.Str2byte("\r\n"));  				@out.Flush();  				int foo = 0;  				StringBuilder sb = new StringBuilder();  				while (foo >= 0)  				{  					foo = @in.Read();  					if (foo != 13)  					{  						sb.Append((char)foo);  						continue;  					}  					foo = @in.Read();  					if (foo != 10)  					{  						continue;  					}  					break;  				}  				if (foo < 0)  				{  					throw new IOException();  				}  				string response = sb.ToString();  				string reason = "Unknow reason";  				int code_1 = -1;  				try  				{  					foo = response.IndexOf(' ');  					int bar = response.IndexOf(' '' foo + 1);  					code_1 = System.Convert.ToInt32(Sharpen.Runtime.Substring(response' foo + 1' bar)  						);  					reason = Sharpen.Runtime.Substring(response' bar + 1);  				}  				catch (Exception)  				{  				}  				if (code_1 != 200)  				{  					throw new IOException("proxy error: " + reason);  				}  				int count = 0;  				while (true)  				{  					count = 0;  					while (foo >= 0)  					{  						foo = @in.Read();  						if (foo != 13)  						{  							count++;  							continue;  						}  						foo = @in.Read();  						if (foo != 10)  						{  							continue;  						}  						break;  					}  					if (foo < 0)  					{  						throw new IOException();  					}  					if (count == 0)  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxyHTTP: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxyHTTP,C:\repos\mono_ngit\NSch\NSch\ProxyHTTP.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				@out.Write(Util.Str2byte("CONNECT " + host + ":" + port + " HTTP/1.0\r\n"));  				if (user != null && passwd != null)  				{  					byte[] code = Util.Str2byte(user + ":" + passwd);  					code = Util.ToBase64(code' 0' code.Length);  					@out.Write(Util.Str2byte("Proxy-Authorization: Basic "));  					@out.Write(code);  					@out.Write(Util.Str2byte("\r\n"));  				}  				@out.Write(Util.Str2byte("\r\n"));  				@out.Flush();  				int foo = 0;  				StringBuilder sb = new StringBuilder();  				while (foo >= 0)  				{  					foo = @in.Read();  					if (foo != 13)  					{  						sb.Append((char)foo);  						continue;  					}  					foo = @in.Read();  					if (foo != 10)  					{  						continue;  					}  					break;  				}  				if (foo < 0)  				{  					throw new IOException();  				}  				string response = sb.ToString();  				string reason = "Unknow reason";  				int code_1 = -1;  				try  				{  					foo = response.IndexOf(' ');  					int bar = response.IndexOf(' '' foo + 1);  					code_1 = System.Convert.ToInt32(Sharpen.Runtime.Substring(response' foo + 1' bar)  						);  					reason = Sharpen.Runtime.Substring(response' bar + 1);  				}  				catch (Exception)  				{  				}  				if (code_1 != 200)  				{  					throw new IOException("proxy error: " + reason);  				}  				int count = 0;  				while (true)  				{  					count = 0;  					while (foo >= 0)  					{  						foo = @in.Read();  						if (foo != 13)  						{  							count++;  							continue;  						}  						foo = @in.Read();  						if (foo != 10)  						{  							continue;  						}  						break;  					}  					if (foo < 0)  					{  						throw new IOException();  					}  					if (count == 0)  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxyHTTP: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS4,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				index = 0;  				buf[index++] = 4;  				buf[index++] = 1;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				try  				{  					IPAddress addr = Sharpen.Extensions.GetAddressByName(host);  					byte[] byteAddress = addr.GetAddressBytes();  					for (int i = 0; i < byteAddress.Length; i++)  					{  						buf[index++] = byteAddress[i];  					}  				}  				catch (UnknownHostException uhe)  				{  					throw new JSchException("ProxySOCKS4: " + uhe.ToString()' uhe);  				}  				if (user != null)  				{  					System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  					index += user.Length;  				}  				buf[index++] = 0;  				@out.Write(buf' 0' index);  				int len = 8;  				int s = 0;  				while (s < len)  				{  					int i = @in.Read(buf' s' len - s);  					if (i <= 0)  					{  						throw new JSchException("ProxySOCKS4: stream is closed");  					}  					s += i;  				}  				if (buf[0] != 0)  				{  					throw new JSchException("ProxySOCKS4: server returns VN " + buf[0]);  				}  				if (buf[1] != 90)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					string message = "ProxySOCKS4: server returns CD " + buf[1];  					throw new JSchException(message);  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				throw new JSchException("ProxySOCKS4: " + e.ToString());  			}
Magic Number,NSch,ProxySOCKS4,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				index = 0;  				buf[index++] = 4;  				buf[index++] = 1;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				try  				{  					IPAddress addr = Sharpen.Extensions.GetAddressByName(host);  					byte[] byteAddress = addr.GetAddressBytes();  					for (int i = 0; i < byteAddress.Length; i++)  					{  						buf[index++] = byteAddress[i];  					}  				}  				catch (UnknownHostException uhe)  				{  					throw new JSchException("ProxySOCKS4: " + uhe.ToString()' uhe);  				}  				if (user != null)  				{  					System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  					index += user.Length;  				}  				buf[index++] = 0;  				@out.Write(buf' 0' index);  				int len = 8;  				int s = 0;  				while (s < len)  				{  					int i = @in.Read(buf' s' len - s);  					if (i <= 0)  					{  						throw new JSchException("ProxySOCKS4: stream is closed");  					}  					s += i;  				}  				if (buf[0] != 0)  				{  					throw new JSchException("ProxySOCKS4: server returns VN " + buf[0]);  				}  				if (buf[1] != 90)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					string message = "ProxySOCKS4: server returns CD " + buf[1];  					throw new JSchException(message);  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				throw new JSchException("ProxySOCKS4: " + e.ToString());  			}
Magic Number,NSch,ProxySOCKS4,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				index = 0;  				buf[index++] = 4;  				buf[index++] = 1;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				try  				{  					IPAddress addr = Sharpen.Extensions.GetAddressByName(host);  					byte[] byteAddress = addr.GetAddressBytes();  					for (int i = 0; i < byteAddress.Length; i++)  					{  						buf[index++] = byteAddress[i];  					}  				}  				catch (UnknownHostException uhe)  				{  					throw new JSchException("ProxySOCKS4: " + uhe.ToString()' uhe);  				}  				if (user != null)  				{  					System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  					index += user.Length;  				}  				buf[index++] = 0;  				@out.Write(buf' 0' index);  				int len = 8;  				int s = 0;  				while (s < len)  				{  					int i = @in.Read(buf' s' len - s);  					if (i <= 0)  					{  						throw new JSchException("ProxySOCKS4: stream is closed");  					}  					s += i;  				}  				if (buf[0] != 0)  				{  					throw new JSchException("ProxySOCKS4: server returns VN " + buf[0]);  				}  				if (buf[1] != 90)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					string message = "ProxySOCKS4: server returns CD " + buf[1];  					throw new JSchException(message);  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				throw new JSchException("ProxySOCKS4: " + e.ToString());  			}
Magic Number,NSch,ProxySOCKS4,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				index = 0;  				buf[index++] = 4;  				buf[index++] = 1;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				try  				{  					IPAddress addr = Sharpen.Extensions.GetAddressByName(host);  					byte[] byteAddress = addr.GetAddressBytes();  					for (int i = 0; i < byteAddress.Length; i++)  					{  						buf[index++] = byteAddress[i];  					}  				}  				catch (UnknownHostException uhe)  				{  					throw new JSchException("ProxySOCKS4: " + uhe.ToString()' uhe);  				}  				if (user != null)  				{  					System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  					index += user.Length;  				}  				buf[index++] = 0;  				@out.Write(buf' 0' index);  				int len = 8;  				int s = 0;  				while (s < len)  				{  					int i = @in.Read(buf' s' len - s);  					if (i <= 0)  					{  						throw new JSchException("ProxySOCKS4: stream is closed");  					}  					s += i;  				}  				if (buf[0] != 0)  				{  					throw new JSchException("ProxySOCKS4: server returns VN " + buf[0]);  				}  				if (buf[1] != 90)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					string message = "ProxySOCKS4: server returns CD " + buf[1];  					throw new JSchException(message);  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				throw new JSchException("ProxySOCKS4: " + e.ToString());  			}
Magic Number,NSch,ProxySOCKS4,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS4.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				index = 0;  				buf[index++] = 4;  				buf[index++] = 1;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				try  				{  					IPAddress addr = Sharpen.Extensions.GetAddressByName(host);  					byte[] byteAddress = addr.GetAddressBytes();  					for (int i = 0; i < byteAddress.Length; i++)  					{  						buf[index++] = byteAddress[i];  					}  				}  				catch (UnknownHostException uhe)  				{  					throw new JSchException("ProxySOCKS4: " + uhe.ToString()' uhe);  				}  				if (user != null)  				{  					System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  					index += user.Length;  				}  				buf[index++] = 0;  				@out.Write(buf' 0' index);  				int len = 8;  				int s = 0;  				while (s < len)  				{  					int i = @in.Read(buf' s' len - s);  					if (i <= 0)  					{  						throw new JSchException("ProxySOCKS4: stream is closed");  					}  					s += i;  				}  				if (buf[0] != 0)  				{  					throw new JSchException("ProxySOCKS4: server returns VN " + buf[0]);  				}  				if (buf[1] != 90)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					string message = "ProxySOCKS4: server returns CD " + buf[1];  					throw new JSchException(message);  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				throw new JSchException("ProxySOCKS4: " + e.ToString());  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,ProxySOCKS5,C:\repos\mono_ngit\NSch\NSch\ProxySOCKS5.cs,Connect,The following statement contains a magic number: try  			{  				if (socket_factory == null)  				{  					socket = Util.CreateSocket(proxy_host' proxy_port' timeout);  					//socket=new Socket(proxy_host' proxy_port);      					@in = socket.GetInputStream();  					@out = socket.GetOutputStream();  				}  				else  				{  					socket = socket_factory.CreateSocket(proxy_host' proxy_port);  					@in = socket_factory.GetInputStream(socket);  					@out = socket_factory.GetOutputStream(socket);  				}  				if (timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				socket.NoDelay = true;  				byte[] buf = new byte[1024];  				int index = 0;  				buf[index++] = 5;  				buf[index++] = 2;  				buf[index++] = 0;  				// NO AUTHENTICATION REQUIRED  				buf[index++] = 2;  				// USERNAME/PASSWORD  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 2);  				Fill(@in' buf' 2);  				bool check = false;  				switch ((buf[1]) & unchecked((int)(0xff)))  				{  					case 0:  					{  						// NO AUTHENTICATION REQUIRED  						check = true;  						break;  					}    					case 2:  					{  						// USERNAME/PASSWORD  						if (user == null || passwd == null)  						{  							break;  						}  						index = 0;  						buf[index++] = 1;  						buf[index++] = unchecked((byte)(user.Length));  						System.Array.Copy(Util.Str2byte(user)' 0' buf' index' user.Length);  						index += user.Length;  						buf[index++] = unchecked((byte)(passwd.Length));  						System.Array.Copy(Util.Str2byte(passwd)' 0' buf' index' passwd.Length);  						index += passwd.Length;  						@out.Write(buf' 0' index);  						//in.read(buf' 0' 2);  						Fill(@in' buf' 2);  						if (buf[1] == 0)  						{  							check = true;  						}  						break;  					}    					default:  					{  						break;  					}  				}  				if (!check)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("fail in SOCKS5 proxy");  				}  				index = 0;  				buf[index++] = 5;  				buf[index++] = 1;  				// CONNECT  				buf[index++] = 0;  				byte[] hostb = Util.Str2byte(host);  				int len = hostb.Length;  				buf[index++] = 3;  				// DOMAINNAME  				buf[index++] = unchecked((byte)(len));  				System.Array.Copy(hostb' 0' buf' index' len);  				index += len;  				buf[index++] = unchecked((byte)((int)(((uint)port) >> 8)));  				buf[index++] = unchecked((byte)(port & unchecked((int)(0xff))));  				@out.Write(buf' 0' index);  				//in.read(buf' 0' 4);  				Fill(@in' buf' 4);  				if (buf[1] != 0)  				{  					try  					{  						socket.Close();  					}  					catch (Exception)  					{  					}  					throw new JSchException("ProxySOCKS5: server returns " + buf[1]);  				}  				switch (buf[3] & unchecked((int)(0xff)))  				{  					case 1:  					{  						//in.read(buf' 0' 6);  						Fill(@in' buf' 6);  						break;  					}    					case 3:  					{  						//in.read(buf' 0' 1);  						Fill(@in' buf' 1);  						//in.read(buf' 0' buf[0]+2);  						Fill(@in' buf' (buf[0] & unchecked((int)(0xff))) + 2);  						break;  					}    					case 4:  					{  						//in.read(buf' 0' 18);  						Fill(@in' buf' 18);  						break;  					}    					default:  					{  						break;  					}  				}  			}  			catch (RuntimeException e)  			{  				throw;  			}  			catch (Exception e)  			{  				try  				{  					if (socket != null)  					{  						socket.Close();  					}  				}  				catch (Exception)  				{  				}  				string message = "ProxySOCKS5: " + e.ToString();  				if (e is Exception)  				{  					throw new JSchException(message' (Exception)e);  				}  				throw new JSchException(message);  			}
Magic Number,NSch,RequestExec,C:\repos\mono_ngit\NSch\NSch\RequestExec.cs,DoRequest,The following statement contains a magic number: buf.CheckFreeSize(4 + command.Length);
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: try  			{  				int i;  				int j;  				if (proxy == null)  				{  					InputStream @in;  					OutputStream @out;  					if (socket_factory == null)  					{  						socket = Util.CreateSocket(host' port' connectTimeout);  						@in = socket.GetInputStream();  						@out = socket.GetOutputStream();  					}  					else  					{  						socket = socket_factory.CreateSocket(host' port);  						@in = socket_factory.GetInputStream(socket);  						@out = socket_factory.GetOutputStream(socket);  					}  					//if(timeout>0){ socket.setSoTimeout(timeout); }  					socket.NoDelay = true;  					io.SetInputStream(@in);  					io.SetOutputStream(@out);  				}  				else  				{  					lock (proxy)  					{  						proxy.Connect(socket_factory' host' port' connectTimeout);  						io.SetInputStream(proxy.GetInputStream());  						io.SetOutputStream(proxy.GetOutputStream());  						socket = proxy.GetSocket();  					}  				}  				if (connectTimeout > 0 && socket != null)  				{  					socket.ReceiveTimeout = connectTimeout;  				}  				isConnected = true;  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Connection established");  				}  				jsch.AddSession(this);  				{  					// Some Cisco devices will miss to read '\n' if it is sent separately.  					byte[] foo = new byte[V_C.Length + 1];  					System.Array.Copy(V_C' 0' foo' 0' V_C.Length);  					foo[foo.Length - 1] = unchecked((byte)(byte)('\n'));  					io.Put(foo' 0' foo.Length);  				}  				while (true)  				{  					i = 0;  					j = 0;  					while (i < buf.buffer.Length)  					{  						j = io.GetByte();  						if (j < 0)  						{  							break;  						}  						buf.buffer[i] = unchecked((byte)j);  						i++;  						if (j == 10)  						{  							break;  						}  					}  					if (j < 0)  					{  						throw new JSchException("connection is closed by foreign host");  					}  					if (buf.buffer[i - 1] == 10)  					{  						// 0x0a  						i--;  						if (i > 0 && buf.buffer[i - 1] == 13)  						{  							// 0x0d  							i--;  						}  					}  					if (i <= 3 || ((i != buf.buffer.Length) && (buf.buffer[0] != 'S' || buf.buffer[1]  						 != 'S' || buf.buffer[2] != 'H' || buf.buffer[3] != '-')))  					{  						// It must not start with 'SSH-'  						//System.err.println(new String(buf.buffer' 0' i);  						continue;  					}  					if (i == buf.buffer.Length || i < 7 || (buf.buffer[4] == '1' && buf.buffer[6] !=   						'9'))  					{  						// SSH-1.99 or SSH-2.0  						// SSH-1.5  						throw new JSchException("invalid server's version string");  					}  					break;  				}  				V_S = new byte[i];  				System.Array.Copy(buf.buffer' 0' V_S' 0' i);  				//System.err.println("V_S: ("+i+") ["+new String(V_S)+"]");  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Remote version string: " + Util.Byte2str(V_S));  					JSch.GetLogger().Log(Logger.INFO' "Local version string: " + Util.Byte2str(V_C));  				}  				Send_kexinit();  				buf = Read(buf);  				if (buf.GetCommand() != SSH_MSG_KEXINIT)  				{  					in_kex = false;  					throw new JSchException("invalid protocol: " + buf.GetCommand());  				}  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEXINIT received");  				}  				KeyExchange kex = Receive_kexinit(buf);  				while (true)  				{  					buf = Read(buf);  					if (kex.GetState() == buf.GetCommand())  					{  						kex_start_time = Runtime.CurrentTimeMillis();  						bool result = kex.Next(buf);  						if (!result)  						{  							//System.err.println("verify: "+result);  							in_kex = false;  							throw new JSchException("verify: " + result);  						}  					}  					else  					{  						in_kex = false;  						throw new JSchException("invalid protocol(kex): " + buf.GetCommand());  					}  					if (kex.GetState() == KeyExchange.STATE_END)  					{  						break;  					}  				}  				try  				{  					CheckHost(host' port' kex);  				}  				catch (JSchException ee)  				{  					in_kex = false;  					throw;  				}  				Send_newkeys();  				// receive SSH_MSG_NEWKEYS(21)  				buf = Read(buf);  				//System.err.println("read: 21 ? "+buf.getCommand());  				if (buf.GetCommand() == SSH_MSG_NEWKEYS)  				{  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_NEWKEYS received");  					}  					Receive_newkeys(buf' kex);  				}  				else  				{  					in_kex = false;  					throw new JSchException("invalid protocol(newkyes): " + buf.GetCommand());  				}  				try  				{  					string s = GetConfig("MaxAuthTries");  					if (s != null)  					{  						max_auth_tries = System.Convert.ToInt32(s);  					}  				}  				catch (FormatException e)  				{  					throw new JSchException("MaxAuthTries: " + GetConfig("MaxAuthTries")' e);  				}  				bool auth = false;  				bool auth_cancel = false;  				UserAuth ua = null;  				try  				{  					Type c = Sharpen.Runtime.GetType(GetConfig("userauth.none"));  					ua = (UserAuth)(System.Activator.CreateInstance(c));  				}  				catch (Exception e)  				{  					throw new JSchException(e.ToString()' e);  				}  				auth = ua.Start(this);  				string cmethods = GetConfig("PreferredAuthentications");  				string[] cmethoda = Util.Split(cmethods' "'");  				string smethods = null;  				if (!auth)  				{  					smethods = ((UserAuthNone)ua).GetMethods();  					if (smethods != null)  					{  						smethods = smethods.ToLower();  					}  					else  					{  						// methods: publickey'password'keyboard-interactive  						//smethods="publickey'password'keyboard-interactive";  						smethods = cmethods;  					}  				}  				string[] smethoda = Util.Split(smethods' "'");  				int methodi = 0;  				while (true)  				{  					while (!auth && cmethoda != null && methodi < cmethoda.Length)  					{  						string method = cmethoda[methodi++];  						bool acceptable = false;  						for (int k = 0; k < smethoda.Length; k++)  						{  							if (smethoda[k].Equals(method))  							{  								acceptable = true;  								break;  							}  						}  						if (!acceptable)  						{  							continue;  						}  						//System.err.println("  method: "+method);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							string str = "Authentications that can continue: ";  							for (int k_1 = methodi - 1; k_1 < cmethoda.Length; k_1++)  							{  								str += cmethoda[k_1];  								if (k_1 + 1 < cmethoda.Length)  								{  									str += "'";  								}  							}  							JSch.GetLogger().Log(Logger.INFO' str);  							JSch.GetLogger().Log(Logger.INFO' "Next authentication method: " + method);  						}  						ua = null;  						try  						{  							Type c = null;  							if (GetConfig("userauth." + method) != null)  							{  								c = Sharpen.Runtime.GetType(GetConfig("userauth." + method));  								ua = (UserAuth)(System.Activator.CreateInstance(c));  							}  						}  						catch (Exception)  						{  							if (JSch.GetLogger().IsEnabled(Logger.WARN))  							{  								JSch.GetLogger().Log(Logger.WARN' "failed to load " + method + " method");  							}  						}  						if (ua != null)  						{  							auth_cancel = false;  							try  							{  								auth = ua.Start(this);  								if (auth && JSch.GetLogger().IsEnabled(Logger.INFO))  								{  									JSch.GetLogger().Log(Logger.INFO' "Authentication succeeded (" + method + ").");  								}  							}  							catch (JSchAuthCancelException)  							{  								auth_cancel = true;  							}  							catch (JSchPartialAuthException ee)  							{  								string tmp = smethods;  								smethods = ee.GetMethods();  								smethoda = Util.Split(smethods' "'");  								if (!tmp.Equals(smethods))  								{  									methodi = 0;  								}  								//System.err.println("PartialAuth: "+methods);  								auth_cancel = false;  								goto loop_continue;  							}  							catch (RuntimeException ee)  							{  								throw;  							}  							catch (Exception)  							{  								//System.err.println("ee: "+ee); // SSH_MSG_DISCONNECT: 2 Too many authentication failures  								goto loop_break;  							}  						}  					}  					break;  loop_continue: ;  				}  loop_break: ;  				if (!auth)  				{  					if (auth_failures >= max_auth_tries)  					{  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "Login trials exceeds " + max_auth_tries);  						}  					}  					if (auth_cancel)  					{  						throw new JSchException("Auth cancel");  					}  					throw new JSchException("Auth fail");  				}  				if (connectTimeout > 0 || timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				isAuthed = true;  				lock (Lock)  				{  					if (isConnected)  					{  						connectThread = new Sharpen.Thread(this);  						connectThread.SetName("Connect thread " + host + " session");  						if (daemon_thread)  						{  							connectThread.SetDaemon(daemon_thread);  						}  						connectThread.SetDaemon (true);  						connectThread.Start();  					}  				}  			}  			catch (Exception e)  			{  				// The session has been already down and  				// we don't have to start new thread.  				in_kex = false;  				if (isConnected)  				{  					try  					{  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_DISCONNECT));  						buf.PutInt(3);  						buf.PutString(Util.Str2byte(e.ToString()));  						buf.PutString(Util.Str2byte("en"));  						Write(packet);  						Disconnect();  					}  					catch (Exception)  					{  					}  				}  				isConnected = false;  				//e.printStackTrace();  				if (e is RuntimeException)  				{  					throw (RuntimeException)e;  				}  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				throw new JSchException("Session.connect: " + e);  			}  			finally  			{  				Util.Bzero(this.password);  				this.password = null;  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: try  			{  				int i;  				int j;  				if (proxy == null)  				{  					InputStream @in;  					OutputStream @out;  					if (socket_factory == null)  					{  						socket = Util.CreateSocket(host' port' connectTimeout);  						@in = socket.GetInputStream();  						@out = socket.GetOutputStream();  					}  					else  					{  						socket = socket_factory.CreateSocket(host' port);  						@in = socket_factory.GetInputStream(socket);  						@out = socket_factory.GetOutputStream(socket);  					}  					//if(timeout>0){ socket.setSoTimeout(timeout); }  					socket.NoDelay = true;  					io.SetInputStream(@in);  					io.SetOutputStream(@out);  				}  				else  				{  					lock (proxy)  					{  						proxy.Connect(socket_factory' host' port' connectTimeout);  						io.SetInputStream(proxy.GetInputStream());  						io.SetOutputStream(proxy.GetOutputStream());  						socket = proxy.GetSocket();  					}  				}  				if (connectTimeout > 0 && socket != null)  				{  					socket.ReceiveTimeout = connectTimeout;  				}  				isConnected = true;  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Connection established");  				}  				jsch.AddSession(this);  				{  					// Some Cisco devices will miss to read '\n' if it is sent separately.  					byte[] foo = new byte[V_C.Length + 1];  					System.Array.Copy(V_C' 0' foo' 0' V_C.Length);  					foo[foo.Length - 1] = unchecked((byte)(byte)('\n'));  					io.Put(foo' 0' foo.Length);  				}  				while (true)  				{  					i = 0;  					j = 0;  					while (i < buf.buffer.Length)  					{  						j = io.GetByte();  						if (j < 0)  						{  							break;  						}  						buf.buffer[i] = unchecked((byte)j);  						i++;  						if (j == 10)  						{  							break;  						}  					}  					if (j < 0)  					{  						throw new JSchException("connection is closed by foreign host");  					}  					if (buf.buffer[i - 1] == 10)  					{  						// 0x0a  						i--;  						if (i > 0 && buf.buffer[i - 1] == 13)  						{  							// 0x0d  							i--;  						}  					}  					if (i <= 3 || ((i != buf.buffer.Length) && (buf.buffer[0] != 'S' || buf.buffer[1]  						 != 'S' || buf.buffer[2] != 'H' || buf.buffer[3] != '-')))  					{  						// It must not start with 'SSH-'  						//System.err.println(new String(buf.buffer' 0' i);  						continue;  					}  					if (i == buf.buffer.Length || i < 7 || (buf.buffer[4] == '1' && buf.buffer[6] !=   						'9'))  					{  						// SSH-1.99 or SSH-2.0  						// SSH-1.5  						throw new JSchException("invalid server's version string");  					}  					break;  				}  				V_S = new byte[i];  				System.Array.Copy(buf.buffer' 0' V_S' 0' i);  				//System.err.println("V_S: ("+i+") ["+new String(V_S)+"]");  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Remote version string: " + Util.Byte2str(V_S));  					JSch.GetLogger().Log(Logger.INFO' "Local version string: " + Util.Byte2str(V_C));  				}  				Send_kexinit();  				buf = Read(buf);  				if (buf.GetCommand() != SSH_MSG_KEXINIT)  				{  					in_kex = false;  					throw new JSchException("invalid protocol: " + buf.GetCommand());  				}  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEXINIT received");  				}  				KeyExchange kex = Receive_kexinit(buf);  				while (true)  				{  					buf = Read(buf);  					if (kex.GetState() == buf.GetCommand())  					{  						kex_start_time = Runtime.CurrentTimeMillis();  						bool result = kex.Next(buf);  						if (!result)  						{  							//System.err.println("verify: "+result);  							in_kex = false;  							throw new JSchException("verify: " + result);  						}  					}  					else  					{  						in_kex = false;  						throw new JSchException("invalid protocol(kex): " + buf.GetCommand());  					}  					if (kex.GetState() == KeyExchange.STATE_END)  					{  						break;  					}  				}  				try  				{  					CheckHost(host' port' kex);  				}  				catch (JSchException ee)  				{  					in_kex = false;  					throw;  				}  				Send_newkeys();  				// receive SSH_MSG_NEWKEYS(21)  				buf = Read(buf);  				//System.err.println("read: 21 ? "+buf.getCommand());  				if (buf.GetCommand() == SSH_MSG_NEWKEYS)  				{  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_NEWKEYS received");  					}  					Receive_newkeys(buf' kex);  				}  				else  				{  					in_kex = false;  					throw new JSchException("invalid protocol(newkyes): " + buf.GetCommand());  				}  				try  				{  					string s = GetConfig("MaxAuthTries");  					if (s != null)  					{  						max_auth_tries = System.Convert.ToInt32(s);  					}  				}  				catch (FormatException e)  				{  					throw new JSchException("MaxAuthTries: " + GetConfig("MaxAuthTries")' e);  				}  				bool auth = false;  				bool auth_cancel = false;  				UserAuth ua = null;  				try  				{  					Type c = Sharpen.Runtime.GetType(GetConfig("userauth.none"));  					ua = (UserAuth)(System.Activator.CreateInstance(c));  				}  				catch (Exception e)  				{  					throw new JSchException(e.ToString()' e);  				}  				auth = ua.Start(this);  				string cmethods = GetConfig("PreferredAuthentications");  				string[] cmethoda = Util.Split(cmethods' "'");  				string smethods = null;  				if (!auth)  				{  					smethods = ((UserAuthNone)ua).GetMethods();  					if (smethods != null)  					{  						smethods = smethods.ToLower();  					}  					else  					{  						// methods: publickey'password'keyboard-interactive  						//smethods="publickey'password'keyboard-interactive";  						smethods = cmethods;  					}  				}  				string[] smethoda = Util.Split(smethods' "'");  				int methodi = 0;  				while (true)  				{  					while (!auth && cmethoda != null && methodi < cmethoda.Length)  					{  						string method = cmethoda[methodi++];  						bool acceptable = false;  						for (int k = 0; k < smethoda.Length; k++)  						{  							if (smethoda[k].Equals(method))  							{  								acceptable = true;  								break;  							}  						}  						if (!acceptable)  						{  							continue;  						}  						//System.err.println("  method: "+method);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							string str = "Authentications that can continue: ";  							for (int k_1 = methodi - 1; k_1 < cmethoda.Length; k_1++)  							{  								str += cmethoda[k_1];  								if (k_1 + 1 < cmethoda.Length)  								{  									str += "'";  								}  							}  							JSch.GetLogger().Log(Logger.INFO' str);  							JSch.GetLogger().Log(Logger.INFO' "Next authentication method: " + method);  						}  						ua = null;  						try  						{  							Type c = null;  							if (GetConfig("userauth." + method) != null)  							{  								c = Sharpen.Runtime.GetType(GetConfig("userauth." + method));  								ua = (UserAuth)(System.Activator.CreateInstance(c));  							}  						}  						catch (Exception)  						{  							if (JSch.GetLogger().IsEnabled(Logger.WARN))  							{  								JSch.GetLogger().Log(Logger.WARN' "failed to load " + method + " method");  							}  						}  						if (ua != null)  						{  							auth_cancel = false;  							try  							{  								auth = ua.Start(this);  								if (auth && JSch.GetLogger().IsEnabled(Logger.INFO))  								{  									JSch.GetLogger().Log(Logger.INFO' "Authentication succeeded (" + method + ").");  								}  							}  							catch (JSchAuthCancelException)  							{  								auth_cancel = true;  							}  							catch (JSchPartialAuthException ee)  							{  								string tmp = smethods;  								smethods = ee.GetMethods();  								smethoda = Util.Split(smethods' "'");  								if (!tmp.Equals(smethods))  								{  									methodi = 0;  								}  								//System.err.println("PartialAuth: "+methods);  								auth_cancel = false;  								goto loop_continue;  							}  							catch (RuntimeException ee)  							{  								throw;  							}  							catch (Exception)  							{  								//System.err.println("ee: "+ee); // SSH_MSG_DISCONNECT: 2 Too many authentication failures  								goto loop_break;  							}  						}  					}  					break;  loop_continue: ;  				}  loop_break: ;  				if (!auth)  				{  					if (auth_failures >= max_auth_tries)  					{  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "Login trials exceeds " + max_auth_tries);  						}  					}  					if (auth_cancel)  					{  						throw new JSchException("Auth cancel");  					}  					throw new JSchException("Auth fail");  				}  				if (connectTimeout > 0 || timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				isAuthed = true;  				lock (Lock)  				{  					if (isConnected)  					{  						connectThread = new Sharpen.Thread(this);  						connectThread.SetName("Connect thread " + host + " session");  						if (daemon_thread)  						{  							connectThread.SetDaemon(daemon_thread);  						}  						connectThread.SetDaemon (true);  						connectThread.Start();  					}  				}  			}  			catch (Exception e)  			{  				// The session has been already down and  				// we don't have to start new thread.  				in_kex = false;  				if (isConnected)  				{  					try  					{  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_DISCONNECT));  						buf.PutInt(3);  						buf.PutString(Util.Str2byte(e.ToString()));  						buf.PutString(Util.Str2byte("en"));  						Write(packet);  						Disconnect();  					}  					catch (Exception)  					{  					}  				}  				isConnected = false;  				//e.printStackTrace();  				if (e is RuntimeException)  				{  					throw (RuntimeException)e;  				}  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				throw new JSchException("Session.connect: " + e);  			}  			finally  			{  				Util.Bzero(this.password);  				this.password = null;  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: try  			{  				int i;  				int j;  				if (proxy == null)  				{  					InputStream @in;  					OutputStream @out;  					if (socket_factory == null)  					{  						socket = Util.CreateSocket(host' port' connectTimeout);  						@in = socket.GetInputStream();  						@out = socket.GetOutputStream();  					}  					else  					{  						socket = socket_factory.CreateSocket(host' port);  						@in = socket_factory.GetInputStream(socket);  						@out = socket_factory.GetOutputStream(socket);  					}  					//if(timeout>0){ socket.setSoTimeout(timeout); }  					socket.NoDelay = true;  					io.SetInputStream(@in);  					io.SetOutputStream(@out);  				}  				else  				{  					lock (proxy)  					{  						proxy.Connect(socket_factory' host' port' connectTimeout);  						io.SetInputStream(proxy.GetInputStream());  						io.SetOutputStream(proxy.GetOutputStream());  						socket = proxy.GetSocket();  					}  				}  				if (connectTimeout > 0 && socket != null)  				{  					socket.ReceiveTimeout = connectTimeout;  				}  				isConnected = true;  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Connection established");  				}  				jsch.AddSession(this);  				{  					// Some Cisco devices will miss to read '\n' if it is sent separately.  					byte[] foo = new byte[V_C.Length + 1];  					System.Array.Copy(V_C' 0' foo' 0' V_C.Length);  					foo[foo.Length - 1] = unchecked((byte)(byte)('\n'));  					io.Put(foo' 0' foo.Length);  				}  				while (true)  				{  					i = 0;  					j = 0;  					while (i < buf.buffer.Length)  					{  						j = io.GetByte();  						if (j < 0)  						{  							break;  						}  						buf.buffer[i] = unchecked((byte)j);  						i++;  						if (j == 10)  						{  							break;  						}  					}  					if (j < 0)  					{  						throw new JSchException("connection is closed by foreign host");  					}  					if (buf.buffer[i - 1] == 10)  					{  						// 0x0a  						i--;  						if (i > 0 && buf.buffer[i - 1] == 13)  						{  							// 0x0d  							i--;  						}  					}  					if (i <= 3 || ((i != buf.buffer.Length) && (buf.buffer[0] != 'S' || buf.buffer[1]  						 != 'S' || buf.buffer[2] != 'H' || buf.buffer[3] != '-')))  					{  						// It must not start with 'SSH-'  						//System.err.println(new String(buf.buffer' 0' i);  						continue;  					}  					if (i == buf.buffer.Length || i < 7 || (buf.buffer[4] == '1' && buf.buffer[6] !=   						'9'))  					{  						// SSH-1.99 or SSH-2.0  						// SSH-1.5  						throw new JSchException("invalid server's version string");  					}  					break;  				}  				V_S = new byte[i];  				System.Array.Copy(buf.buffer' 0' V_S' 0' i);  				//System.err.println("V_S: ("+i+") ["+new String(V_S)+"]");  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Remote version string: " + Util.Byte2str(V_S));  					JSch.GetLogger().Log(Logger.INFO' "Local version string: " + Util.Byte2str(V_C));  				}  				Send_kexinit();  				buf = Read(buf);  				if (buf.GetCommand() != SSH_MSG_KEXINIT)  				{  					in_kex = false;  					throw new JSchException("invalid protocol: " + buf.GetCommand());  				}  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEXINIT received");  				}  				KeyExchange kex = Receive_kexinit(buf);  				while (true)  				{  					buf = Read(buf);  					if (kex.GetState() == buf.GetCommand())  					{  						kex_start_time = Runtime.CurrentTimeMillis();  						bool result = kex.Next(buf);  						if (!result)  						{  							//System.err.println("verify: "+result);  							in_kex = false;  							throw new JSchException("verify: " + result);  						}  					}  					else  					{  						in_kex = false;  						throw new JSchException("invalid protocol(kex): " + buf.GetCommand());  					}  					if (kex.GetState() == KeyExchange.STATE_END)  					{  						break;  					}  				}  				try  				{  					CheckHost(host' port' kex);  				}  				catch (JSchException ee)  				{  					in_kex = false;  					throw;  				}  				Send_newkeys();  				// receive SSH_MSG_NEWKEYS(21)  				buf = Read(buf);  				//System.err.println("read: 21 ? "+buf.getCommand());  				if (buf.GetCommand() == SSH_MSG_NEWKEYS)  				{  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_NEWKEYS received");  					}  					Receive_newkeys(buf' kex);  				}  				else  				{  					in_kex = false;  					throw new JSchException("invalid protocol(newkyes): " + buf.GetCommand());  				}  				try  				{  					string s = GetConfig("MaxAuthTries");  					if (s != null)  					{  						max_auth_tries = System.Convert.ToInt32(s);  					}  				}  				catch (FormatException e)  				{  					throw new JSchException("MaxAuthTries: " + GetConfig("MaxAuthTries")' e);  				}  				bool auth = false;  				bool auth_cancel = false;  				UserAuth ua = null;  				try  				{  					Type c = Sharpen.Runtime.GetType(GetConfig("userauth.none"));  					ua = (UserAuth)(System.Activator.CreateInstance(c));  				}  				catch (Exception e)  				{  					throw new JSchException(e.ToString()' e);  				}  				auth = ua.Start(this);  				string cmethods = GetConfig("PreferredAuthentications");  				string[] cmethoda = Util.Split(cmethods' "'");  				string smethods = null;  				if (!auth)  				{  					smethods = ((UserAuthNone)ua).GetMethods();  					if (smethods != null)  					{  						smethods = smethods.ToLower();  					}  					else  					{  						// methods: publickey'password'keyboard-interactive  						//smethods="publickey'password'keyboard-interactive";  						smethods = cmethods;  					}  				}  				string[] smethoda = Util.Split(smethods' "'");  				int methodi = 0;  				while (true)  				{  					while (!auth && cmethoda != null && methodi < cmethoda.Length)  					{  						string method = cmethoda[methodi++];  						bool acceptable = false;  						for (int k = 0; k < smethoda.Length; k++)  						{  							if (smethoda[k].Equals(method))  							{  								acceptable = true;  								break;  							}  						}  						if (!acceptable)  						{  							continue;  						}  						//System.err.println("  method: "+method);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							string str = "Authentications that can continue: ";  							for (int k_1 = methodi - 1; k_1 < cmethoda.Length; k_1++)  							{  								str += cmethoda[k_1];  								if (k_1 + 1 < cmethoda.Length)  								{  									str += "'";  								}  							}  							JSch.GetLogger().Log(Logger.INFO' str);  							JSch.GetLogger().Log(Logger.INFO' "Next authentication method: " + method);  						}  						ua = null;  						try  						{  							Type c = null;  							if (GetConfig("userauth." + method) != null)  							{  								c = Sharpen.Runtime.GetType(GetConfig("userauth." + method));  								ua = (UserAuth)(System.Activator.CreateInstance(c));  							}  						}  						catch (Exception)  						{  							if (JSch.GetLogger().IsEnabled(Logger.WARN))  							{  								JSch.GetLogger().Log(Logger.WARN' "failed to load " + method + " method");  							}  						}  						if (ua != null)  						{  							auth_cancel = false;  							try  							{  								auth = ua.Start(this);  								if (auth && JSch.GetLogger().IsEnabled(Logger.INFO))  								{  									JSch.GetLogger().Log(Logger.INFO' "Authentication succeeded (" + method + ").");  								}  							}  							catch (JSchAuthCancelException)  							{  								auth_cancel = true;  							}  							catch (JSchPartialAuthException ee)  							{  								string tmp = smethods;  								smethods = ee.GetMethods();  								smethoda = Util.Split(smethods' "'");  								if (!tmp.Equals(smethods))  								{  									methodi = 0;  								}  								//System.err.println("PartialAuth: "+methods);  								auth_cancel = false;  								goto loop_continue;  							}  							catch (RuntimeException ee)  							{  								throw;  							}  							catch (Exception)  							{  								//System.err.println("ee: "+ee); // SSH_MSG_DISCONNECT: 2 Too many authentication failures  								goto loop_break;  							}  						}  					}  					break;  loop_continue: ;  				}  loop_break: ;  				if (!auth)  				{  					if (auth_failures >= max_auth_tries)  					{  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "Login trials exceeds " + max_auth_tries);  						}  					}  					if (auth_cancel)  					{  						throw new JSchException("Auth cancel");  					}  					throw new JSchException("Auth fail");  				}  				if (connectTimeout > 0 || timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				isAuthed = true;  				lock (Lock)  				{  					if (isConnected)  					{  						connectThread = new Sharpen.Thread(this);  						connectThread.SetName("Connect thread " + host + " session");  						if (daemon_thread)  						{  							connectThread.SetDaemon(daemon_thread);  						}  						connectThread.SetDaemon (true);  						connectThread.Start();  					}  				}  			}  			catch (Exception e)  			{  				// The session has been already down and  				// we don't have to start new thread.  				in_kex = false;  				if (isConnected)  				{  					try  					{  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_DISCONNECT));  						buf.PutInt(3);  						buf.PutString(Util.Str2byte(e.ToString()));  						buf.PutString(Util.Str2byte("en"));  						Write(packet);  						Disconnect();  					}  					catch (Exception)  					{  					}  				}  				isConnected = false;  				//e.printStackTrace();  				if (e is RuntimeException)  				{  					throw (RuntimeException)e;  				}  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				throw new JSchException("Session.connect: " + e);  			}  			finally  			{  				Util.Bzero(this.password);  				this.password = null;  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: try  			{  				int i;  				int j;  				if (proxy == null)  				{  					InputStream @in;  					OutputStream @out;  					if (socket_factory == null)  					{  						socket = Util.CreateSocket(host' port' connectTimeout);  						@in = socket.GetInputStream();  						@out = socket.GetOutputStream();  					}  					else  					{  						socket = socket_factory.CreateSocket(host' port);  						@in = socket_factory.GetInputStream(socket);  						@out = socket_factory.GetOutputStream(socket);  					}  					//if(timeout>0){ socket.setSoTimeout(timeout); }  					socket.NoDelay = true;  					io.SetInputStream(@in);  					io.SetOutputStream(@out);  				}  				else  				{  					lock (proxy)  					{  						proxy.Connect(socket_factory' host' port' connectTimeout);  						io.SetInputStream(proxy.GetInputStream());  						io.SetOutputStream(proxy.GetOutputStream());  						socket = proxy.GetSocket();  					}  				}  				if (connectTimeout > 0 && socket != null)  				{  					socket.ReceiveTimeout = connectTimeout;  				}  				isConnected = true;  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Connection established");  				}  				jsch.AddSession(this);  				{  					// Some Cisco devices will miss to read '\n' if it is sent separately.  					byte[] foo = new byte[V_C.Length + 1];  					System.Array.Copy(V_C' 0' foo' 0' V_C.Length);  					foo[foo.Length - 1] = unchecked((byte)(byte)('\n'));  					io.Put(foo' 0' foo.Length);  				}  				while (true)  				{  					i = 0;  					j = 0;  					while (i < buf.buffer.Length)  					{  						j = io.GetByte();  						if (j < 0)  						{  							break;  						}  						buf.buffer[i] = unchecked((byte)j);  						i++;  						if (j == 10)  						{  							break;  						}  					}  					if (j < 0)  					{  						throw new JSchException("connection is closed by foreign host");  					}  					if (buf.buffer[i - 1] == 10)  					{  						// 0x0a  						i--;  						if (i > 0 && buf.buffer[i - 1] == 13)  						{  							// 0x0d  							i--;  						}  					}  					if (i <= 3 || ((i != buf.buffer.Length) && (buf.buffer[0] != 'S' || buf.buffer[1]  						 != 'S' || buf.buffer[2] != 'H' || buf.buffer[3] != '-')))  					{  						// It must not start with 'SSH-'  						//System.err.println(new String(buf.buffer' 0' i);  						continue;  					}  					if (i == buf.buffer.Length || i < 7 || (buf.buffer[4] == '1' && buf.buffer[6] !=   						'9'))  					{  						// SSH-1.99 or SSH-2.0  						// SSH-1.5  						throw new JSchException("invalid server's version string");  					}  					break;  				}  				V_S = new byte[i];  				System.Array.Copy(buf.buffer' 0' V_S' 0' i);  				//System.err.println("V_S: ("+i+") ["+new String(V_S)+"]");  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Remote version string: " + Util.Byte2str(V_S));  					JSch.GetLogger().Log(Logger.INFO' "Local version string: " + Util.Byte2str(V_C));  				}  				Send_kexinit();  				buf = Read(buf);  				if (buf.GetCommand() != SSH_MSG_KEXINIT)  				{  					in_kex = false;  					throw new JSchException("invalid protocol: " + buf.GetCommand());  				}  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEXINIT received");  				}  				KeyExchange kex = Receive_kexinit(buf);  				while (true)  				{  					buf = Read(buf);  					if (kex.GetState() == buf.GetCommand())  					{  						kex_start_time = Runtime.CurrentTimeMillis();  						bool result = kex.Next(buf);  						if (!result)  						{  							//System.err.println("verify: "+result);  							in_kex = false;  							throw new JSchException("verify: " + result);  						}  					}  					else  					{  						in_kex = false;  						throw new JSchException("invalid protocol(kex): " + buf.GetCommand());  					}  					if (kex.GetState() == KeyExchange.STATE_END)  					{  						break;  					}  				}  				try  				{  					CheckHost(host' port' kex);  				}  				catch (JSchException ee)  				{  					in_kex = false;  					throw;  				}  				Send_newkeys();  				// receive SSH_MSG_NEWKEYS(21)  				buf = Read(buf);  				//System.err.println("read: 21 ? "+buf.getCommand());  				if (buf.GetCommand() == SSH_MSG_NEWKEYS)  				{  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_NEWKEYS received");  					}  					Receive_newkeys(buf' kex);  				}  				else  				{  					in_kex = false;  					throw new JSchException("invalid protocol(newkyes): " + buf.GetCommand());  				}  				try  				{  					string s = GetConfig("MaxAuthTries");  					if (s != null)  					{  						max_auth_tries = System.Convert.ToInt32(s);  					}  				}  				catch (FormatException e)  				{  					throw new JSchException("MaxAuthTries: " + GetConfig("MaxAuthTries")' e);  				}  				bool auth = false;  				bool auth_cancel = false;  				UserAuth ua = null;  				try  				{  					Type c = Sharpen.Runtime.GetType(GetConfig("userauth.none"));  					ua = (UserAuth)(System.Activator.CreateInstance(c));  				}  				catch (Exception e)  				{  					throw new JSchException(e.ToString()' e);  				}  				auth = ua.Start(this);  				string cmethods = GetConfig("PreferredAuthentications");  				string[] cmethoda = Util.Split(cmethods' "'");  				string smethods = null;  				if (!auth)  				{  					smethods = ((UserAuthNone)ua).GetMethods();  					if (smethods != null)  					{  						smethods = smethods.ToLower();  					}  					else  					{  						// methods: publickey'password'keyboard-interactive  						//smethods="publickey'password'keyboard-interactive";  						smethods = cmethods;  					}  				}  				string[] smethoda = Util.Split(smethods' "'");  				int methodi = 0;  				while (true)  				{  					while (!auth && cmethoda != null && methodi < cmethoda.Length)  					{  						string method = cmethoda[methodi++];  						bool acceptable = false;  						for (int k = 0; k < smethoda.Length; k++)  						{  							if (smethoda[k].Equals(method))  							{  								acceptable = true;  								break;  							}  						}  						if (!acceptable)  						{  							continue;  						}  						//System.err.println("  method: "+method);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							string str = "Authentications that can continue: ";  							for (int k_1 = methodi - 1; k_1 < cmethoda.Length; k_1++)  							{  								str += cmethoda[k_1];  								if (k_1 + 1 < cmethoda.Length)  								{  									str += "'";  								}  							}  							JSch.GetLogger().Log(Logger.INFO' str);  							JSch.GetLogger().Log(Logger.INFO' "Next authentication method: " + method);  						}  						ua = null;  						try  						{  							Type c = null;  							if (GetConfig("userauth." + method) != null)  							{  								c = Sharpen.Runtime.GetType(GetConfig("userauth." + method));  								ua = (UserAuth)(System.Activator.CreateInstance(c));  							}  						}  						catch (Exception)  						{  							if (JSch.GetLogger().IsEnabled(Logger.WARN))  							{  								JSch.GetLogger().Log(Logger.WARN' "failed to load " + method + " method");  							}  						}  						if (ua != null)  						{  							auth_cancel = false;  							try  							{  								auth = ua.Start(this);  								if (auth && JSch.GetLogger().IsEnabled(Logger.INFO))  								{  									JSch.GetLogger().Log(Logger.INFO' "Authentication succeeded (" + method + ").");  								}  							}  							catch (JSchAuthCancelException)  							{  								auth_cancel = true;  							}  							catch (JSchPartialAuthException ee)  							{  								string tmp = smethods;  								smethods = ee.GetMethods();  								smethoda = Util.Split(smethods' "'");  								if (!tmp.Equals(smethods))  								{  									methodi = 0;  								}  								//System.err.println("PartialAuth: "+methods);  								auth_cancel = false;  								goto loop_continue;  							}  							catch (RuntimeException ee)  							{  								throw;  							}  							catch (Exception)  							{  								//System.err.println("ee: "+ee); // SSH_MSG_DISCONNECT: 2 Too many authentication failures  								goto loop_break;  							}  						}  					}  					break;  loop_continue: ;  				}  loop_break: ;  				if (!auth)  				{  					if (auth_failures >= max_auth_tries)  					{  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "Login trials exceeds " + max_auth_tries);  						}  					}  					if (auth_cancel)  					{  						throw new JSchException("Auth cancel");  					}  					throw new JSchException("Auth fail");  				}  				if (connectTimeout > 0 || timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				isAuthed = true;  				lock (Lock)  				{  					if (isConnected)  					{  						connectThread = new Sharpen.Thread(this);  						connectThread.SetName("Connect thread " + host + " session");  						if (daemon_thread)  						{  							connectThread.SetDaemon(daemon_thread);  						}  						connectThread.SetDaemon (true);  						connectThread.Start();  					}  				}  			}  			catch (Exception e)  			{  				// The session has been already down and  				// we don't have to start new thread.  				in_kex = false;  				if (isConnected)  				{  					try  					{  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_DISCONNECT));  						buf.PutInt(3);  						buf.PutString(Util.Str2byte(e.ToString()));  						buf.PutString(Util.Str2byte("en"));  						Write(packet);  						Disconnect();  					}  					catch (Exception)  					{  					}  				}  				isConnected = false;  				//e.printStackTrace();  				if (e is RuntimeException)  				{  					throw (RuntimeException)e;  				}  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				throw new JSchException("Session.connect: " + e);  			}  			finally  			{  				Util.Bzero(this.password);  				this.password = null;  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: try  			{  				int i;  				int j;  				if (proxy == null)  				{  					InputStream @in;  					OutputStream @out;  					if (socket_factory == null)  					{  						socket = Util.CreateSocket(host' port' connectTimeout);  						@in = socket.GetInputStream();  						@out = socket.GetOutputStream();  					}  					else  					{  						socket = socket_factory.CreateSocket(host' port);  						@in = socket_factory.GetInputStream(socket);  						@out = socket_factory.GetOutputStream(socket);  					}  					//if(timeout>0){ socket.setSoTimeout(timeout); }  					socket.NoDelay = true;  					io.SetInputStream(@in);  					io.SetOutputStream(@out);  				}  				else  				{  					lock (proxy)  					{  						proxy.Connect(socket_factory' host' port' connectTimeout);  						io.SetInputStream(proxy.GetInputStream());  						io.SetOutputStream(proxy.GetOutputStream());  						socket = proxy.GetSocket();  					}  				}  				if (connectTimeout > 0 && socket != null)  				{  					socket.ReceiveTimeout = connectTimeout;  				}  				isConnected = true;  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Connection established");  				}  				jsch.AddSession(this);  				{  					// Some Cisco devices will miss to read '\n' if it is sent separately.  					byte[] foo = new byte[V_C.Length + 1];  					System.Array.Copy(V_C' 0' foo' 0' V_C.Length);  					foo[foo.Length - 1] = unchecked((byte)(byte)('\n'));  					io.Put(foo' 0' foo.Length);  				}  				while (true)  				{  					i = 0;  					j = 0;  					while (i < buf.buffer.Length)  					{  						j = io.GetByte();  						if (j < 0)  						{  							break;  						}  						buf.buffer[i] = unchecked((byte)j);  						i++;  						if (j == 10)  						{  							break;  						}  					}  					if (j < 0)  					{  						throw new JSchException("connection is closed by foreign host");  					}  					if (buf.buffer[i - 1] == 10)  					{  						// 0x0a  						i--;  						if (i > 0 && buf.buffer[i - 1] == 13)  						{  							// 0x0d  							i--;  						}  					}  					if (i <= 3 || ((i != buf.buffer.Length) && (buf.buffer[0] != 'S' || buf.buffer[1]  						 != 'S' || buf.buffer[2] != 'H' || buf.buffer[3] != '-')))  					{  						// It must not start with 'SSH-'  						//System.err.println(new String(buf.buffer' 0' i);  						continue;  					}  					if (i == buf.buffer.Length || i < 7 || (buf.buffer[4] == '1' && buf.buffer[6] !=   						'9'))  					{  						// SSH-1.99 or SSH-2.0  						// SSH-1.5  						throw new JSchException("invalid server's version string");  					}  					break;  				}  				V_S = new byte[i];  				System.Array.Copy(buf.buffer' 0' V_S' 0' i);  				//System.err.println("V_S: ("+i+") ["+new String(V_S)+"]");  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Remote version string: " + Util.Byte2str(V_S));  					JSch.GetLogger().Log(Logger.INFO' "Local version string: " + Util.Byte2str(V_C));  				}  				Send_kexinit();  				buf = Read(buf);  				if (buf.GetCommand() != SSH_MSG_KEXINIT)  				{  					in_kex = false;  					throw new JSchException("invalid protocol: " + buf.GetCommand());  				}  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEXINIT received");  				}  				KeyExchange kex = Receive_kexinit(buf);  				while (true)  				{  					buf = Read(buf);  					if (kex.GetState() == buf.GetCommand())  					{  						kex_start_time = Runtime.CurrentTimeMillis();  						bool result = kex.Next(buf);  						if (!result)  						{  							//System.err.println("verify: "+result);  							in_kex = false;  							throw new JSchException("verify: " + result);  						}  					}  					else  					{  						in_kex = false;  						throw new JSchException("invalid protocol(kex): " + buf.GetCommand());  					}  					if (kex.GetState() == KeyExchange.STATE_END)  					{  						break;  					}  				}  				try  				{  					CheckHost(host' port' kex);  				}  				catch (JSchException ee)  				{  					in_kex = false;  					throw;  				}  				Send_newkeys();  				// receive SSH_MSG_NEWKEYS(21)  				buf = Read(buf);  				//System.err.println("read: 21 ? "+buf.getCommand());  				if (buf.GetCommand() == SSH_MSG_NEWKEYS)  				{  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_NEWKEYS received");  					}  					Receive_newkeys(buf' kex);  				}  				else  				{  					in_kex = false;  					throw new JSchException("invalid protocol(newkyes): " + buf.GetCommand());  				}  				try  				{  					string s = GetConfig("MaxAuthTries");  					if (s != null)  					{  						max_auth_tries = System.Convert.ToInt32(s);  					}  				}  				catch (FormatException e)  				{  					throw new JSchException("MaxAuthTries: " + GetConfig("MaxAuthTries")' e);  				}  				bool auth = false;  				bool auth_cancel = false;  				UserAuth ua = null;  				try  				{  					Type c = Sharpen.Runtime.GetType(GetConfig("userauth.none"));  					ua = (UserAuth)(System.Activator.CreateInstance(c));  				}  				catch (Exception e)  				{  					throw new JSchException(e.ToString()' e);  				}  				auth = ua.Start(this);  				string cmethods = GetConfig("PreferredAuthentications");  				string[] cmethoda = Util.Split(cmethods' "'");  				string smethods = null;  				if (!auth)  				{  					smethods = ((UserAuthNone)ua).GetMethods();  					if (smethods != null)  					{  						smethods = smethods.ToLower();  					}  					else  					{  						// methods: publickey'password'keyboard-interactive  						//smethods="publickey'password'keyboard-interactive";  						smethods = cmethods;  					}  				}  				string[] smethoda = Util.Split(smethods' "'");  				int methodi = 0;  				while (true)  				{  					while (!auth && cmethoda != null && methodi < cmethoda.Length)  					{  						string method = cmethoda[methodi++];  						bool acceptable = false;  						for (int k = 0; k < smethoda.Length; k++)  						{  							if (smethoda[k].Equals(method))  							{  								acceptable = true;  								break;  							}  						}  						if (!acceptable)  						{  							continue;  						}  						//System.err.println("  method: "+method);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							string str = "Authentications that can continue: ";  							for (int k_1 = methodi - 1; k_1 < cmethoda.Length; k_1++)  							{  								str += cmethoda[k_1];  								if (k_1 + 1 < cmethoda.Length)  								{  									str += "'";  								}  							}  							JSch.GetLogger().Log(Logger.INFO' str);  							JSch.GetLogger().Log(Logger.INFO' "Next authentication method: " + method);  						}  						ua = null;  						try  						{  							Type c = null;  							if (GetConfig("userauth." + method) != null)  							{  								c = Sharpen.Runtime.GetType(GetConfig("userauth." + method));  								ua = (UserAuth)(System.Activator.CreateInstance(c));  							}  						}  						catch (Exception)  						{  							if (JSch.GetLogger().IsEnabled(Logger.WARN))  							{  								JSch.GetLogger().Log(Logger.WARN' "failed to load " + method + " method");  							}  						}  						if (ua != null)  						{  							auth_cancel = false;  							try  							{  								auth = ua.Start(this);  								if (auth && JSch.GetLogger().IsEnabled(Logger.INFO))  								{  									JSch.GetLogger().Log(Logger.INFO' "Authentication succeeded (" + method + ").");  								}  							}  							catch (JSchAuthCancelException)  							{  								auth_cancel = true;  							}  							catch (JSchPartialAuthException ee)  							{  								string tmp = smethods;  								smethods = ee.GetMethods();  								smethoda = Util.Split(smethods' "'");  								if (!tmp.Equals(smethods))  								{  									methodi = 0;  								}  								//System.err.println("PartialAuth: "+methods);  								auth_cancel = false;  								goto loop_continue;  							}  							catch (RuntimeException ee)  							{  								throw;  							}  							catch (Exception)  							{  								//System.err.println("ee: "+ee); // SSH_MSG_DISCONNECT: 2 Too many authentication failures  								goto loop_break;  							}  						}  					}  					break;  loop_continue: ;  				}  loop_break: ;  				if (!auth)  				{  					if (auth_failures >= max_auth_tries)  					{  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "Login trials exceeds " + max_auth_tries);  						}  					}  					if (auth_cancel)  					{  						throw new JSchException("Auth cancel");  					}  					throw new JSchException("Auth fail");  				}  				if (connectTimeout > 0 || timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				isAuthed = true;  				lock (Lock)  				{  					if (isConnected)  					{  						connectThread = new Sharpen.Thread(this);  						connectThread.SetName("Connect thread " + host + " session");  						if (daemon_thread)  						{  							connectThread.SetDaemon(daemon_thread);  						}  						connectThread.SetDaemon (true);  						connectThread.Start();  					}  				}  			}  			catch (Exception e)  			{  				// The session has been already down and  				// we don't have to start new thread.  				in_kex = false;  				if (isConnected)  				{  					try  					{  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_DISCONNECT));  						buf.PutInt(3);  						buf.PutString(Util.Str2byte(e.ToString()));  						buf.PutString(Util.Str2byte("en"));  						Write(packet);  						Disconnect();  					}  					catch (Exception)  					{  					}  				}  				isConnected = false;  				//e.printStackTrace();  				if (e is RuntimeException)  				{  					throw (RuntimeException)e;  				}  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				throw new JSchException("Session.connect: " + e);  			}  			finally  			{  				Util.Bzero(this.password);  				this.password = null;  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: try  			{  				int i;  				int j;  				if (proxy == null)  				{  					InputStream @in;  					OutputStream @out;  					if (socket_factory == null)  					{  						socket = Util.CreateSocket(host' port' connectTimeout);  						@in = socket.GetInputStream();  						@out = socket.GetOutputStream();  					}  					else  					{  						socket = socket_factory.CreateSocket(host' port);  						@in = socket_factory.GetInputStream(socket);  						@out = socket_factory.GetOutputStream(socket);  					}  					//if(timeout>0){ socket.setSoTimeout(timeout); }  					socket.NoDelay = true;  					io.SetInputStream(@in);  					io.SetOutputStream(@out);  				}  				else  				{  					lock (proxy)  					{  						proxy.Connect(socket_factory' host' port' connectTimeout);  						io.SetInputStream(proxy.GetInputStream());  						io.SetOutputStream(proxy.GetOutputStream());  						socket = proxy.GetSocket();  					}  				}  				if (connectTimeout > 0 && socket != null)  				{  					socket.ReceiveTimeout = connectTimeout;  				}  				isConnected = true;  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Connection established");  				}  				jsch.AddSession(this);  				{  					// Some Cisco devices will miss to read '\n' if it is sent separately.  					byte[] foo = new byte[V_C.Length + 1];  					System.Array.Copy(V_C' 0' foo' 0' V_C.Length);  					foo[foo.Length - 1] = unchecked((byte)(byte)('\n'));  					io.Put(foo' 0' foo.Length);  				}  				while (true)  				{  					i = 0;  					j = 0;  					while (i < buf.buffer.Length)  					{  						j = io.GetByte();  						if (j < 0)  						{  							break;  						}  						buf.buffer[i] = unchecked((byte)j);  						i++;  						if (j == 10)  						{  							break;  						}  					}  					if (j < 0)  					{  						throw new JSchException("connection is closed by foreign host");  					}  					if (buf.buffer[i - 1] == 10)  					{  						// 0x0a  						i--;  						if (i > 0 && buf.buffer[i - 1] == 13)  						{  							// 0x0d  							i--;  						}  					}  					if (i <= 3 || ((i != buf.buffer.Length) && (buf.buffer[0] != 'S' || buf.buffer[1]  						 != 'S' || buf.buffer[2] != 'H' || buf.buffer[3] != '-')))  					{  						// It must not start with 'SSH-'  						//System.err.println(new String(buf.buffer' 0' i);  						continue;  					}  					if (i == buf.buffer.Length || i < 7 || (buf.buffer[4] == '1' && buf.buffer[6] !=   						'9'))  					{  						// SSH-1.99 or SSH-2.0  						// SSH-1.5  						throw new JSchException("invalid server's version string");  					}  					break;  				}  				V_S = new byte[i];  				System.Array.Copy(buf.buffer' 0' V_S' 0' i);  				//System.err.println("V_S: ("+i+") ["+new String(V_S)+"]");  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Remote version string: " + Util.Byte2str(V_S));  					JSch.GetLogger().Log(Logger.INFO' "Local version string: " + Util.Byte2str(V_C));  				}  				Send_kexinit();  				buf = Read(buf);  				if (buf.GetCommand() != SSH_MSG_KEXINIT)  				{  					in_kex = false;  					throw new JSchException("invalid protocol: " + buf.GetCommand());  				}  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEXINIT received");  				}  				KeyExchange kex = Receive_kexinit(buf);  				while (true)  				{  					buf = Read(buf);  					if (kex.GetState() == buf.GetCommand())  					{  						kex_start_time = Runtime.CurrentTimeMillis();  						bool result = kex.Next(buf);  						if (!result)  						{  							//System.err.println("verify: "+result);  							in_kex = false;  							throw new JSchException("verify: " + result);  						}  					}  					else  					{  						in_kex = false;  						throw new JSchException("invalid protocol(kex): " + buf.GetCommand());  					}  					if (kex.GetState() == KeyExchange.STATE_END)  					{  						break;  					}  				}  				try  				{  					CheckHost(host' port' kex);  				}  				catch (JSchException ee)  				{  					in_kex = false;  					throw;  				}  				Send_newkeys();  				// receive SSH_MSG_NEWKEYS(21)  				buf = Read(buf);  				//System.err.println("read: 21 ? "+buf.getCommand());  				if (buf.GetCommand() == SSH_MSG_NEWKEYS)  				{  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_NEWKEYS received");  					}  					Receive_newkeys(buf' kex);  				}  				else  				{  					in_kex = false;  					throw new JSchException("invalid protocol(newkyes): " + buf.GetCommand());  				}  				try  				{  					string s = GetConfig("MaxAuthTries");  					if (s != null)  					{  						max_auth_tries = System.Convert.ToInt32(s);  					}  				}  				catch (FormatException e)  				{  					throw new JSchException("MaxAuthTries: " + GetConfig("MaxAuthTries")' e);  				}  				bool auth = false;  				bool auth_cancel = false;  				UserAuth ua = null;  				try  				{  					Type c = Sharpen.Runtime.GetType(GetConfig("userauth.none"));  					ua = (UserAuth)(System.Activator.CreateInstance(c));  				}  				catch (Exception e)  				{  					throw new JSchException(e.ToString()' e);  				}  				auth = ua.Start(this);  				string cmethods = GetConfig("PreferredAuthentications");  				string[] cmethoda = Util.Split(cmethods' "'");  				string smethods = null;  				if (!auth)  				{  					smethods = ((UserAuthNone)ua).GetMethods();  					if (smethods != null)  					{  						smethods = smethods.ToLower();  					}  					else  					{  						// methods: publickey'password'keyboard-interactive  						//smethods="publickey'password'keyboard-interactive";  						smethods = cmethods;  					}  				}  				string[] smethoda = Util.Split(smethods' "'");  				int methodi = 0;  				while (true)  				{  					while (!auth && cmethoda != null && methodi < cmethoda.Length)  					{  						string method = cmethoda[methodi++];  						bool acceptable = false;  						for (int k = 0; k < smethoda.Length; k++)  						{  							if (smethoda[k].Equals(method))  							{  								acceptable = true;  								break;  							}  						}  						if (!acceptable)  						{  							continue;  						}  						//System.err.println("  method: "+method);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							string str = "Authentications that can continue: ";  							for (int k_1 = methodi - 1; k_1 < cmethoda.Length; k_1++)  							{  								str += cmethoda[k_1];  								if (k_1 + 1 < cmethoda.Length)  								{  									str += "'";  								}  							}  							JSch.GetLogger().Log(Logger.INFO' str);  							JSch.GetLogger().Log(Logger.INFO' "Next authentication method: " + method);  						}  						ua = null;  						try  						{  							Type c = null;  							if (GetConfig("userauth." + method) != null)  							{  								c = Sharpen.Runtime.GetType(GetConfig("userauth." + method));  								ua = (UserAuth)(System.Activator.CreateInstance(c));  							}  						}  						catch (Exception)  						{  							if (JSch.GetLogger().IsEnabled(Logger.WARN))  							{  								JSch.GetLogger().Log(Logger.WARN' "failed to load " + method + " method");  							}  						}  						if (ua != null)  						{  							auth_cancel = false;  							try  							{  								auth = ua.Start(this);  								if (auth && JSch.GetLogger().IsEnabled(Logger.INFO))  								{  									JSch.GetLogger().Log(Logger.INFO' "Authentication succeeded (" + method + ").");  								}  							}  							catch (JSchAuthCancelException)  							{  								auth_cancel = true;  							}  							catch (JSchPartialAuthException ee)  							{  								string tmp = smethods;  								smethods = ee.GetMethods();  								smethoda = Util.Split(smethods' "'");  								if (!tmp.Equals(smethods))  								{  									methodi = 0;  								}  								//System.err.println("PartialAuth: "+methods);  								auth_cancel = false;  								goto loop_continue;  							}  							catch (RuntimeException ee)  							{  								throw;  							}  							catch (Exception)  							{  								//System.err.println("ee: "+ee); // SSH_MSG_DISCONNECT: 2 Too many authentication failures  								goto loop_break;  							}  						}  					}  					break;  loop_continue: ;  				}  loop_break: ;  				if (!auth)  				{  					if (auth_failures >= max_auth_tries)  					{  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "Login trials exceeds " + max_auth_tries);  						}  					}  					if (auth_cancel)  					{  						throw new JSchException("Auth cancel");  					}  					throw new JSchException("Auth fail");  				}  				if (connectTimeout > 0 || timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				isAuthed = true;  				lock (Lock)  				{  					if (isConnected)  					{  						connectThread = new Sharpen.Thread(this);  						connectThread.SetName("Connect thread " + host + " session");  						if (daemon_thread)  						{  							connectThread.SetDaemon(daemon_thread);  						}  						connectThread.SetDaemon (true);  						connectThread.Start();  					}  				}  			}  			catch (Exception e)  			{  				// The session has been already down and  				// we don't have to start new thread.  				in_kex = false;  				if (isConnected)  				{  					try  					{  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_DISCONNECT));  						buf.PutInt(3);  						buf.PutString(Util.Str2byte(e.ToString()));  						buf.PutString(Util.Str2byte("en"));  						Write(packet);  						Disconnect();  					}  					catch (Exception)  					{  					}  				}  				isConnected = false;  				//e.printStackTrace();  				if (e is RuntimeException)  				{  					throw (RuntimeException)e;  				}  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				throw new JSchException("Session.connect: " + e);  			}  			finally  			{  				Util.Bzero(this.password);  				this.password = null;  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: try  			{  				int i;  				int j;  				if (proxy == null)  				{  					InputStream @in;  					OutputStream @out;  					if (socket_factory == null)  					{  						socket = Util.CreateSocket(host' port' connectTimeout);  						@in = socket.GetInputStream();  						@out = socket.GetOutputStream();  					}  					else  					{  						socket = socket_factory.CreateSocket(host' port);  						@in = socket_factory.GetInputStream(socket);  						@out = socket_factory.GetOutputStream(socket);  					}  					//if(timeout>0){ socket.setSoTimeout(timeout); }  					socket.NoDelay = true;  					io.SetInputStream(@in);  					io.SetOutputStream(@out);  				}  				else  				{  					lock (proxy)  					{  						proxy.Connect(socket_factory' host' port' connectTimeout);  						io.SetInputStream(proxy.GetInputStream());  						io.SetOutputStream(proxy.GetOutputStream());  						socket = proxy.GetSocket();  					}  				}  				if (connectTimeout > 0 && socket != null)  				{  					socket.ReceiveTimeout = connectTimeout;  				}  				isConnected = true;  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Connection established");  				}  				jsch.AddSession(this);  				{  					// Some Cisco devices will miss to read '\n' if it is sent separately.  					byte[] foo = new byte[V_C.Length + 1];  					System.Array.Copy(V_C' 0' foo' 0' V_C.Length);  					foo[foo.Length - 1] = unchecked((byte)(byte)('\n'));  					io.Put(foo' 0' foo.Length);  				}  				while (true)  				{  					i = 0;  					j = 0;  					while (i < buf.buffer.Length)  					{  						j = io.GetByte();  						if (j < 0)  						{  							break;  						}  						buf.buffer[i] = unchecked((byte)j);  						i++;  						if (j == 10)  						{  							break;  						}  					}  					if (j < 0)  					{  						throw new JSchException("connection is closed by foreign host");  					}  					if (buf.buffer[i - 1] == 10)  					{  						// 0x0a  						i--;  						if (i > 0 && buf.buffer[i - 1] == 13)  						{  							// 0x0d  							i--;  						}  					}  					if (i <= 3 || ((i != buf.buffer.Length) && (buf.buffer[0] != 'S' || buf.buffer[1]  						 != 'S' || buf.buffer[2] != 'H' || buf.buffer[3] != '-')))  					{  						// It must not start with 'SSH-'  						//System.err.println(new String(buf.buffer' 0' i);  						continue;  					}  					if (i == buf.buffer.Length || i < 7 || (buf.buffer[4] == '1' && buf.buffer[6] !=   						'9'))  					{  						// SSH-1.99 or SSH-2.0  						// SSH-1.5  						throw new JSchException("invalid server's version string");  					}  					break;  				}  				V_S = new byte[i];  				System.Array.Copy(buf.buffer' 0' V_S' 0' i);  				//System.err.println("V_S: ("+i+") ["+new String(V_S)+"]");  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Remote version string: " + Util.Byte2str(V_S));  					JSch.GetLogger().Log(Logger.INFO' "Local version string: " + Util.Byte2str(V_C));  				}  				Send_kexinit();  				buf = Read(buf);  				if (buf.GetCommand() != SSH_MSG_KEXINIT)  				{  					in_kex = false;  					throw new JSchException("invalid protocol: " + buf.GetCommand());  				}  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEXINIT received");  				}  				KeyExchange kex = Receive_kexinit(buf);  				while (true)  				{  					buf = Read(buf);  					if (kex.GetState() == buf.GetCommand())  					{  						kex_start_time = Runtime.CurrentTimeMillis();  						bool result = kex.Next(buf);  						if (!result)  						{  							//System.err.println("verify: "+result);  							in_kex = false;  							throw new JSchException("verify: " + result);  						}  					}  					else  					{  						in_kex = false;  						throw new JSchException("invalid protocol(kex): " + buf.GetCommand());  					}  					if (kex.GetState() == KeyExchange.STATE_END)  					{  						break;  					}  				}  				try  				{  					CheckHost(host' port' kex);  				}  				catch (JSchException ee)  				{  					in_kex = false;  					throw;  				}  				Send_newkeys();  				// receive SSH_MSG_NEWKEYS(21)  				buf = Read(buf);  				//System.err.println("read: 21 ? "+buf.getCommand());  				if (buf.GetCommand() == SSH_MSG_NEWKEYS)  				{  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_NEWKEYS received");  					}  					Receive_newkeys(buf' kex);  				}  				else  				{  					in_kex = false;  					throw new JSchException("invalid protocol(newkyes): " + buf.GetCommand());  				}  				try  				{  					string s = GetConfig("MaxAuthTries");  					if (s != null)  					{  						max_auth_tries = System.Convert.ToInt32(s);  					}  				}  				catch (FormatException e)  				{  					throw new JSchException("MaxAuthTries: " + GetConfig("MaxAuthTries")' e);  				}  				bool auth = false;  				bool auth_cancel = false;  				UserAuth ua = null;  				try  				{  					Type c = Sharpen.Runtime.GetType(GetConfig("userauth.none"));  					ua = (UserAuth)(System.Activator.CreateInstance(c));  				}  				catch (Exception e)  				{  					throw new JSchException(e.ToString()' e);  				}  				auth = ua.Start(this);  				string cmethods = GetConfig("PreferredAuthentications");  				string[] cmethoda = Util.Split(cmethods' "'");  				string smethods = null;  				if (!auth)  				{  					smethods = ((UserAuthNone)ua).GetMethods();  					if (smethods != null)  					{  						smethods = smethods.ToLower();  					}  					else  					{  						// methods: publickey'password'keyboard-interactive  						//smethods="publickey'password'keyboard-interactive";  						smethods = cmethods;  					}  				}  				string[] smethoda = Util.Split(smethods' "'");  				int methodi = 0;  				while (true)  				{  					while (!auth && cmethoda != null && methodi < cmethoda.Length)  					{  						string method = cmethoda[methodi++];  						bool acceptable = false;  						for (int k = 0; k < smethoda.Length; k++)  						{  							if (smethoda[k].Equals(method))  							{  								acceptable = true;  								break;  							}  						}  						if (!acceptable)  						{  							continue;  						}  						//System.err.println("  method: "+method);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							string str = "Authentications that can continue: ";  							for (int k_1 = methodi - 1; k_1 < cmethoda.Length; k_1++)  							{  								str += cmethoda[k_1];  								if (k_1 + 1 < cmethoda.Length)  								{  									str += "'";  								}  							}  							JSch.GetLogger().Log(Logger.INFO' str);  							JSch.GetLogger().Log(Logger.INFO' "Next authentication method: " + method);  						}  						ua = null;  						try  						{  							Type c = null;  							if (GetConfig("userauth." + method) != null)  							{  								c = Sharpen.Runtime.GetType(GetConfig("userauth." + method));  								ua = (UserAuth)(System.Activator.CreateInstance(c));  							}  						}  						catch (Exception)  						{  							if (JSch.GetLogger().IsEnabled(Logger.WARN))  							{  								JSch.GetLogger().Log(Logger.WARN' "failed to load " + method + " method");  							}  						}  						if (ua != null)  						{  							auth_cancel = false;  							try  							{  								auth = ua.Start(this);  								if (auth && JSch.GetLogger().IsEnabled(Logger.INFO))  								{  									JSch.GetLogger().Log(Logger.INFO' "Authentication succeeded (" + method + ").");  								}  							}  							catch (JSchAuthCancelException)  							{  								auth_cancel = true;  							}  							catch (JSchPartialAuthException ee)  							{  								string tmp = smethods;  								smethods = ee.GetMethods();  								smethoda = Util.Split(smethods' "'");  								if (!tmp.Equals(smethods))  								{  									methodi = 0;  								}  								//System.err.println("PartialAuth: "+methods);  								auth_cancel = false;  								goto loop_continue;  							}  							catch (RuntimeException ee)  							{  								throw;  							}  							catch (Exception)  							{  								//System.err.println("ee: "+ee); // SSH_MSG_DISCONNECT: 2 Too many authentication failures  								goto loop_break;  							}  						}  					}  					break;  loop_continue: ;  				}  loop_break: ;  				if (!auth)  				{  					if (auth_failures >= max_auth_tries)  					{  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "Login trials exceeds " + max_auth_tries);  						}  					}  					if (auth_cancel)  					{  						throw new JSchException("Auth cancel");  					}  					throw new JSchException("Auth fail");  				}  				if (connectTimeout > 0 || timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				isAuthed = true;  				lock (Lock)  				{  					if (isConnected)  					{  						connectThread = new Sharpen.Thread(this);  						connectThread.SetName("Connect thread " + host + " session");  						if (daemon_thread)  						{  							connectThread.SetDaemon(daemon_thread);  						}  						connectThread.SetDaemon (true);  						connectThread.Start();  					}  				}  			}  			catch (Exception e)  			{  				// The session has been already down and  				// we don't have to start new thread.  				in_kex = false;  				if (isConnected)  				{  					try  					{  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_DISCONNECT));  						buf.PutInt(3);  						buf.PutString(Util.Str2byte(e.ToString()));  						buf.PutString(Util.Str2byte("en"));  						Write(packet);  						Disconnect();  					}  					catch (Exception)  					{  					}  				}  				isConnected = false;  				//e.printStackTrace();  				if (e is RuntimeException)  				{  					throw (RuntimeException)e;  				}  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				throw new JSchException("Session.connect: " + e);  			}  			finally  			{  				Util.Bzero(this.password);  				this.password = null;  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: try  			{  				int i;  				int j;  				if (proxy == null)  				{  					InputStream @in;  					OutputStream @out;  					if (socket_factory == null)  					{  						socket = Util.CreateSocket(host' port' connectTimeout);  						@in = socket.GetInputStream();  						@out = socket.GetOutputStream();  					}  					else  					{  						socket = socket_factory.CreateSocket(host' port);  						@in = socket_factory.GetInputStream(socket);  						@out = socket_factory.GetOutputStream(socket);  					}  					//if(timeout>0){ socket.setSoTimeout(timeout); }  					socket.NoDelay = true;  					io.SetInputStream(@in);  					io.SetOutputStream(@out);  				}  				else  				{  					lock (proxy)  					{  						proxy.Connect(socket_factory' host' port' connectTimeout);  						io.SetInputStream(proxy.GetInputStream());  						io.SetOutputStream(proxy.GetOutputStream());  						socket = proxy.GetSocket();  					}  				}  				if (connectTimeout > 0 && socket != null)  				{  					socket.ReceiveTimeout = connectTimeout;  				}  				isConnected = true;  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Connection established");  				}  				jsch.AddSession(this);  				{  					// Some Cisco devices will miss to read '\n' if it is sent separately.  					byte[] foo = new byte[V_C.Length + 1];  					System.Array.Copy(V_C' 0' foo' 0' V_C.Length);  					foo[foo.Length - 1] = unchecked((byte)(byte)('\n'));  					io.Put(foo' 0' foo.Length);  				}  				while (true)  				{  					i = 0;  					j = 0;  					while (i < buf.buffer.Length)  					{  						j = io.GetByte();  						if (j < 0)  						{  							break;  						}  						buf.buffer[i] = unchecked((byte)j);  						i++;  						if (j == 10)  						{  							break;  						}  					}  					if (j < 0)  					{  						throw new JSchException("connection is closed by foreign host");  					}  					if (buf.buffer[i - 1] == 10)  					{  						// 0x0a  						i--;  						if (i > 0 && buf.buffer[i - 1] == 13)  						{  							// 0x0d  							i--;  						}  					}  					if (i <= 3 || ((i != buf.buffer.Length) && (buf.buffer[0] != 'S' || buf.buffer[1]  						 != 'S' || buf.buffer[2] != 'H' || buf.buffer[3] != '-')))  					{  						// It must not start with 'SSH-'  						//System.err.println(new String(buf.buffer' 0' i);  						continue;  					}  					if (i == buf.buffer.Length || i < 7 || (buf.buffer[4] == '1' && buf.buffer[6] !=   						'9'))  					{  						// SSH-1.99 or SSH-2.0  						// SSH-1.5  						throw new JSchException("invalid server's version string");  					}  					break;  				}  				V_S = new byte[i];  				System.Array.Copy(buf.buffer' 0' V_S' 0' i);  				//System.err.println("V_S: ("+i+") ["+new String(V_S)+"]");  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Remote version string: " + Util.Byte2str(V_S));  					JSch.GetLogger().Log(Logger.INFO' "Local version string: " + Util.Byte2str(V_C));  				}  				Send_kexinit();  				buf = Read(buf);  				if (buf.GetCommand() != SSH_MSG_KEXINIT)  				{  					in_kex = false;  					throw new JSchException("invalid protocol: " + buf.GetCommand());  				}  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEXINIT received");  				}  				KeyExchange kex = Receive_kexinit(buf);  				while (true)  				{  					buf = Read(buf);  					if (kex.GetState() == buf.GetCommand())  					{  						kex_start_time = Runtime.CurrentTimeMillis();  						bool result = kex.Next(buf);  						if (!result)  						{  							//System.err.println("verify: "+result);  							in_kex = false;  							throw new JSchException("verify: " + result);  						}  					}  					else  					{  						in_kex = false;  						throw new JSchException("invalid protocol(kex): " + buf.GetCommand());  					}  					if (kex.GetState() == KeyExchange.STATE_END)  					{  						break;  					}  				}  				try  				{  					CheckHost(host' port' kex);  				}  				catch (JSchException ee)  				{  					in_kex = false;  					throw;  				}  				Send_newkeys();  				// receive SSH_MSG_NEWKEYS(21)  				buf = Read(buf);  				//System.err.println("read: 21 ? "+buf.getCommand());  				if (buf.GetCommand() == SSH_MSG_NEWKEYS)  				{  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_NEWKEYS received");  					}  					Receive_newkeys(buf' kex);  				}  				else  				{  					in_kex = false;  					throw new JSchException("invalid protocol(newkyes): " + buf.GetCommand());  				}  				try  				{  					string s = GetConfig("MaxAuthTries");  					if (s != null)  					{  						max_auth_tries = System.Convert.ToInt32(s);  					}  				}  				catch (FormatException e)  				{  					throw new JSchException("MaxAuthTries: " + GetConfig("MaxAuthTries")' e);  				}  				bool auth = false;  				bool auth_cancel = false;  				UserAuth ua = null;  				try  				{  					Type c = Sharpen.Runtime.GetType(GetConfig("userauth.none"));  					ua = (UserAuth)(System.Activator.CreateInstance(c));  				}  				catch (Exception e)  				{  					throw new JSchException(e.ToString()' e);  				}  				auth = ua.Start(this);  				string cmethods = GetConfig("PreferredAuthentications");  				string[] cmethoda = Util.Split(cmethods' "'");  				string smethods = null;  				if (!auth)  				{  					smethods = ((UserAuthNone)ua).GetMethods();  					if (smethods != null)  					{  						smethods = smethods.ToLower();  					}  					else  					{  						// methods: publickey'password'keyboard-interactive  						//smethods="publickey'password'keyboard-interactive";  						smethods = cmethods;  					}  				}  				string[] smethoda = Util.Split(smethods' "'");  				int methodi = 0;  				while (true)  				{  					while (!auth && cmethoda != null && methodi < cmethoda.Length)  					{  						string method = cmethoda[methodi++];  						bool acceptable = false;  						for (int k = 0; k < smethoda.Length; k++)  						{  							if (smethoda[k].Equals(method))  							{  								acceptable = true;  								break;  							}  						}  						if (!acceptable)  						{  							continue;  						}  						//System.err.println("  method: "+method);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							string str = "Authentications that can continue: ";  							for (int k_1 = methodi - 1; k_1 < cmethoda.Length; k_1++)  							{  								str += cmethoda[k_1];  								if (k_1 + 1 < cmethoda.Length)  								{  									str += "'";  								}  							}  							JSch.GetLogger().Log(Logger.INFO' str);  							JSch.GetLogger().Log(Logger.INFO' "Next authentication method: " + method);  						}  						ua = null;  						try  						{  							Type c = null;  							if (GetConfig("userauth." + method) != null)  							{  								c = Sharpen.Runtime.GetType(GetConfig("userauth." + method));  								ua = (UserAuth)(System.Activator.CreateInstance(c));  							}  						}  						catch (Exception)  						{  							if (JSch.GetLogger().IsEnabled(Logger.WARN))  							{  								JSch.GetLogger().Log(Logger.WARN' "failed to load " + method + " method");  							}  						}  						if (ua != null)  						{  							auth_cancel = false;  							try  							{  								auth = ua.Start(this);  								if (auth && JSch.GetLogger().IsEnabled(Logger.INFO))  								{  									JSch.GetLogger().Log(Logger.INFO' "Authentication succeeded (" + method + ").");  								}  							}  							catch (JSchAuthCancelException)  							{  								auth_cancel = true;  							}  							catch (JSchPartialAuthException ee)  							{  								string tmp = smethods;  								smethods = ee.GetMethods();  								smethoda = Util.Split(smethods' "'");  								if (!tmp.Equals(smethods))  								{  									methodi = 0;  								}  								//System.err.println("PartialAuth: "+methods);  								auth_cancel = false;  								goto loop_continue;  							}  							catch (RuntimeException ee)  							{  								throw;  							}  							catch (Exception)  							{  								//System.err.println("ee: "+ee); // SSH_MSG_DISCONNECT: 2 Too many authentication failures  								goto loop_break;  							}  						}  					}  					break;  loop_continue: ;  				}  loop_break: ;  				if (!auth)  				{  					if (auth_failures >= max_auth_tries)  					{  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "Login trials exceeds " + max_auth_tries);  						}  					}  					if (auth_cancel)  					{  						throw new JSchException("Auth cancel");  					}  					throw new JSchException("Auth fail");  				}  				if (connectTimeout > 0 || timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				isAuthed = true;  				lock (Lock)  				{  					if (isConnected)  					{  						connectThread = new Sharpen.Thread(this);  						connectThread.SetName("Connect thread " + host + " session");  						if (daemon_thread)  						{  							connectThread.SetDaemon(daemon_thread);  						}  						connectThread.SetDaemon (true);  						connectThread.Start();  					}  				}  			}  			catch (Exception e)  			{  				// The session has been already down and  				// we don't have to start new thread.  				in_kex = false;  				if (isConnected)  				{  					try  					{  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_DISCONNECT));  						buf.PutInt(3);  						buf.PutString(Util.Str2byte(e.ToString()));  						buf.PutString(Util.Str2byte("en"));  						Write(packet);  						Disconnect();  					}  					catch (Exception)  					{  					}  				}  				isConnected = false;  				//e.printStackTrace();  				if (e is RuntimeException)  				{  					throw (RuntimeException)e;  				}  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				throw new JSchException("Session.connect: " + e);  			}  			finally  			{  				Util.Bzero(this.password);  				this.password = null;  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: try  			{  				int i;  				int j;  				if (proxy == null)  				{  					InputStream @in;  					OutputStream @out;  					if (socket_factory == null)  					{  						socket = Util.CreateSocket(host' port' connectTimeout);  						@in = socket.GetInputStream();  						@out = socket.GetOutputStream();  					}  					else  					{  						socket = socket_factory.CreateSocket(host' port);  						@in = socket_factory.GetInputStream(socket);  						@out = socket_factory.GetOutputStream(socket);  					}  					//if(timeout>0){ socket.setSoTimeout(timeout); }  					socket.NoDelay = true;  					io.SetInputStream(@in);  					io.SetOutputStream(@out);  				}  				else  				{  					lock (proxy)  					{  						proxy.Connect(socket_factory' host' port' connectTimeout);  						io.SetInputStream(proxy.GetInputStream());  						io.SetOutputStream(proxy.GetOutputStream());  						socket = proxy.GetSocket();  					}  				}  				if (connectTimeout > 0 && socket != null)  				{  					socket.ReceiveTimeout = connectTimeout;  				}  				isConnected = true;  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Connection established");  				}  				jsch.AddSession(this);  				{  					// Some Cisco devices will miss to read '\n' if it is sent separately.  					byte[] foo = new byte[V_C.Length + 1];  					System.Array.Copy(V_C' 0' foo' 0' V_C.Length);  					foo[foo.Length - 1] = unchecked((byte)(byte)('\n'));  					io.Put(foo' 0' foo.Length);  				}  				while (true)  				{  					i = 0;  					j = 0;  					while (i < buf.buffer.Length)  					{  						j = io.GetByte();  						if (j < 0)  						{  							break;  						}  						buf.buffer[i] = unchecked((byte)j);  						i++;  						if (j == 10)  						{  							break;  						}  					}  					if (j < 0)  					{  						throw new JSchException("connection is closed by foreign host");  					}  					if (buf.buffer[i - 1] == 10)  					{  						// 0x0a  						i--;  						if (i > 0 && buf.buffer[i - 1] == 13)  						{  							// 0x0d  							i--;  						}  					}  					if (i <= 3 || ((i != buf.buffer.Length) && (buf.buffer[0] != 'S' || buf.buffer[1]  						 != 'S' || buf.buffer[2] != 'H' || buf.buffer[3] != '-')))  					{  						// It must not start with 'SSH-'  						//System.err.println(new String(buf.buffer' 0' i);  						continue;  					}  					if (i == buf.buffer.Length || i < 7 || (buf.buffer[4] == '1' && buf.buffer[6] !=   						'9'))  					{  						// SSH-1.99 or SSH-2.0  						// SSH-1.5  						throw new JSchException("invalid server's version string");  					}  					break;  				}  				V_S = new byte[i];  				System.Array.Copy(buf.buffer' 0' V_S' 0' i);  				//System.err.println("V_S: ("+i+") ["+new String(V_S)+"]");  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Remote version string: " + Util.Byte2str(V_S));  					JSch.GetLogger().Log(Logger.INFO' "Local version string: " + Util.Byte2str(V_C));  				}  				Send_kexinit();  				buf = Read(buf);  				if (buf.GetCommand() != SSH_MSG_KEXINIT)  				{  					in_kex = false;  					throw new JSchException("invalid protocol: " + buf.GetCommand());  				}  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEXINIT received");  				}  				KeyExchange kex = Receive_kexinit(buf);  				while (true)  				{  					buf = Read(buf);  					if (kex.GetState() == buf.GetCommand())  					{  						kex_start_time = Runtime.CurrentTimeMillis();  						bool result = kex.Next(buf);  						if (!result)  						{  							//System.err.println("verify: "+result);  							in_kex = false;  							throw new JSchException("verify: " + result);  						}  					}  					else  					{  						in_kex = false;  						throw new JSchException("invalid protocol(kex): " + buf.GetCommand());  					}  					if (kex.GetState() == KeyExchange.STATE_END)  					{  						break;  					}  				}  				try  				{  					CheckHost(host' port' kex);  				}  				catch (JSchException ee)  				{  					in_kex = false;  					throw;  				}  				Send_newkeys();  				// receive SSH_MSG_NEWKEYS(21)  				buf = Read(buf);  				//System.err.println("read: 21 ? "+buf.getCommand());  				if (buf.GetCommand() == SSH_MSG_NEWKEYS)  				{  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_NEWKEYS received");  					}  					Receive_newkeys(buf' kex);  				}  				else  				{  					in_kex = false;  					throw new JSchException("invalid protocol(newkyes): " + buf.GetCommand());  				}  				try  				{  					string s = GetConfig("MaxAuthTries");  					if (s != null)  					{  						max_auth_tries = System.Convert.ToInt32(s);  					}  				}  				catch (FormatException e)  				{  					throw new JSchException("MaxAuthTries: " + GetConfig("MaxAuthTries")' e);  				}  				bool auth = false;  				bool auth_cancel = false;  				UserAuth ua = null;  				try  				{  					Type c = Sharpen.Runtime.GetType(GetConfig("userauth.none"));  					ua = (UserAuth)(System.Activator.CreateInstance(c));  				}  				catch (Exception e)  				{  					throw new JSchException(e.ToString()' e);  				}  				auth = ua.Start(this);  				string cmethods = GetConfig("PreferredAuthentications");  				string[] cmethoda = Util.Split(cmethods' "'");  				string smethods = null;  				if (!auth)  				{  					smethods = ((UserAuthNone)ua).GetMethods();  					if (smethods != null)  					{  						smethods = smethods.ToLower();  					}  					else  					{  						// methods: publickey'password'keyboard-interactive  						//smethods="publickey'password'keyboard-interactive";  						smethods = cmethods;  					}  				}  				string[] smethoda = Util.Split(smethods' "'");  				int methodi = 0;  				while (true)  				{  					while (!auth && cmethoda != null && methodi < cmethoda.Length)  					{  						string method = cmethoda[methodi++];  						bool acceptable = false;  						for (int k = 0; k < smethoda.Length; k++)  						{  							if (smethoda[k].Equals(method))  							{  								acceptable = true;  								break;  							}  						}  						if (!acceptable)  						{  							continue;  						}  						//System.err.println("  method: "+method);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							string str = "Authentications that can continue: ";  							for (int k_1 = methodi - 1; k_1 < cmethoda.Length; k_1++)  							{  								str += cmethoda[k_1];  								if (k_1 + 1 < cmethoda.Length)  								{  									str += "'";  								}  							}  							JSch.GetLogger().Log(Logger.INFO' str);  							JSch.GetLogger().Log(Logger.INFO' "Next authentication method: " + method);  						}  						ua = null;  						try  						{  							Type c = null;  							if (GetConfig("userauth." + method) != null)  							{  								c = Sharpen.Runtime.GetType(GetConfig("userauth." + method));  								ua = (UserAuth)(System.Activator.CreateInstance(c));  							}  						}  						catch (Exception)  						{  							if (JSch.GetLogger().IsEnabled(Logger.WARN))  							{  								JSch.GetLogger().Log(Logger.WARN' "failed to load " + method + " method");  							}  						}  						if (ua != null)  						{  							auth_cancel = false;  							try  							{  								auth = ua.Start(this);  								if (auth && JSch.GetLogger().IsEnabled(Logger.INFO))  								{  									JSch.GetLogger().Log(Logger.INFO' "Authentication succeeded (" + method + ").");  								}  							}  							catch (JSchAuthCancelException)  							{  								auth_cancel = true;  							}  							catch (JSchPartialAuthException ee)  							{  								string tmp = smethods;  								smethods = ee.GetMethods();  								smethoda = Util.Split(smethods' "'");  								if (!tmp.Equals(smethods))  								{  									methodi = 0;  								}  								//System.err.println("PartialAuth: "+methods);  								auth_cancel = false;  								goto loop_continue;  							}  							catch (RuntimeException ee)  							{  								throw;  							}  							catch (Exception)  							{  								//System.err.println("ee: "+ee); // SSH_MSG_DISCONNECT: 2 Too many authentication failures  								goto loop_break;  							}  						}  					}  					break;  loop_continue: ;  				}  loop_break: ;  				if (!auth)  				{  					if (auth_failures >= max_auth_tries)  					{  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "Login trials exceeds " + max_auth_tries);  						}  					}  					if (auth_cancel)  					{  						throw new JSchException("Auth cancel");  					}  					throw new JSchException("Auth fail");  				}  				if (connectTimeout > 0 || timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				isAuthed = true;  				lock (Lock)  				{  					if (isConnected)  					{  						connectThread = new Sharpen.Thread(this);  						connectThread.SetName("Connect thread " + host + " session");  						if (daemon_thread)  						{  							connectThread.SetDaemon(daemon_thread);  						}  						connectThread.SetDaemon (true);  						connectThread.Start();  					}  				}  			}  			catch (Exception e)  			{  				// The session has been already down and  				// we don't have to start new thread.  				in_kex = false;  				if (isConnected)  				{  					try  					{  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_DISCONNECT));  						buf.PutInt(3);  						buf.PutString(Util.Str2byte(e.ToString()));  						buf.PutString(Util.Str2byte("en"));  						Write(packet);  						Disconnect();  					}  					catch (Exception)  					{  					}  				}  				isConnected = false;  				//e.printStackTrace();  				if (e is RuntimeException)  				{  					throw (RuntimeException)e;  				}  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				throw new JSchException("Session.connect: " + e);  			}  			finally  			{  				Util.Bzero(this.password);  				this.password = null;  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Connect,The following statement contains a magic number: try  			{  				int i;  				int j;  				if (proxy == null)  				{  					InputStream @in;  					OutputStream @out;  					if (socket_factory == null)  					{  						socket = Util.CreateSocket(host' port' connectTimeout);  						@in = socket.GetInputStream();  						@out = socket.GetOutputStream();  					}  					else  					{  						socket = socket_factory.CreateSocket(host' port);  						@in = socket_factory.GetInputStream(socket);  						@out = socket_factory.GetOutputStream(socket);  					}  					//if(timeout>0){ socket.setSoTimeout(timeout); }  					socket.NoDelay = true;  					io.SetInputStream(@in);  					io.SetOutputStream(@out);  				}  				else  				{  					lock (proxy)  					{  						proxy.Connect(socket_factory' host' port' connectTimeout);  						io.SetInputStream(proxy.GetInputStream());  						io.SetOutputStream(proxy.GetOutputStream());  						socket = proxy.GetSocket();  					}  				}  				if (connectTimeout > 0 && socket != null)  				{  					socket.ReceiveTimeout = connectTimeout;  				}  				isConnected = true;  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Connection established");  				}  				jsch.AddSession(this);  				{  					// Some Cisco devices will miss to read '\n' if it is sent separately.  					byte[] foo = new byte[V_C.Length + 1];  					System.Array.Copy(V_C' 0' foo' 0' V_C.Length);  					foo[foo.Length - 1] = unchecked((byte)(byte)('\n'));  					io.Put(foo' 0' foo.Length);  				}  				while (true)  				{  					i = 0;  					j = 0;  					while (i < buf.buffer.Length)  					{  						j = io.GetByte();  						if (j < 0)  						{  							break;  						}  						buf.buffer[i] = unchecked((byte)j);  						i++;  						if (j == 10)  						{  							break;  						}  					}  					if (j < 0)  					{  						throw new JSchException("connection is closed by foreign host");  					}  					if (buf.buffer[i - 1] == 10)  					{  						// 0x0a  						i--;  						if (i > 0 && buf.buffer[i - 1] == 13)  						{  							// 0x0d  							i--;  						}  					}  					if (i <= 3 || ((i != buf.buffer.Length) && (buf.buffer[0] != 'S' || buf.buffer[1]  						 != 'S' || buf.buffer[2] != 'H' || buf.buffer[3] != '-')))  					{  						// It must not start with 'SSH-'  						//System.err.println(new String(buf.buffer' 0' i);  						continue;  					}  					if (i == buf.buffer.Length || i < 7 || (buf.buffer[4] == '1' && buf.buffer[6] !=   						'9'))  					{  						// SSH-1.99 or SSH-2.0  						// SSH-1.5  						throw new JSchException("invalid server's version string");  					}  					break;  				}  				V_S = new byte[i];  				System.Array.Copy(buf.buffer' 0' V_S' 0' i);  				//System.err.println("V_S: ("+i+") ["+new String(V_S)+"]");  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Remote version string: " + Util.Byte2str(V_S));  					JSch.GetLogger().Log(Logger.INFO' "Local version string: " + Util.Byte2str(V_C));  				}  				Send_kexinit();  				buf = Read(buf);  				if (buf.GetCommand() != SSH_MSG_KEXINIT)  				{  					in_kex = false;  					throw new JSchException("invalid protocol: " + buf.GetCommand());  				}  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEXINIT received");  				}  				KeyExchange kex = Receive_kexinit(buf);  				while (true)  				{  					buf = Read(buf);  					if (kex.GetState() == buf.GetCommand())  					{  						kex_start_time = Runtime.CurrentTimeMillis();  						bool result = kex.Next(buf);  						if (!result)  						{  							//System.err.println("verify: "+result);  							in_kex = false;  							throw new JSchException("verify: " + result);  						}  					}  					else  					{  						in_kex = false;  						throw new JSchException("invalid protocol(kex): " + buf.GetCommand());  					}  					if (kex.GetState() == KeyExchange.STATE_END)  					{  						break;  					}  				}  				try  				{  					CheckHost(host' port' kex);  				}  				catch (JSchException ee)  				{  					in_kex = false;  					throw;  				}  				Send_newkeys();  				// receive SSH_MSG_NEWKEYS(21)  				buf = Read(buf);  				//System.err.println("read: 21 ? "+buf.getCommand());  				if (buf.GetCommand() == SSH_MSG_NEWKEYS)  				{  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_NEWKEYS received");  					}  					Receive_newkeys(buf' kex);  				}  				else  				{  					in_kex = false;  					throw new JSchException("invalid protocol(newkyes): " + buf.GetCommand());  				}  				try  				{  					string s = GetConfig("MaxAuthTries");  					if (s != null)  					{  						max_auth_tries = System.Convert.ToInt32(s);  					}  				}  				catch (FormatException e)  				{  					throw new JSchException("MaxAuthTries: " + GetConfig("MaxAuthTries")' e);  				}  				bool auth = false;  				bool auth_cancel = false;  				UserAuth ua = null;  				try  				{  					Type c = Sharpen.Runtime.GetType(GetConfig("userauth.none"));  					ua = (UserAuth)(System.Activator.CreateInstance(c));  				}  				catch (Exception e)  				{  					throw new JSchException(e.ToString()' e);  				}  				auth = ua.Start(this);  				string cmethods = GetConfig("PreferredAuthentications");  				string[] cmethoda = Util.Split(cmethods' "'");  				string smethods = null;  				if (!auth)  				{  					smethods = ((UserAuthNone)ua).GetMethods();  					if (smethods != null)  					{  						smethods = smethods.ToLower();  					}  					else  					{  						// methods: publickey'password'keyboard-interactive  						//smethods="publickey'password'keyboard-interactive";  						smethods = cmethods;  					}  				}  				string[] smethoda = Util.Split(smethods' "'");  				int methodi = 0;  				while (true)  				{  					while (!auth && cmethoda != null && methodi < cmethoda.Length)  					{  						string method = cmethoda[methodi++];  						bool acceptable = false;  						for (int k = 0; k < smethoda.Length; k++)  						{  							if (smethoda[k].Equals(method))  							{  								acceptable = true;  								break;  							}  						}  						if (!acceptable)  						{  							continue;  						}  						//System.err.println("  method: "+method);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							string str = "Authentications that can continue: ";  							for (int k_1 = methodi - 1; k_1 < cmethoda.Length; k_1++)  							{  								str += cmethoda[k_1];  								if (k_1 + 1 < cmethoda.Length)  								{  									str += "'";  								}  							}  							JSch.GetLogger().Log(Logger.INFO' str);  							JSch.GetLogger().Log(Logger.INFO' "Next authentication method: " + method);  						}  						ua = null;  						try  						{  							Type c = null;  							if (GetConfig("userauth." + method) != null)  							{  								c = Sharpen.Runtime.GetType(GetConfig("userauth." + method));  								ua = (UserAuth)(System.Activator.CreateInstance(c));  							}  						}  						catch (Exception)  						{  							if (JSch.GetLogger().IsEnabled(Logger.WARN))  							{  								JSch.GetLogger().Log(Logger.WARN' "failed to load " + method + " method");  							}  						}  						if (ua != null)  						{  							auth_cancel = false;  							try  							{  								auth = ua.Start(this);  								if (auth && JSch.GetLogger().IsEnabled(Logger.INFO))  								{  									JSch.GetLogger().Log(Logger.INFO' "Authentication succeeded (" + method + ").");  								}  							}  							catch (JSchAuthCancelException)  							{  								auth_cancel = true;  							}  							catch (JSchPartialAuthException ee)  							{  								string tmp = smethods;  								smethods = ee.GetMethods();  								smethoda = Util.Split(smethods' "'");  								if (!tmp.Equals(smethods))  								{  									methodi = 0;  								}  								//System.err.println("PartialAuth: "+methods);  								auth_cancel = false;  								goto loop_continue;  							}  							catch (RuntimeException ee)  							{  								throw;  							}  							catch (Exception)  							{  								//System.err.println("ee: "+ee); // SSH_MSG_DISCONNECT: 2 Too many authentication failures  								goto loop_break;  							}  						}  					}  					break;  loop_continue: ;  				}  loop_break: ;  				if (!auth)  				{  					if (auth_failures >= max_auth_tries)  					{  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "Login trials exceeds " + max_auth_tries);  						}  					}  					if (auth_cancel)  					{  						throw new JSchException("Auth cancel");  					}  					throw new JSchException("Auth fail");  				}  				if (connectTimeout > 0 || timeout > 0)  				{  					socket.ReceiveTimeout = timeout;  				}  				isAuthed = true;  				lock (Lock)  				{  					if (isConnected)  					{  						connectThread = new Sharpen.Thread(this);  						connectThread.SetName("Connect thread " + host + " session");  						if (daemon_thread)  						{  							connectThread.SetDaemon(daemon_thread);  						}  						connectThread.SetDaemon (true);  						connectThread.Start();  					}  				}  			}  			catch (Exception e)  			{  				// The session has been already down and  				// we don't have to start new thread.  				in_kex = false;  				if (isConnected)  				{  					try  					{  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_DISCONNECT));  						buf.PutInt(3);  						buf.PutString(Util.Str2byte(e.ToString()));  						buf.PutString(Util.Str2byte("en"));  						Write(packet);  						Disconnect();  					}  					catch (Exception)  					{  					}  				}  				isConnected = false;  				//e.printStackTrace();  				if (e is RuntimeException)  				{  					throw (RuntimeException)e;  				}  				if (e is JSchException)  				{  					throw (JSchException)e;  				}  				throw new JSchException("Session.connect: " + e);  			}  			finally  			{  				Util.Bzero(this.password);  				this.password = null;  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Receive_kexinit,The following statement contains a magic number: if (j != buf.GetLength())  			{  				// packet was compressed and  				buf.GetByte();  				// j is the size of deflated packet.  				I_S = new byte[buf.index - 5];  			}  			else  			{  				I_S = new byte[j - 1 - buf.GetByte()];  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Send_kexinit,The following statement contains a magic number: lock (random)  			{  				random.Fill(buf.buffer' buf.index' 16);  				buf.Skip(16);  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Send_kexinit,The following statement contains a magic number: lock (random)  			{  				random.Fill(buf.buffer' buf.index' 16);  				buf.Skip(16);  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Send_kexinit,The following statement contains a magic number: buf.SetOffSet(5);
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,CheckHost,The following statement contains a magic number: if (hostKeyAlias == null && port != 22)  			{  				chost = ("[" + chost + "]:" + port);  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Encode,The following statement contains a magic number: if (deflater != null)  			{  				compress_len[0] = packet.buffer.index;  				packet.buffer.buffer = deflater.Compress(packet.buffer.buffer' 5' compress_len);  				packet.buffer.index = compress_len[0];  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Encode,The following statement contains a magic number: if (c2scipher != null)  			{  				//packet.padding(c2scipher.getIVSize());  				packet.Padding(c2scipher_size);  				int pad = packet.buffer.buffer[4];  				lock (random)  				{  					random.Fill(packet.buffer.buffer' packet.buffer.index - pad' pad);  				}  			}  			else  			{  				packet.Padding(8);  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Encode,The following statement contains a magic number: if (c2scipher != null)  			{  				//packet.padding(c2scipher.getIVSize());  				packet.Padding(c2scipher_size);  				int pad = packet.buffer.buffer[4];  				lock (random)  				{  					random.Fill(packet.buffer.buffer' packet.buffer.index - pad' pad);  				}  			}  			else  			{  				packet.Padding(8);  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: while (true)  			{  				buf.Reset();  				io.GetByte(buf.buffer' buf.index' s2ccipher_size);  				buf.index += s2ccipher_size;  				if (s2ccipher != null)  				{  					s2ccipher.Update(buf.buffer' 0' s2ccipher_size' buf.buffer' 0);  				}  				j = ((buf.buffer[0] << 24) & unchecked((int)(0xff000000))) | ((buf.buffer[1] << 16  					) & unchecked((int)(0x00ff0000))) | ((buf.buffer[2] << 8) & unchecked((int)(0x0000ff00  					))) | ((buf.buffer[3]) & unchecked((int)(0x000000ff)));  				// RFC 4253 6.1. Maximum Packet Length  				if (j < 5 || j > PACKET_MAX_SIZE)  				{  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE);  				}  				int need = j + 4 - s2ccipher_size;  				//if(need<0){  				//  throw new IOException("invalid data");  				//}  				if ((buf.index + need) > buf.buffer.Length)  				{  					byte[] foo = new byte[buf.index + need];  					System.Array.Copy(buf.buffer' 0' foo' 0' buf.index);  					buf.buffer = foo;  				}  				if ((need % s2ccipher_size) != 0)  				{  					string message = "Bad packet length " + need;  					if (JSch.GetLogger().IsEnabled(Logger.FATAL))  					{  						JSch.GetLogger().Log(Logger.FATAL' message);  					}  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - s2ccipher_size);  				}  				if (need > 0)  				{  					io.GetByte(buf.buffer' buf.index' need);  					buf.index += (need);  					if (s2ccipher != null)  					{  						s2ccipher.Update(buf.buffer' s2ccipher_size' need' buf.buffer' s2ccipher_size);  					}  				}  				if (s2cmac != null)  				{  					s2cmac.Update(seqi);  					s2cmac.Update(buf.buffer' 0' buf.index);  					s2cmac.DoFinal(s2cmac_result1' 0);  					io.GetByte(s2cmac_result2' 0' s2cmac_result2.Length);  					if (!Arrays.Equals(s2cmac_result1' s2cmac_result2))  					{  						if (need > PACKET_MAX_SIZE)  						{  							throw new IOException("MAC Error");  						}  						Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - need);  						continue;  					}  				}  				seqi++;  				if (inflater != null)  				{  					//inflater.uncompress(buf);  					int pad = buf.buffer[4];  					uncompress_len[0] = buf.index - 5 - pad;  					byte[] foo = inflater.Uncompress(buf.buffer' 5' uncompress_len);  					if (foo != null)  					{  						buf.buffer = foo;  						buf.index = 5 + uncompress_len[0];  					}  					else  					{  						System.Console.Error.WriteLine("fail in inflater");  						break;  					}  				}  				int type = buf.GetCommand() & unchecked((int)(0xff));  				//System.err.println("read: "+type);  				if (type == SSH_MSG_DISCONNECT)  				{  					buf.Rewind();  					buf.GetInt();  					buf.GetShort();  					int reason_code = buf.GetInt();  					byte[] description = buf.GetString();  					byte[] language_tag = buf.GetString();  					throw new JSchException("SSH_MSG_DISCONNECT: " + reason_code + " " + Util.Byte2str  						(description) + " " + Util.Byte2str(language_tag));  				}  				else  				{  					//break;  					if (type == SSH_MSG_IGNORE)  					{  					}  					else  					{  						if (type == SSH_MSG_UNIMPLEMENTED)  						{  							buf.Rewind();  							buf.GetInt();  							buf.GetShort();  							int reason_id = buf.GetInt();  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "Received SSH_MSG_UNIMPLEMENTED for " + reason_id  									);  							}  						}  						else  						{  							if (type == SSH_MSG_DEBUG)  							{  								buf.Rewind();  								buf.GetInt();  								buf.GetShort();  							}  							else  							{  								if (type == SSH_MSG_CHANNEL_WINDOW_ADJUST)  								{  									buf.Rewind();  									buf.GetInt();  									buf.GetShort();  									Channel c = Channel.GetChannel(buf.GetInt()' this);  									if (c == null)  									{  									}  									else  									{  										c.AddRemoteWindowSize(buf.GetInt());  									}  								}  								else  								{  									if (type == UserAuth.SSH_MSG_USERAUTH_SUCCESS)  									{  										isAuthed = true;  										if (inflater == null && deflater == null)  										{  											string method;  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_CTOS];  											InitDeflater(method);  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_STOC];  											InitInflater(method);  										}  										break;  									}  									else  									{  										break;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: while (true)  			{  				buf.Reset();  				io.GetByte(buf.buffer' buf.index' s2ccipher_size);  				buf.index += s2ccipher_size;  				if (s2ccipher != null)  				{  					s2ccipher.Update(buf.buffer' 0' s2ccipher_size' buf.buffer' 0);  				}  				j = ((buf.buffer[0] << 24) & unchecked((int)(0xff000000))) | ((buf.buffer[1] << 16  					) & unchecked((int)(0x00ff0000))) | ((buf.buffer[2] << 8) & unchecked((int)(0x0000ff00  					))) | ((buf.buffer[3]) & unchecked((int)(0x000000ff)));  				// RFC 4253 6.1. Maximum Packet Length  				if (j < 5 || j > PACKET_MAX_SIZE)  				{  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE);  				}  				int need = j + 4 - s2ccipher_size;  				//if(need<0){  				//  throw new IOException("invalid data");  				//}  				if ((buf.index + need) > buf.buffer.Length)  				{  					byte[] foo = new byte[buf.index + need];  					System.Array.Copy(buf.buffer' 0' foo' 0' buf.index);  					buf.buffer = foo;  				}  				if ((need % s2ccipher_size) != 0)  				{  					string message = "Bad packet length " + need;  					if (JSch.GetLogger().IsEnabled(Logger.FATAL))  					{  						JSch.GetLogger().Log(Logger.FATAL' message);  					}  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - s2ccipher_size);  				}  				if (need > 0)  				{  					io.GetByte(buf.buffer' buf.index' need);  					buf.index += (need);  					if (s2ccipher != null)  					{  						s2ccipher.Update(buf.buffer' s2ccipher_size' need' buf.buffer' s2ccipher_size);  					}  				}  				if (s2cmac != null)  				{  					s2cmac.Update(seqi);  					s2cmac.Update(buf.buffer' 0' buf.index);  					s2cmac.DoFinal(s2cmac_result1' 0);  					io.GetByte(s2cmac_result2' 0' s2cmac_result2.Length);  					if (!Arrays.Equals(s2cmac_result1' s2cmac_result2))  					{  						if (need > PACKET_MAX_SIZE)  						{  							throw new IOException("MAC Error");  						}  						Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - need);  						continue;  					}  				}  				seqi++;  				if (inflater != null)  				{  					//inflater.uncompress(buf);  					int pad = buf.buffer[4];  					uncompress_len[0] = buf.index - 5 - pad;  					byte[] foo = inflater.Uncompress(buf.buffer' 5' uncompress_len);  					if (foo != null)  					{  						buf.buffer = foo;  						buf.index = 5 + uncompress_len[0];  					}  					else  					{  						System.Console.Error.WriteLine("fail in inflater");  						break;  					}  				}  				int type = buf.GetCommand() & unchecked((int)(0xff));  				//System.err.println("read: "+type);  				if (type == SSH_MSG_DISCONNECT)  				{  					buf.Rewind();  					buf.GetInt();  					buf.GetShort();  					int reason_code = buf.GetInt();  					byte[] description = buf.GetString();  					byte[] language_tag = buf.GetString();  					throw new JSchException("SSH_MSG_DISCONNECT: " + reason_code + " " + Util.Byte2str  						(description) + " " + Util.Byte2str(language_tag));  				}  				else  				{  					//break;  					if (type == SSH_MSG_IGNORE)  					{  					}  					else  					{  						if (type == SSH_MSG_UNIMPLEMENTED)  						{  							buf.Rewind();  							buf.GetInt();  							buf.GetShort();  							int reason_id = buf.GetInt();  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "Received SSH_MSG_UNIMPLEMENTED for " + reason_id  									);  							}  						}  						else  						{  							if (type == SSH_MSG_DEBUG)  							{  								buf.Rewind();  								buf.GetInt();  								buf.GetShort();  							}  							else  							{  								if (type == SSH_MSG_CHANNEL_WINDOW_ADJUST)  								{  									buf.Rewind();  									buf.GetInt();  									buf.GetShort();  									Channel c = Channel.GetChannel(buf.GetInt()' this);  									if (c == null)  									{  									}  									else  									{  										c.AddRemoteWindowSize(buf.GetInt());  									}  								}  								else  								{  									if (type == UserAuth.SSH_MSG_USERAUTH_SUCCESS)  									{  										isAuthed = true;  										if (inflater == null && deflater == null)  										{  											string method;  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_CTOS];  											InitDeflater(method);  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_STOC];  											InitInflater(method);  										}  										break;  									}  									else  									{  										break;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: while (true)  			{  				buf.Reset();  				io.GetByte(buf.buffer' buf.index' s2ccipher_size);  				buf.index += s2ccipher_size;  				if (s2ccipher != null)  				{  					s2ccipher.Update(buf.buffer' 0' s2ccipher_size' buf.buffer' 0);  				}  				j = ((buf.buffer[0] << 24) & unchecked((int)(0xff000000))) | ((buf.buffer[1] << 16  					) & unchecked((int)(0x00ff0000))) | ((buf.buffer[2] << 8) & unchecked((int)(0x0000ff00  					))) | ((buf.buffer[3]) & unchecked((int)(0x000000ff)));  				// RFC 4253 6.1. Maximum Packet Length  				if (j < 5 || j > PACKET_MAX_SIZE)  				{  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE);  				}  				int need = j + 4 - s2ccipher_size;  				//if(need<0){  				//  throw new IOException("invalid data");  				//}  				if ((buf.index + need) > buf.buffer.Length)  				{  					byte[] foo = new byte[buf.index + need];  					System.Array.Copy(buf.buffer' 0' foo' 0' buf.index);  					buf.buffer = foo;  				}  				if ((need % s2ccipher_size) != 0)  				{  					string message = "Bad packet length " + need;  					if (JSch.GetLogger().IsEnabled(Logger.FATAL))  					{  						JSch.GetLogger().Log(Logger.FATAL' message);  					}  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - s2ccipher_size);  				}  				if (need > 0)  				{  					io.GetByte(buf.buffer' buf.index' need);  					buf.index += (need);  					if (s2ccipher != null)  					{  						s2ccipher.Update(buf.buffer' s2ccipher_size' need' buf.buffer' s2ccipher_size);  					}  				}  				if (s2cmac != null)  				{  					s2cmac.Update(seqi);  					s2cmac.Update(buf.buffer' 0' buf.index);  					s2cmac.DoFinal(s2cmac_result1' 0);  					io.GetByte(s2cmac_result2' 0' s2cmac_result2.Length);  					if (!Arrays.Equals(s2cmac_result1' s2cmac_result2))  					{  						if (need > PACKET_MAX_SIZE)  						{  							throw new IOException("MAC Error");  						}  						Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - need);  						continue;  					}  				}  				seqi++;  				if (inflater != null)  				{  					//inflater.uncompress(buf);  					int pad = buf.buffer[4];  					uncompress_len[0] = buf.index - 5 - pad;  					byte[] foo = inflater.Uncompress(buf.buffer' 5' uncompress_len);  					if (foo != null)  					{  						buf.buffer = foo;  						buf.index = 5 + uncompress_len[0];  					}  					else  					{  						System.Console.Error.WriteLine("fail in inflater");  						break;  					}  				}  				int type = buf.GetCommand() & unchecked((int)(0xff));  				//System.err.println("read: "+type);  				if (type == SSH_MSG_DISCONNECT)  				{  					buf.Rewind();  					buf.GetInt();  					buf.GetShort();  					int reason_code = buf.GetInt();  					byte[] description = buf.GetString();  					byte[] language_tag = buf.GetString();  					throw new JSchException("SSH_MSG_DISCONNECT: " + reason_code + " " + Util.Byte2str  						(description) + " " + Util.Byte2str(language_tag));  				}  				else  				{  					//break;  					if (type == SSH_MSG_IGNORE)  					{  					}  					else  					{  						if (type == SSH_MSG_UNIMPLEMENTED)  						{  							buf.Rewind();  							buf.GetInt();  							buf.GetShort();  							int reason_id = buf.GetInt();  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "Received SSH_MSG_UNIMPLEMENTED for " + reason_id  									);  							}  						}  						else  						{  							if (type == SSH_MSG_DEBUG)  							{  								buf.Rewind();  								buf.GetInt();  								buf.GetShort();  							}  							else  							{  								if (type == SSH_MSG_CHANNEL_WINDOW_ADJUST)  								{  									buf.Rewind();  									buf.GetInt();  									buf.GetShort();  									Channel c = Channel.GetChannel(buf.GetInt()' this);  									if (c == null)  									{  									}  									else  									{  										c.AddRemoteWindowSize(buf.GetInt());  									}  								}  								else  								{  									if (type == UserAuth.SSH_MSG_USERAUTH_SUCCESS)  									{  										isAuthed = true;  										if (inflater == null && deflater == null)  										{  											string method;  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_CTOS];  											InitDeflater(method);  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_STOC];  											InitInflater(method);  										}  										break;  									}  									else  									{  										break;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: while (true)  			{  				buf.Reset();  				io.GetByte(buf.buffer' buf.index' s2ccipher_size);  				buf.index += s2ccipher_size;  				if (s2ccipher != null)  				{  					s2ccipher.Update(buf.buffer' 0' s2ccipher_size' buf.buffer' 0);  				}  				j = ((buf.buffer[0] << 24) & unchecked((int)(0xff000000))) | ((buf.buffer[1] << 16  					) & unchecked((int)(0x00ff0000))) | ((buf.buffer[2] << 8) & unchecked((int)(0x0000ff00  					))) | ((buf.buffer[3]) & unchecked((int)(0x000000ff)));  				// RFC 4253 6.1. Maximum Packet Length  				if (j < 5 || j > PACKET_MAX_SIZE)  				{  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE);  				}  				int need = j + 4 - s2ccipher_size;  				//if(need<0){  				//  throw new IOException("invalid data");  				//}  				if ((buf.index + need) > buf.buffer.Length)  				{  					byte[] foo = new byte[buf.index + need];  					System.Array.Copy(buf.buffer' 0' foo' 0' buf.index);  					buf.buffer = foo;  				}  				if ((need % s2ccipher_size) != 0)  				{  					string message = "Bad packet length " + need;  					if (JSch.GetLogger().IsEnabled(Logger.FATAL))  					{  						JSch.GetLogger().Log(Logger.FATAL' message);  					}  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - s2ccipher_size);  				}  				if (need > 0)  				{  					io.GetByte(buf.buffer' buf.index' need);  					buf.index += (need);  					if (s2ccipher != null)  					{  						s2ccipher.Update(buf.buffer' s2ccipher_size' need' buf.buffer' s2ccipher_size);  					}  				}  				if (s2cmac != null)  				{  					s2cmac.Update(seqi);  					s2cmac.Update(buf.buffer' 0' buf.index);  					s2cmac.DoFinal(s2cmac_result1' 0);  					io.GetByte(s2cmac_result2' 0' s2cmac_result2.Length);  					if (!Arrays.Equals(s2cmac_result1' s2cmac_result2))  					{  						if (need > PACKET_MAX_SIZE)  						{  							throw new IOException("MAC Error");  						}  						Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - need);  						continue;  					}  				}  				seqi++;  				if (inflater != null)  				{  					//inflater.uncompress(buf);  					int pad = buf.buffer[4];  					uncompress_len[0] = buf.index - 5 - pad;  					byte[] foo = inflater.Uncompress(buf.buffer' 5' uncompress_len);  					if (foo != null)  					{  						buf.buffer = foo;  						buf.index = 5 + uncompress_len[0];  					}  					else  					{  						System.Console.Error.WriteLine("fail in inflater");  						break;  					}  				}  				int type = buf.GetCommand() & unchecked((int)(0xff));  				//System.err.println("read: "+type);  				if (type == SSH_MSG_DISCONNECT)  				{  					buf.Rewind();  					buf.GetInt();  					buf.GetShort();  					int reason_code = buf.GetInt();  					byte[] description = buf.GetString();  					byte[] language_tag = buf.GetString();  					throw new JSchException("SSH_MSG_DISCONNECT: " + reason_code + " " + Util.Byte2str  						(description) + " " + Util.Byte2str(language_tag));  				}  				else  				{  					//break;  					if (type == SSH_MSG_IGNORE)  					{  					}  					else  					{  						if (type == SSH_MSG_UNIMPLEMENTED)  						{  							buf.Rewind();  							buf.GetInt();  							buf.GetShort();  							int reason_id = buf.GetInt();  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "Received SSH_MSG_UNIMPLEMENTED for " + reason_id  									);  							}  						}  						else  						{  							if (type == SSH_MSG_DEBUG)  							{  								buf.Rewind();  								buf.GetInt();  								buf.GetShort();  							}  							else  							{  								if (type == SSH_MSG_CHANNEL_WINDOW_ADJUST)  								{  									buf.Rewind();  									buf.GetInt();  									buf.GetShort();  									Channel c = Channel.GetChannel(buf.GetInt()' this);  									if (c == null)  									{  									}  									else  									{  										c.AddRemoteWindowSize(buf.GetInt());  									}  								}  								else  								{  									if (type == UserAuth.SSH_MSG_USERAUTH_SUCCESS)  									{  										isAuthed = true;  										if (inflater == null && deflater == null)  										{  											string method;  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_CTOS];  											InitDeflater(method);  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_STOC];  											InitInflater(method);  										}  										break;  									}  									else  									{  										break;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: while (true)  			{  				buf.Reset();  				io.GetByte(buf.buffer' buf.index' s2ccipher_size);  				buf.index += s2ccipher_size;  				if (s2ccipher != null)  				{  					s2ccipher.Update(buf.buffer' 0' s2ccipher_size' buf.buffer' 0);  				}  				j = ((buf.buffer[0] << 24) & unchecked((int)(0xff000000))) | ((buf.buffer[1] << 16  					) & unchecked((int)(0x00ff0000))) | ((buf.buffer[2] << 8) & unchecked((int)(0x0000ff00  					))) | ((buf.buffer[3]) & unchecked((int)(0x000000ff)));  				// RFC 4253 6.1. Maximum Packet Length  				if (j < 5 || j > PACKET_MAX_SIZE)  				{  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE);  				}  				int need = j + 4 - s2ccipher_size;  				//if(need<0){  				//  throw new IOException("invalid data");  				//}  				if ((buf.index + need) > buf.buffer.Length)  				{  					byte[] foo = new byte[buf.index + need];  					System.Array.Copy(buf.buffer' 0' foo' 0' buf.index);  					buf.buffer = foo;  				}  				if ((need % s2ccipher_size) != 0)  				{  					string message = "Bad packet length " + need;  					if (JSch.GetLogger().IsEnabled(Logger.FATAL))  					{  						JSch.GetLogger().Log(Logger.FATAL' message);  					}  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - s2ccipher_size);  				}  				if (need > 0)  				{  					io.GetByte(buf.buffer' buf.index' need);  					buf.index += (need);  					if (s2ccipher != null)  					{  						s2ccipher.Update(buf.buffer' s2ccipher_size' need' buf.buffer' s2ccipher_size);  					}  				}  				if (s2cmac != null)  				{  					s2cmac.Update(seqi);  					s2cmac.Update(buf.buffer' 0' buf.index);  					s2cmac.DoFinal(s2cmac_result1' 0);  					io.GetByte(s2cmac_result2' 0' s2cmac_result2.Length);  					if (!Arrays.Equals(s2cmac_result1' s2cmac_result2))  					{  						if (need > PACKET_MAX_SIZE)  						{  							throw new IOException("MAC Error");  						}  						Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - need);  						continue;  					}  				}  				seqi++;  				if (inflater != null)  				{  					//inflater.uncompress(buf);  					int pad = buf.buffer[4];  					uncompress_len[0] = buf.index - 5 - pad;  					byte[] foo = inflater.Uncompress(buf.buffer' 5' uncompress_len);  					if (foo != null)  					{  						buf.buffer = foo;  						buf.index = 5 + uncompress_len[0];  					}  					else  					{  						System.Console.Error.WriteLine("fail in inflater");  						break;  					}  				}  				int type = buf.GetCommand() & unchecked((int)(0xff));  				//System.err.println("read: "+type);  				if (type == SSH_MSG_DISCONNECT)  				{  					buf.Rewind();  					buf.GetInt();  					buf.GetShort();  					int reason_code = buf.GetInt();  					byte[] description = buf.GetString();  					byte[] language_tag = buf.GetString();  					throw new JSchException("SSH_MSG_DISCONNECT: " + reason_code + " " + Util.Byte2str  						(description) + " " + Util.Byte2str(language_tag));  				}  				else  				{  					//break;  					if (type == SSH_MSG_IGNORE)  					{  					}  					else  					{  						if (type == SSH_MSG_UNIMPLEMENTED)  						{  							buf.Rewind();  							buf.GetInt();  							buf.GetShort();  							int reason_id = buf.GetInt();  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "Received SSH_MSG_UNIMPLEMENTED for " + reason_id  									);  							}  						}  						else  						{  							if (type == SSH_MSG_DEBUG)  							{  								buf.Rewind();  								buf.GetInt();  								buf.GetShort();  							}  							else  							{  								if (type == SSH_MSG_CHANNEL_WINDOW_ADJUST)  								{  									buf.Rewind();  									buf.GetInt();  									buf.GetShort();  									Channel c = Channel.GetChannel(buf.GetInt()' this);  									if (c == null)  									{  									}  									else  									{  										c.AddRemoteWindowSize(buf.GetInt());  									}  								}  								else  								{  									if (type == UserAuth.SSH_MSG_USERAUTH_SUCCESS)  									{  										isAuthed = true;  										if (inflater == null && deflater == null)  										{  											string method;  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_CTOS];  											InitDeflater(method);  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_STOC];  											InitInflater(method);  										}  										break;  									}  									else  									{  										break;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: while (true)  			{  				buf.Reset();  				io.GetByte(buf.buffer' buf.index' s2ccipher_size);  				buf.index += s2ccipher_size;  				if (s2ccipher != null)  				{  					s2ccipher.Update(buf.buffer' 0' s2ccipher_size' buf.buffer' 0);  				}  				j = ((buf.buffer[0] << 24) & unchecked((int)(0xff000000))) | ((buf.buffer[1] << 16  					) & unchecked((int)(0x00ff0000))) | ((buf.buffer[2] << 8) & unchecked((int)(0x0000ff00  					))) | ((buf.buffer[3]) & unchecked((int)(0x000000ff)));  				// RFC 4253 6.1. Maximum Packet Length  				if (j < 5 || j > PACKET_MAX_SIZE)  				{  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE);  				}  				int need = j + 4 - s2ccipher_size;  				//if(need<0){  				//  throw new IOException("invalid data");  				//}  				if ((buf.index + need) > buf.buffer.Length)  				{  					byte[] foo = new byte[buf.index + need];  					System.Array.Copy(buf.buffer' 0' foo' 0' buf.index);  					buf.buffer = foo;  				}  				if ((need % s2ccipher_size) != 0)  				{  					string message = "Bad packet length " + need;  					if (JSch.GetLogger().IsEnabled(Logger.FATAL))  					{  						JSch.GetLogger().Log(Logger.FATAL' message);  					}  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - s2ccipher_size);  				}  				if (need > 0)  				{  					io.GetByte(buf.buffer' buf.index' need);  					buf.index += (need);  					if (s2ccipher != null)  					{  						s2ccipher.Update(buf.buffer' s2ccipher_size' need' buf.buffer' s2ccipher_size);  					}  				}  				if (s2cmac != null)  				{  					s2cmac.Update(seqi);  					s2cmac.Update(buf.buffer' 0' buf.index);  					s2cmac.DoFinal(s2cmac_result1' 0);  					io.GetByte(s2cmac_result2' 0' s2cmac_result2.Length);  					if (!Arrays.Equals(s2cmac_result1' s2cmac_result2))  					{  						if (need > PACKET_MAX_SIZE)  						{  							throw new IOException("MAC Error");  						}  						Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - need);  						continue;  					}  				}  				seqi++;  				if (inflater != null)  				{  					//inflater.uncompress(buf);  					int pad = buf.buffer[4];  					uncompress_len[0] = buf.index - 5 - pad;  					byte[] foo = inflater.Uncompress(buf.buffer' 5' uncompress_len);  					if (foo != null)  					{  						buf.buffer = foo;  						buf.index = 5 + uncompress_len[0];  					}  					else  					{  						System.Console.Error.WriteLine("fail in inflater");  						break;  					}  				}  				int type = buf.GetCommand() & unchecked((int)(0xff));  				//System.err.println("read: "+type);  				if (type == SSH_MSG_DISCONNECT)  				{  					buf.Rewind();  					buf.GetInt();  					buf.GetShort();  					int reason_code = buf.GetInt();  					byte[] description = buf.GetString();  					byte[] language_tag = buf.GetString();  					throw new JSchException("SSH_MSG_DISCONNECT: " + reason_code + " " + Util.Byte2str  						(description) + " " + Util.Byte2str(language_tag));  				}  				else  				{  					//break;  					if (type == SSH_MSG_IGNORE)  					{  					}  					else  					{  						if (type == SSH_MSG_UNIMPLEMENTED)  						{  							buf.Rewind();  							buf.GetInt();  							buf.GetShort();  							int reason_id = buf.GetInt();  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "Received SSH_MSG_UNIMPLEMENTED for " + reason_id  									);  							}  						}  						else  						{  							if (type == SSH_MSG_DEBUG)  							{  								buf.Rewind();  								buf.GetInt();  								buf.GetShort();  							}  							else  							{  								if (type == SSH_MSG_CHANNEL_WINDOW_ADJUST)  								{  									buf.Rewind();  									buf.GetInt();  									buf.GetShort();  									Channel c = Channel.GetChannel(buf.GetInt()' this);  									if (c == null)  									{  									}  									else  									{  										c.AddRemoteWindowSize(buf.GetInt());  									}  								}  								else  								{  									if (type == UserAuth.SSH_MSG_USERAUTH_SUCCESS)  									{  										isAuthed = true;  										if (inflater == null && deflater == null)  										{  											string method;  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_CTOS];  											InitDeflater(method);  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_STOC];  											InitInflater(method);  										}  										break;  									}  									else  									{  										break;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: while (true)  			{  				buf.Reset();  				io.GetByte(buf.buffer' buf.index' s2ccipher_size);  				buf.index += s2ccipher_size;  				if (s2ccipher != null)  				{  					s2ccipher.Update(buf.buffer' 0' s2ccipher_size' buf.buffer' 0);  				}  				j = ((buf.buffer[0] << 24) & unchecked((int)(0xff000000))) | ((buf.buffer[1] << 16  					) & unchecked((int)(0x00ff0000))) | ((buf.buffer[2] << 8) & unchecked((int)(0x0000ff00  					))) | ((buf.buffer[3]) & unchecked((int)(0x000000ff)));  				// RFC 4253 6.1. Maximum Packet Length  				if (j < 5 || j > PACKET_MAX_SIZE)  				{  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE);  				}  				int need = j + 4 - s2ccipher_size;  				//if(need<0){  				//  throw new IOException("invalid data");  				//}  				if ((buf.index + need) > buf.buffer.Length)  				{  					byte[] foo = new byte[buf.index + need];  					System.Array.Copy(buf.buffer' 0' foo' 0' buf.index);  					buf.buffer = foo;  				}  				if ((need % s2ccipher_size) != 0)  				{  					string message = "Bad packet length " + need;  					if (JSch.GetLogger().IsEnabled(Logger.FATAL))  					{  						JSch.GetLogger().Log(Logger.FATAL' message);  					}  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - s2ccipher_size);  				}  				if (need > 0)  				{  					io.GetByte(buf.buffer' buf.index' need);  					buf.index += (need);  					if (s2ccipher != null)  					{  						s2ccipher.Update(buf.buffer' s2ccipher_size' need' buf.buffer' s2ccipher_size);  					}  				}  				if (s2cmac != null)  				{  					s2cmac.Update(seqi);  					s2cmac.Update(buf.buffer' 0' buf.index);  					s2cmac.DoFinal(s2cmac_result1' 0);  					io.GetByte(s2cmac_result2' 0' s2cmac_result2.Length);  					if (!Arrays.Equals(s2cmac_result1' s2cmac_result2))  					{  						if (need > PACKET_MAX_SIZE)  						{  							throw new IOException("MAC Error");  						}  						Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - need);  						continue;  					}  				}  				seqi++;  				if (inflater != null)  				{  					//inflater.uncompress(buf);  					int pad = buf.buffer[4];  					uncompress_len[0] = buf.index - 5 - pad;  					byte[] foo = inflater.Uncompress(buf.buffer' 5' uncompress_len);  					if (foo != null)  					{  						buf.buffer = foo;  						buf.index = 5 + uncompress_len[0];  					}  					else  					{  						System.Console.Error.WriteLine("fail in inflater");  						break;  					}  				}  				int type = buf.GetCommand() & unchecked((int)(0xff));  				//System.err.println("read: "+type);  				if (type == SSH_MSG_DISCONNECT)  				{  					buf.Rewind();  					buf.GetInt();  					buf.GetShort();  					int reason_code = buf.GetInt();  					byte[] description = buf.GetString();  					byte[] language_tag = buf.GetString();  					throw new JSchException("SSH_MSG_DISCONNECT: " + reason_code + " " + Util.Byte2str  						(description) + " " + Util.Byte2str(language_tag));  				}  				else  				{  					//break;  					if (type == SSH_MSG_IGNORE)  					{  					}  					else  					{  						if (type == SSH_MSG_UNIMPLEMENTED)  						{  							buf.Rewind();  							buf.GetInt();  							buf.GetShort();  							int reason_id = buf.GetInt();  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "Received SSH_MSG_UNIMPLEMENTED for " + reason_id  									);  							}  						}  						else  						{  							if (type == SSH_MSG_DEBUG)  							{  								buf.Rewind();  								buf.GetInt();  								buf.GetShort();  							}  							else  							{  								if (type == SSH_MSG_CHANNEL_WINDOW_ADJUST)  								{  									buf.Rewind();  									buf.GetInt();  									buf.GetShort();  									Channel c = Channel.GetChannel(buf.GetInt()' this);  									if (c == null)  									{  									}  									else  									{  										c.AddRemoteWindowSize(buf.GetInt());  									}  								}  								else  								{  									if (type == UserAuth.SSH_MSG_USERAUTH_SUCCESS)  									{  										isAuthed = true;  										if (inflater == null && deflater == null)  										{  											string method;  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_CTOS];  											InitDeflater(method);  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_STOC];  											InitInflater(method);  										}  										break;  									}  									else  									{  										break;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: while (true)  			{  				buf.Reset();  				io.GetByte(buf.buffer' buf.index' s2ccipher_size);  				buf.index += s2ccipher_size;  				if (s2ccipher != null)  				{  					s2ccipher.Update(buf.buffer' 0' s2ccipher_size' buf.buffer' 0);  				}  				j = ((buf.buffer[0] << 24) & unchecked((int)(0xff000000))) | ((buf.buffer[1] << 16  					) & unchecked((int)(0x00ff0000))) | ((buf.buffer[2] << 8) & unchecked((int)(0x0000ff00  					))) | ((buf.buffer[3]) & unchecked((int)(0x000000ff)));  				// RFC 4253 6.1. Maximum Packet Length  				if (j < 5 || j > PACKET_MAX_SIZE)  				{  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE);  				}  				int need = j + 4 - s2ccipher_size;  				//if(need<0){  				//  throw new IOException("invalid data");  				//}  				if ((buf.index + need) > buf.buffer.Length)  				{  					byte[] foo = new byte[buf.index + need];  					System.Array.Copy(buf.buffer' 0' foo' 0' buf.index);  					buf.buffer = foo;  				}  				if ((need % s2ccipher_size) != 0)  				{  					string message = "Bad packet length " + need;  					if (JSch.GetLogger().IsEnabled(Logger.FATAL))  					{  						JSch.GetLogger().Log(Logger.FATAL' message);  					}  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - s2ccipher_size);  				}  				if (need > 0)  				{  					io.GetByte(buf.buffer' buf.index' need);  					buf.index += (need);  					if (s2ccipher != null)  					{  						s2ccipher.Update(buf.buffer' s2ccipher_size' need' buf.buffer' s2ccipher_size);  					}  				}  				if (s2cmac != null)  				{  					s2cmac.Update(seqi);  					s2cmac.Update(buf.buffer' 0' buf.index);  					s2cmac.DoFinal(s2cmac_result1' 0);  					io.GetByte(s2cmac_result2' 0' s2cmac_result2.Length);  					if (!Arrays.Equals(s2cmac_result1' s2cmac_result2))  					{  						if (need > PACKET_MAX_SIZE)  						{  							throw new IOException("MAC Error");  						}  						Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - need);  						continue;  					}  				}  				seqi++;  				if (inflater != null)  				{  					//inflater.uncompress(buf);  					int pad = buf.buffer[4];  					uncompress_len[0] = buf.index - 5 - pad;  					byte[] foo = inflater.Uncompress(buf.buffer' 5' uncompress_len);  					if (foo != null)  					{  						buf.buffer = foo;  						buf.index = 5 + uncompress_len[0];  					}  					else  					{  						System.Console.Error.WriteLine("fail in inflater");  						break;  					}  				}  				int type = buf.GetCommand() & unchecked((int)(0xff));  				//System.err.println("read: "+type);  				if (type == SSH_MSG_DISCONNECT)  				{  					buf.Rewind();  					buf.GetInt();  					buf.GetShort();  					int reason_code = buf.GetInt();  					byte[] description = buf.GetString();  					byte[] language_tag = buf.GetString();  					throw new JSchException("SSH_MSG_DISCONNECT: " + reason_code + " " + Util.Byte2str  						(description) + " " + Util.Byte2str(language_tag));  				}  				else  				{  					//break;  					if (type == SSH_MSG_IGNORE)  					{  					}  					else  					{  						if (type == SSH_MSG_UNIMPLEMENTED)  						{  							buf.Rewind();  							buf.GetInt();  							buf.GetShort();  							int reason_id = buf.GetInt();  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "Received SSH_MSG_UNIMPLEMENTED for " + reason_id  									);  							}  						}  						else  						{  							if (type == SSH_MSG_DEBUG)  							{  								buf.Rewind();  								buf.GetInt();  								buf.GetShort();  							}  							else  							{  								if (type == SSH_MSG_CHANNEL_WINDOW_ADJUST)  								{  									buf.Rewind();  									buf.GetInt();  									buf.GetShort();  									Channel c = Channel.GetChannel(buf.GetInt()' this);  									if (c == null)  									{  									}  									else  									{  										c.AddRemoteWindowSize(buf.GetInt());  									}  								}  								else  								{  									if (type == UserAuth.SSH_MSG_USERAUTH_SUCCESS)  									{  										isAuthed = true;  										if (inflater == null && deflater == null)  										{  											string method;  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_CTOS];  											InitDeflater(method);  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_STOC];  											InitInflater(method);  										}  										break;  									}  									else  									{  										break;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: while (true)  			{  				buf.Reset();  				io.GetByte(buf.buffer' buf.index' s2ccipher_size);  				buf.index += s2ccipher_size;  				if (s2ccipher != null)  				{  					s2ccipher.Update(buf.buffer' 0' s2ccipher_size' buf.buffer' 0);  				}  				j = ((buf.buffer[0] << 24) & unchecked((int)(0xff000000))) | ((buf.buffer[1] << 16  					) & unchecked((int)(0x00ff0000))) | ((buf.buffer[2] << 8) & unchecked((int)(0x0000ff00  					))) | ((buf.buffer[3]) & unchecked((int)(0x000000ff)));  				// RFC 4253 6.1. Maximum Packet Length  				if (j < 5 || j > PACKET_MAX_SIZE)  				{  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE);  				}  				int need = j + 4 - s2ccipher_size;  				//if(need<0){  				//  throw new IOException("invalid data");  				//}  				if ((buf.index + need) > buf.buffer.Length)  				{  					byte[] foo = new byte[buf.index + need];  					System.Array.Copy(buf.buffer' 0' foo' 0' buf.index);  					buf.buffer = foo;  				}  				if ((need % s2ccipher_size) != 0)  				{  					string message = "Bad packet length " + need;  					if (JSch.GetLogger().IsEnabled(Logger.FATAL))  					{  						JSch.GetLogger().Log(Logger.FATAL' message);  					}  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - s2ccipher_size);  				}  				if (need > 0)  				{  					io.GetByte(buf.buffer' buf.index' need);  					buf.index += (need);  					if (s2ccipher != null)  					{  						s2ccipher.Update(buf.buffer' s2ccipher_size' need' buf.buffer' s2ccipher_size);  					}  				}  				if (s2cmac != null)  				{  					s2cmac.Update(seqi);  					s2cmac.Update(buf.buffer' 0' buf.index);  					s2cmac.DoFinal(s2cmac_result1' 0);  					io.GetByte(s2cmac_result2' 0' s2cmac_result2.Length);  					if (!Arrays.Equals(s2cmac_result1' s2cmac_result2))  					{  						if (need > PACKET_MAX_SIZE)  						{  							throw new IOException("MAC Error");  						}  						Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - need);  						continue;  					}  				}  				seqi++;  				if (inflater != null)  				{  					//inflater.uncompress(buf);  					int pad = buf.buffer[4];  					uncompress_len[0] = buf.index - 5 - pad;  					byte[] foo = inflater.Uncompress(buf.buffer' 5' uncompress_len);  					if (foo != null)  					{  						buf.buffer = foo;  						buf.index = 5 + uncompress_len[0];  					}  					else  					{  						System.Console.Error.WriteLine("fail in inflater");  						break;  					}  				}  				int type = buf.GetCommand() & unchecked((int)(0xff));  				//System.err.println("read: "+type);  				if (type == SSH_MSG_DISCONNECT)  				{  					buf.Rewind();  					buf.GetInt();  					buf.GetShort();  					int reason_code = buf.GetInt();  					byte[] description = buf.GetString();  					byte[] language_tag = buf.GetString();  					throw new JSchException("SSH_MSG_DISCONNECT: " + reason_code + " " + Util.Byte2str  						(description) + " " + Util.Byte2str(language_tag));  				}  				else  				{  					//break;  					if (type == SSH_MSG_IGNORE)  					{  					}  					else  					{  						if (type == SSH_MSG_UNIMPLEMENTED)  						{  							buf.Rewind();  							buf.GetInt();  							buf.GetShort();  							int reason_id = buf.GetInt();  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "Received SSH_MSG_UNIMPLEMENTED for " + reason_id  									);  							}  						}  						else  						{  							if (type == SSH_MSG_DEBUG)  							{  								buf.Rewind();  								buf.GetInt();  								buf.GetShort();  							}  							else  							{  								if (type == SSH_MSG_CHANNEL_WINDOW_ADJUST)  								{  									buf.Rewind();  									buf.GetInt();  									buf.GetShort();  									Channel c = Channel.GetChannel(buf.GetInt()' this);  									if (c == null)  									{  									}  									else  									{  										c.AddRemoteWindowSize(buf.GetInt());  									}  								}  								else  								{  									if (type == UserAuth.SSH_MSG_USERAUTH_SUCCESS)  									{  										isAuthed = true;  										if (inflater == null && deflater == null)  										{  											string method;  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_CTOS];  											InitDeflater(method);  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_STOC];  											InitInflater(method);  										}  										break;  									}  									else  									{  										break;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: while (true)  			{  				buf.Reset();  				io.GetByte(buf.buffer' buf.index' s2ccipher_size);  				buf.index += s2ccipher_size;  				if (s2ccipher != null)  				{  					s2ccipher.Update(buf.buffer' 0' s2ccipher_size' buf.buffer' 0);  				}  				j = ((buf.buffer[0] << 24) & unchecked((int)(0xff000000))) | ((buf.buffer[1] << 16  					) & unchecked((int)(0x00ff0000))) | ((buf.buffer[2] << 8) & unchecked((int)(0x0000ff00  					))) | ((buf.buffer[3]) & unchecked((int)(0x000000ff)));  				// RFC 4253 6.1. Maximum Packet Length  				if (j < 5 || j > PACKET_MAX_SIZE)  				{  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE);  				}  				int need = j + 4 - s2ccipher_size;  				//if(need<0){  				//  throw new IOException("invalid data");  				//}  				if ((buf.index + need) > buf.buffer.Length)  				{  					byte[] foo = new byte[buf.index + need];  					System.Array.Copy(buf.buffer' 0' foo' 0' buf.index);  					buf.buffer = foo;  				}  				if ((need % s2ccipher_size) != 0)  				{  					string message = "Bad packet length " + need;  					if (JSch.GetLogger().IsEnabled(Logger.FATAL))  					{  						JSch.GetLogger().Log(Logger.FATAL' message);  					}  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - s2ccipher_size);  				}  				if (need > 0)  				{  					io.GetByte(buf.buffer' buf.index' need);  					buf.index += (need);  					if (s2ccipher != null)  					{  						s2ccipher.Update(buf.buffer' s2ccipher_size' need' buf.buffer' s2ccipher_size);  					}  				}  				if (s2cmac != null)  				{  					s2cmac.Update(seqi);  					s2cmac.Update(buf.buffer' 0' buf.index);  					s2cmac.DoFinal(s2cmac_result1' 0);  					io.GetByte(s2cmac_result2' 0' s2cmac_result2.Length);  					if (!Arrays.Equals(s2cmac_result1' s2cmac_result2))  					{  						if (need > PACKET_MAX_SIZE)  						{  							throw new IOException("MAC Error");  						}  						Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - need);  						continue;  					}  				}  				seqi++;  				if (inflater != null)  				{  					//inflater.uncompress(buf);  					int pad = buf.buffer[4];  					uncompress_len[0] = buf.index - 5 - pad;  					byte[] foo = inflater.Uncompress(buf.buffer' 5' uncompress_len);  					if (foo != null)  					{  						buf.buffer = foo;  						buf.index = 5 + uncompress_len[0];  					}  					else  					{  						System.Console.Error.WriteLine("fail in inflater");  						break;  					}  				}  				int type = buf.GetCommand() & unchecked((int)(0xff));  				//System.err.println("read: "+type);  				if (type == SSH_MSG_DISCONNECT)  				{  					buf.Rewind();  					buf.GetInt();  					buf.GetShort();  					int reason_code = buf.GetInt();  					byte[] description = buf.GetString();  					byte[] language_tag = buf.GetString();  					throw new JSchException("SSH_MSG_DISCONNECT: " + reason_code + " " + Util.Byte2str  						(description) + " " + Util.Byte2str(language_tag));  				}  				else  				{  					//break;  					if (type == SSH_MSG_IGNORE)  					{  					}  					else  					{  						if (type == SSH_MSG_UNIMPLEMENTED)  						{  							buf.Rewind();  							buf.GetInt();  							buf.GetShort();  							int reason_id = buf.GetInt();  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "Received SSH_MSG_UNIMPLEMENTED for " + reason_id  									);  							}  						}  						else  						{  							if (type == SSH_MSG_DEBUG)  							{  								buf.Rewind();  								buf.GetInt();  								buf.GetShort();  							}  							else  							{  								if (type == SSH_MSG_CHANNEL_WINDOW_ADJUST)  								{  									buf.Rewind();  									buf.GetInt();  									buf.GetShort();  									Channel c = Channel.GetChannel(buf.GetInt()' this);  									if (c == null)  									{  									}  									else  									{  										c.AddRemoteWindowSize(buf.GetInt());  									}  								}  								else  								{  									if (type == UserAuth.SSH_MSG_USERAUTH_SUCCESS)  									{  										isAuthed = true;  										if (inflater == null && deflater == null)  										{  											string method;  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_CTOS];  											InitDeflater(method);  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_STOC];  											InitInflater(method);  										}  										break;  									}  									else  									{  										break;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Read,The following statement contains a magic number: while (true)  			{  				buf.Reset();  				io.GetByte(buf.buffer' buf.index' s2ccipher_size);  				buf.index += s2ccipher_size;  				if (s2ccipher != null)  				{  					s2ccipher.Update(buf.buffer' 0' s2ccipher_size' buf.buffer' 0);  				}  				j = ((buf.buffer[0] << 24) & unchecked((int)(0xff000000))) | ((buf.buffer[1] << 16  					) & unchecked((int)(0x00ff0000))) | ((buf.buffer[2] << 8) & unchecked((int)(0x0000ff00  					))) | ((buf.buffer[3]) & unchecked((int)(0x000000ff)));  				// RFC 4253 6.1. Maximum Packet Length  				if (j < 5 || j > PACKET_MAX_SIZE)  				{  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE);  				}  				int need = j + 4 - s2ccipher_size;  				//if(need<0){  				//  throw new IOException("invalid data");  				//}  				if ((buf.index + need) > buf.buffer.Length)  				{  					byte[] foo = new byte[buf.index + need];  					System.Array.Copy(buf.buffer' 0' foo' 0' buf.index);  					buf.buffer = foo;  				}  				if ((need % s2ccipher_size) != 0)  				{  					string message = "Bad packet length " + need;  					if (JSch.GetLogger().IsEnabled(Logger.FATAL))  					{  						JSch.GetLogger().Log(Logger.FATAL' message);  					}  					Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - s2ccipher_size);  				}  				if (need > 0)  				{  					io.GetByte(buf.buffer' buf.index' need);  					buf.index += (need);  					if (s2ccipher != null)  					{  						s2ccipher.Update(buf.buffer' s2ccipher_size' need' buf.buffer' s2ccipher_size);  					}  				}  				if (s2cmac != null)  				{  					s2cmac.Update(seqi);  					s2cmac.Update(buf.buffer' 0' buf.index);  					s2cmac.DoFinal(s2cmac_result1' 0);  					io.GetByte(s2cmac_result2' 0' s2cmac_result2.Length);  					if (!Arrays.Equals(s2cmac_result1' s2cmac_result2))  					{  						if (need > PACKET_MAX_SIZE)  						{  							throw new IOException("MAC Error");  						}  						Start_discard(buf' s2ccipher' s2cmac' j' PACKET_MAX_SIZE - need);  						continue;  					}  				}  				seqi++;  				if (inflater != null)  				{  					//inflater.uncompress(buf);  					int pad = buf.buffer[4];  					uncompress_len[0] = buf.index - 5 - pad;  					byte[] foo = inflater.Uncompress(buf.buffer' 5' uncompress_len);  					if (foo != null)  					{  						buf.buffer = foo;  						buf.index = 5 + uncompress_len[0];  					}  					else  					{  						System.Console.Error.WriteLine("fail in inflater");  						break;  					}  				}  				int type = buf.GetCommand() & unchecked((int)(0xff));  				//System.err.println("read: "+type);  				if (type == SSH_MSG_DISCONNECT)  				{  					buf.Rewind();  					buf.GetInt();  					buf.GetShort();  					int reason_code = buf.GetInt();  					byte[] description = buf.GetString();  					byte[] language_tag = buf.GetString();  					throw new JSchException("SSH_MSG_DISCONNECT: " + reason_code + " " + Util.Byte2str  						(description) + " " + Util.Byte2str(language_tag));  				}  				else  				{  					//break;  					if (type == SSH_MSG_IGNORE)  					{  					}  					else  					{  						if (type == SSH_MSG_UNIMPLEMENTED)  						{  							buf.Rewind();  							buf.GetInt();  							buf.GetShort();  							int reason_id = buf.GetInt();  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "Received SSH_MSG_UNIMPLEMENTED for " + reason_id  									);  							}  						}  						else  						{  							if (type == SSH_MSG_DEBUG)  							{  								buf.Rewind();  								buf.GetInt();  								buf.GetShort();  							}  							else  							{  								if (type == SSH_MSG_CHANNEL_WINDOW_ADJUST)  								{  									buf.Rewind();  									buf.GetInt();  									buf.GetShort();  									Channel c = Channel.GetChannel(buf.GetInt()' this);  									if (c == null)  									{  									}  									else  									{  										c.AddRemoteWindowSize(buf.GetInt());  									}  								}  								else  								{  									if (type == UserAuth.SSH_MSG_USERAUTH_SUCCESS)  									{  										isAuthed = true;  										if (inflater == null && deflater == null)  										{  											string method;  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_CTOS];  											InitDeflater(method);  											method = guess[KeyExchange.PROPOSAL_COMP_ALGS_STOC];  											InitInflater(method);  										}  										break;  									}  									else  									{  										break;  									}  								}  							}  						}  					}  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Write,The following statement contains a magic number: while (true)  			{  				if (in_kex)  				{  					if (t > 0L && (Runtime.CurrentTimeMillis() - kex_start_time) > t)  					{  						throw new JSchException("timeout in wating for rekeying process.");  					}  					try  					{  						Sharpen.Thread.Sleep(10);  					}  					catch (Exception)  					{  					}  					continue;  				}  				lock (c)  				{  					if (c.rwsize < length)  					{  						try  						{  							c.notifyme++;  							Sharpen.Runtime.Wait(c' 100);  						}  						catch (Exception)  						{  						}  						finally  						{  							c.notifyme--;  						}  					}  					if (c.rwsize >= length)  					{  						c.rwsize -= length;  						break;  					}  				}  				if (c.close || !c.IsConnected())  				{  					throw new IOException("channel is broken");  				}  				bool sendit = false;  				int s = 0;  				byte command = 0;  				int recipient = -1;  				lock (c)  				{  					if (c.rwsize > 0)  					{  						long len = c.rwsize;  						if (len > length)  						{  							len = length;  						}  						if (len != length)  						{  							s = packet.Shift((int)len' (c2scipher != null ? c2scipher_size : 8)' (c2smac != null  								 ? c2smac.GetBlockSize() : 0));  						}  						command = packet.buffer.GetCommand();  						recipient = c.GetRecipient();  						length -= (int)len;  						c.rwsize -= len;  						sendit = true;  					}  				}  				if (sendit)  				{  					_write(packet);  					if (length == 0)  					{  						return;  					}  					packet.Unshift(command' recipient' s' length);  				}  				lock (c)  				{  					if (in_kex)  					{  						continue;  					}  					if (c.rwsize >= length)  					{  						c.rwsize -= length;  						break;  					}  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Write,The following statement contains a magic number: while (true)  			{  				if (in_kex)  				{  					if (t > 0L && (Runtime.CurrentTimeMillis() - kex_start_time) > t)  					{  						throw new JSchException("timeout in wating for rekeying process.");  					}  					try  					{  						Sharpen.Thread.Sleep(10);  					}  					catch (Exception)  					{  					}  					continue;  				}  				lock (c)  				{  					if (c.rwsize < length)  					{  						try  						{  							c.notifyme++;  							Sharpen.Runtime.Wait(c' 100);  						}  						catch (Exception)  						{  						}  						finally  						{  							c.notifyme--;  						}  					}  					if (c.rwsize >= length)  					{  						c.rwsize -= length;  						break;  					}  				}  				if (c.close || !c.IsConnected())  				{  					throw new IOException("channel is broken");  				}  				bool sendit = false;  				int s = 0;  				byte command = 0;  				int recipient = -1;  				lock (c)  				{  					if (c.rwsize > 0)  					{  						long len = c.rwsize;  						if (len > length)  						{  							len = length;  						}  						if (len != length)  						{  							s = packet.Shift((int)len' (c2scipher != null ? c2scipher_size : 8)' (c2smac != null  								 ? c2smac.GetBlockSize() : 0));  						}  						command = packet.buffer.GetCommand();  						recipient = c.GetRecipient();  						length -= (int)len;  						c.rwsize -= len;  						sendit = true;  					}  				}  				if (sendit)  				{  					_write(packet);  					if (length == 0)  					{  						return;  					}  					packet.Unshift(command' recipient' s' length);  				}  				lock (c)  				{  					if (in_kex)  					{  						continue;  					}  					if (c.rwsize >= length)  					{  						c.rwsize -= length;  						break;  					}  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Write,The following statement contains a magic number: while (true)  			{  				if (in_kex)  				{  					if (t > 0L && (Runtime.CurrentTimeMillis() - kex_start_time) > t)  					{  						throw new JSchException("timeout in wating for rekeying process.");  					}  					try  					{  						Sharpen.Thread.Sleep(10);  					}  					catch (Exception)  					{  					}  					continue;  				}  				lock (c)  				{  					if (c.rwsize < length)  					{  						try  						{  							c.notifyme++;  							Sharpen.Runtime.Wait(c' 100);  						}  						catch (Exception)  						{  						}  						finally  						{  							c.notifyme--;  						}  					}  					if (c.rwsize >= length)  					{  						c.rwsize -= length;  						break;  					}  				}  				if (c.close || !c.IsConnected())  				{  					throw new IOException("channel is broken");  				}  				bool sendit = false;  				int s = 0;  				byte command = 0;  				int recipient = -1;  				lock (c)  				{  					if (c.rwsize > 0)  					{  						long len = c.rwsize;  						if (len > length)  						{  							len = length;  						}  						if (len != length)  						{  							s = packet.Shift((int)len' (c2scipher != null ? c2scipher_size : 8)' (c2smac != null  								 ? c2smac.GetBlockSize() : 0));  						}  						command = packet.buffer.GetCommand();  						recipient = c.GetRecipient();  						length -= (int)len;  						c.rwsize -= len;  						sendit = true;  					}  				}  				if (sendit)  				{  					_write(packet);  					if (length == 0)  					{  						return;  					}  					packet.Unshift(command' recipient' s' length);  				}  				lock (c)  				{  					if (in_kex)  					{  						continue;  					}  					if (c.rwsize >= length)  					{  						c.rwsize -= length;  						break;  					}  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Write,The following statement contains a magic number: while (in_kex)  			{  				if (t > 0L && (Runtime.CurrentTimeMillis() - kex_start_time) > t)  				{  					throw new JSchException("timeout in wating for rekeying process.");  				}  				byte command = packet.buffer.GetCommand();  				//System.err.println("command: "+command);  				if (command == SSH_MSG_KEXINIT || command == SSH_MSG_NEWKEYS || command == SSH_MSG_KEXDH_INIT  					 || command == SSH_MSG_KEXDH_REPLY || command == SSH_MSG_KEX_DH_GEX_GROUP || command  					 == SSH_MSG_KEX_DH_GEX_INIT || command == SSH_MSG_KEX_DH_GEX_REPLY || command ==  					 SSH_MSG_KEX_DH_GEX_REQUEST || command == SSH_MSG_DISCONNECT)  				{  					break;  				}  				try  				{  					Sharpen.Thread.Sleep(10);  				}  				catch (Exception)  				{  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Run,The following statement contains a magic number: try  			{  				while (isConnected && thread != null)  				{  					try  					{  						buf = Read(buf);  						stimeout = 0;  					}  					catch (ThreadInterruptedException ee)  					{  						if (!in_kex && stimeout < serverAliveCountMax)  						{  							SendKeepAliveMsg();  							stimeout++;  							continue;  						}  						else  						{  							if (in_kex && stimeout < serverAliveCountMax)  							{  								stimeout++;  								continue;  							}  						}  						throw;  					}  					int msgType = buf.GetCommand() & unchecked((int)(0xff));  					if (kex != null && kex.GetState() == msgType)  					{  						kex_start_time = Runtime.CurrentTimeMillis();  						bool result = kex.Next(buf);  						if (!result)  						{  							throw new JSchException("verify: " + result);  						}  						continue;  					}  					switch (msgType)  					{  						case SSH_MSG_KEXINIT:  						{  							//System.err.println("KEXINIT");  							kex = Receive_kexinit(buf);  							break;  						}    						case SSH_MSG_NEWKEYS:  						{  							//System.err.println("NEWKEYS");  							Send_newkeys();  							Receive_newkeys(buf' kex);  							kex = null;  							break;  						}    						case SSH_MSG_CHANNEL_DATA:  						{  							buf.GetInt();  							buf.GetByte();  							buf.GetByte();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							foo = buf.GetString(start' length);  							if (channel == null)  							{  								break;  							}  							if (length[0] == 0)  							{  								break;  							}  							try  							{  								channel.Write(foo' start[0]' length[0]);  							}  							catch (Exception)  							{  								//System.err.println(e);  								try  								{  									channel.Disconnect();  								}  								catch (Exception)  								{  								}  								break;  							}  							int len = length[0];  							channel.SetLocalWindowSize(channel.lwsize - len);  							if (channel.lwsize < channel.lwsize_max / 2)  							{  								packet.Reset();  								buf.PutByte(unchecked((byte)SSH_MSG_CHANNEL_WINDOW_ADJUST));  								buf.PutInt(channel.GetRecipient());  								buf.PutInt(channel.lwsize_max - channel.lwsize);  								lock (channel)  								{  									if (!channel.close)  									{  										Write(packet);  									}  								}  								channel.SetLocalWindowSize(channel.lwsize_max);  							}  							break;  						}    						case SSH_MSG_CHANNEL_EXTENDED_DATA:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							buf.GetInt();  							// data_type_code == 1  							foo = buf.GetString(start' length);  							//System.err.println("stderr: "+new String(foo'start[0]'length[0]));  							if (channel == null)  							{  								break;  							}  							if (length[0] == 0)  							{  								break;  							}  							channel.Write_ext(foo' start[0]' length[0]);  							int len = length[0];  							channel.SetLocalWindowSize(channel.lwsize - len);  							if (channel.lwsize < channel.lwsize_max / 2)  							{  								packet.Reset();  								buf.PutByte(unchecked((byte)SSH_MSG_CHANNEL_WINDOW_ADJUST));  								buf.PutInt(channel.GetRecipient());  								buf.PutInt(channel.lwsize_max - channel.lwsize);  								lock (channel)  								{  									if (!channel.close)  									{  										Write(packet);  									}  								}  								channel.SetLocalWindowSize(channel.lwsize_max);  							}  							break;  						}    						case SSH_MSG_CHANNEL_WINDOW_ADJUST:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							if (channel == null)  							{  								break;  							}  							channel.AddRemoteWindowSize(buf.GetInt());  							break;  						}    						case SSH_MSG_CHANNEL_EOF:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							if (channel != null)  							{  								//channel.eof_remote=true;  								//channel.eof();  								channel.Eof_remote();  							}  							break;  						}    						case SSH_MSG_CHANNEL_CLOSE:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							if (channel != null)  							{  								//	      channel.close();  								channel.Disconnect();  							}  							break;  						}    						case SSH_MSG_CHANNEL_OPEN_CONFIRMATION:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							if (channel == null)  							{  							}  							//break;  							int r = buf.GetInt();  							long rws = buf.GetUInt();  							int rps = buf.GetInt();  							channel.SetRemoteWindowSize(rws);  							channel.SetRemotePacketSize(rps);  							channel.open_confirmation = true;  							channel.SetRecipient(r);  							break;  						}    						case SSH_MSG_CHANNEL_OPEN_FAILURE:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							if (channel == null)  							{  							}  							//break;  							int reason_code = buf.GetInt();  							//foo=buf.getString();  // additional textual information  							//foo=buf.getString();  // language tag   							channel.SetExitStatus(reason_code);  							channel.close = true;  							channel.eof_remote = true;  							channel.SetRecipient(0);  							break;  						}    						case SSH_MSG_CHANNEL_REQUEST:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							foo = buf.GetString();  							bool reply = (buf.GetByte() != 0);  							channel = Channel.GetChannel(i' this);  							if (channel != null)  							{  								byte reply_type = unchecked((byte)SSH_MSG_CHANNEL_FAILURE);  								if ((Util.Byte2str(foo)).Equals("exit-status"))  								{  									i = buf.GetInt();  									// exit-status  									channel.SetExitStatus(i);  									reply_type = unchecked((byte)SSH_MSG_CHANNEL_SUCCESS);  								}  								if (reply)  								{  									packet.Reset();  									buf.PutByte(reply_type);  									buf.PutInt(channel.GetRecipient());  									Write(packet);  								}  							}  							break;  						}    						case SSH_MSG_CHANNEL_OPEN:  						{  							buf.GetInt();  							buf.GetShort();  							foo = buf.GetString();  							string ctyp = Util.Byte2str(foo);  							if (!"forwarded-tcpip".Equals(ctyp) && !("x11".Equals(ctyp) && x11_forwarding) &&  								 !("auth-agent@openssh.com".Equals(ctyp) && agent_forwarding))  							{  								//System.err.println("Session.run: CHANNEL OPEN "+ctyp);   								//throw new IOException("Session.run: CHANNEL OPEN "+ctyp);  								packet.Reset();  								buf.PutByte(unchecked((byte)SSH_MSG_CHANNEL_OPEN_FAILURE));  								buf.PutInt(buf.GetInt());  								buf.PutInt(Channel.SSH_OPEN_ADMINISTRATIVELY_PROHIBITED);  								buf.PutString(Util.empty);  								buf.PutString(Util.empty);  								Write(packet);  							}  							else  							{  								channel = Channel.GetChannel(ctyp);  								AddChannel(channel);  								channel.GetData(buf);  								channel.Init();  								Sharpen.Thread tmp = new Sharpen.Thread(channel);  								tmp.SetName("Channel " + ctyp + " " + host);  								if (daemon_thread)  								{  									tmp.SetDaemon(daemon_thread);  								}  								tmp.Start();  								break;  							}  							goto case SSH_MSG_CHANNEL_SUCCESS;  						}    						case SSH_MSG_CHANNEL_SUCCESS:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							if (channel == null)  							{  								break;  							}  							channel.reply = 1;  							break;  						}    						case SSH_MSG_CHANNEL_FAILURE:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							if (channel == null)  							{  								break;  							}  							channel.reply = 0;  							break;  						}    						case SSH_MSG_GLOBAL_REQUEST:  						{  							buf.GetInt();  							buf.GetShort();  							foo = buf.GetString();  							// request name  							bool reply = (buf.GetByte() != 0);  							if (reply)  							{  								packet.Reset();  								buf.PutByte(unchecked((byte)SSH_MSG_REQUEST_FAILURE));  								Write(packet);  							}  							break;  						}    						case SSH_MSG_REQUEST_FAILURE:  						case SSH_MSG_REQUEST_SUCCESS:  						{  							Sharpen.Thread t = grr.GetThread();  							if (t != null)  							{  								grr.SetReply(msgType == SSH_MSG_REQUEST_SUCCESS ? 1 : 0);  								t.Interrupt();  							}  							break;  						}    						default:  						{  							//System.err.println("Session.run: unsupported type "+msgType);   							throw new IOException("Unknown SSH message type " + msgType);  						}  					}  				}  			}  			catch (Exception e)  			{  				in_kex = false;  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Caught an exception' leaving main loop due to "  						 + e.Message);  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Run,The following statement contains a magic number: try  			{  				while (isConnected && thread != null)  				{  					try  					{  						buf = Read(buf);  						stimeout = 0;  					}  					catch (ThreadInterruptedException ee)  					{  						if (!in_kex && stimeout < serverAliveCountMax)  						{  							SendKeepAliveMsg();  							stimeout++;  							continue;  						}  						else  						{  							if (in_kex && stimeout < serverAliveCountMax)  							{  								stimeout++;  								continue;  							}  						}  						throw;  					}  					int msgType = buf.GetCommand() & unchecked((int)(0xff));  					if (kex != null && kex.GetState() == msgType)  					{  						kex_start_time = Runtime.CurrentTimeMillis();  						bool result = kex.Next(buf);  						if (!result)  						{  							throw new JSchException("verify: " + result);  						}  						continue;  					}  					switch (msgType)  					{  						case SSH_MSG_KEXINIT:  						{  							//System.err.println("KEXINIT");  							kex = Receive_kexinit(buf);  							break;  						}    						case SSH_MSG_NEWKEYS:  						{  							//System.err.println("NEWKEYS");  							Send_newkeys();  							Receive_newkeys(buf' kex);  							kex = null;  							break;  						}    						case SSH_MSG_CHANNEL_DATA:  						{  							buf.GetInt();  							buf.GetByte();  							buf.GetByte();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							foo = buf.GetString(start' length);  							if (channel == null)  							{  								break;  							}  							if (length[0] == 0)  							{  								break;  							}  							try  							{  								channel.Write(foo' start[0]' length[0]);  							}  							catch (Exception)  							{  								//System.err.println(e);  								try  								{  									channel.Disconnect();  								}  								catch (Exception)  								{  								}  								break;  							}  							int len = length[0];  							channel.SetLocalWindowSize(channel.lwsize - len);  							if (channel.lwsize < channel.lwsize_max / 2)  							{  								packet.Reset();  								buf.PutByte(unchecked((byte)SSH_MSG_CHANNEL_WINDOW_ADJUST));  								buf.PutInt(channel.GetRecipient());  								buf.PutInt(channel.lwsize_max - channel.lwsize);  								lock (channel)  								{  									if (!channel.close)  									{  										Write(packet);  									}  								}  								channel.SetLocalWindowSize(channel.lwsize_max);  							}  							break;  						}    						case SSH_MSG_CHANNEL_EXTENDED_DATA:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							buf.GetInt();  							// data_type_code == 1  							foo = buf.GetString(start' length);  							//System.err.println("stderr: "+new String(foo'start[0]'length[0]));  							if (channel == null)  							{  								break;  							}  							if (length[0] == 0)  							{  								break;  							}  							channel.Write_ext(foo' start[0]' length[0]);  							int len = length[0];  							channel.SetLocalWindowSize(channel.lwsize - len);  							if (channel.lwsize < channel.lwsize_max / 2)  							{  								packet.Reset();  								buf.PutByte(unchecked((byte)SSH_MSG_CHANNEL_WINDOW_ADJUST));  								buf.PutInt(channel.GetRecipient());  								buf.PutInt(channel.lwsize_max - channel.lwsize);  								lock (channel)  								{  									if (!channel.close)  									{  										Write(packet);  									}  								}  								channel.SetLocalWindowSize(channel.lwsize_max);  							}  							break;  						}    						case SSH_MSG_CHANNEL_WINDOW_ADJUST:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							if (channel == null)  							{  								break;  							}  							channel.AddRemoteWindowSize(buf.GetInt());  							break;  						}    						case SSH_MSG_CHANNEL_EOF:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							if (channel != null)  							{  								//channel.eof_remote=true;  								//channel.eof();  								channel.Eof_remote();  							}  							break;  						}    						case SSH_MSG_CHANNEL_CLOSE:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							if (channel != null)  							{  								//	      channel.close();  								channel.Disconnect();  							}  							break;  						}    						case SSH_MSG_CHANNEL_OPEN_CONFIRMATION:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							if (channel == null)  							{  							}  							//break;  							int r = buf.GetInt();  							long rws = buf.GetUInt();  							int rps = buf.GetInt();  							channel.SetRemoteWindowSize(rws);  							channel.SetRemotePacketSize(rps);  							channel.open_confirmation = true;  							channel.SetRecipient(r);  							break;  						}    						case SSH_MSG_CHANNEL_OPEN_FAILURE:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							if (channel == null)  							{  							}  							//break;  							int reason_code = buf.GetInt();  							//foo=buf.getString();  // additional textual information  							//foo=buf.getString();  // language tag   							channel.SetExitStatus(reason_code);  							channel.close = true;  							channel.eof_remote = true;  							channel.SetRecipient(0);  							break;  						}    						case SSH_MSG_CHANNEL_REQUEST:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							foo = buf.GetString();  							bool reply = (buf.GetByte() != 0);  							channel = Channel.GetChannel(i' this);  							if (channel != null)  							{  								byte reply_type = unchecked((byte)SSH_MSG_CHANNEL_FAILURE);  								if ((Util.Byte2str(foo)).Equals("exit-status"))  								{  									i = buf.GetInt();  									// exit-status  									channel.SetExitStatus(i);  									reply_type = unchecked((byte)SSH_MSG_CHANNEL_SUCCESS);  								}  								if (reply)  								{  									packet.Reset();  									buf.PutByte(reply_type);  									buf.PutInt(channel.GetRecipient());  									Write(packet);  								}  							}  							break;  						}    						case SSH_MSG_CHANNEL_OPEN:  						{  							buf.GetInt();  							buf.GetShort();  							foo = buf.GetString();  							string ctyp = Util.Byte2str(foo);  							if (!"forwarded-tcpip".Equals(ctyp) && !("x11".Equals(ctyp) && x11_forwarding) &&  								 !("auth-agent@openssh.com".Equals(ctyp) && agent_forwarding))  							{  								//System.err.println("Session.run: CHANNEL OPEN "+ctyp);   								//throw new IOException("Session.run: CHANNEL OPEN "+ctyp);  								packet.Reset();  								buf.PutByte(unchecked((byte)SSH_MSG_CHANNEL_OPEN_FAILURE));  								buf.PutInt(buf.GetInt());  								buf.PutInt(Channel.SSH_OPEN_ADMINISTRATIVELY_PROHIBITED);  								buf.PutString(Util.empty);  								buf.PutString(Util.empty);  								Write(packet);  							}  							else  							{  								channel = Channel.GetChannel(ctyp);  								AddChannel(channel);  								channel.GetData(buf);  								channel.Init();  								Sharpen.Thread tmp = new Sharpen.Thread(channel);  								tmp.SetName("Channel " + ctyp + " " + host);  								if (daemon_thread)  								{  									tmp.SetDaemon(daemon_thread);  								}  								tmp.Start();  								break;  							}  							goto case SSH_MSG_CHANNEL_SUCCESS;  						}    						case SSH_MSG_CHANNEL_SUCCESS:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							if (channel == null)  							{  								break;  							}  							channel.reply = 1;  							break;  						}    						case SSH_MSG_CHANNEL_FAILURE:  						{  							buf.GetInt();  							buf.GetShort();  							i = buf.GetInt();  							channel = Channel.GetChannel(i' this);  							if (channel == null)  							{  								break;  							}  							channel.reply = 0;  							break;  						}    						case SSH_MSG_GLOBAL_REQUEST:  						{  							buf.GetInt();  							buf.GetShort();  							foo = buf.GetString();  							// request name  							bool reply = (buf.GetByte() != 0);  							if (reply)  							{  								packet.Reset();  								buf.PutByte(unchecked((byte)SSH_MSG_REQUEST_FAILURE));  								Write(packet);  							}  							break;  						}    						case SSH_MSG_REQUEST_FAILURE:  						case SSH_MSG_REQUEST_SUCCESS:  						{  							Sharpen.Thread t = grr.GetThread();  							if (t != null)  							{  								grr.SetReply(msgType == SSH_MSG_REQUEST_SUCCESS ? 1 : 0);  								t.Interrupt();  							}  							break;  						}    						default:  						{  							//System.err.println("Session.run: unsupported type "+msgType);   							throw new IOException("Unknown SSH message type " + msgType);  						}  					}  				}  			}  			catch (Exception e)  			{  				in_kex = false;  				if (JSch.GetLogger().IsEnabled(Logger.INFO))  				{  					JSch.GetLogger().Log(Logger.INFO' "Caught an exception' leaving main loop due to "  						 + e.Message);  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,SetPortForwarding,The following statement contains a magic number: lock (grr)  			{  				Buffer buf = new Buffer(100);  				// ??  				Packet packet = new Packet(buf);  				string address_to_bind = ChannelForwardedTCPIP.Normalize(bind_address);  				grr.SetThread(Sharpen.Thread.CurrentThread());  				try  				{  					// byte SSH_MSG_GLOBAL_REQUEST 80  					// string "tcpip-forward"  					// boolean want_reply  					// string  address_to_bind  					// uint32  port number to bind  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_GLOBAL_REQUEST));  					buf.PutString(Util.Str2byte("tcpip-forward"));  					buf.PutByte(unchecked((byte)1));  					buf.PutString(Util.Str2byte(address_to_bind));  					buf.PutInt(rport);  					Write(packet);  				}  				catch (Exception e)  				{  					grr.SetThread(null);  					if (e is Exception)  					{  						throw new JSchException(e.ToString()' (Exception)e);  					}  					throw new JSchException(e.ToString());  				}  				int count = 0;  				int reply = grr.GetReply();  				while (count < 10 && reply == -1)  				{  					try  					{  						Sharpen.Thread.Sleep(1000);  					}  					catch (Exception)  					{  					}  					count++;  					reply = grr.GetReply();  				}  				grr.SetThread(null);  				if (reply != 1)  				{  					throw new JSchException("remote port forwarding failed for listen port " + rport);  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,SetPortForwarding,The following statement contains a magic number: lock (grr)  			{  				Buffer buf = new Buffer(100);  				// ??  				Packet packet = new Packet(buf);  				string address_to_bind = ChannelForwardedTCPIP.Normalize(bind_address);  				grr.SetThread(Sharpen.Thread.CurrentThread());  				try  				{  					// byte SSH_MSG_GLOBAL_REQUEST 80  					// string "tcpip-forward"  					// boolean want_reply  					// string  address_to_bind  					// uint32  port number to bind  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_GLOBAL_REQUEST));  					buf.PutString(Util.Str2byte("tcpip-forward"));  					buf.PutByte(unchecked((byte)1));  					buf.PutString(Util.Str2byte(address_to_bind));  					buf.PutInt(rport);  					Write(packet);  				}  				catch (Exception e)  				{  					grr.SetThread(null);  					if (e is Exception)  					{  						throw new JSchException(e.ToString()' (Exception)e);  					}  					throw new JSchException(e.ToString());  				}  				int count = 0;  				int reply = grr.GetReply();  				while (count < 10 && reply == -1)  				{  					try  					{  						Sharpen.Thread.Sleep(1000);  					}  					catch (Exception)  					{  					}  					count++;  					reply = grr.GetReply();  				}  				grr.SetThread(null);  				if (reply != 1)  				{  					throw new JSchException("remote port forwarding failed for listen port " + rport);  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,SetPortForwarding,The following statement contains a magic number: lock (grr)  			{  				Buffer buf = new Buffer(100);  				// ??  				Packet packet = new Packet(buf);  				string address_to_bind = ChannelForwardedTCPIP.Normalize(bind_address);  				grr.SetThread(Sharpen.Thread.CurrentThread());  				try  				{  					// byte SSH_MSG_GLOBAL_REQUEST 80  					// string "tcpip-forward"  					// boolean want_reply  					// string  address_to_bind  					// uint32  port number to bind  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_GLOBAL_REQUEST));  					buf.PutString(Util.Str2byte("tcpip-forward"));  					buf.PutByte(unchecked((byte)1));  					buf.PutString(Util.Str2byte(address_to_bind));  					buf.PutInt(rport);  					Write(packet);  				}  				catch (Exception e)  				{  					grr.SetThread(null);  					if (e is Exception)  					{  						throw new JSchException(e.ToString()' (Exception)e);  					}  					throw new JSchException(e.ToString());  				}  				int count = 0;  				int reply = grr.GetReply();  				while (count < 10 && reply == -1)  				{  					try  					{  						Sharpen.Thread.Sleep(1000);  					}  					catch (Exception)  					{  					}  					count++;  					reply = grr.GetReply();  				}  				grr.SetThread(null);  				if (reply != 1)  				{  					throw new JSchException("remote port forwarding failed for listen port " + rport);  				}  			}
Magic Number,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,InitDeflater,The following statement contains a magic number: if (foo != null)  			{  				if (method.Equals("zlib") || (isAuthed && method.Equals("zlib@openssh.com")))  				{  					try  					{  						Type c = Sharpen.Runtime.GetType(foo);  						deflater = (Compression)(System.Activator.CreateInstance(c));  						int level = 6;  						try  						{  							level = System.Convert.ToInt32(GetConfig("compression_level"));  						}  						catch (Exception)  						{  						}  						deflater.Init(Compression.DEFLATER' level);  					}  					catch (Exception ee)  					{  						throw new JSchException(ee.ToString()' ee);  					}  				}  			}
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,GetPermissionsString,The following statement contains a magic number: StringBuilder buf = new StringBuilder(10);
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,GetMtimeString,The following statement contains a magic number: DateTime date = Sharpen.Extensions.CreateDate(((long)mtime) * 1000);
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,GetATTR,The following statement contains a magic number: if ((attr.flags & SSH_FILEXFER_ATTR_EXTENDED) != 0)  			{  				int count = buf.GetInt();  				if (count > 0)  				{  					attr.extended = new string[count * 2];  					for (int i = 0; i < count; i++)  					{  						attr.extended[i * 2] = Util.Byte2str(buf.GetString());  						attr.extended[i * 2 + 1] = Util.Byte2str(buf.GetString());  					}  				}  			}
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,GetATTR,The following statement contains a magic number: if ((attr.flags & SSH_FILEXFER_ATTR_EXTENDED) != 0)  			{  				int count = buf.GetInt();  				if (count > 0)  				{  					attr.extended = new string[count * 2];  					for (int i = 0; i < count; i++)  					{  						attr.extended[i * 2] = Util.Byte2str(buf.GetString());  						attr.extended[i * 2 + 1] = Util.Byte2str(buf.GetString());  					}  				}  			}
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,GetATTR,The following statement contains a magic number: if ((attr.flags & SSH_FILEXFER_ATTR_EXTENDED) != 0)  			{  				int count = buf.GetInt();  				if (count > 0)  				{  					attr.extended = new string[count * 2];  					for (int i = 0; i < count; i++)  					{  						attr.extended[i * 2] = Util.Byte2str(buf.GetString());  						attr.extended[i * 2 + 1] = Util.Byte2str(buf.GetString());  					}  				}  			}
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: int len = 4;
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: if ((flags & SSH_FILEXFER_ATTR_SIZE) != 0)  			{  				len += 8;  			}
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: if ((flags & SSH_FILEXFER_ATTR_UIDGID) != 0)  			{  				len += 8;  			}
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: if ((flags & SSH_FILEXFER_ATTR_PERMISSIONS) != 0)  			{  				len += 4;  			}
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: if ((flags & SSH_FILEXFER_ATTR_ACMODTIME) != 0)  			{  				len += 8;  			}
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: if ((flags & SSH_FILEXFER_ATTR_EXTENDED) != 0)  			{  				len += 4;  				int count = extended.Length / 2;  				if (count > 0)  				{  					for (int i = 0; i < count; i++)  					{  						len += 4;  						len += extended[i * 2].Length;  						len += 4;  						len += extended[i * 2 + 1].Length;  					}  				}  			}
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: if ((flags & SSH_FILEXFER_ATTR_EXTENDED) != 0)  			{  				len += 4;  				int count = extended.Length / 2;  				if (count > 0)  				{  					for (int i = 0; i < count; i++)  					{  						len += 4;  						len += extended[i * 2].Length;  						len += 4;  						len += extended[i * 2 + 1].Length;  					}  				}  			}
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: if ((flags & SSH_FILEXFER_ATTR_EXTENDED) != 0)  			{  				len += 4;  				int count = extended.Length / 2;  				if (count > 0)  				{  					for (int i = 0; i < count; i++)  					{  						len += 4;  						len += extended[i * 2].Length;  						len += 4;  						len += extended[i * 2 + 1].Length;  					}  				}  			}
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: if ((flags & SSH_FILEXFER_ATTR_EXTENDED) != 0)  			{  				len += 4;  				int count = extended.Length / 2;  				if (count > 0)  				{  					for (int i = 0; i < count; i++)  					{  						len += 4;  						len += extended[i * 2].Length;  						len += 4;  						len += extended[i * 2 + 1].Length;  					}  				}  			}
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: if ((flags & SSH_FILEXFER_ATTR_EXTENDED) != 0)  			{  				len += 4;  				int count = extended.Length / 2;  				if (count > 0)  				{  					for (int i = 0; i < count; i++)  					{  						len += 4;  						len += extended[i * 2].Length;  						len += 4;  						len += extended[i * 2 + 1].Length;  					}  				}  			}
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Length,The following statement contains a magic number: if ((flags & SSH_FILEXFER_ATTR_EXTENDED) != 0)  			{  				len += 4;  				int count = extended.Length / 2;  				if (count > 0)  				{  					for (int i = 0; i < count; i++)  					{  						len += 4;  						len += extended[i * 2].Length;  						len += 4;  						len += extended[i * 2 + 1].Length;  					}  				}  			}
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Dump,The following statement contains a magic number: if ((flags & SSH_FILEXFER_ATTR_EXTENDED) != 0)  			{  				int count = extended.Length / 2;  				if (count > 0)  				{  					for (int i = 0; i < count; i++)  					{  						buf.PutString(Util.Str2byte(extended[i * 2]));  						buf.PutString(Util.Str2byte(extended[i * 2 + 1]));  					}  				}  			}
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Dump,The following statement contains a magic number: if ((flags & SSH_FILEXFER_ATTR_EXTENDED) != 0)  			{  				int count = extended.Length / 2;  				if (count > 0)  				{  					for (int i = 0; i < count; i++)  					{  						buf.PutString(Util.Str2byte(extended[i * 2]));  						buf.PutString(Util.Str2byte(extended[i * 2 + 1]));  					}  				}  			}
Magic Number,NSch,SftpATTRS,C:\repos\mono_ngit\NSch\NSch\SftpATTRS.cs,Dump,The following statement contains a magic number: if ((flags & SSH_FILEXFER_ATTR_EXTENDED) != 0)  			{  				int count = extended.Length / 2;  				if (count > 0)  				{  					for (int i = 0; i < count; i++)  					{  						buf.PutString(Util.Str2byte(extended[i * 2]));  						buf.PutString(Util.Str2byte(extended[i * 2 + 1]));  					}  				}  			}
Magic Number,NSch,UserAuthKeyboardInteractive,C:\repos\mono_ngit\NSch\NSch\UserAuthKeyboardInteractive.cs,Start,The following statement contains a magic number: if (session.port != 22)  			{  				dest += (":" + session.port);  			}
Magic Number,NSch,UserAuthPassword,C:\repos\mono_ngit\NSch\NSch\UserAuthPassword.cs,Start,The following statement contains a magic number: if (session.port != 22)  			{  				dest += (":" + session.port);  			}
Magic Number,NSch,UserAuthPublicKey,C:\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: lock (identities)  			{  				if (identities.Count <= 0)  				{  					return false;  				}  				_username = Util.Str2byte(username);  				for (int i = 0; i < identities.Count; i++)  				{  					if (session.auth_failures >= session.max_auth_tries)  					{  						return false;  					}  					Identity identity = (Identity)(identities[i]);  					byte[] pubkeyblob = identity.GetPublicKeyBlob();  					//System.err.println("UserAuthPublicKey: "+identity+" "+pubkeyblob);  					if (pubkeyblob != null)  					{  						// send  						// byte      SSH_MSG_USERAUTH_REQUEST(50)  						// string    user name  						// string    service name ("ssh-connection")  						// string    "publickey"  						// boolen    FALSE  						// string    plaintext password (ISO-10646 UTF-8)  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  						buf.PutString(_username);  						buf.PutString(Util.Str2byte("ssh-connection"));  						buf.PutString(Util.Str2byte("publickey"));  						buf.PutByte(unchecked((byte)0));  						buf.PutString(Util.Str2byte(identity.GetAlgName()));  						buf.PutString(pubkeyblob);  						session.Write(packet);  						while (true)  						{  							buf = session.Read(buf);  							command = buf.GetCommand() & unchecked((int)(0xff));  							if (command == SSH_MSG_USERAUTH_PK_OK)  							{  								break;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									break;  								}  								else  								{  									if (command == SSH_MSG_USERAUTH_BANNER)  									{  										buf.GetInt();  										buf.GetByte();  										buf.GetByte();  										byte[] _message = buf.GetString();  										byte[] lang = buf.GetString();  										string message = Util.Byte2str(_message);  										if (userinfo != null)  										{  											userinfo.ShowMessage(message);  										}  										goto loop1_continue;  									}  									else  									{  										//System.err.println("USERAUTH fail ("+command+")");  										//throw new JSchException("USERAUTH fail ("+command+")");  										break;  									}  								}  							}  loop1_continue: ;  						}  loop1_break: ;  						if (command != SSH_MSG_USERAUTH_PK_OK)  						{  							continue;  						}  					}  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					int count = 5;  					while (true)  					{  						if ((identity.IsEncrypted() && passphrase == null))  						{  							if (userinfo == null)  							{  								throw new JSchException("USERAUTH fail");  							}  							if (identity.IsEncrypted() && !userinfo.PromptPassphrase("Passphrase for " + identity  								.GetName()))  							{  								throw new JSchAuthCancelException("publickey");  							}  							//throw new JSchException("USERAUTH cancel");  							//break;  							string _passphrase = userinfo.GetPassphrase();  							if (_passphrase != null)  							{  								passphrase = Util.Str2byte(_passphrase);  							}  						}  						if (!identity.IsEncrypted() || passphrase != null)  						{  							if (identity.SetPassphrase(passphrase))  							{  								break;  							}  							else  							{  								throw new System.Exception ("Invalid passphrase supplied for the ssh key");  							}  						}  						Util.Bzero(passphrase);  						passphrase = null;  						count--;  						if (count == 0)  						{  							break;  						}  					}  					Util.Bzero(passphrase);  					passphrase = null;  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					if (identity.IsEncrypted())  					{  						continue;  					}  					if (pubkeyblob == null)  					{  						pubkeyblob = identity.GetPublicKeyBlob();  					}  					//System.err.println("UserAuthPublicKey: pubkeyblob="+pubkeyblob);  					if (pubkeyblob == null)  					{  						continue;  					}  					// send  					// byte      SSH_MSG_USERAUTH_REQUEST(50)  					// string    user name  					// string    service name ("ssh-connection")  					// string    "publickey"  					// boolen    TRUE  					// string    plaintext password (ISO-10646 UTF-8)  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  					buf.PutString(_username);  					buf.PutString(Util.Str2byte("ssh-connection"));  					buf.PutString(Util.Str2byte("publickey"));  					buf.PutByte(unchecked((byte)1));  					buf.PutString(Util.Str2byte(identity.GetAlgName()));  					buf.PutString(pubkeyblob);  					//      byte[] tmp=new byte[buf.index-5];  					//      System.arraycopy(buf.buffer' 5' tmp' 0' tmp.length);  					//      buf.putString(signature);  					byte[] sid = session.GetSessionId();  					int sidlen = sid.Length;  					byte[] tmp = new byte[4 + sidlen + buf.index - 5];  					tmp[0] = unchecked((byte)((int)(((uint)sidlen) >> 24)));  					tmp[1] = unchecked((byte)((int)(((uint)sidlen) >> 16)));  					tmp[2] = unchecked((byte)((int)(((uint)sidlen) >> 8)));  					tmp[3] = unchecked((byte)(sidlen));  					System.Array.Copy(sid' 0' tmp' 4' sidlen);  					System.Array.Copy(buf.buffer' 5' tmp' 4 + sidlen' buf.index - 5);  					byte[] signature = identity.GetSignature(tmp);  					if (signature == null)  					{  						// for example' too long key length.  						break;  					}  					buf.PutString(signature);  					session.Write(packet);  					while (true)  					{  						buf = session.Read(buf);  						command = buf.GetCommand() & unchecked((int)(0xff));  						if (command == SSH_MSG_USERAUTH_SUCCESS)  						{  							return true;  						}  						else  						{  							if (command == SSH_MSG_USERAUTH_BANNER)  							{  								buf.GetInt();  								buf.GetByte();  								buf.GetByte();  								byte[] _message = buf.GetString();  								byte[] lang = buf.GetString();  								string message = Util.Byte2str(_message);  								if (userinfo != null)  								{  									userinfo.ShowMessage(message);  								}  								goto loop2_continue;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									buf.GetInt();  									buf.GetByte();  									buf.GetByte();  									byte[] foo = buf.GetString();  									int partial_success = buf.GetByte();  									//System.err.println(new String(foo)+  									//                   " partial_success:"+(partial_success!=0));  									if (partial_success != 0)  									{  										throw new JSchPartialAuthException(Util.Byte2str(foo));  									}  									session.auth_failures++;  									break;  								}  							}  						}  						//System.err.println("USERAUTH fail ("+command+")");  						//throw new JSchException("USERAUTH fail ("+command+")");  						break;  loop2_continue: ;  					}  loop2_break: ;  				}  			}
Magic Number,NSch,UserAuthPublicKey,C:\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: lock (identities)  			{  				if (identities.Count <= 0)  				{  					return false;  				}  				_username = Util.Str2byte(username);  				for (int i = 0; i < identities.Count; i++)  				{  					if (session.auth_failures >= session.max_auth_tries)  					{  						return false;  					}  					Identity identity = (Identity)(identities[i]);  					byte[] pubkeyblob = identity.GetPublicKeyBlob();  					//System.err.println("UserAuthPublicKey: "+identity+" "+pubkeyblob);  					if (pubkeyblob != null)  					{  						// send  						// byte      SSH_MSG_USERAUTH_REQUEST(50)  						// string    user name  						// string    service name ("ssh-connection")  						// string    "publickey"  						// boolen    FALSE  						// string    plaintext password (ISO-10646 UTF-8)  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  						buf.PutString(_username);  						buf.PutString(Util.Str2byte("ssh-connection"));  						buf.PutString(Util.Str2byte("publickey"));  						buf.PutByte(unchecked((byte)0));  						buf.PutString(Util.Str2byte(identity.GetAlgName()));  						buf.PutString(pubkeyblob);  						session.Write(packet);  						while (true)  						{  							buf = session.Read(buf);  							command = buf.GetCommand() & unchecked((int)(0xff));  							if (command == SSH_MSG_USERAUTH_PK_OK)  							{  								break;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									break;  								}  								else  								{  									if (command == SSH_MSG_USERAUTH_BANNER)  									{  										buf.GetInt();  										buf.GetByte();  										buf.GetByte();  										byte[] _message = buf.GetString();  										byte[] lang = buf.GetString();  										string message = Util.Byte2str(_message);  										if (userinfo != null)  										{  											userinfo.ShowMessage(message);  										}  										goto loop1_continue;  									}  									else  									{  										//System.err.println("USERAUTH fail ("+command+")");  										//throw new JSchException("USERAUTH fail ("+command+")");  										break;  									}  								}  							}  loop1_continue: ;  						}  loop1_break: ;  						if (command != SSH_MSG_USERAUTH_PK_OK)  						{  							continue;  						}  					}  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					int count = 5;  					while (true)  					{  						if ((identity.IsEncrypted() && passphrase == null))  						{  							if (userinfo == null)  							{  								throw new JSchException("USERAUTH fail");  							}  							if (identity.IsEncrypted() && !userinfo.PromptPassphrase("Passphrase for " + identity  								.GetName()))  							{  								throw new JSchAuthCancelException("publickey");  							}  							//throw new JSchException("USERAUTH cancel");  							//break;  							string _passphrase = userinfo.GetPassphrase();  							if (_passphrase != null)  							{  								passphrase = Util.Str2byte(_passphrase);  							}  						}  						if (!identity.IsEncrypted() || passphrase != null)  						{  							if (identity.SetPassphrase(passphrase))  							{  								break;  							}  							else  							{  								throw new System.Exception ("Invalid passphrase supplied for the ssh key");  							}  						}  						Util.Bzero(passphrase);  						passphrase = null;  						count--;  						if (count == 0)  						{  							break;  						}  					}  					Util.Bzero(passphrase);  					passphrase = null;  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					if (identity.IsEncrypted())  					{  						continue;  					}  					if (pubkeyblob == null)  					{  						pubkeyblob = identity.GetPublicKeyBlob();  					}  					//System.err.println("UserAuthPublicKey: pubkeyblob="+pubkeyblob);  					if (pubkeyblob == null)  					{  						continue;  					}  					// send  					// byte      SSH_MSG_USERAUTH_REQUEST(50)  					// string    user name  					// string    service name ("ssh-connection")  					// string    "publickey"  					// boolen    TRUE  					// string    plaintext password (ISO-10646 UTF-8)  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  					buf.PutString(_username);  					buf.PutString(Util.Str2byte("ssh-connection"));  					buf.PutString(Util.Str2byte("publickey"));  					buf.PutByte(unchecked((byte)1));  					buf.PutString(Util.Str2byte(identity.GetAlgName()));  					buf.PutString(pubkeyblob);  					//      byte[] tmp=new byte[buf.index-5];  					//      System.arraycopy(buf.buffer' 5' tmp' 0' tmp.length);  					//      buf.putString(signature);  					byte[] sid = session.GetSessionId();  					int sidlen = sid.Length;  					byte[] tmp = new byte[4 + sidlen + buf.index - 5];  					tmp[0] = unchecked((byte)((int)(((uint)sidlen) >> 24)));  					tmp[1] = unchecked((byte)((int)(((uint)sidlen) >> 16)));  					tmp[2] = unchecked((byte)((int)(((uint)sidlen) >> 8)));  					tmp[3] = unchecked((byte)(sidlen));  					System.Array.Copy(sid' 0' tmp' 4' sidlen);  					System.Array.Copy(buf.buffer' 5' tmp' 4 + sidlen' buf.index - 5);  					byte[] signature = identity.GetSignature(tmp);  					if (signature == null)  					{  						// for example' too long key length.  						break;  					}  					buf.PutString(signature);  					session.Write(packet);  					while (true)  					{  						buf = session.Read(buf);  						command = buf.GetCommand() & unchecked((int)(0xff));  						if (command == SSH_MSG_USERAUTH_SUCCESS)  						{  							return true;  						}  						else  						{  							if (command == SSH_MSG_USERAUTH_BANNER)  							{  								buf.GetInt();  								buf.GetByte();  								buf.GetByte();  								byte[] _message = buf.GetString();  								byte[] lang = buf.GetString();  								string message = Util.Byte2str(_message);  								if (userinfo != null)  								{  									userinfo.ShowMessage(message);  								}  								goto loop2_continue;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									buf.GetInt();  									buf.GetByte();  									buf.GetByte();  									byte[] foo = buf.GetString();  									int partial_success = buf.GetByte();  									//System.err.println(new String(foo)+  									//                   " partial_success:"+(partial_success!=0));  									if (partial_success != 0)  									{  										throw new JSchPartialAuthException(Util.Byte2str(foo));  									}  									session.auth_failures++;  									break;  								}  							}  						}  						//System.err.println("USERAUTH fail ("+command+")");  						//throw new JSchException("USERAUTH fail ("+command+")");  						break;  loop2_continue: ;  					}  loop2_break: ;  				}  			}
Magic Number,NSch,UserAuthPublicKey,C:\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: lock (identities)  			{  				if (identities.Count <= 0)  				{  					return false;  				}  				_username = Util.Str2byte(username);  				for (int i = 0; i < identities.Count; i++)  				{  					if (session.auth_failures >= session.max_auth_tries)  					{  						return false;  					}  					Identity identity = (Identity)(identities[i]);  					byte[] pubkeyblob = identity.GetPublicKeyBlob();  					//System.err.println("UserAuthPublicKey: "+identity+" "+pubkeyblob);  					if (pubkeyblob != null)  					{  						// send  						// byte      SSH_MSG_USERAUTH_REQUEST(50)  						// string    user name  						// string    service name ("ssh-connection")  						// string    "publickey"  						// boolen    FALSE  						// string    plaintext password (ISO-10646 UTF-8)  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  						buf.PutString(_username);  						buf.PutString(Util.Str2byte("ssh-connection"));  						buf.PutString(Util.Str2byte("publickey"));  						buf.PutByte(unchecked((byte)0));  						buf.PutString(Util.Str2byte(identity.GetAlgName()));  						buf.PutString(pubkeyblob);  						session.Write(packet);  						while (true)  						{  							buf = session.Read(buf);  							command = buf.GetCommand() & unchecked((int)(0xff));  							if (command == SSH_MSG_USERAUTH_PK_OK)  							{  								break;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									break;  								}  								else  								{  									if (command == SSH_MSG_USERAUTH_BANNER)  									{  										buf.GetInt();  										buf.GetByte();  										buf.GetByte();  										byte[] _message = buf.GetString();  										byte[] lang = buf.GetString();  										string message = Util.Byte2str(_message);  										if (userinfo != null)  										{  											userinfo.ShowMessage(message);  										}  										goto loop1_continue;  									}  									else  									{  										//System.err.println("USERAUTH fail ("+command+")");  										//throw new JSchException("USERAUTH fail ("+command+")");  										break;  									}  								}  							}  loop1_continue: ;  						}  loop1_break: ;  						if (command != SSH_MSG_USERAUTH_PK_OK)  						{  							continue;  						}  					}  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					int count = 5;  					while (true)  					{  						if ((identity.IsEncrypted() && passphrase == null))  						{  							if (userinfo == null)  							{  								throw new JSchException("USERAUTH fail");  							}  							if (identity.IsEncrypted() && !userinfo.PromptPassphrase("Passphrase for " + identity  								.GetName()))  							{  								throw new JSchAuthCancelException("publickey");  							}  							//throw new JSchException("USERAUTH cancel");  							//break;  							string _passphrase = userinfo.GetPassphrase();  							if (_passphrase != null)  							{  								passphrase = Util.Str2byte(_passphrase);  							}  						}  						if (!identity.IsEncrypted() || passphrase != null)  						{  							if (identity.SetPassphrase(passphrase))  							{  								break;  							}  							else  							{  								throw new System.Exception ("Invalid passphrase supplied for the ssh key");  							}  						}  						Util.Bzero(passphrase);  						passphrase = null;  						count--;  						if (count == 0)  						{  							break;  						}  					}  					Util.Bzero(passphrase);  					passphrase = null;  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					if (identity.IsEncrypted())  					{  						continue;  					}  					if (pubkeyblob == null)  					{  						pubkeyblob = identity.GetPublicKeyBlob();  					}  					//System.err.println("UserAuthPublicKey: pubkeyblob="+pubkeyblob);  					if (pubkeyblob == null)  					{  						continue;  					}  					// send  					// byte      SSH_MSG_USERAUTH_REQUEST(50)  					// string    user name  					// string    service name ("ssh-connection")  					// string    "publickey"  					// boolen    TRUE  					// string    plaintext password (ISO-10646 UTF-8)  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  					buf.PutString(_username);  					buf.PutString(Util.Str2byte("ssh-connection"));  					buf.PutString(Util.Str2byte("publickey"));  					buf.PutByte(unchecked((byte)1));  					buf.PutString(Util.Str2byte(identity.GetAlgName()));  					buf.PutString(pubkeyblob);  					//      byte[] tmp=new byte[buf.index-5];  					//      System.arraycopy(buf.buffer' 5' tmp' 0' tmp.length);  					//      buf.putString(signature);  					byte[] sid = session.GetSessionId();  					int sidlen = sid.Length;  					byte[] tmp = new byte[4 + sidlen + buf.index - 5];  					tmp[0] = unchecked((byte)((int)(((uint)sidlen) >> 24)));  					tmp[1] = unchecked((byte)((int)(((uint)sidlen) >> 16)));  					tmp[2] = unchecked((byte)((int)(((uint)sidlen) >> 8)));  					tmp[3] = unchecked((byte)(sidlen));  					System.Array.Copy(sid' 0' tmp' 4' sidlen);  					System.Array.Copy(buf.buffer' 5' tmp' 4 + sidlen' buf.index - 5);  					byte[] signature = identity.GetSignature(tmp);  					if (signature == null)  					{  						// for example' too long key length.  						break;  					}  					buf.PutString(signature);  					session.Write(packet);  					while (true)  					{  						buf = session.Read(buf);  						command = buf.GetCommand() & unchecked((int)(0xff));  						if (command == SSH_MSG_USERAUTH_SUCCESS)  						{  							return true;  						}  						else  						{  							if (command == SSH_MSG_USERAUTH_BANNER)  							{  								buf.GetInt();  								buf.GetByte();  								buf.GetByte();  								byte[] _message = buf.GetString();  								byte[] lang = buf.GetString();  								string message = Util.Byte2str(_message);  								if (userinfo != null)  								{  									userinfo.ShowMessage(message);  								}  								goto loop2_continue;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									buf.GetInt();  									buf.GetByte();  									buf.GetByte();  									byte[] foo = buf.GetString();  									int partial_success = buf.GetByte();  									//System.err.println(new String(foo)+  									//                   " partial_success:"+(partial_success!=0));  									if (partial_success != 0)  									{  										throw new JSchPartialAuthException(Util.Byte2str(foo));  									}  									session.auth_failures++;  									break;  								}  							}  						}  						//System.err.println("USERAUTH fail ("+command+")");  						//throw new JSchException("USERAUTH fail ("+command+")");  						break;  loop2_continue: ;  					}  loop2_break: ;  				}  			}
Magic Number,NSch,UserAuthPublicKey,C:\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: lock (identities)  			{  				if (identities.Count <= 0)  				{  					return false;  				}  				_username = Util.Str2byte(username);  				for (int i = 0; i < identities.Count; i++)  				{  					if (session.auth_failures >= session.max_auth_tries)  					{  						return false;  					}  					Identity identity = (Identity)(identities[i]);  					byte[] pubkeyblob = identity.GetPublicKeyBlob();  					//System.err.println("UserAuthPublicKey: "+identity+" "+pubkeyblob);  					if (pubkeyblob != null)  					{  						// send  						// byte      SSH_MSG_USERAUTH_REQUEST(50)  						// string    user name  						// string    service name ("ssh-connection")  						// string    "publickey"  						// boolen    FALSE  						// string    plaintext password (ISO-10646 UTF-8)  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  						buf.PutString(_username);  						buf.PutString(Util.Str2byte("ssh-connection"));  						buf.PutString(Util.Str2byte("publickey"));  						buf.PutByte(unchecked((byte)0));  						buf.PutString(Util.Str2byte(identity.GetAlgName()));  						buf.PutString(pubkeyblob);  						session.Write(packet);  						while (true)  						{  							buf = session.Read(buf);  							command = buf.GetCommand() & unchecked((int)(0xff));  							if (command == SSH_MSG_USERAUTH_PK_OK)  							{  								break;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									break;  								}  								else  								{  									if (command == SSH_MSG_USERAUTH_BANNER)  									{  										buf.GetInt();  										buf.GetByte();  										buf.GetByte();  										byte[] _message = buf.GetString();  										byte[] lang = buf.GetString();  										string message = Util.Byte2str(_message);  										if (userinfo != null)  										{  											userinfo.ShowMessage(message);  										}  										goto loop1_continue;  									}  									else  									{  										//System.err.println("USERAUTH fail ("+command+")");  										//throw new JSchException("USERAUTH fail ("+command+")");  										break;  									}  								}  							}  loop1_continue: ;  						}  loop1_break: ;  						if (command != SSH_MSG_USERAUTH_PK_OK)  						{  							continue;  						}  					}  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					int count = 5;  					while (true)  					{  						if ((identity.IsEncrypted() && passphrase == null))  						{  							if (userinfo == null)  							{  								throw new JSchException("USERAUTH fail");  							}  							if (identity.IsEncrypted() && !userinfo.PromptPassphrase("Passphrase for " + identity  								.GetName()))  							{  								throw new JSchAuthCancelException("publickey");  							}  							//throw new JSchException("USERAUTH cancel");  							//break;  							string _passphrase = userinfo.GetPassphrase();  							if (_passphrase != null)  							{  								passphrase = Util.Str2byte(_passphrase);  							}  						}  						if (!identity.IsEncrypted() || passphrase != null)  						{  							if (identity.SetPassphrase(passphrase))  							{  								break;  							}  							else  							{  								throw new System.Exception ("Invalid passphrase supplied for the ssh key");  							}  						}  						Util.Bzero(passphrase);  						passphrase = null;  						count--;  						if (count == 0)  						{  							break;  						}  					}  					Util.Bzero(passphrase);  					passphrase = null;  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					if (identity.IsEncrypted())  					{  						continue;  					}  					if (pubkeyblob == null)  					{  						pubkeyblob = identity.GetPublicKeyBlob();  					}  					//System.err.println("UserAuthPublicKey: pubkeyblob="+pubkeyblob);  					if (pubkeyblob == null)  					{  						continue;  					}  					// send  					// byte      SSH_MSG_USERAUTH_REQUEST(50)  					// string    user name  					// string    service name ("ssh-connection")  					// string    "publickey"  					// boolen    TRUE  					// string    plaintext password (ISO-10646 UTF-8)  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  					buf.PutString(_username);  					buf.PutString(Util.Str2byte("ssh-connection"));  					buf.PutString(Util.Str2byte("publickey"));  					buf.PutByte(unchecked((byte)1));  					buf.PutString(Util.Str2byte(identity.GetAlgName()));  					buf.PutString(pubkeyblob);  					//      byte[] tmp=new byte[buf.index-5];  					//      System.arraycopy(buf.buffer' 5' tmp' 0' tmp.length);  					//      buf.putString(signature);  					byte[] sid = session.GetSessionId();  					int sidlen = sid.Length;  					byte[] tmp = new byte[4 + sidlen + buf.index - 5];  					tmp[0] = unchecked((byte)((int)(((uint)sidlen) >> 24)));  					tmp[1] = unchecked((byte)((int)(((uint)sidlen) >> 16)));  					tmp[2] = unchecked((byte)((int)(((uint)sidlen) >> 8)));  					tmp[3] = unchecked((byte)(sidlen));  					System.Array.Copy(sid' 0' tmp' 4' sidlen);  					System.Array.Copy(buf.buffer' 5' tmp' 4 + sidlen' buf.index - 5);  					byte[] signature = identity.GetSignature(tmp);  					if (signature == null)  					{  						// for example' too long key length.  						break;  					}  					buf.PutString(signature);  					session.Write(packet);  					while (true)  					{  						buf = session.Read(buf);  						command = buf.GetCommand() & unchecked((int)(0xff));  						if (command == SSH_MSG_USERAUTH_SUCCESS)  						{  							return true;  						}  						else  						{  							if (command == SSH_MSG_USERAUTH_BANNER)  							{  								buf.GetInt();  								buf.GetByte();  								buf.GetByte();  								byte[] _message = buf.GetString();  								byte[] lang = buf.GetString();  								string message = Util.Byte2str(_message);  								if (userinfo != null)  								{  									userinfo.ShowMessage(message);  								}  								goto loop2_continue;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									buf.GetInt();  									buf.GetByte();  									buf.GetByte();  									byte[] foo = buf.GetString();  									int partial_success = buf.GetByte();  									//System.err.println(new String(foo)+  									//                   " partial_success:"+(partial_success!=0));  									if (partial_success != 0)  									{  										throw new JSchPartialAuthException(Util.Byte2str(foo));  									}  									session.auth_failures++;  									break;  								}  							}  						}  						//System.err.println("USERAUTH fail ("+command+")");  						//throw new JSchException("USERAUTH fail ("+command+")");  						break;  loop2_continue: ;  					}  loop2_break: ;  				}  			}
Magic Number,NSch,UserAuthPublicKey,C:\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: lock (identities)  			{  				if (identities.Count <= 0)  				{  					return false;  				}  				_username = Util.Str2byte(username);  				for (int i = 0; i < identities.Count; i++)  				{  					if (session.auth_failures >= session.max_auth_tries)  					{  						return false;  					}  					Identity identity = (Identity)(identities[i]);  					byte[] pubkeyblob = identity.GetPublicKeyBlob();  					//System.err.println("UserAuthPublicKey: "+identity+" "+pubkeyblob);  					if (pubkeyblob != null)  					{  						// send  						// byte      SSH_MSG_USERAUTH_REQUEST(50)  						// string    user name  						// string    service name ("ssh-connection")  						// string    "publickey"  						// boolen    FALSE  						// string    plaintext password (ISO-10646 UTF-8)  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  						buf.PutString(_username);  						buf.PutString(Util.Str2byte("ssh-connection"));  						buf.PutString(Util.Str2byte("publickey"));  						buf.PutByte(unchecked((byte)0));  						buf.PutString(Util.Str2byte(identity.GetAlgName()));  						buf.PutString(pubkeyblob);  						session.Write(packet);  						while (true)  						{  							buf = session.Read(buf);  							command = buf.GetCommand() & unchecked((int)(0xff));  							if (command == SSH_MSG_USERAUTH_PK_OK)  							{  								break;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									break;  								}  								else  								{  									if (command == SSH_MSG_USERAUTH_BANNER)  									{  										buf.GetInt();  										buf.GetByte();  										buf.GetByte();  										byte[] _message = buf.GetString();  										byte[] lang = buf.GetString();  										string message = Util.Byte2str(_message);  										if (userinfo != null)  										{  											userinfo.ShowMessage(message);  										}  										goto loop1_continue;  									}  									else  									{  										//System.err.println("USERAUTH fail ("+command+")");  										//throw new JSchException("USERAUTH fail ("+command+")");  										break;  									}  								}  							}  loop1_continue: ;  						}  loop1_break: ;  						if (command != SSH_MSG_USERAUTH_PK_OK)  						{  							continue;  						}  					}  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					int count = 5;  					while (true)  					{  						if ((identity.IsEncrypted() && passphrase == null))  						{  							if (userinfo == null)  							{  								throw new JSchException("USERAUTH fail");  							}  							if (identity.IsEncrypted() && !userinfo.PromptPassphrase("Passphrase for " + identity  								.GetName()))  							{  								throw new JSchAuthCancelException("publickey");  							}  							//throw new JSchException("USERAUTH cancel");  							//break;  							string _passphrase = userinfo.GetPassphrase();  							if (_passphrase != null)  							{  								passphrase = Util.Str2byte(_passphrase);  							}  						}  						if (!identity.IsEncrypted() || passphrase != null)  						{  							if (identity.SetPassphrase(passphrase))  							{  								break;  							}  							else  							{  								throw new System.Exception ("Invalid passphrase supplied for the ssh key");  							}  						}  						Util.Bzero(passphrase);  						passphrase = null;  						count--;  						if (count == 0)  						{  							break;  						}  					}  					Util.Bzero(passphrase);  					passphrase = null;  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					if (identity.IsEncrypted())  					{  						continue;  					}  					if (pubkeyblob == null)  					{  						pubkeyblob = identity.GetPublicKeyBlob();  					}  					//System.err.println("UserAuthPublicKey: pubkeyblob="+pubkeyblob);  					if (pubkeyblob == null)  					{  						continue;  					}  					// send  					// byte      SSH_MSG_USERAUTH_REQUEST(50)  					// string    user name  					// string    service name ("ssh-connection")  					// string    "publickey"  					// boolen    TRUE  					// string    plaintext password (ISO-10646 UTF-8)  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  					buf.PutString(_username);  					buf.PutString(Util.Str2byte("ssh-connection"));  					buf.PutString(Util.Str2byte("publickey"));  					buf.PutByte(unchecked((byte)1));  					buf.PutString(Util.Str2byte(identity.GetAlgName()));  					buf.PutString(pubkeyblob);  					//      byte[] tmp=new byte[buf.index-5];  					//      System.arraycopy(buf.buffer' 5' tmp' 0' tmp.length);  					//      buf.putString(signature);  					byte[] sid = session.GetSessionId();  					int sidlen = sid.Length;  					byte[] tmp = new byte[4 + sidlen + buf.index - 5];  					tmp[0] = unchecked((byte)((int)(((uint)sidlen) >> 24)));  					tmp[1] = unchecked((byte)((int)(((uint)sidlen) >> 16)));  					tmp[2] = unchecked((byte)((int)(((uint)sidlen) >> 8)));  					tmp[3] = unchecked((byte)(sidlen));  					System.Array.Copy(sid' 0' tmp' 4' sidlen);  					System.Array.Copy(buf.buffer' 5' tmp' 4 + sidlen' buf.index - 5);  					byte[] signature = identity.GetSignature(tmp);  					if (signature == null)  					{  						// for example' too long key length.  						break;  					}  					buf.PutString(signature);  					session.Write(packet);  					while (true)  					{  						buf = session.Read(buf);  						command = buf.GetCommand() & unchecked((int)(0xff));  						if (command == SSH_MSG_USERAUTH_SUCCESS)  						{  							return true;  						}  						else  						{  							if (command == SSH_MSG_USERAUTH_BANNER)  							{  								buf.GetInt();  								buf.GetByte();  								buf.GetByte();  								byte[] _message = buf.GetString();  								byte[] lang = buf.GetString();  								string message = Util.Byte2str(_message);  								if (userinfo != null)  								{  									userinfo.ShowMessage(message);  								}  								goto loop2_continue;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									buf.GetInt();  									buf.GetByte();  									buf.GetByte();  									byte[] foo = buf.GetString();  									int partial_success = buf.GetByte();  									//System.err.println(new String(foo)+  									//                   " partial_success:"+(partial_success!=0));  									if (partial_success != 0)  									{  										throw new JSchPartialAuthException(Util.Byte2str(foo));  									}  									session.auth_failures++;  									break;  								}  							}  						}  						//System.err.println("USERAUTH fail ("+command+")");  						//throw new JSchException("USERAUTH fail ("+command+")");  						break;  loop2_continue: ;  					}  loop2_break: ;  				}  			}
Magic Number,NSch,UserAuthPublicKey,C:\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: lock (identities)  			{  				if (identities.Count <= 0)  				{  					return false;  				}  				_username = Util.Str2byte(username);  				for (int i = 0; i < identities.Count; i++)  				{  					if (session.auth_failures >= session.max_auth_tries)  					{  						return false;  					}  					Identity identity = (Identity)(identities[i]);  					byte[] pubkeyblob = identity.GetPublicKeyBlob();  					//System.err.println("UserAuthPublicKey: "+identity+" "+pubkeyblob);  					if (pubkeyblob != null)  					{  						// send  						// byte      SSH_MSG_USERAUTH_REQUEST(50)  						// string    user name  						// string    service name ("ssh-connection")  						// string    "publickey"  						// boolen    FALSE  						// string    plaintext password (ISO-10646 UTF-8)  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  						buf.PutString(_username);  						buf.PutString(Util.Str2byte("ssh-connection"));  						buf.PutString(Util.Str2byte("publickey"));  						buf.PutByte(unchecked((byte)0));  						buf.PutString(Util.Str2byte(identity.GetAlgName()));  						buf.PutString(pubkeyblob);  						session.Write(packet);  						while (true)  						{  							buf = session.Read(buf);  							command = buf.GetCommand() & unchecked((int)(0xff));  							if (command == SSH_MSG_USERAUTH_PK_OK)  							{  								break;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									break;  								}  								else  								{  									if (command == SSH_MSG_USERAUTH_BANNER)  									{  										buf.GetInt();  										buf.GetByte();  										buf.GetByte();  										byte[] _message = buf.GetString();  										byte[] lang = buf.GetString();  										string message = Util.Byte2str(_message);  										if (userinfo != null)  										{  											userinfo.ShowMessage(message);  										}  										goto loop1_continue;  									}  									else  									{  										//System.err.println("USERAUTH fail ("+command+")");  										//throw new JSchException("USERAUTH fail ("+command+")");  										break;  									}  								}  							}  loop1_continue: ;  						}  loop1_break: ;  						if (command != SSH_MSG_USERAUTH_PK_OK)  						{  							continue;  						}  					}  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					int count = 5;  					while (true)  					{  						if ((identity.IsEncrypted() && passphrase == null))  						{  							if (userinfo == null)  							{  								throw new JSchException("USERAUTH fail");  							}  							if (identity.IsEncrypted() && !userinfo.PromptPassphrase("Passphrase for " + identity  								.GetName()))  							{  								throw new JSchAuthCancelException("publickey");  							}  							//throw new JSchException("USERAUTH cancel");  							//break;  							string _passphrase = userinfo.GetPassphrase();  							if (_passphrase != null)  							{  								passphrase = Util.Str2byte(_passphrase);  							}  						}  						if (!identity.IsEncrypted() || passphrase != null)  						{  							if (identity.SetPassphrase(passphrase))  							{  								break;  							}  							else  							{  								throw new System.Exception ("Invalid passphrase supplied for the ssh key");  							}  						}  						Util.Bzero(passphrase);  						passphrase = null;  						count--;  						if (count == 0)  						{  							break;  						}  					}  					Util.Bzero(passphrase);  					passphrase = null;  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					if (identity.IsEncrypted())  					{  						continue;  					}  					if (pubkeyblob == null)  					{  						pubkeyblob = identity.GetPublicKeyBlob();  					}  					//System.err.println("UserAuthPublicKey: pubkeyblob="+pubkeyblob);  					if (pubkeyblob == null)  					{  						continue;  					}  					// send  					// byte      SSH_MSG_USERAUTH_REQUEST(50)  					// string    user name  					// string    service name ("ssh-connection")  					// string    "publickey"  					// boolen    TRUE  					// string    plaintext password (ISO-10646 UTF-8)  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  					buf.PutString(_username);  					buf.PutString(Util.Str2byte("ssh-connection"));  					buf.PutString(Util.Str2byte("publickey"));  					buf.PutByte(unchecked((byte)1));  					buf.PutString(Util.Str2byte(identity.GetAlgName()));  					buf.PutString(pubkeyblob);  					//      byte[] tmp=new byte[buf.index-5];  					//      System.arraycopy(buf.buffer' 5' tmp' 0' tmp.length);  					//      buf.putString(signature);  					byte[] sid = session.GetSessionId();  					int sidlen = sid.Length;  					byte[] tmp = new byte[4 + sidlen + buf.index - 5];  					tmp[0] = unchecked((byte)((int)(((uint)sidlen) >> 24)));  					tmp[1] = unchecked((byte)((int)(((uint)sidlen) >> 16)));  					tmp[2] = unchecked((byte)((int)(((uint)sidlen) >> 8)));  					tmp[3] = unchecked((byte)(sidlen));  					System.Array.Copy(sid' 0' tmp' 4' sidlen);  					System.Array.Copy(buf.buffer' 5' tmp' 4 + sidlen' buf.index - 5);  					byte[] signature = identity.GetSignature(tmp);  					if (signature == null)  					{  						// for example' too long key length.  						break;  					}  					buf.PutString(signature);  					session.Write(packet);  					while (true)  					{  						buf = session.Read(buf);  						command = buf.GetCommand() & unchecked((int)(0xff));  						if (command == SSH_MSG_USERAUTH_SUCCESS)  						{  							return true;  						}  						else  						{  							if (command == SSH_MSG_USERAUTH_BANNER)  							{  								buf.GetInt();  								buf.GetByte();  								buf.GetByte();  								byte[] _message = buf.GetString();  								byte[] lang = buf.GetString();  								string message = Util.Byte2str(_message);  								if (userinfo != null)  								{  									userinfo.ShowMessage(message);  								}  								goto loop2_continue;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									buf.GetInt();  									buf.GetByte();  									buf.GetByte();  									byte[] foo = buf.GetString();  									int partial_success = buf.GetByte();  									//System.err.println(new String(foo)+  									//                   " partial_success:"+(partial_success!=0));  									if (partial_success != 0)  									{  										throw new JSchPartialAuthException(Util.Byte2str(foo));  									}  									session.auth_failures++;  									break;  								}  							}  						}  						//System.err.println("USERAUTH fail ("+command+")");  						//throw new JSchException("USERAUTH fail ("+command+")");  						break;  loop2_continue: ;  					}  loop2_break: ;  				}  			}
Magic Number,NSch,UserAuthPublicKey,C:\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: lock (identities)  			{  				if (identities.Count <= 0)  				{  					return false;  				}  				_username = Util.Str2byte(username);  				for (int i = 0; i < identities.Count; i++)  				{  					if (session.auth_failures >= session.max_auth_tries)  					{  						return false;  					}  					Identity identity = (Identity)(identities[i]);  					byte[] pubkeyblob = identity.GetPublicKeyBlob();  					//System.err.println("UserAuthPublicKey: "+identity+" "+pubkeyblob);  					if (pubkeyblob != null)  					{  						// send  						// byte      SSH_MSG_USERAUTH_REQUEST(50)  						// string    user name  						// string    service name ("ssh-connection")  						// string    "publickey"  						// boolen    FALSE  						// string    plaintext password (ISO-10646 UTF-8)  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  						buf.PutString(_username);  						buf.PutString(Util.Str2byte("ssh-connection"));  						buf.PutString(Util.Str2byte("publickey"));  						buf.PutByte(unchecked((byte)0));  						buf.PutString(Util.Str2byte(identity.GetAlgName()));  						buf.PutString(pubkeyblob);  						session.Write(packet);  						while (true)  						{  							buf = session.Read(buf);  							command = buf.GetCommand() & unchecked((int)(0xff));  							if (command == SSH_MSG_USERAUTH_PK_OK)  							{  								break;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									break;  								}  								else  								{  									if (command == SSH_MSG_USERAUTH_BANNER)  									{  										buf.GetInt();  										buf.GetByte();  										buf.GetByte();  										byte[] _message = buf.GetString();  										byte[] lang = buf.GetString();  										string message = Util.Byte2str(_message);  										if (userinfo != null)  										{  											userinfo.ShowMessage(message);  										}  										goto loop1_continue;  									}  									else  									{  										//System.err.println("USERAUTH fail ("+command+")");  										//throw new JSchException("USERAUTH fail ("+command+")");  										break;  									}  								}  							}  loop1_continue: ;  						}  loop1_break: ;  						if (command != SSH_MSG_USERAUTH_PK_OK)  						{  							continue;  						}  					}  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					int count = 5;  					while (true)  					{  						if ((identity.IsEncrypted() && passphrase == null))  						{  							if (userinfo == null)  							{  								throw new JSchException("USERAUTH fail");  							}  							if (identity.IsEncrypted() && !userinfo.PromptPassphrase("Passphrase for " + identity  								.GetName()))  							{  								throw new JSchAuthCancelException("publickey");  							}  							//throw new JSchException("USERAUTH cancel");  							//break;  							string _passphrase = userinfo.GetPassphrase();  							if (_passphrase != null)  							{  								passphrase = Util.Str2byte(_passphrase);  							}  						}  						if (!identity.IsEncrypted() || passphrase != null)  						{  							if (identity.SetPassphrase(passphrase))  							{  								break;  							}  							else  							{  								throw new System.Exception ("Invalid passphrase supplied for the ssh key");  							}  						}  						Util.Bzero(passphrase);  						passphrase = null;  						count--;  						if (count == 0)  						{  							break;  						}  					}  					Util.Bzero(passphrase);  					passphrase = null;  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					if (identity.IsEncrypted())  					{  						continue;  					}  					if (pubkeyblob == null)  					{  						pubkeyblob = identity.GetPublicKeyBlob();  					}  					//System.err.println("UserAuthPublicKey: pubkeyblob="+pubkeyblob);  					if (pubkeyblob == null)  					{  						continue;  					}  					// send  					// byte      SSH_MSG_USERAUTH_REQUEST(50)  					// string    user name  					// string    service name ("ssh-connection")  					// string    "publickey"  					// boolen    TRUE  					// string    plaintext password (ISO-10646 UTF-8)  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  					buf.PutString(_username);  					buf.PutString(Util.Str2byte("ssh-connection"));  					buf.PutString(Util.Str2byte("publickey"));  					buf.PutByte(unchecked((byte)1));  					buf.PutString(Util.Str2byte(identity.GetAlgName()));  					buf.PutString(pubkeyblob);  					//      byte[] tmp=new byte[buf.index-5];  					//      System.arraycopy(buf.buffer' 5' tmp' 0' tmp.length);  					//      buf.putString(signature);  					byte[] sid = session.GetSessionId();  					int sidlen = sid.Length;  					byte[] tmp = new byte[4 + sidlen + buf.index - 5];  					tmp[0] = unchecked((byte)((int)(((uint)sidlen) >> 24)));  					tmp[1] = unchecked((byte)((int)(((uint)sidlen) >> 16)));  					tmp[2] = unchecked((byte)((int)(((uint)sidlen) >> 8)));  					tmp[3] = unchecked((byte)(sidlen));  					System.Array.Copy(sid' 0' tmp' 4' sidlen);  					System.Array.Copy(buf.buffer' 5' tmp' 4 + sidlen' buf.index - 5);  					byte[] signature = identity.GetSignature(tmp);  					if (signature == null)  					{  						// for example' too long key length.  						break;  					}  					buf.PutString(signature);  					session.Write(packet);  					while (true)  					{  						buf = session.Read(buf);  						command = buf.GetCommand() & unchecked((int)(0xff));  						if (command == SSH_MSG_USERAUTH_SUCCESS)  						{  							return true;  						}  						else  						{  							if (command == SSH_MSG_USERAUTH_BANNER)  							{  								buf.GetInt();  								buf.GetByte();  								buf.GetByte();  								byte[] _message = buf.GetString();  								byte[] lang = buf.GetString();  								string message = Util.Byte2str(_message);  								if (userinfo != null)  								{  									userinfo.ShowMessage(message);  								}  								goto loop2_continue;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									buf.GetInt();  									buf.GetByte();  									buf.GetByte();  									byte[] foo = buf.GetString();  									int partial_success = buf.GetByte();  									//System.err.println(new String(foo)+  									//                   " partial_success:"+(partial_success!=0));  									if (partial_success != 0)  									{  										throw new JSchPartialAuthException(Util.Byte2str(foo));  									}  									session.auth_failures++;  									break;  								}  							}  						}  						//System.err.println("USERAUTH fail ("+command+")");  						//throw new JSchException("USERAUTH fail ("+command+")");  						break;  loop2_continue: ;  					}  loop2_break: ;  				}  			}
Magic Number,NSch,UserAuthPublicKey,C:\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: lock (identities)  			{  				if (identities.Count <= 0)  				{  					return false;  				}  				_username = Util.Str2byte(username);  				for (int i = 0; i < identities.Count; i++)  				{  					if (session.auth_failures >= session.max_auth_tries)  					{  						return false;  					}  					Identity identity = (Identity)(identities[i]);  					byte[] pubkeyblob = identity.GetPublicKeyBlob();  					//System.err.println("UserAuthPublicKey: "+identity+" "+pubkeyblob);  					if (pubkeyblob != null)  					{  						// send  						// byte      SSH_MSG_USERAUTH_REQUEST(50)  						// string    user name  						// string    service name ("ssh-connection")  						// string    "publickey"  						// boolen    FALSE  						// string    plaintext password (ISO-10646 UTF-8)  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  						buf.PutString(_username);  						buf.PutString(Util.Str2byte("ssh-connection"));  						buf.PutString(Util.Str2byte("publickey"));  						buf.PutByte(unchecked((byte)0));  						buf.PutString(Util.Str2byte(identity.GetAlgName()));  						buf.PutString(pubkeyblob);  						session.Write(packet);  						while (true)  						{  							buf = session.Read(buf);  							command = buf.GetCommand() & unchecked((int)(0xff));  							if (command == SSH_MSG_USERAUTH_PK_OK)  							{  								break;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									break;  								}  								else  								{  									if (command == SSH_MSG_USERAUTH_BANNER)  									{  										buf.GetInt();  										buf.GetByte();  										buf.GetByte();  										byte[] _message = buf.GetString();  										byte[] lang = buf.GetString();  										string message = Util.Byte2str(_message);  										if (userinfo != null)  										{  											userinfo.ShowMessage(message);  										}  										goto loop1_continue;  									}  									else  									{  										//System.err.println("USERAUTH fail ("+command+")");  										//throw new JSchException("USERAUTH fail ("+command+")");  										break;  									}  								}  							}  loop1_continue: ;  						}  loop1_break: ;  						if (command != SSH_MSG_USERAUTH_PK_OK)  						{  							continue;  						}  					}  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					int count = 5;  					while (true)  					{  						if ((identity.IsEncrypted() && passphrase == null))  						{  							if (userinfo == null)  							{  								throw new JSchException("USERAUTH fail");  							}  							if (identity.IsEncrypted() && !userinfo.PromptPassphrase("Passphrase for " + identity  								.GetName()))  							{  								throw new JSchAuthCancelException("publickey");  							}  							//throw new JSchException("USERAUTH cancel");  							//break;  							string _passphrase = userinfo.GetPassphrase();  							if (_passphrase != null)  							{  								passphrase = Util.Str2byte(_passphrase);  							}  						}  						if (!identity.IsEncrypted() || passphrase != null)  						{  							if (identity.SetPassphrase(passphrase))  							{  								break;  							}  							else  							{  								throw new System.Exception ("Invalid passphrase supplied for the ssh key");  							}  						}  						Util.Bzero(passphrase);  						passphrase = null;  						count--;  						if (count == 0)  						{  							break;  						}  					}  					Util.Bzero(passphrase);  					passphrase = null;  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					if (identity.IsEncrypted())  					{  						continue;  					}  					if (pubkeyblob == null)  					{  						pubkeyblob = identity.GetPublicKeyBlob();  					}  					//System.err.println("UserAuthPublicKey: pubkeyblob="+pubkeyblob);  					if (pubkeyblob == null)  					{  						continue;  					}  					// send  					// byte      SSH_MSG_USERAUTH_REQUEST(50)  					// string    user name  					// string    service name ("ssh-connection")  					// string    "publickey"  					// boolen    TRUE  					// string    plaintext password (ISO-10646 UTF-8)  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  					buf.PutString(_username);  					buf.PutString(Util.Str2byte("ssh-connection"));  					buf.PutString(Util.Str2byte("publickey"));  					buf.PutByte(unchecked((byte)1));  					buf.PutString(Util.Str2byte(identity.GetAlgName()));  					buf.PutString(pubkeyblob);  					//      byte[] tmp=new byte[buf.index-5];  					//      System.arraycopy(buf.buffer' 5' tmp' 0' tmp.length);  					//      buf.putString(signature);  					byte[] sid = session.GetSessionId();  					int sidlen = sid.Length;  					byte[] tmp = new byte[4 + sidlen + buf.index - 5];  					tmp[0] = unchecked((byte)((int)(((uint)sidlen) >> 24)));  					tmp[1] = unchecked((byte)((int)(((uint)sidlen) >> 16)));  					tmp[2] = unchecked((byte)((int)(((uint)sidlen) >> 8)));  					tmp[3] = unchecked((byte)(sidlen));  					System.Array.Copy(sid' 0' tmp' 4' sidlen);  					System.Array.Copy(buf.buffer' 5' tmp' 4 + sidlen' buf.index - 5);  					byte[] signature = identity.GetSignature(tmp);  					if (signature == null)  					{  						// for example' too long key length.  						break;  					}  					buf.PutString(signature);  					session.Write(packet);  					while (true)  					{  						buf = session.Read(buf);  						command = buf.GetCommand() & unchecked((int)(0xff));  						if (command == SSH_MSG_USERAUTH_SUCCESS)  						{  							return true;  						}  						else  						{  							if (command == SSH_MSG_USERAUTH_BANNER)  							{  								buf.GetInt();  								buf.GetByte();  								buf.GetByte();  								byte[] _message = buf.GetString();  								byte[] lang = buf.GetString();  								string message = Util.Byte2str(_message);  								if (userinfo != null)  								{  									userinfo.ShowMessage(message);  								}  								goto loop2_continue;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									buf.GetInt();  									buf.GetByte();  									buf.GetByte();  									byte[] foo = buf.GetString();  									int partial_success = buf.GetByte();  									//System.err.println(new String(foo)+  									//                   " partial_success:"+(partial_success!=0));  									if (partial_success != 0)  									{  										throw new JSchPartialAuthException(Util.Byte2str(foo));  									}  									session.auth_failures++;  									break;  								}  							}  						}  						//System.err.println("USERAUTH fail ("+command+")");  						//throw new JSchException("USERAUTH fail ("+command+")");  						break;  loop2_continue: ;  					}  loop2_break: ;  				}  			}
Magic Number,NSch,UserAuthPublicKey,C:\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: lock (identities)  			{  				if (identities.Count <= 0)  				{  					return false;  				}  				_username = Util.Str2byte(username);  				for (int i = 0; i < identities.Count; i++)  				{  					if (session.auth_failures >= session.max_auth_tries)  					{  						return false;  					}  					Identity identity = (Identity)(identities[i]);  					byte[] pubkeyblob = identity.GetPublicKeyBlob();  					//System.err.println("UserAuthPublicKey: "+identity+" "+pubkeyblob);  					if (pubkeyblob != null)  					{  						// send  						// byte      SSH_MSG_USERAUTH_REQUEST(50)  						// string    user name  						// string    service name ("ssh-connection")  						// string    "publickey"  						// boolen    FALSE  						// string    plaintext password (ISO-10646 UTF-8)  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  						buf.PutString(_username);  						buf.PutString(Util.Str2byte("ssh-connection"));  						buf.PutString(Util.Str2byte("publickey"));  						buf.PutByte(unchecked((byte)0));  						buf.PutString(Util.Str2byte(identity.GetAlgName()));  						buf.PutString(pubkeyblob);  						session.Write(packet);  						while (true)  						{  							buf = session.Read(buf);  							command = buf.GetCommand() & unchecked((int)(0xff));  							if (command == SSH_MSG_USERAUTH_PK_OK)  							{  								break;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									break;  								}  								else  								{  									if (command == SSH_MSG_USERAUTH_BANNER)  									{  										buf.GetInt();  										buf.GetByte();  										buf.GetByte();  										byte[] _message = buf.GetString();  										byte[] lang = buf.GetString();  										string message = Util.Byte2str(_message);  										if (userinfo != null)  										{  											userinfo.ShowMessage(message);  										}  										goto loop1_continue;  									}  									else  									{  										//System.err.println("USERAUTH fail ("+command+")");  										//throw new JSchException("USERAUTH fail ("+command+")");  										break;  									}  								}  							}  loop1_continue: ;  						}  loop1_break: ;  						if (command != SSH_MSG_USERAUTH_PK_OK)  						{  							continue;  						}  					}  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					int count = 5;  					while (true)  					{  						if ((identity.IsEncrypted() && passphrase == null))  						{  							if (userinfo == null)  							{  								throw new JSchException("USERAUTH fail");  							}  							if (identity.IsEncrypted() && !userinfo.PromptPassphrase("Passphrase for " + identity  								.GetName()))  							{  								throw new JSchAuthCancelException("publickey");  							}  							//throw new JSchException("USERAUTH cancel");  							//break;  							string _passphrase = userinfo.GetPassphrase();  							if (_passphrase != null)  							{  								passphrase = Util.Str2byte(_passphrase);  							}  						}  						if (!identity.IsEncrypted() || passphrase != null)  						{  							if (identity.SetPassphrase(passphrase))  							{  								break;  							}  							else  							{  								throw new System.Exception ("Invalid passphrase supplied for the ssh key");  							}  						}  						Util.Bzero(passphrase);  						passphrase = null;  						count--;  						if (count == 0)  						{  							break;  						}  					}  					Util.Bzero(passphrase);  					passphrase = null;  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					if (identity.IsEncrypted())  					{  						continue;  					}  					if (pubkeyblob == null)  					{  						pubkeyblob = identity.GetPublicKeyBlob();  					}  					//System.err.println("UserAuthPublicKey: pubkeyblob="+pubkeyblob);  					if (pubkeyblob == null)  					{  						continue;  					}  					// send  					// byte      SSH_MSG_USERAUTH_REQUEST(50)  					// string    user name  					// string    service name ("ssh-connection")  					// string    "publickey"  					// boolen    TRUE  					// string    plaintext password (ISO-10646 UTF-8)  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  					buf.PutString(_username);  					buf.PutString(Util.Str2byte("ssh-connection"));  					buf.PutString(Util.Str2byte("publickey"));  					buf.PutByte(unchecked((byte)1));  					buf.PutString(Util.Str2byte(identity.GetAlgName()));  					buf.PutString(pubkeyblob);  					//      byte[] tmp=new byte[buf.index-5];  					//      System.arraycopy(buf.buffer' 5' tmp' 0' tmp.length);  					//      buf.putString(signature);  					byte[] sid = session.GetSessionId();  					int sidlen = sid.Length;  					byte[] tmp = new byte[4 + sidlen + buf.index - 5];  					tmp[0] = unchecked((byte)((int)(((uint)sidlen) >> 24)));  					tmp[1] = unchecked((byte)((int)(((uint)sidlen) >> 16)));  					tmp[2] = unchecked((byte)((int)(((uint)sidlen) >> 8)));  					tmp[3] = unchecked((byte)(sidlen));  					System.Array.Copy(sid' 0' tmp' 4' sidlen);  					System.Array.Copy(buf.buffer' 5' tmp' 4 + sidlen' buf.index - 5);  					byte[] signature = identity.GetSignature(tmp);  					if (signature == null)  					{  						// for example' too long key length.  						break;  					}  					buf.PutString(signature);  					session.Write(packet);  					while (true)  					{  						buf = session.Read(buf);  						command = buf.GetCommand() & unchecked((int)(0xff));  						if (command == SSH_MSG_USERAUTH_SUCCESS)  						{  							return true;  						}  						else  						{  							if (command == SSH_MSG_USERAUTH_BANNER)  							{  								buf.GetInt();  								buf.GetByte();  								buf.GetByte();  								byte[] _message = buf.GetString();  								byte[] lang = buf.GetString();  								string message = Util.Byte2str(_message);  								if (userinfo != null)  								{  									userinfo.ShowMessage(message);  								}  								goto loop2_continue;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									buf.GetInt();  									buf.GetByte();  									buf.GetByte();  									byte[] foo = buf.GetString();  									int partial_success = buf.GetByte();  									//System.err.println(new String(foo)+  									//                   " partial_success:"+(partial_success!=0));  									if (partial_success != 0)  									{  										throw new JSchPartialAuthException(Util.Byte2str(foo));  									}  									session.auth_failures++;  									break;  								}  							}  						}  						//System.err.println("USERAUTH fail ("+command+")");  						//throw new JSchException("USERAUTH fail ("+command+")");  						break;  loop2_continue: ;  					}  loop2_break: ;  				}  			}
Magic Number,NSch,UserAuthPublicKey,C:\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: lock (identities)  			{  				if (identities.Count <= 0)  				{  					return false;  				}  				_username = Util.Str2byte(username);  				for (int i = 0; i < identities.Count; i++)  				{  					if (session.auth_failures >= session.max_auth_tries)  					{  						return false;  					}  					Identity identity = (Identity)(identities[i]);  					byte[] pubkeyblob = identity.GetPublicKeyBlob();  					//System.err.println("UserAuthPublicKey: "+identity+" "+pubkeyblob);  					if (pubkeyblob != null)  					{  						// send  						// byte      SSH_MSG_USERAUTH_REQUEST(50)  						// string    user name  						// string    service name ("ssh-connection")  						// string    "publickey"  						// boolen    FALSE  						// string    plaintext password (ISO-10646 UTF-8)  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  						buf.PutString(_username);  						buf.PutString(Util.Str2byte("ssh-connection"));  						buf.PutString(Util.Str2byte("publickey"));  						buf.PutByte(unchecked((byte)0));  						buf.PutString(Util.Str2byte(identity.GetAlgName()));  						buf.PutString(pubkeyblob);  						session.Write(packet);  						while (true)  						{  							buf = session.Read(buf);  							command = buf.GetCommand() & unchecked((int)(0xff));  							if (command == SSH_MSG_USERAUTH_PK_OK)  							{  								break;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									break;  								}  								else  								{  									if (command == SSH_MSG_USERAUTH_BANNER)  									{  										buf.GetInt();  										buf.GetByte();  										buf.GetByte();  										byte[] _message = buf.GetString();  										byte[] lang = buf.GetString();  										string message = Util.Byte2str(_message);  										if (userinfo != null)  										{  											userinfo.ShowMessage(message);  										}  										goto loop1_continue;  									}  									else  									{  										//System.err.println("USERAUTH fail ("+command+")");  										//throw new JSchException("USERAUTH fail ("+command+")");  										break;  									}  								}  							}  loop1_continue: ;  						}  loop1_break: ;  						if (command != SSH_MSG_USERAUTH_PK_OK)  						{  							continue;  						}  					}  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					int count = 5;  					while (true)  					{  						if ((identity.IsEncrypted() && passphrase == null))  						{  							if (userinfo == null)  							{  								throw new JSchException("USERAUTH fail");  							}  							if (identity.IsEncrypted() && !userinfo.PromptPassphrase("Passphrase for " + identity  								.GetName()))  							{  								throw new JSchAuthCancelException("publickey");  							}  							//throw new JSchException("USERAUTH cancel");  							//break;  							string _passphrase = userinfo.GetPassphrase();  							if (_passphrase != null)  							{  								passphrase = Util.Str2byte(_passphrase);  							}  						}  						if (!identity.IsEncrypted() || passphrase != null)  						{  							if (identity.SetPassphrase(passphrase))  							{  								break;  							}  							else  							{  								throw new System.Exception ("Invalid passphrase supplied for the ssh key");  							}  						}  						Util.Bzero(passphrase);  						passphrase = null;  						count--;  						if (count == 0)  						{  							break;  						}  					}  					Util.Bzero(passphrase);  					passphrase = null;  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					if (identity.IsEncrypted())  					{  						continue;  					}  					if (pubkeyblob == null)  					{  						pubkeyblob = identity.GetPublicKeyBlob();  					}  					//System.err.println("UserAuthPublicKey: pubkeyblob="+pubkeyblob);  					if (pubkeyblob == null)  					{  						continue;  					}  					// send  					// byte      SSH_MSG_USERAUTH_REQUEST(50)  					// string    user name  					// string    service name ("ssh-connection")  					// string    "publickey"  					// boolen    TRUE  					// string    plaintext password (ISO-10646 UTF-8)  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  					buf.PutString(_username);  					buf.PutString(Util.Str2byte("ssh-connection"));  					buf.PutString(Util.Str2byte("publickey"));  					buf.PutByte(unchecked((byte)1));  					buf.PutString(Util.Str2byte(identity.GetAlgName()));  					buf.PutString(pubkeyblob);  					//      byte[] tmp=new byte[buf.index-5];  					//      System.arraycopy(buf.buffer' 5' tmp' 0' tmp.length);  					//      buf.putString(signature);  					byte[] sid = session.GetSessionId();  					int sidlen = sid.Length;  					byte[] tmp = new byte[4 + sidlen + buf.index - 5];  					tmp[0] = unchecked((byte)((int)(((uint)sidlen) >> 24)));  					tmp[1] = unchecked((byte)((int)(((uint)sidlen) >> 16)));  					tmp[2] = unchecked((byte)((int)(((uint)sidlen) >> 8)));  					tmp[3] = unchecked((byte)(sidlen));  					System.Array.Copy(sid' 0' tmp' 4' sidlen);  					System.Array.Copy(buf.buffer' 5' tmp' 4 + sidlen' buf.index - 5);  					byte[] signature = identity.GetSignature(tmp);  					if (signature == null)  					{  						// for example' too long key length.  						break;  					}  					buf.PutString(signature);  					session.Write(packet);  					while (true)  					{  						buf = session.Read(buf);  						command = buf.GetCommand() & unchecked((int)(0xff));  						if (command == SSH_MSG_USERAUTH_SUCCESS)  						{  							return true;  						}  						else  						{  							if (command == SSH_MSG_USERAUTH_BANNER)  							{  								buf.GetInt();  								buf.GetByte();  								buf.GetByte();  								byte[] _message = buf.GetString();  								byte[] lang = buf.GetString();  								string message = Util.Byte2str(_message);  								if (userinfo != null)  								{  									userinfo.ShowMessage(message);  								}  								goto loop2_continue;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									buf.GetInt();  									buf.GetByte();  									buf.GetByte();  									byte[] foo = buf.GetString();  									int partial_success = buf.GetByte();  									//System.err.println(new String(foo)+  									//                   " partial_success:"+(partial_success!=0));  									if (partial_success != 0)  									{  										throw new JSchPartialAuthException(Util.Byte2str(foo));  									}  									session.auth_failures++;  									break;  								}  							}  						}  						//System.err.println("USERAUTH fail ("+command+")");  						//throw new JSchException("USERAUTH fail ("+command+")");  						break;  loop2_continue: ;  					}  loop2_break: ;  				}  			}
Magic Number,NSch,UserAuthPublicKey,C:\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: lock (identities)  			{  				if (identities.Count <= 0)  				{  					return false;  				}  				_username = Util.Str2byte(username);  				for (int i = 0; i < identities.Count; i++)  				{  					if (session.auth_failures >= session.max_auth_tries)  					{  						return false;  					}  					Identity identity = (Identity)(identities[i]);  					byte[] pubkeyblob = identity.GetPublicKeyBlob();  					//System.err.println("UserAuthPublicKey: "+identity+" "+pubkeyblob);  					if (pubkeyblob != null)  					{  						// send  						// byte      SSH_MSG_USERAUTH_REQUEST(50)  						// string    user name  						// string    service name ("ssh-connection")  						// string    "publickey"  						// boolen    FALSE  						// string    plaintext password (ISO-10646 UTF-8)  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  						buf.PutString(_username);  						buf.PutString(Util.Str2byte("ssh-connection"));  						buf.PutString(Util.Str2byte("publickey"));  						buf.PutByte(unchecked((byte)0));  						buf.PutString(Util.Str2byte(identity.GetAlgName()));  						buf.PutString(pubkeyblob);  						session.Write(packet);  						while (true)  						{  							buf = session.Read(buf);  							command = buf.GetCommand() & unchecked((int)(0xff));  							if (command == SSH_MSG_USERAUTH_PK_OK)  							{  								break;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									break;  								}  								else  								{  									if (command == SSH_MSG_USERAUTH_BANNER)  									{  										buf.GetInt();  										buf.GetByte();  										buf.GetByte();  										byte[] _message = buf.GetString();  										byte[] lang = buf.GetString();  										string message = Util.Byte2str(_message);  										if (userinfo != null)  										{  											userinfo.ShowMessage(message);  										}  										goto loop1_continue;  									}  									else  									{  										//System.err.println("USERAUTH fail ("+command+")");  										//throw new JSchException("USERAUTH fail ("+command+")");  										break;  									}  								}  							}  loop1_continue: ;  						}  loop1_break: ;  						if (command != SSH_MSG_USERAUTH_PK_OK)  						{  							continue;  						}  					}  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					int count = 5;  					while (true)  					{  						if ((identity.IsEncrypted() && passphrase == null))  						{  							if (userinfo == null)  							{  								throw new JSchException("USERAUTH fail");  							}  							if (identity.IsEncrypted() && !userinfo.PromptPassphrase("Passphrase for " + identity  								.GetName()))  							{  								throw new JSchAuthCancelException("publickey");  							}  							//throw new JSchException("USERAUTH cancel");  							//break;  							string _passphrase = userinfo.GetPassphrase();  							if (_passphrase != null)  							{  								passphrase = Util.Str2byte(_passphrase);  							}  						}  						if (!identity.IsEncrypted() || passphrase != null)  						{  							if (identity.SetPassphrase(passphrase))  							{  								break;  							}  							else  							{  								throw new System.Exception ("Invalid passphrase supplied for the ssh key");  							}  						}  						Util.Bzero(passphrase);  						passphrase = null;  						count--;  						if (count == 0)  						{  							break;  						}  					}  					Util.Bzero(passphrase);  					passphrase = null;  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					if (identity.IsEncrypted())  					{  						continue;  					}  					if (pubkeyblob == null)  					{  						pubkeyblob = identity.GetPublicKeyBlob();  					}  					//System.err.println("UserAuthPublicKey: pubkeyblob="+pubkeyblob);  					if (pubkeyblob == null)  					{  						continue;  					}  					// send  					// byte      SSH_MSG_USERAUTH_REQUEST(50)  					// string    user name  					// string    service name ("ssh-connection")  					// string    "publickey"  					// boolen    TRUE  					// string    plaintext password (ISO-10646 UTF-8)  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  					buf.PutString(_username);  					buf.PutString(Util.Str2byte("ssh-connection"));  					buf.PutString(Util.Str2byte("publickey"));  					buf.PutByte(unchecked((byte)1));  					buf.PutString(Util.Str2byte(identity.GetAlgName()));  					buf.PutString(pubkeyblob);  					//      byte[] tmp=new byte[buf.index-5];  					//      System.arraycopy(buf.buffer' 5' tmp' 0' tmp.length);  					//      buf.putString(signature);  					byte[] sid = session.GetSessionId();  					int sidlen = sid.Length;  					byte[] tmp = new byte[4 + sidlen + buf.index - 5];  					tmp[0] = unchecked((byte)((int)(((uint)sidlen) >> 24)));  					tmp[1] = unchecked((byte)((int)(((uint)sidlen) >> 16)));  					tmp[2] = unchecked((byte)((int)(((uint)sidlen) >> 8)));  					tmp[3] = unchecked((byte)(sidlen));  					System.Array.Copy(sid' 0' tmp' 4' sidlen);  					System.Array.Copy(buf.buffer' 5' tmp' 4 + sidlen' buf.index - 5);  					byte[] signature = identity.GetSignature(tmp);  					if (signature == null)  					{  						// for example' too long key length.  						break;  					}  					buf.PutString(signature);  					session.Write(packet);  					while (true)  					{  						buf = session.Read(buf);  						command = buf.GetCommand() & unchecked((int)(0xff));  						if (command == SSH_MSG_USERAUTH_SUCCESS)  						{  							return true;  						}  						else  						{  							if (command == SSH_MSG_USERAUTH_BANNER)  							{  								buf.GetInt();  								buf.GetByte();  								buf.GetByte();  								byte[] _message = buf.GetString();  								byte[] lang = buf.GetString();  								string message = Util.Byte2str(_message);  								if (userinfo != null)  								{  									userinfo.ShowMessage(message);  								}  								goto loop2_continue;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									buf.GetInt();  									buf.GetByte();  									buf.GetByte();  									byte[] foo = buf.GetString();  									int partial_success = buf.GetByte();  									//System.err.println(new String(foo)+  									//                   " partial_success:"+(partial_success!=0));  									if (partial_success != 0)  									{  										throw new JSchPartialAuthException(Util.Byte2str(foo));  									}  									session.auth_failures++;  									break;  								}  							}  						}  						//System.err.println("USERAUTH fail ("+command+")");  						//throw new JSchException("USERAUTH fail ("+command+")");  						break;  loop2_continue: ;  					}  loop2_break: ;  				}  			}
Magic Number,NSch,UserAuthPublicKey,C:\repos\mono_ngit\NSch\NSch\UserAuthPublicKey.cs,Start,The following statement contains a magic number: lock (identities)  			{  				if (identities.Count <= 0)  				{  					return false;  				}  				_username = Util.Str2byte(username);  				for (int i = 0; i < identities.Count; i++)  				{  					if (session.auth_failures >= session.max_auth_tries)  					{  						return false;  					}  					Identity identity = (Identity)(identities[i]);  					byte[] pubkeyblob = identity.GetPublicKeyBlob();  					//System.err.println("UserAuthPublicKey: "+identity+" "+pubkeyblob);  					if (pubkeyblob != null)  					{  						// send  						// byte      SSH_MSG_USERAUTH_REQUEST(50)  						// string    user name  						// string    service name ("ssh-connection")  						// string    "publickey"  						// boolen    FALSE  						// string    plaintext password (ISO-10646 UTF-8)  						packet.Reset();  						buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  						buf.PutString(_username);  						buf.PutString(Util.Str2byte("ssh-connection"));  						buf.PutString(Util.Str2byte("publickey"));  						buf.PutByte(unchecked((byte)0));  						buf.PutString(Util.Str2byte(identity.GetAlgName()));  						buf.PutString(pubkeyblob);  						session.Write(packet);  						while (true)  						{  							buf = session.Read(buf);  							command = buf.GetCommand() & unchecked((int)(0xff));  							if (command == SSH_MSG_USERAUTH_PK_OK)  							{  								break;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									break;  								}  								else  								{  									if (command == SSH_MSG_USERAUTH_BANNER)  									{  										buf.GetInt();  										buf.GetByte();  										buf.GetByte();  										byte[] _message = buf.GetString();  										byte[] lang = buf.GetString();  										string message = Util.Byte2str(_message);  										if (userinfo != null)  										{  											userinfo.ShowMessage(message);  										}  										goto loop1_continue;  									}  									else  									{  										//System.err.println("USERAUTH fail ("+command+")");  										//throw new JSchException("USERAUTH fail ("+command+")");  										break;  									}  								}  							}  loop1_continue: ;  						}  loop1_break: ;  						if (command != SSH_MSG_USERAUTH_PK_OK)  						{  							continue;  						}  					}  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					int count = 5;  					while (true)  					{  						if ((identity.IsEncrypted() && passphrase == null))  						{  							if (userinfo == null)  							{  								throw new JSchException("USERAUTH fail");  							}  							if (identity.IsEncrypted() && !userinfo.PromptPassphrase("Passphrase for " + identity  								.GetName()))  							{  								throw new JSchAuthCancelException("publickey");  							}  							//throw new JSchException("USERAUTH cancel");  							//break;  							string _passphrase = userinfo.GetPassphrase();  							if (_passphrase != null)  							{  								passphrase = Util.Str2byte(_passphrase);  							}  						}  						if (!identity.IsEncrypted() || passphrase != null)  						{  							if (identity.SetPassphrase(passphrase))  							{  								break;  							}  							else  							{  								throw new System.Exception ("Invalid passphrase supplied for the ssh key");  							}  						}  						Util.Bzero(passphrase);  						passphrase = null;  						count--;  						if (count == 0)  						{  							break;  						}  					}  					Util.Bzero(passphrase);  					passphrase = null;  					//System.err.println("UserAuthPublicKey: identity.isEncrypted()="+identity.isEncrypted());  					if (identity.IsEncrypted())  					{  						continue;  					}  					if (pubkeyblob == null)  					{  						pubkeyblob = identity.GetPublicKeyBlob();  					}  					//System.err.println("UserAuthPublicKey: pubkeyblob="+pubkeyblob);  					if (pubkeyblob == null)  					{  						continue;  					}  					// send  					// byte      SSH_MSG_USERAUTH_REQUEST(50)  					// string    user name  					// string    service name ("ssh-connection")  					// string    "publickey"  					// boolen    TRUE  					// string    plaintext password (ISO-10646 UTF-8)  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_USERAUTH_REQUEST));  					buf.PutString(_username);  					buf.PutString(Util.Str2byte("ssh-connection"));  					buf.PutString(Util.Str2byte("publickey"));  					buf.PutByte(unchecked((byte)1));  					buf.PutString(Util.Str2byte(identity.GetAlgName()));  					buf.PutString(pubkeyblob);  					//      byte[] tmp=new byte[buf.index-5];  					//      System.arraycopy(buf.buffer' 5' tmp' 0' tmp.length);  					//      buf.putString(signature);  					byte[] sid = session.GetSessionId();  					int sidlen = sid.Length;  					byte[] tmp = new byte[4 + sidlen + buf.index - 5];  					tmp[0] = unchecked((byte)((int)(((uint)sidlen) >> 24)));  					tmp[1] = unchecked((byte)((int)(((uint)sidlen) >> 16)));  					tmp[2] = unchecked((byte)((int)(((uint)sidlen) >> 8)));  					tmp[3] = unchecked((byte)(sidlen));  					System.Array.Copy(sid' 0' tmp' 4' sidlen);  					System.Array.Copy(buf.buffer' 5' tmp' 4 + sidlen' buf.index - 5);  					byte[] signature = identity.GetSignature(tmp);  					if (signature == null)  					{  						// for example' too long key length.  						break;  					}  					buf.PutString(signature);  					session.Write(packet);  					while (true)  					{  						buf = session.Read(buf);  						command = buf.GetCommand() & unchecked((int)(0xff));  						if (command == SSH_MSG_USERAUTH_SUCCESS)  						{  							return true;  						}  						else  						{  							if (command == SSH_MSG_USERAUTH_BANNER)  							{  								buf.GetInt();  								buf.GetByte();  								buf.GetByte();  								byte[] _message = buf.GetString();  								byte[] lang = buf.GetString();  								string message = Util.Byte2str(_message);  								if (userinfo != null)  								{  									userinfo.ShowMessage(message);  								}  								goto loop2_continue;  							}  							else  							{  								if (command == SSH_MSG_USERAUTH_FAILURE)  								{  									buf.GetInt();  									buf.GetByte();  									buf.GetByte();  									byte[] foo = buf.GetString();  									int partial_success = buf.GetByte();  									//System.err.println(new String(foo)+  									//                   " partial_success:"+(partial_success!=0));  									if (partial_success != 0)  									{  										throw new JSchPartialAuthException(Util.Byte2str(foo));  									}  									session.auth_failures++;  									break;  								}  							}  						}  						//System.err.println("USERAUTH fail ("+command+")");  						//throw new JSchException("USERAUTH fail ("+command+")");  						break;  loop2_continue: ;  					}  loop2_break: ;  				}  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: for (int i = start; i < start + length; i += 4)  			{  				foo[j] = unchecked((byte)((Val(buf[i]) << 2) | ((int)(((uint)(Val(buf[i + 1]) & unchecked(  					(int)(0x30)))) >> 4))));  				if (buf[i + 2] == unchecked((byte)'='))  				{  					j++;  					break;  				}  				foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) |  					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));  				if (buf[i + 3] == unchecked((byte)'='))  				{  					j += 2;  					break;  				}  				foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) |  					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));  				j += 3;  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: for (int i = start; i < start + length; i += 4)  			{  				foo[j] = unchecked((byte)((Val(buf[i]) << 2) | ((int)(((uint)(Val(buf[i + 1]) & unchecked(  					(int)(0x30)))) >> 4))));  				if (buf[i + 2] == unchecked((byte)'='))  				{  					j++;  					break;  				}  				foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) |  					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));  				if (buf[i + 3] == unchecked((byte)'='))  				{  					j += 2;  					break;  				}  				foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) |  					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));  				j += 3;  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: for (int i = start; i < start + length; i += 4)  			{  				foo[j] = unchecked((byte)((Val(buf[i]) << 2) | ((int)(((uint)(Val(buf[i + 1]) & unchecked(  					(int)(0x30)))) >> 4))));  				if (buf[i + 2] == unchecked((byte)'='))  				{  					j++;  					break;  				}  				foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) |  					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));  				if (buf[i + 3] == unchecked((byte)'='))  				{  					j += 2;  					break;  				}  				foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) |  					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));  				j += 3;  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: for (int i = start; i < start + length; i += 4)  			{  				foo[j] = unchecked((byte)((Val(buf[i]) << 2) | ((int)(((uint)(Val(buf[i + 1]) & unchecked(  					(int)(0x30)))) >> 4))));  				if (buf[i + 2] == unchecked((byte)'='))  				{  					j++;  					break;  				}  				foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) |  					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));  				if (buf[i + 3] == unchecked((byte)'='))  				{  					j += 2;  					break;  				}  				foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) |  					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));  				j += 3;  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: for (int i = start; i < start + length; i += 4)  			{  				foo[j] = unchecked((byte)((Val(buf[i]) << 2) | ((int)(((uint)(Val(buf[i + 1]) & unchecked(  					(int)(0x30)))) >> 4))));  				if (buf[i + 2] == unchecked((byte)'='))  				{  					j++;  					break;  				}  				foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) |  					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));  				if (buf[i + 3] == unchecked((byte)'='))  				{  					j += 2;  					break;  				}  				foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) |  					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));  				j += 3;  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: for (int i = start; i < start + length; i += 4)  			{  				foo[j] = unchecked((byte)((Val(buf[i]) << 2) | ((int)(((uint)(Val(buf[i + 1]) & unchecked(  					(int)(0x30)))) >> 4))));  				if (buf[i + 2] == unchecked((byte)'='))  				{  					j++;  					break;  				}  				foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) |  					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));  				if (buf[i + 3] == unchecked((byte)'='))  				{  					j += 2;  					break;  				}  				foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) |  					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));  				j += 3;  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: for (int i = start; i < start + length; i += 4)  			{  				foo[j] = unchecked((byte)((Val(buf[i]) << 2) | ((int)(((uint)(Val(buf[i + 1]) & unchecked(  					(int)(0x30)))) >> 4))));  				if (buf[i + 2] == unchecked((byte)'='))  				{  					j++;  					break;  				}  				foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) |  					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));  				if (buf[i + 3] == unchecked((byte)'='))  				{  					j += 2;  					break;  				}  				foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) |  					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));  				j += 3;  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: for (int i = start; i < start + length; i += 4)  			{  				foo[j] = unchecked((byte)((Val(buf[i]) << 2) | ((int)(((uint)(Val(buf[i + 1]) & unchecked(  					(int)(0x30)))) >> 4))));  				if (buf[i + 2] == unchecked((byte)'='))  				{  					j++;  					break;  				}  				foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) |  					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));  				if (buf[i + 3] == unchecked((byte)'='))  				{  					j += 2;  					break;  				}  				foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) |  					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));  				j += 3;  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: for (int i = start; i < start + length; i += 4)  			{  				foo[j] = unchecked((byte)((Val(buf[i]) << 2) | ((int)(((uint)(Val(buf[i + 1]) & unchecked(  					(int)(0x30)))) >> 4))));  				if (buf[i + 2] == unchecked((byte)'='))  				{  					j++;  					break;  				}  				foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) |  					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));  				if (buf[i + 3] == unchecked((byte)'='))  				{  					j += 2;  					break;  				}  				foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) |  					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));  				j += 3;  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: for (int i = start; i < start + length; i += 4)  			{  				foo[j] = unchecked((byte)((Val(buf[i]) << 2) | ((int)(((uint)(Val(buf[i + 1]) & unchecked(  					(int)(0x30)))) >> 4))));  				if (buf[i + 2] == unchecked((byte)'='))  				{  					j++;  					break;  				}  				foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) |  					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));  				if (buf[i + 3] == unchecked((byte)'='))  				{  					j += 2;  					break;  				}  				foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) |  					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));  				j += 3;  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: for (int i = start; i < start + length; i += 4)  			{  				foo[j] = unchecked((byte)((Val(buf[i]) << 2) | ((int)(((uint)(Val(buf[i + 1]) & unchecked(  					(int)(0x30)))) >> 4))));  				if (buf[i + 2] == unchecked((byte)'='))  				{  					j++;  					break;  				}  				foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) |  					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));  				if (buf[i + 3] == unchecked((byte)'='))  				{  					j += 2;  					break;  				}  				foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) |  					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));  				j += 3;  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: for (int i = start; i < start + length; i += 4)  			{  				foo[j] = unchecked((byte)((Val(buf[i]) << 2) | ((int)(((uint)(Val(buf[i + 1]) & unchecked(  					(int)(0x30)))) >> 4))));  				if (buf[i + 2] == unchecked((byte)'='))  				{  					j++;  					break;  				}  				foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) |  					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));  				if (buf[i + 3] == unchecked((byte)'='))  				{  					j += 2;  					break;  				}  				foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) |  					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));  				j += 3;  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: for (int i = start; i < start + length; i += 4)  			{  				foo[j] = unchecked((byte)((Val(buf[i]) << 2) | ((int)(((uint)(Val(buf[i + 1]) & unchecked(  					(int)(0x30)))) >> 4))));  				if (buf[i + 2] == unchecked((byte)'='))  				{  					j++;  					break;  				}  				foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) |  					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));  				if (buf[i + 3] == unchecked((byte)'='))  				{  					j += 2;  					break;  				}  				foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) |  					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));  				j += 3;  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,FromBase64,The following statement contains a magic number: for (int i = start; i < start + length; i += 4)  			{  				foo[j] = unchecked((byte)((Val(buf[i]) << 2) | ((int)(((uint)(Val(buf[i + 1]) & unchecked(  					(int)(0x30)))) >> 4))));  				if (buf[i + 2] == unchecked((byte)'='))  				{  					j++;  					break;  				}  				foo[j + 1] = unchecked((byte)(((Val(buf[i + 1]) & unchecked((int)(0x0f))) << 4) |  					 ((int)(((uint)(Val(buf[i + 2]) & unchecked((int)(0x3c)))) >> 2))));  				if (buf[i + 3] == unchecked((byte)'='))  				{  					j += 2;  					break;  				}  				foo[j + 2] = unchecked((byte)(((Val(buf[i + 2]) & unchecked((int)(0x03))) << 6) |  					 (Val(buf[i + 3]) & unchecked((int)(0x3f)))));  				j += 3;  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: byte[] tmp = new byte[length * 2];
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: int foo = (length / 3) * 3 + start;
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: int foo = (length / 3) * 3 + start;
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: for (j = start; j < foo; j += 3)  			{  				k = (buf[j] >> 2) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)(  					0x0f));  				tmp[i++] = b64[k];  				k = (buf[j + 1] & unchecked((int)(0x0f))) << 2 | (buf[j + 2] >> 6) & unchecked((int  					)(0x03));  				tmp[i++] = b64[k];  				k = buf[j + 2] & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: for (j = start; j < foo; j += 3)  			{  				k = (buf[j] >> 2) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)(  					0x0f));  				tmp[i++] = b64[k];  				k = (buf[j + 1] & unchecked((int)(0x0f))) << 2 | (buf[j + 2] >> 6) & unchecked((int  					)(0x03));  				tmp[i++] = b64[k];  				k = buf[j + 2] & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: for (j = start; j < foo; j += 3)  			{  				k = (buf[j] >> 2) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)(  					0x0f));  				tmp[i++] = b64[k];  				k = (buf[j + 1] & unchecked((int)(0x0f))) << 2 | (buf[j + 2] >> 6) & unchecked((int  					)(0x03));  				tmp[i++] = b64[k];  				k = buf[j + 2] & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: for (j = start; j < foo; j += 3)  			{  				k = (buf[j] >> 2) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)(  					0x0f));  				tmp[i++] = b64[k];  				k = (buf[j + 1] & unchecked((int)(0x0f))) << 2 | (buf[j + 2] >> 6) & unchecked((int  					)(0x03));  				tmp[i++] = b64[k];  				k = buf[j + 2] & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: for (j = start; j < foo; j += 3)  			{  				k = (buf[j] >> 2) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)(  					0x0f));  				tmp[i++] = b64[k];  				k = (buf[j + 1] & unchecked((int)(0x0f))) << 2 | (buf[j + 2] >> 6) & unchecked((int  					)(0x03));  				tmp[i++] = b64[k];  				k = buf[j + 2] & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: for (j = start; j < foo; j += 3)  			{  				k = (buf[j] >> 2) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)(  					0x0f));  				tmp[i++] = b64[k];  				k = (buf[j + 1] & unchecked((int)(0x0f))) << 2 | (buf[j + 2] >> 6) & unchecked((int  					)(0x03));  				tmp[i++] = b64[k];  				k = buf[j + 2] & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: for (j = start; j < foo; j += 3)  			{  				k = (buf[j] >> 2) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)(  					0x0f));  				tmp[i++] = b64[k];  				k = (buf[j + 1] & unchecked((int)(0x0f))) << 2 | (buf[j + 2] >> 6) & unchecked((int  					)(0x03));  				tmp[i++] = b64[k];  				k = buf[j + 2] & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: for (j = start; j < foo; j += 3)  			{  				k = (buf[j] >> 2) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)(  					0x0f));  				tmp[i++] = b64[k];  				k = (buf[j + 1] & unchecked((int)(0x0f))) << 2 | (buf[j + 2] >> 6) & unchecked((int  					)(0x03));  				tmp[i++] = b64[k];  				k = buf[j + 2] & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: if (foo == 1)  			{  				k = (buf[j] >> 2) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				k = ((buf[j] & unchecked((int)(0x03))) << 4) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				tmp[i++] = unchecked((byte)(byte)('='));  				tmp[i++] = unchecked((byte)(byte)('='));  			}  			else  			{  				if (foo == 2)  				{  					k = (buf[j] >> 2) & unchecked((int)(0x3f));  					tmp[i++] = b64[k];  					k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)(  						0x0f));  					tmp[i++] = b64[k];  					k = ((buf[j + 1] & unchecked((int)(0x0f))) << 2) & unchecked((int)(0x3f));  					tmp[i++] = b64[k];  					tmp[i++] = unchecked((byte)(byte)('='));  				}  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: if (foo == 1)  			{  				k = (buf[j] >> 2) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				k = ((buf[j] & unchecked((int)(0x03))) << 4) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				tmp[i++] = unchecked((byte)(byte)('='));  				tmp[i++] = unchecked((byte)(byte)('='));  			}  			else  			{  				if (foo == 2)  				{  					k = (buf[j] >> 2) & unchecked((int)(0x3f));  					tmp[i++] = b64[k];  					k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)(  						0x0f));  					tmp[i++] = b64[k];  					k = ((buf[j + 1] & unchecked((int)(0x0f))) << 2) & unchecked((int)(0x3f));  					tmp[i++] = b64[k];  					tmp[i++] = unchecked((byte)(byte)('='));  				}  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: if (foo == 1)  			{  				k = (buf[j] >> 2) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				k = ((buf[j] & unchecked((int)(0x03))) << 4) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				tmp[i++] = unchecked((byte)(byte)('='));  				tmp[i++] = unchecked((byte)(byte)('='));  			}  			else  			{  				if (foo == 2)  				{  					k = (buf[j] >> 2) & unchecked((int)(0x3f));  					tmp[i++] = b64[k];  					k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)(  						0x0f));  					tmp[i++] = b64[k];  					k = ((buf[j + 1] & unchecked((int)(0x0f))) << 2) & unchecked((int)(0x3f));  					tmp[i++] = b64[k];  					tmp[i++] = unchecked((byte)(byte)('='));  				}  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: if (foo == 1)  			{  				k = (buf[j] >> 2) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				k = ((buf[j] & unchecked((int)(0x03))) << 4) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				tmp[i++] = unchecked((byte)(byte)('='));  				tmp[i++] = unchecked((byte)(byte)('='));  			}  			else  			{  				if (foo == 2)  				{  					k = (buf[j] >> 2) & unchecked((int)(0x3f));  					tmp[i++] = b64[k];  					k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)(  						0x0f));  					tmp[i++] = b64[k];  					k = ((buf[j + 1] & unchecked((int)(0x0f))) << 2) & unchecked((int)(0x3f));  					tmp[i++] = b64[k];  					tmp[i++] = unchecked((byte)(byte)('='));  				}  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: if (foo == 1)  			{  				k = (buf[j] >> 2) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				k = ((buf[j] & unchecked((int)(0x03))) << 4) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				tmp[i++] = unchecked((byte)(byte)('='));  				tmp[i++] = unchecked((byte)(byte)('='));  			}  			else  			{  				if (foo == 2)  				{  					k = (buf[j] >> 2) & unchecked((int)(0x3f));  					tmp[i++] = b64[k];  					k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)(  						0x0f));  					tmp[i++] = b64[k];  					k = ((buf[j + 1] & unchecked((int)(0x0f))) << 2) & unchecked((int)(0x3f));  					tmp[i++] = b64[k];  					tmp[i++] = unchecked((byte)(byte)('='));  				}  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: if (foo == 1)  			{  				k = (buf[j] >> 2) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				k = ((buf[j] & unchecked((int)(0x03))) << 4) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				tmp[i++] = unchecked((byte)(byte)('='));  				tmp[i++] = unchecked((byte)(byte)('='));  			}  			else  			{  				if (foo == 2)  				{  					k = (buf[j] >> 2) & unchecked((int)(0x3f));  					tmp[i++] = b64[k];  					k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)(  						0x0f));  					tmp[i++] = b64[k];  					k = ((buf[j + 1] & unchecked((int)(0x0f))) << 2) & unchecked((int)(0x3f));  					tmp[i++] = b64[k];  					tmp[i++] = unchecked((byte)(byte)('='));  				}  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,ToBase64,The following statement contains a magic number: if (foo == 1)  			{  				k = (buf[j] >> 2) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				k = ((buf[j] & unchecked((int)(0x03))) << 4) & unchecked((int)(0x3f));  				tmp[i++] = b64[k];  				tmp[i++] = unchecked((byte)(byte)('='));  				tmp[i++] = unchecked((byte)(byte)('='));  			}  			else  			{  				if (foo == 2)  				{  					k = (buf[j] >> 2) & unchecked((int)(0x3f));  					tmp[i++] = b64[k];  					k = (buf[j] & unchecked((int)(0x03))) << 4 | (buf[j + 1] >> 4) & unchecked((int)(  						0x0f));  					tmp[i++] = b64[k];  					k = ((buf[j + 1] & unchecked((int)(0x0f))) << 2) & unchecked((int)(0x3f));  					tmp[i++] = b64[k];  					tmp[i++] = unchecked((byte)(byte)('='));  				}  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,Glob0,The following statement contains a magic number: if (name.Length > 0 && name[0] == '.')  			{  				if (pattern.Length > 0 && pattern[0] == '.')  				{  					if (pattern.Length == 2 && pattern[1] == '*')  					{  						return true;  					}  					return Glob(pattern' pattern_index + 1' name' name_index + 1);  				}  				return false;  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,GetFingerPrint,The following statement contains a magic number: try  			{  				hash.Init();  				hash.Update(data' 0' data.Length);  				byte[] foo = hash.Digest();  				StringBuilder sb = new StringBuilder();  				int bar;  				for (int i = 0; i < foo.Length; i++)  				{  					bar = foo[i] & unchecked((int)(0xff));  					sb.Append(chars[((int)(((uint)bar) >> 4)) & unchecked((int)(0xf))]);  					sb.Append(chars[(bar) & unchecked((int)(0xf))]);  					if (i + 1 < foo.Length)  					{  						sb.Append(":");  					}  				}  				return sb.ToString();  			}  			catch (Exception)  			{  				return "???";  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,SkipUTF8Char,The following statement contains a magic number: if (unchecked((byte)(b & unchecked((int)(0xe0)))) == unchecked((byte)unchecked((int  				)(0xc0))))  			{  				return 2;  			}
Magic Number,NSch,Util,C:\repos\mono_ngit\NSch\NSch\Util.cs,SkipUTF8Char,The following statement contains a magic number: if (unchecked((byte)(b & unchecked((int)(0xf0)))) == unchecked((byte)unchecked((int  				)(0xe0))))  			{  				return 3;  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following statement contains a magic number: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Magic Number,NSch.Jce,HMACMD5,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD5.cs,Update,The following statement contains a magic number: tmp[0] = unchecked((byte)((int)(((uint)i) >> 24)));
Magic Number,NSch.Jce,HMACMD5,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD5.cs,Update,The following statement contains a magic number: tmp[1] = unchecked((byte)((int)(((uint)i) >> 16)));
Magic Number,NSch.Jce,HMACMD5,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD5.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jce,HMACMD5,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD5.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jce,HMACMD5,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD5.cs,Update,The following statement contains a magic number: tmp[3] = unchecked((byte)i);
Magic Number,NSch.Jce,HMACMD5,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD5.cs,Update,The following statement contains a magic number: Update(tmp' 0' 4);
Magic Number,NSch.Jce,HMACMD596,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Init,The following statement contains a magic number: if (key.Length > 16)  			{  				byte[] tmp = new byte[16];  				System.Array.Copy(key' 0' tmp' 0' 16);  				key = tmp;  			}
Magic Number,NSch.Jce,HMACMD596,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Init,The following statement contains a magic number: if (key.Length > 16)  			{  				byte[] tmp = new byte[16];  				System.Array.Copy(key' 0' tmp' 0' 16);  				key = tmp;  			}
Magic Number,NSch.Jce,HMACMD596,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Init,The following statement contains a magic number: if (key.Length > 16)  			{  				byte[] tmp = new byte[16];  				System.Array.Copy(key' 0' tmp' 0' 16);  				key = tmp;  			}
Magic Number,NSch.Jce,HMACMD596,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Update,The following statement contains a magic number: tmp[0] = unchecked((byte)((int)(((uint)i) >> 24)));
Magic Number,NSch.Jce,HMACMD596,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Update,The following statement contains a magic number: tmp[1] = unchecked((byte)((int)(((uint)i) >> 16)));
Magic Number,NSch.Jce,HMACMD596,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jce,HMACMD596,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jce,HMACMD596,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Update,The following statement contains a magic number: tmp[3] = unchecked((byte)i);
Magic Number,NSch.Jce,HMACMD596,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,Update,The following statement contains a magic number: Update(tmp' 0' 4);
Magic Number,NSch.Jce,HMACMD596,C:\repos\mono_ngit\NSch\NSch.Jce\HMACMD596.cs,DoFinal,The following statement contains a magic number: System.Array.Copy(_buf16' 0' buf' offset' 12);
Magic Number,NSch.Jce,HMACSHA1,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA1.cs,Update,The following statement contains a magic number: tmp[0] = unchecked((byte)((int)(((uint)i) >> 24)));
Magic Number,NSch.Jce,HMACSHA1,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA1.cs,Update,The following statement contains a magic number: tmp[1] = unchecked((byte)((int)(((uint)i) >> 16)));
Magic Number,NSch.Jce,HMACSHA1,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA1.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jce,HMACSHA1,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA1.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jce,HMACSHA1,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA1.cs,Update,The following statement contains a magic number: tmp[3] = unchecked((byte)i);
Magic Number,NSch.Jce,HMACSHA1,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA1.cs,Update,The following statement contains a magic number: Update(tmp' 0' 4);
Magic Number,NSch.Jce,HMACSHA196,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Init,The following statement contains a magic number: if (key.Length > 20)  			{  				byte[] tmp = new byte[20];  				System.Array.Copy(key' 0' tmp' 0' 20);  				key = tmp;  			}
Magic Number,NSch.Jce,HMACSHA196,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Init,The following statement contains a magic number: if (key.Length > 20)  			{  				byte[] tmp = new byte[20];  				System.Array.Copy(key' 0' tmp' 0' 20);  				key = tmp;  			}
Magic Number,NSch.Jce,HMACSHA196,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Init,The following statement contains a magic number: if (key.Length > 20)  			{  				byte[] tmp = new byte[20];  				System.Array.Copy(key' 0' tmp' 0' 20);  				key = tmp;  			}
Magic Number,NSch.Jce,HMACSHA196,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Update,The following statement contains a magic number: tmp[0] = unchecked((byte)((int)(((uint)i) >> 24)));
Magic Number,NSch.Jce,HMACSHA196,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Update,The following statement contains a magic number: tmp[1] = unchecked((byte)((int)(((uint)i) >> 16)));
Magic Number,NSch.Jce,HMACSHA196,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jce,HMACSHA196,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jce,HMACSHA196,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Update,The following statement contains a magic number: tmp[3] = unchecked((byte)i);
Magic Number,NSch.Jce,HMACSHA196,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,Update,The following statement contains a magic number: Update(tmp' 0' 4);
Magic Number,NSch.Jce,HMACSHA196,C:\repos\mono_ngit\NSch\NSch.Jce\HMACSHA196.cs,DoFinal,The following statement contains a magic number: System.Array.Copy(_buf20' 0' buf' offset' 12);
Magic Number,NSch.Jce,MD5,C:\repos\mono_ngit\NSch\NSch.Jce\MD5.cs,GetBlockSize,The following statement contains a magic number: return 16;
Magic Number,NSch.Jce,SHA1,C:\repos\mono_ngit\NSch\NSch.Jce\SHA1.cs,GetBlockSize,The following statement contains a magic number: return 20;
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: int index = 3;
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: byte[] result = new byte[40];
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(r' (r.Length > 20) ? 1 : 0' result' (r.Length > 20) ? 0 : 20 -   				r.Length' (r.Length > 20) ? 20 : r.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(r' (r.Length > 20) ? 1 : 0' result' (r.Length > 20) ? 0 : 20 -   				r.Length' (r.Length > 20) ? 20 : r.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(r' (r.Length > 20) ? 1 : 0' result' (r.Length > 20) ? 0 : 20 -   				r.Length' (r.Length > 20) ? 20 : r.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(r' (r.Length > 20) ? 1 : 0' result' (r.Length > 20) ? 0 : 20 -   				r.Length' (r.Length > 20) ? 20 : r.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(r' (r.Length > 20) ? 1 : 0' result' (r.Length > 20) ? 0 : 20 -   				r.Length' (r.Length > 20) ? 20 : r.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(s' (s.Length > 20) ? 1 : 0' result' (s.Length > 20) ? 20 : 40 -  				 s.Length' (s.Length > 20) ? 20 : s.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(s' (s.Length > 20) ? 1 : 0' result' (s.Length > 20) ? 20 : 40 -  				 s.Length' (s.Length > 20) ? 20 : s.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(s' (s.Length > 20) ? 1 : 0' result' (s.Length > 20) ? 20 : 40 -  				 s.Length' (s.Length > 20) ? 20 : s.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(s' (s.Length > 20) ? 1 : 0' result' (s.Length > 20) ? 20 : 40 -  				 s.Length' (s.Length > 20) ? 20 : s.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(s' (s.Length > 20) ? 1 : 0' result' (s.Length > 20) ? 20 : 40 -  				 s.Length' (s.Length > 20) ? 20 : s.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Sign,The following statement contains a magic number: System.Array.Copy(s' (s.Length > 20) ? 1 : 0' result' (s.Length > 20) ? 20 : 40 -  				 s.Length' (s.Length > 20) ? 20 : s.Length);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: if (sig[0] == 0 && sig[1] == 0 && sig[2] == 0)  			{  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				i += j;  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				tmp = new byte[j];  				System.Array.Copy(sig' i' tmp' 0' j);  				sig = tmp;  			}
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: if (sig[0] == 0 && sig[1] == 0 && sig[2] == 0)  			{  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				i += j;  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				tmp = new byte[j];  				System.Array.Copy(sig' i' tmp' 0' j);  				sig = tmp;  			}
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: if (sig[0] == 0 && sig[1] == 0 && sig[2] == 0)  			{  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				i += j;  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				tmp = new byte[j];  				System.Array.Copy(sig' i' tmp' 0' j);  				sig = tmp;  			}
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: if (sig[0] == 0 && sig[1] == 0 && sig[2] == 0)  			{  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				i += j;  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				tmp = new byte[j];  				System.Array.Copy(sig' i' tmp' 0' j);  				sig = tmp;  			}
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: if (sig[0] == 0 && sig[1] == 0 && sig[2] == 0)  			{  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				i += j;  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				tmp = new byte[j];  				System.Array.Copy(sig' i' tmp' 0' j);  				sig = tmp;  			}
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: if (sig[0] == 0 && sig[1] == 0 && sig[2] == 0)  			{  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				i += j;  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				tmp = new byte[j];  				System.Array.Copy(sig' i' tmp' 0' j);  				sig = tmp;  			}
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: if (sig[0] == 0 && sig[1] == 0 && sig[2] == 0)  			{  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				i += j;  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				tmp = new byte[j];  				System.Array.Copy(sig' i' tmp' 0' j);  				sig = tmp;  			}
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: byte scnd = (byte)((sig[20] & unchecked((int)(0x80))) != 0 ? 1 : 0);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: int length = sig.Length + 6 + frst + scnd;
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[2] = unchecked((byte)unchecked((int)(0x02)));
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[3] = unchecked((byte)unchecked((int)(0x14)));
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[3] += frst;
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: System.Array.Copy(sig' 0' tmp' 4 + frst' 20);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: System.Array.Copy(sig' 0' tmp' 4 + frst' 20);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[4 + tmp[3]] = unchecked((byte)unchecked((int)(0x02)));
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[4 + tmp[3]] = unchecked((byte)unchecked((int)(0x02)));
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[5 + tmp[3]] = unchecked((byte)unchecked((int)(0x14)));
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[5 + tmp[3]] = unchecked((byte)unchecked((int)(0x14)));
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[5 + tmp[3]] += scnd;
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: tmp[5 + tmp[3]] += scnd;
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: System.Array.Copy(sig' 20' tmp' 6 + tmp[3] + scnd' 20);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: System.Array.Copy(sig' 20' tmp' 6 + tmp[3] + scnd' 20);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: System.Array.Copy(sig' 20' tmp' 6 + tmp[3] + scnd' 20);
Magic Number,NSch.Jce,SignatureDSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureDSA.cs,Verify,The following statement contains a magic number: System.Array.Copy(sig' 20' tmp' 6 + tmp[3] + scnd' 20);
Magic Number,NSch.Jce,SignatureRSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureRSA.cs,Verify,The following statement contains a magic number: if (sig[0] == 0 && sig[1] == 0 && sig[2] == 0)  			{  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				i += j;  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				tmp = new byte[j];  				System.Array.Copy(sig' i' tmp' 0' j);  				sig = tmp;  			}
Magic Number,NSch.Jce,SignatureRSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureRSA.cs,Verify,The following statement contains a magic number: if (sig[0] == 0 && sig[1] == 0 && sig[2] == 0)  			{  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				i += j;  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				tmp = new byte[j];  				System.Array.Copy(sig' i' tmp' 0' j);  				sig = tmp;  			}
Magic Number,NSch.Jce,SignatureRSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureRSA.cs,Verify,The following statement contains a magic number: if (sig[0] == 0 && sig[1] == 0 && sig[2] == 0)  			{  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				i += j;  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				tmp = new byte[j];  				System.Array.Copy(sig' i' tmp' 0' j);  				sig = tmp;  			}
Magic Number,NSch.Jce,SignatureRSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureRSA.cs,Verify,The following statement contains a magic number: if (sig[0] == 0 && sig[1] == 0 && sig[2] == 0)  			{  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				i += j;  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				tmp = new byte[j];  				System.Array.Copy(sig' i' tmp' 0' j);  				sig = tmp;  			}
Magic Number,NSch.Jce,SignatureRSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureRSA.cs,Verify,The following statement contains a magic number: if (sig[0] == 0 && sig[1] == 0 && sig[2] == 0)  			{  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				i += j;  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				tmp = new byte[j];  				System.Array.Copy(sig' i' tmp' 0' j);  				sig = tmp;  			}
Magic Number,NSch.Jce,SignatureRSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureRSA.cs,Verify,The following statement contains a magic number: if (sig[0] == 0 && sig[1] == 0 && sig[2] == 0)  			{  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				i += j;  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				tmp = new byte[j];  				System.Array.Copy(sig' i' tmp' 0' j);  				sig = tmp;  			}
Magic Number,NSch.Jce,SignatureRSA,C:\repos\mono_ngit\NSch\NSch.Jce\SignatureRSA.cs,Verify,The following statement contains a magic number: if (sig[0] == 0 && sig[1] == 0 && sig[2] == 0)  			{  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				i += j;  				j = ((sig[i++] << 24) & unchecked((int)(0xff000000))) | ((sig[i++] << 16) & unchecked(  					(int)(0x00ff0000))) | ((sig[i++] << 8) & unchecked((int)(0x0000ff00))) | ((sig[i  					++]) & unchecked((int)(0x000000ff)));  				tmp = new byte[j];  				System.Array.Copy(sig' i' tmp' 0' j);  				sig = tmp;  			}
Magic Number,NSch.Jcraft,Compression,C:\repos\mono_ngit\NSch\NSch.Jcraft\Compression.cs,Compress,The following statement contains a magic number: do  			{  				stream.next_out = tmpbuf;  				stream.next_out_index = 0;  				stream.avail_out = BUF_SIZE;  				status = stream.Deflate(JZlib.Z_PARTIAL_FLUSH);  				switch (status)  				{  					case JZlib.Z_OK:  					{  						tmp = BUF_SIZE - stream.avail_out;  						if (outputbuf.Length < outputlen + tmp + buffer_margin)  						{  							byte[] foo = new byte[(outputlen + tmp + buffer_margin) * 2];  							System.Array.Copy(outputbuf' 0' foo' 0' outputbuf.Length);  							outputbuf = foo;  						}  						System.Array.Copy(tmpbuf' 0' outputbuf' outputlen' tmp);  						outputlen += tmp;  						break;  					}    					default:  					{  						System.Console.Error.WriteLine("compress: deflate returnd " + status);  						break;  					}  				}  			}  			while (stream.avail_out == 0);
Magic Number,NSch.Jcraft,Compression,C:\repos\mono_ngit\NSch\NSch.Jcraft\Compression.cs,Uncompress,The following statement contains a magic number: while (true)  			{  				stream.next_out = tmpbuf;  				stream.next_out_index = 0;  				stream.avail_out = BUF_SIZE;  				int status = stream.Inflate(JZlib.Z_PARTIAL_FLUSH);  				switch (status)  				{  					case JZlib.Z_OK:  					{  						if (inflated_buf.Length < inflated_end + BUF_SIZE - stream.avail_out)  						{  							int len = inflated_buf.Length * 2;  							if (len < inflated_end + BUF_SIZE - stream.avail_out)  							{  								len = inflated_end + BUF_SIZE - stream.avail_out;  							}  							byte[] foo = new byte[len];  							System.Array.Copy(inflated_buf' 0' foo' 0' inflated_end);  							inflated_buf = foo;  						}  						System.Array.Copy(tmpbuf' 0' inflated_buf' inflated_end' BUF_SIZE - stream.avail_out  							);  						inflated_end += (BUF_SIZE - stream.avail_out);  						length[0] = inflated_end;  						break;  					}    					case JZlib.Z_BUF_ERROR:  					{  						if (inflated_end > buffer.Length - start)  						{  							byte[] foo = new byte[inflated_end + start];  							System.Array.Copy(buffer' 0' foo' 0' start);  							System.Array.Copy(inflated_buf' 0' foo' start' inflated_end);  							buffer = foo;  						}  						else  						{  							System.Array.Copy(inflated_buf' 0' buffer' start' inflated_end);  						}  						length[0] = inflated_end;  						return buffer;  					}    					default:  					{  						System.Console.Error.WriteLine("uncompress: inflate returnd " + status);  						return null;  						break;  					}  				}  			}
Magic Number,NSch.Jcraft,HMAC,C:\repos\mono_ngit\NSch\NSch.Jcraft\HMAC.cs,Update,The following statement contains a magic number: tmp[0] = unchecked((byte)((int)(((uint)i) >> 24)));
Magic Number,NSch.Jcraft,HMAC,C:\repos\mono_ngit\NSch\NSch.Jcraft\HMAC.cs,Update,The following statement contains a magic number: tmp[1] = unchecked((byte)((int)(((uint)i) >> 16)));
Magic Number,NSch.Jcraft,HMAC,C:\repos\mono_ngit\NSch\NSch.Jcraft\HMAC.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jcraft,HMAC,C:\repos\mono_ngit\NSch\NSch.Jcraft\HMAC.cs,Update,The following statement contains a magic number: tmp[2] = unchecked((byte)((int)(((uint)i) >> 8)));
Magic Number,NSch.Jcraft,HMAC,C:\repos\mono_ngit\NSch\NSch.Jcraft\HMAC.cs,Update,The following statement contains a magic number: tmp[3] = unchecked((byte)i);
Magic Number,NSch.Jcraft,HMAC,C:\repos\mono_ngit\NSch\NSch.Jcraft\HMAC.cs,Update,The following statement contains a magic number: Update(tmp' 0' 4);
Magic Number,NSch.ZLib,Adler32,C:\repos\mono_ngit\NSch\NSch.ZLib\Adler32.cs,Adler,The following statement contains a magic number: long s2 = (adler >> 16) & unchecked((int)(0xffff));
Magic Number,NSch.ZLib,Adler32,C:\repos\mono_ngit\NSch\NSch.ZLib\Adler32.cs,Adler,The following statement contains a magic number: while (len > 0)  			{  				k = len < NMAX ? len : NMAX;  				len -= k;  				while (k >= 16)  				{  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					k -= 16;  				}  				if (k != 0)  				{  					do  					{  						s1 += buf[index++] & unchecked((int)(0xff));  						s2 += s1;  					}  					while (--k != 0);  				}  				s1 %= BASE;  				s2 %= BASE;  			}
Magic Number,NSch.ZLib,Adler32,C:\repos\mono_ngit\NSch\NSch.ZLib\Adler32.cs,Adler,The following statement contains a magic number: while (len > 0)  			{  				k = len < NMAX ? len : NMAX;  				len -= k;  				while (k >= 16)  				{  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					s1 += buf[index++] & unchecked((int)(0xff));  					s2 += s1;  					k -= 16;  				}  				if (k != 0)  				{  					do  					{  						s1 += buf[index++] & unchecked((int)(0xff));  						s2 += s1;  					}  					while (--k != 0);  				}  				s1 %= BASE;  				s2 %= BASE;  			}
Magic Number,NSch.ZLib,Adler32,C:\repos\mono_ngit\NSch\NSch.ZLib\Adler32.cs,Adler,The following statement contains a magic number: return (s2 << 16) | s1;
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,InfBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case TYPE:  					{  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = (int)(b & 7);  						last = t & 1;  						switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}  						break;  					}    					case LENS:  					{  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						if ((((int)(((uint)(~b)) >> 16)) & unchecked((int)(0xffff))) != (b & unchecked((int  							)(0xffff))))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						left = (b & unchecked((int)(0xffff)));  						b = k = 0;  						// dump bits  						mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  						break;  					}    					case STORED:  					{  						if (n == 0)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0;  								m = (int)(q < read ? read - q - 1 : end - q);  							}  							if (m == 0)  							{  								write = q;  								r = Inflate_flush(z' r);  								q = write;  								m = (int)(q < read ? read - q - 1 : end - q);  								if (q == end && read != 0)  								{  									q = 0;  									m = (int)(q < read ? read - q - 1 : end - q);  								}  								if (m == 0)  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						t = left;  						if (t > n)  						{  							t = n;  						}  						if (t > m)  						{  							t = m;  						}  						System.Array.Copy(z.next_in' p' window' q' t);  						p += t;  						n -= t;  						q += t;  						m -= t;  						if ((left -= t) != 0)  						{  							break;  						}  						mode = last != 0 ? DRY : TYPE;  						break;  					}    					case TABLE:  					{  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						table = t = (b & unchecked((int)(0x3fff)));  						if ((t & unchecked((int)(0x1f))) > 29 || ((t >> 5) & unchecked((int)(0x1f))) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						t = 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f)));  						if (blens == null || blens.Length < t)  						{  							blens = new int[t];  						}  						else  						{  							for (int i = 0; i < t; i++)  							{  								blens[i] = 0;  							}  						}  						b = (int)(((uint)b) >> (14));  						k -= (14);  						index = 0;  						mode = BTREE;  						goto case BTREE;  					}    					case BTREE:  					{  						while (index < 4 + ((int)(((uint)table) >> 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							blens[border[index++]] = b & 7;  							{  								b = (int)(((uint)b) >> (3));  								k -= (3);  							}  						}  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						bb[0] = 7;  						t = inftree.Inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						index = 0;  						mode = DTREE;  						goto case DTREE;  					}    					case DTREE:  					{  						while (true)  						{  							t = table;  							if (!(index < 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  								)))))  							{  								break;  							}  							int[] h;  							int i;  							int j;  							int c;  							t = bb[0];  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								n--;  								b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  								k += 8;  							}  							if (tb[0] == -1)  							{  							}  							//System.err.println("null...");  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							if (c < 16)  							{  								b = (int)(((uint)b) >> (t));  								k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18 ? 7 : c - 14;  								j = c == 18 ? 11 : 3;  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b;  										bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										write = q;  										return Inflate_flush(z' r);  									}  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								b = (int)(((uint)b) >> (t));  								k -= (t);  								j += (b & inflate_mask[i]);  								b = (int)(((uint)b) >> (i));  								k -= (i);  								i = index;  								t = table;  								if (i + j > 258 + (t & unchecked((int)(0x1f))) + ((t >> 5) & unchecked((int)(0x1f  									))) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									bitb = b;  									bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									write = q;  									return Inflate_flush(z' r);  								}  								c = c == 16 ? blens[i - 1] : 0;  								do  								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						tb[0] = -1;  						int[] bl = new int[1];  						int[] bd = new int[1];  						int[] tl = new int[1];  						int[] td = new int[1];  						bl[0] = 9;  						// must be <= 9 for lookahead assumptions  						bd[0] = 6;  						// must be <= 9 for lookahead assumptions  						t = table;  						t = inftree.Inflate_trees_dynamic(257 + (t & unchecked((int)(0x1f)))' 1 + ((t >>   							5) & unchecked((int)(0x1f)))' blens' bl' bd' tl' td' hufts' z);  						if (t != Z_OK)  						{  							if (t == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							r = t;  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						mode = CODES;  						goto case CODES;  					}    					case CODES:  					{  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						if ((r = codes.Proc(this' z' r)) != Z_STREAM_END)  						{  							return Inflate_flush(z' r);  						}  						r = Z_OK;  						codes.Free(z);  						p = z.next_in_index;  						n = z.avail_in;  						b = bitb;  						k = bitk;  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					}    					case DRY:  					{  						write = q;  						r = Inflate_flush(z' r);  						q = write;  						m = (int)(q < read ? read - q - 1 : end - q);  						if (read != write)  						{  							bitb = b;  							bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							write = q;  							return Inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						r = Z_STREAM_END;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					case BAD:  					{  						r = Z_DATA_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					case START:  					{  						// waiting for "i:"=input' "o:"=output' "x:"=nothing  						// x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							r = Inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							p = z.next_in_index;  							n = z.avail_in;  							b = s.bitb;  							k = s.bitk;  							q = s.write;  							m = q < s.read ? s.read - q - 1 : s.end - q;  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END ? WASH : BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						mode = LEN;  						goto case LEN;  					}    					case LEN:  					{  						// i: get length/literal/eob next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b = (int)(((uint)b) >> (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						e = tree[tindex];  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case LENEXT:  					{  						// i: getting length extra (have base)  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						len += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					}    					case DIST:  					{  						// i: get distance next  						j = need;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE;  						// invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case DISTEXT:  					{  						// i: getting distance extra  						j = get;  						while (k < (j))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								s.bitb = b;  								s.bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								s.write = q;  								return s.Inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						dist += (b & inflate_mask[j]);  						b >>= j;  						k -= j;  						mode = COPY;  						goto case COPY;  					}    					case COPY:  					{  						// o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end;  						}  						// of "if" handles invalid distances  						while (len != 0)  						{  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.write = q;  									r = s.Inflate_flush(z' r);  									q = s.write;  									m = q < s.read ? s.read - q - 1 : s.end - q;  									if (q == s.end && s.read != 0)  									{  										q = 0;  										m = q < s.read ? s.read - q - 1 : s.end - q;  									}  									if (m == 0)  									{  										s.bitb = b;  										s.bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index;  										z.next_in_index = p;  										s.write = q;  										return s.Inflate_flush(z' r);  									}  								}  							}  							s.window[q++] = s.window[f++];  							m--;  							if (f == s.end)  							{  								f = 0;  							}  							len--;  						}  						mode = START;  						break;  					}    					case LIT:  					{  						// o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0;  								m = q < s.read ? s.read - q - 1 : s.end - q;  							}  							if (m == 0)  							{  								s.write = q;  								r = s.Inflate_flush(z' r);  								q = s.write;  								m = q < s.read ? s.read - q - 1 : s.end - q;  								if (q == s.end && s.read != 0)  								{  									q = 0;  									m = q < s.read ? s.read - q - 1 : s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return s.Inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						s.window[q++] = unchecked((byte)lit);  						m--;  						mode = START;  						break;  					}    					case WASH:  					{  						// o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--;  						}  						// can always return one  						s.write = q;  						r = s.Inflate_flush(z' r);  						q = s.write;  						m = q < s.read ? s.read - q - 1 : s.end - q;  						if (s.read != s.write)  						{  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return s.Inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					}    					case END:  					{  						r = Z_STREAM_END;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					case BADCODE:  					{  						// x: got error  						r = Z_DATA_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  					}    					default:  					{  						r = Z_STREAM_ERROR;  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.Inflate_flush(z' r);  						break;  					}  				}  			}
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: do  			{  				// do until not enough input or output space for fast loop  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  					k += 8;  				}  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				tp_index_t_3 = (tp_index + t) * 3;  				if ((e = tp[tp_index_t_3]) == 0)  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  					m--;  					continue;  				}  				do  				{  					b >>= (tp[tp_index_t_3 + 1]);  					k -= (tp[tp_index_t_3 + 1]);  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);  						b >>= e;  						k -= e;  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  							k += 8;  						}  						t = b & md;  						tp = td;  						tp_index = td_index;  						tp_index_t_3 = (tp_index + t) * 3;  						e = tp[tp_index_t_3];  						do  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & unchecked((int)(0xff))) << k;  									k += 8;  								}  								d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);  								b >>= (e);  								k -= (e);  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++];  										// minimum count is three'  										s.window[q++] = s.window[r++];  										// so unroll loop a little  										c -= 2;  									}  									else  									{  										System.Array.Copy(s.window' r' s.window' q' 2);  										q += 2;  										r += 2;  										c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do  									{  										r += s.end;  									}  									while (r < 0);  									// force pointer in window  									// covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e;  										// wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do  											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											System.Array.Copy(s.window' r' s.window' q' e);  											q += e;  											r += e;  											e = 0;  										}  										r = 0;  									}  								}  								// copy rest from start of window  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do  									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									System.Array.Copy(s.window' r' s.window' q' c);  									q += c;  									r += c;  									c = 0;  								}  								break;  							}  							else  							{  								if ((e & 64) == 0)  								{  									t += tp[tp_index_t_3 + 2];  									t += (b & inflate_mask[e]);  									tp_index_t_3 = (tp_index + t) * 3;  									e = tp[tp_index_t_3];  								}  								else  								{  									z.msg = "invalid distance code";  									c = z.avail_in - n;  									c = (k >> 3) < c ? k >> 3 : c;  									n += c;  									p -= c;  									k -= c << 3;  									s.bitb = b;  									s.bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index;  									z.next_in_index = p;  									s.write = q;  									return Z_DATA_ERROR;  								}  							}  						}  						while (true);  						break;  					}  					if ((e & 64) == 0)  					{  						t += tp[tp_index_t_3 + 2];  						t += (b & inflate_mask[e]);  						tp_index_t_3 = (tp_index + t) * 3;  						if ((e = tp[tp_index_t_3]) == 0)  						{  							b >>= (tp[tp_index_t_3 + 1]);  							k -= (tp[tp_index_t_3 + 1]);  							s.window[q++] = unchecked((byte)tp[tp_index_t_3 + 2]);  							m--;  							break;  						}  					}  					else  					{  						if ((e & 32) != 0)  						{  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_STREAM_END;  						}  						else  						{  							z.msg = "invalid literal/length code";  							c = z.avail_in - n;  							c = (k >> 3) < c ? k >> 3 : c;  							n += c;  							p -= c;  							k -= c << 3;  							s.bitb = b;  							s.bitk = k;  							z.avail_in = n;  							z.total_in += p - z.next_in_index;  							z.next_in_index = p;  							s.write = q;  							return Z_DATA_ERROR;  						}  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Inflate_fast,The following statement contains a magic number: k -= c << 3;
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: xp = 2;
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l;  						// previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l) ? l : z;  						// table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1;  							// deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  									{  										break;  									}  									// enough codes to use up j bits  									f -= c[xp];  								}  							}  						}  						// else deduct codes from patterns  						z = 1 << j;  						// table entries for j-bit table  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR;  						}  						// overflow of MANY  						u[h] = q = hn[0];  						// DEBUG  						hn[0] += z;  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i;  							// save pattern for backing up  							r[0] = unchecked((byte)j);  							// bits in this table  							r[1] = unchecked((byte)l);  							// bits to dump before this table  							j = (int)(((uint)i) >> (w - l));  							r[2] = (int)(q - u[h - 1] - j);  							// offset to this table  							System.Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);  						}  						else  						{  							// connect to last table  							t[0] = q;  						}  					}  					// first table is returned result  					// set up table entry in r  					r[1] = unchecked((byte)(k - w));  					if (p >= n)  					{  						r[0] = 128 + 64;  					}  					else  					{  						// out of values--invalid code  						if (v[p] < s)  						{  							r[0] = unchecked((byte)(v[p] < 256 ? 0 : 32 + 64));  							// 256 is end-of-block  							r[2] = v[p++];  						}  						else  						{  							// simple code is just the value  							r[0] = unchecked((byte)(e[v[p] - s] + 16 + 64));  							// non-simple--look up in lists  							r[2] = d[v[p++] - s];  						}  					}  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = (int)(((uint)i) >> w); j < z; j += f)  					{  						System.Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = (int)(((uint)j) >> 1))  					{  						i ^= j;  					}  					i ^= j;  					// backup over finished tables  					mask = (1 << w) - 1;  					// needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--;  						// don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l;  						// previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l) ? l : z;  						// table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1;  							// deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  									{  										break;  									}  									// enough codes to use up j bits  									f -= c[xp];  								}  							}  						}  						// else deduct codes from patterns  						z = 1 << j;  						// table entries for j-bit table  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR;  						}  						// overflow of MANY  						u[h] = q = hn[0];  						// DEBUG  						hn[0] += z;  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i;  							// save pattern for backing up  							r[0] = unchecked((byte)j);  							// bits in this table  							r[1] = unchecked((byte)l);  							// bits to dump before this table  							j = (int)(((uint)i) >> (w - l));  							r[2] = (int)(q - u[h - 1] - j);  							// offset to this table  							System.Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);  						}  						else  						{  							// connect to last table  							t[0] = q;  						}  					}  					// first table is returned result  					// set up table entry in r  					r[1] = unchecked((byte)(k - w));  					if (p >= n)  					{  						r[0] = 128 + 64;  					}  					else  					{  						// out of values--invalid code  						if (v[p] < s)  						{  							r[0] = unchecked((byte)(v[p] < 256 ? 0 : 32 + 64));  							// 256 is end-of-block  							r[2] = v[p++];  						}  						else  						{  							// simple code is just the value  							r[0] = unchecked((byte)(e[v[p] - s] + 16 + 64));  							// non-simple--look up in lists  							r[2] = d[v[p++] - s];  						}  					}  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = (int)(((uint)i) >> w); j < z; j += f)  					{  						System.Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = (int)(((uint)j) >> 1))  					{  						i ^= j;  					}  					i ^= j;  					// backup over finished tables  					mask = (1 << w) - 1;  					// needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--;  						// don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l;  						// previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l) ? l : z;  						// table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1;  							// deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  									{  										break;  									}  									// enough codes to use up j bits  									f -= c[xp];  								}  							}  						}  						// else deduct codes from patterns  						z = 1 << j;  						// table entries for j-bit table  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR;  						}  						// overflow of MANY  						u[h] = q = hn[0];  						// DEBUG  						hn[0] += z;  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i;  							// save pattern for backing up  							r[0] = unchecked((byte)j);  							// bits in this table  							r[1] = unchecked((byte)l);  							// bits to dump before this table  							j = (int)(((uint)i) >> (w - l));  							r[2] = (int)(q - u[h - 1] - j);  							// offset to this table  							System.Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);  						}  						else  						{  							// connect to last table  							t[0] = q;  						}  					}  					// first table is returned result  					// set up table entry in r  					r[1] = unchecked((byte)(k - w));  					if (p >= n)  					{  						r[0] = 128 + 64;  					}  					else  					{  						// out of values--invalid code  						if (v[p] < s)  						{  							r[0] = unchecked((byte)(v[p] < 256 ? 0 : 32 + 64));  							// 256 is end-of-block  							r[2] = v[p++];  						}  						else  						{  							// simple code is just the value  							r[0] = unchecked((byte)(e[v[p] - s] + 16 + 64));  							// non-simple--look up in lists  							r[2] = d[v[p++] - s];  						}  					}  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = (int)(((uint)i) >> w); j < z; j += f)  					{  						System.Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = (int)(((uint)j) >> 1))  					{  						i ^= j;  					}  					i ^= j;  					// backup over finished tables  					mask = (1 << w) - 1;  					// needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--;  						// don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l;  						// previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l) ? l : z;  						// table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1;  							// deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  									{  										break;  									}  									// enough codes to use up j bits  									f -= c[xp];  								}  							}  						}  						// else deduct codes from patterns  						z = 1 << j;  						// table entries for j-bit table  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR;  						}  						// overflow of MANY  						u[h] = q = hn[0];  						// DEBUG  						hn[0] += z;  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i;  							// save pattern for backing up  							r[0] = unchecked((byte)j);  							// bits in this table  							r[1] = unchecked((byte)l);  							// bits to dump before this table  							j = (int)(((uint)i) >> (w - l));  							r[2] = (int)(q - u[h - 1] - j);  							// offset to this table  							System.Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);  						}  						else  						{  							// connect to last table  							t[0] = q;  						}  					}  					// first table is returned result  					// set up table entry in r  					r[1] = unchecked((byte)(k - w));  					if (p >= n)  					{  						r[0] = 128 + 64;  					}  					else  					{  						// out of values--invalid code  						if (v[p] < s)  						{  							r[0] = unchecked((byte)(v[p] < 256 ? 0 : 32 + 64));  							// 256 is end-of-block  							r[2] = v[p++];  						}  						else  						{  							// simple code is just the value  							r[0] = unchecked((byte)(e[v[p] - s] + 16 + 64));  							// non-simple--look up in lists  							r[2] = d[v[p++] - s];  						}  					}  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = (int)(((uint)i) >> w); j < z; j += f)  					{  						System.Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = (int)(((uint)j) >> 1))  					{  						i ^= j;  					}  					i ^= j;  					// backup over finished tables  					mask = (1 << w) - 1;  					// needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--;  						// don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l;  						// previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l) ? l : z;  						// table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1;  							// deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  									{  										break;  									}  									// enough codes to use up j bits  									f -= c[xp];  								}  							}  						}  						// else deduct codes from patterns  						z = 1 << j;  						// table entries for j-bit table  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR;  						}  						// overflow of MANY  						u[h] = q = hn[0];  						// DEBUG  						hn[0] += z;  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i;  							// save pattern for backing up  							r[0] = unchecked((byte)j);  							// bits in this table  							r[1] = unchecked((byte)l);  							// bits to dump before this table  							j = (int)(((uint)i) >> (w - l));  							r[2] = (int)(q - u[h - 1] - j);  							// offset to this table  							System.Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);  						}  						else  						{  							// connect to last table  							t[0] = q;  						}  					}  					// first table is returned result  					// set up table entry in r  					r[1] = unchecked((byte)(k - w));  					if (p >= n)  					{  						r[0] = 128 + 64;  					}  					else  					{  						// out of values--invalid code  						if (v[p] < s)  						{  							r[0] = unchecked((byte)(v[p] < 256 ? 0 : 32 + 64));  							// 256 is end-of-block  							r[2] = v[p++];  						}  						else  						{  							// simple code is just the value  							r[0] = unchecked((byte)(e[v[p] - s] + 16 + 64));  							// non-simple--look up in lists  							r[2] = d[v[p++] - s];  						}  					}  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = (int)(((uint)i) >> w); j < z; j += f)  					{  						System.Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = (int)(((uint)j) >> 1))  					{  						i ^= j;  					}  					i ^= j;  					// backup over finished tables  					mask = (1 << w) - 1;  					// needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--;  						// don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l;  						// previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l) ? l : z;  						// table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1;  							// deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  									{  										break;  									}  									// enough codes to use up j bits  									f -= c[xp];  								}  							}  						}  						// else deduct codes from patterns  						z = 1 << j;  						// table entries for j-bit table  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR;  						}  						// overflow of MANY  						u[h] = q = hn[0];  						// DEBUG  						hn[0] += z;  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i;  							// save pattern for backing up  							r[0] = unchecked((byte)j);  							// bits in this table  							r[1] = unchecked((byte)l);  							// bits to dump before this table  							j = (int)(((uint)i) >> (w - l));  							r[2] = (int)(q - u[h - 1] - j);  							// offset to this table  							System.Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);  						}  						else  						{  							// connect to last table  							t[0] = q;  						}  					}  					// first table is returned result  					// set up table entry in r  					r[1] = unchecked((byte)(k - w));  					if (p >= n)  					{  						r[0] = 128 + 64;  					}  					else  					{  						// out of values--invalid code  						if (v[p] < s)  						{  							r[0] = unchecked((byte)(v[p] < 256 ? 0 : 32 + 64));  							// 256 is end-of-block  							r[2] = v[p++];  						}  						else  						{  							// simple code is just the value  							r[0] = unchecked((byte)(e[v[p] - s] + 16 + 64));  							// non-simple--look up in lists  							r[2] = d[v[p++] - s];  						}  					}  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = (int)(((uint)i) >> w); j < z; j += f)  					{  						System.Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = (int)(((uint)j) >> 1))  					{  						i ^= j;  					}  					i ^= j;  					// backup over finished tables  					mask = (1 << w) - 1;  					// needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--;  						// don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l;  						// previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l) ? l : z;  						// table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1;  							// deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  									{  										break;  									}  									// enough codes to use up j bits  									f -= c[xp];  								}  							}  						}  						// else deduct codes from patterns  						z = 1 << j;  						// table entries for j-bit table  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR;  						}  						// overflow of MANY  						u[h] = q = hn[0];  						// DEBUG  						hn[0] += z;  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i;  							// save pattern for backing up  							r[0] = unchecked((byte)j);  							// bits in this table  							r[1] = unchecked((byte)l);  							// bits to dump before this table  							j = (int)(((uint)i) >> (w - l));  							r[2] = (int)(q - u[h - 1] - j);  							// offset to this table  							System.Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);  						}  						else  						{  							// connect to last table  							t[0] = q;  						}  					}  					// first table is returned result  					// set up table entry in r  					r[1] = unchecked((byte)(k - w));  					if (p >= n)  					{  						r[0] = 128 + 64;  					}  					else  					{  						// out of values--invalid code  						if (v[p] < s)  						{  							r[0] = unchecked((byte)(v[p] < 256 ? 0 : 32 + 64));  							// 256 is end-of-block  							r[2] = v[p++];  						}  						else  						{  							// simple code is just the value  							r[0] = unchecked((byte)(e[v[p] - s] + 16 + 64));  							// non-simple--look up in lists  							r[2] = d[v[p++] - s];  						}  					}  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = (int)(((uint)i) >> w); j < z; j += f)  					{  						System.Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = (int)(((uint)j) >> 1))  					{  						i ^= j;  					}  					i ^= j;  					// backup over finished tables  					mask = (1 << w) - 1;  					// needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--;  						// don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l;  						// previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l) ? l : z;  						// table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1;  							// deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  									{  										break;  									}  									// enough codes to use up j bits  									f -= c[xp];  								}  							}  						}  						// else deduct codes from patterns  						z = 1 << j;  						// table entries for j-bit table  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR;  						}  						// overflow of MANY  						u[h] = q = hn[0];  						// DEBUG  						hn[0] += z;  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i;  							// save pattern for backing up  							r[0] = unchecked((byte)j);  							// bits in this table  							r[1] = unchecked((byte)l);  							// bits to dump before this table  							j = (int)(((uint)i) >> (w - l));  							r[2] = (int)(q - u[h - 1] - j);  							// offset to this table  							System.Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);  						}  						else  						{  							// connect to last table  							t[0] = q;  						}  					}  					// first table is returned result  					// set up table entry in r  					r[1] = unchecked((byte)(k - w));  					if (p >= n)  					{  						r[0] = 128 + 64;  					}  					else  					{  						// out of values--invalid code  						if (v[p] < s)  						{  							r[0] = unchecked((byte)(v[p] < 256 ? 0 : 32 + 64));  							// 256 is end-of-block  							r[2] = v[p++];  						}  						else  						{  							// simple code is just the value  							r[0] = unchecked((byte)(e[v[p] - s] + 16 + 64));  							// non-simple--look up in lists  							r[2] = d[v[p++] - s];  						}  					}  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = (int)(((uint)i) >> w); j < z; j += f)  					{  						System.Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = (int)(((uint)j) >> 1))  					{  						i ^= j;  					}  					i ^= j;  					// backup over finished tables  					mask = (1 << w) - 1;  					// needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--;  						// don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l;  						// previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l) ? l : z;  						// table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1;  							// deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  									{  										break;  									}  									// enough codes to use up j bits  									f -= c[xp];  								}  							}  						}  						// else deduct codes from patterns  						z = 1 << j;  						// table entries for j-bit table  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR;  						}  						// overflow of MANY  						u[h] = q = hn[0];  						// DEBUG  						hn[0] += z;  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i;  							// save pattern for backing up  							r[0] = unchecked((byte)j);  							// bits in this table  							r[1] = unchecked((byte)l);  							// bits to dump before this table  							j = (int)(((uint)i) >> (w - l));  							r[2] = (int)(q - u[h - 1] - j);  							// offset to this table  							System.Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);  						}  						else  						{  							// connect to last table  							t[0] = q;  						}  					}  					// first table is returned result  					// set up table entry in r  					r[1] = unchecked((byte)(k - w));  					if (p >= n)  					{  						r[0] = 128 + 64;  					}  					else  					{  						// out of values--invalid code  						if (v[p] < s)  						{  							r[0] = unchecked((byte)(v[p] < 256 ? 0 : 32 + 64));  							// 256 is end-of-block  							r[2] = v[p++];  						}  						else  						{  							// simple code is just the value  							r[0] = unchecked((byte)(e[v[p] - s] + 16 + 64));  							// non-simple--look up in lists  							r[2] = d[v[p++] - s];  						}  					}  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = (int)(((uint)i) >> w); j < z; j += f)  					{  						System.Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = (int)(((uint)j) >> 1))  					{  						i ^= j;  					}  					i ^= j;  					// backup over finished tables  					mask = (1 << w) - 1;  					// needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--;  						// don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l;  						// previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l) ? l : z;  						// table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1;  							// deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  									{  										break;  									}  									// enough codes to use up j bits  									f -= c[xp];  								}  							}  						}  						// else deduct codes from patterns  						z = 1 << j;  						// table entries for j-bit table  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR;  						}  						// overflow of MANY  						u[h] = q = hn[0];  						// DEBUG  						hn[0] += z;  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i;  							// save pattern for backing up  							r[0] = unchecked((byte)j);  							// bits in this table  							r[1] = unchecked((byte)l);  							// bits to dump before this table  							j = (int)(((uint)i) >> (w - l));  							r[2] = (int)(q - u[h - 1] - j);  							// offset to this table  							System.Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);  						}  						else  						{  							// connect to last table  							t[0] = q;  						}  					}  					// first table is returned result  					// set up table entry in r  					r[1] = unchecked((byte)(k - w));  					if (p >= n)  					{  						r[0] = 128 + 64;  					}  					else  					{  						// out of values--invalid code  						if (v[p] < s)  						{  							r[0] = unchecked((byte)(v[p] < 256 ? 0 : 32 + 64));  							// 256 is end-of-block  							r[2] = v[p++];  						}  						else  						{  							// simple code is just the value  							r[0] = unchecked((byte)(e[v[p] - s] + 16 + 64));  							// non-simple--look up in lists  							r[2] = d[v[p++] - s];  						}  					}  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = (int)(((uint)i) >> w); j < z; j += f)  					{  						System.Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = (int)(((uint)j) >> 1))  					{  						i ^= j;  					}  					i ^= j;  					// backup over finished tables  					mask = (1 << w) - 1;  					// needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--;  						// don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l;  						// previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l) ? l : z;  						// table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1;  							// deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  									{  										break;  									}  									// enough codes to use up j bits  									f -= c[xp];  								}  							}  						}  						// else deduct codes from patterns  						z = 1 << j;  						// table entries for j-bit table  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR;  						}  						// overflow of MANY  						u[h] = q = hn[0];  						// DEBUG  						hn[0] += z;  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i;  							// save pattern for backing up  							r[0] = unchecked((byte)j);  							// bits in this table  							r[1] = unchecked((byte)l);  							// bits to dump before this table  							j = (int)(((uint)i) >> (w - l));  							r[2] = (int)(q - u[h - 1] - j);  							// offset to this table  							System.Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);  						}  						else  						{  							// connect to last table  							t[0] = q;  						}  					}  					// first table is returned result  					// set up table entry in r  					r[1] = unchecked((byte)(k - w));  					if (p >= n)  					{  						r[0] = 128 + 64;  					}  					else  					{  						// out of values--invalid code  						if (v[p] < s)  						{  							r[0] = unchecked((byte)(v[p] < 256 ? 0 : 32 + 64));  							// 256 is end-of-block  							r[2] = v[p++];  						}  						else  						{  							// simple code is just the value  							r[0] = unchecked((byte)(e[v[p] - s] + 16 + 64));  							// non-simple--look up in lists  							r[2] = d[v[p++] - s];  						}  					}  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = (int)(((uint)i) >> w); j < z; j += f)  					{  						System.Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = (int)(((uint)j) >> 1))  					{  						i ^= j;  					}  					i ^= j;  					// backup over finished tables  					mask = (1 << w) - 1;  					// needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--;  						// don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l;  						// previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l) ? l : z;  						// table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1;  							// deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  									{  										break;  									}  									// enough codes to use up j bits  									f -= c[xp];  								}  							}  						}  						// else deduct codes from patterns  						z = 1 << j;  						// table entries for j-bit table  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR;  						}  						// overflow of MANY  						u[h] = q = hn[0];  						// DEBUG  						hn[0] += z;  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i;  							// save pattern for backing up  							r[0] = unchecked((byte)j);  							// bits in this table  							r[1] = unchecked((byte)l);  							// bits to dump before this table  							j = (int)(((uint)i) >> (w - l));  							r[2] = (int)(q - u[h - 1] - j);  							// offset to this table  							System.Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);  						}  						else  						{  							// connect to last table  							t[0] = q;  						}  					}  					// first table is returned result  					// set up table entry in r  					r[1] = unchecked((byte)(k - w));  					if (p >= n)  					{  						r[0] = 128 + 64;  					}  					else  					{  						// out of values--invalid code  						if (v[p] < s)  						{  							r[0] = unchecked((byte)(v[p] < 256 ? 0 : 32 + 64));  							// 256 is end-of-block  							r[2] = v[p++];  						}  						else  						{  							// simple code is just the value  							r[0] = unchecked((byte)(e[v[p] - s] + 16 + 64));  							// non-simple--look up in lists  							r[2] = d[v[p++] - s];  						}  					}  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = (int)(((uint)i) >> w); j < z; j += f)  					{  						System.Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = (int)(((uint)j) >> 1))  					{  						i ^= j;  					}  					i ^= j;  					// backup over finished tables  					mask = (1 << w) - 1;  					// needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--;  						// don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l;  						// previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l) ? l : z;  						// table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1;  							// deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  									{  										break;  									}  									// enough codes to use up j bits  									f -= c[xp];  								}  							}  						}  						// else deduct codes from patterns  						z = 1 << j;  						// table entries for j-bit table  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR;  						}  						// overflow of MANY  						u[h] = q = hn[0];  						// DEBUG  						hn[0] += z;  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i;  							// save pattern for backing up  							r[0] = unchecked((byte)j);  							// bits in this table  							r[1] = unchecked((byte)l);  							// bits to dump before this table  							j = (int)(((uint)i) >> (w - l));  							r[2] = (int)(q - u[h - 1] - j);  							// offset to this table  							System.Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);  						}  						else  						{  							// connect to last table  							t[0] = q;  						}  					}  					// first table is returned result  					// set up table entry in r  					r[1] = unchecked((byte)(k - w));  					if (p >= n)  					{  						r[0] = 128 + 64;  					}  					else  					{  						// out of values--invalid code  						if (v[p] < s)  						{  							r[0] = unchecked((byte)(v[p] < 256 ? 0 : 32 + 64));  							// 256 is end-of-block  							r[2] = v[p++];  						}  						else  						{  							// simple code is just the value  							r[0] = unchecked((byte)(e[v[p] - s] + 16 + 64));  							// non-simple--look up in lists  							r[2] = d[v[p++] - s];  						}  					}  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = (int)(((uint)i) >> w); j < z; j += f)  					{  						System.Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = (int)(((uint)j) >> 1))  					{  						i ^= j;  					}  					i ^= j;  					// backup over finished tables  					mask = (1 << w) - 1;  					// needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--;  						// don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l;  						// previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l) ? l : z;  						// table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1;  							// deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  									{  										break;  									}  									// enough codes to use up j bits  									f -= c[xp];  								}  							}  						}  						// else deduct codes from patterns  						z = 1 << j;  						// table entries for j-bit table  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR;  						}  						// overflow of MANY  						u[h] = q = hn[0];  						// DEBUG  						hn[0] += z;  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i;  							// save pattern for backing up  							r[0] = unchecked((byte)j);  							// bits in this table  							r[1] = unchecked((byte)l);  							// bits to dump before this table  							j = (int)(((uint)i) >> (w - l));  							r[2] = (int)(q - u[h - 1] - j);  							// offset to this table  							System.Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);  						}  						else  						{  							// connect to last table  							t[0] = q;  						}  					}  					// first table is returned result  					// set up table entry in r  					r[1] = unchecked((byte)(k - w));  					if (p >= n)  					{  						r[0] = 128 + 64;  					}  					else  					{  						// out of values--invalid code  						if (v[p] < s)  						{  							r[0] = unchecked((byte)(v[p] < 256 ? 0 : 32 + 64));  							// 256 is end-of-block  							r[2] = v[p++];  						}  						else  						{  							// simple code is just the value  							r[0] = unchecked((byte)(e[v[p] - s] + 16 + 64));  							// non-simple--look up in lists  							r[2] = d[v[p++] - s];  						}  					}  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = (int)(((uint)i) >> w); j < z; j += f)  					{  						System.Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = (int)(((uint)j) >> 1))  					{  						i ^= j;  					}  					i ^= j;  					// backup over finished tables  					mask = (1 << w) - 1;  					// needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--;  						// don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_bits,The following statement contains a magic number: InitWorkArea(19);
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_bits,The following statement contains a magic number: result = Huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_bits,The following statement contains a magic number: result = Huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_dynamic,The following statement contains a magic number: InitWorkArea(288);
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_dynamic,The following statement contains a magic number: result = Huft_build(c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_dynamic,The following statement contains a magic number: InitWorkArea(288);
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,Inflate_trees_dynamic,The following statement contains a magic number: if (result != Z_OK || (bd[0] == 0 && nl > 257))  			{  				if (result == Z_DATA_ERROR)  				{  					z.msg = "oversubscribed distance tree";  				}  				else  				{  					if (result == Z_BUF_ERROR)  					{  						z.msg = "incomplete distance tree";  						result = Z_DATA_ERROR;  					}  					else  					{  						if (result != Z_MEM_ERROR)  						{  							z.msg = "empty distance tree with lengths";  							result = Z_DATA_ERROR;  						}  					}  				}  				return result;  			}
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,InitWorkArea,The following statement contains a magic number: if (hn == null)  			{  				hn = new int[1];  				v = new int[vsize];  				c = new int[BMAX + 1];  				r = new int[3];  				u = new int[BMAX];  				x = new int[BMAX + 1];  			}
Magic Number,NSch.ZLib,InfTree,C:\repos\mono_ngit\NSch\NSch.ZLib\InfTree.cs,InitWorkArea,The following statement contains a magic number: for (int i_2 = 0; i_2 < 3; i_2++)  			{  				r[i_2] = 0;  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,InflateInit,The following statement contains a magic number: if (w < 8 || w > 15)  			{  				InflateEnd(z);  				return Z_STREAM_ERROR;  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,InflateInit,The following statement contains a magic number: if (w < 8 || w > 15)  			{  				InflateEnd(z);  				return Z_STREAM_ERROR;  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: while (true)  			{  				switch (z.istate.mode)  				{  					case METHOD:  					{  						//System.out.println("mode: "+z.istate.mode);  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) !=  							 Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					}    					case FLAG:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff));  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					}    					case DICT4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = DICT3;  						goto case DICT3;  					}    					case DICT3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = DICT2;  						goto case DICT2;  					}    					case DICT2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = DICT1;  						goto case DICT1;  					}    					case DICT1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					}    					case DICT0:  					{  						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0;  						// can try inflateSync  						return Z_STREAM_ERROR;  					}    					case BLOCKS:  					{  						r = z.istate.blocks.Proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0;  							// can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.Reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					}    					case CHECK4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = CHECK3;  						goto case CHECK3;  					}    					case CHECK3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = CHECK2;  						goto case CHECK2;  					}    					case CHECK2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = CHECK1;  						goto case CHECK1;  					}    					case CHECK1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						return Z_STREAM_END;  					}    					case BAD:  					{  						return Z_DATA_ERROR;  					}    					default:  					{  						return Z_STREAM_ERROR;  						break;  					}  				}  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: while (true)  			{  				switch (z.istate.mode)  				{  					case METHOD:  					{  						//System.out.println("mode: "+z.istate.mode);  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) !=  							 Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					}    					case FLAG:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff));  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					}    					case DICT4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = DICT3;  						goto case DICT3;  					}    					case DICT3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = DICT2;  						goto case DICT2;  					}    					case DICT2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = DICT1;  						goto case DICT1;  					}    					case DICT1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					}    					case DICT0:  					{  						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0;  						// can try inflateSync  						return Z_STREAM_ERROR;  					}    					case BLOCKS:  					{  						r = z.istate.blocks.Proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0;  							// can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.Reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					}    					case CHECK4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = CHECK3;  						goto case CHECK3;  					}    					case CHECK3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = CHECK2;  						goto case CHECK2;  					}    					case CHECK2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = CHECK1;  						goto case CHECK1;  					}    					case CHECK1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						return Z_STREAM_END;  					}    					case BAD:  					{  						return Z_DATA_ERROR;  					}    					default:  					{  						return Z_STREAM_ERROR;  						break;  					}  				}  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: while (true)  			{  				switch (z.istate.mode)  				{  					case METHOD:  					{  						//System.out.println("mode: "+z.istate.mode);  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) !=  							 Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					}    					case FLAG:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff));  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					}    					case DICT4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = DICT3;  						goto case DICT3;  					}    					case DICT3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = DICT2;  						goto case DICT2;  					}    					case DICT2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = DICT1;  						goto case DICT1;  					}    					case DICT1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					}    					case DICT0:  					{  						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0;  						// can try inflateSync  						return Z_STREAM_ERROR;  					}    					case BLOCKS:  					{  						r = z.istate.blocks.Proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0;  							// can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.Reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					}    					case CHECK4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = CHECK3;  						goto case CHECK3;  					}    					case CHECK3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = CHECK2;  						goto case CHECK2;  					}    					case CHECK2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = CHECK1;  						goto case CHECK1;  					}    					case CHECK1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						return Z_STREAM_END;  					}    					case BAD:  					{  						return Z_DATA_ERROR;  					}    					default:  					{  						return Z_STREAM_ERROR;  						break;  					}  				}  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: while (true)  			{  				switch (z.istate.mode)  				{  					case METHOD:  					{  						//System.out.println("mode: "+z.istate.mode);  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) !=  							 Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					}    					case FLAG:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff));  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					}    					case DICT4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = DICT3;  						goto case DICT3;  					}    					case DICT3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = DICT2;  						goto case DICT2;  					}    					case DICT2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = DICT1;  						goto case DICT1;  					}    					case DICT1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					}    					case DICT0:  					{  						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0;  						// can try inflateSync  						return Z_STREAM_ERROR;  					}    					case BLOCKS:  					{  						r = z.istate.blocks.Proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0;  							// can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.Reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					}    					case CHECK4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = CHECK3;  						goto case CHECK3;  					}    					case CHECK3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = CHECK2;  						goto case CHECK2;  					}    					case CHECK2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = CHECK1;  						goto case CHECK1;  					}    					case CHECK1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						return Z_STREAM_END;  					}    					case BAD:  					{  						return Z_DATA_ERROR;  					}    					default:  					{  						return Z_STREAM_ERROR;  						break;  					}  				}  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: while (true)  			{  				switch (z.istate.mode)  				{  					case METHOD:  					{  						//System.out.println("mode: "+z.istate.mode);  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) !=  							 Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					}    					case FLAG:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff));  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					}    					case DICT4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = DICT3;  						goto case DICT3;  					}    					case DICT3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = DICT2;  						goto case DICT2;  					}    					case DICT2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = DICT1;  						goto case DICT1;  					}    					case DICT1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					}    					case DICT0:  					{  						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0;  						// can try inflateSync  						return Z_STREAM_ERROR;  					}    					case BLOCKS:  					{  						r = z.istate.blocks.Proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0;  							// can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.Reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					}    					case CHECK4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = CHECK3;  						goto case CHECK3;  					}    					case CHECK3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = CHECK2;  						goto case CHECK2;  					}    					case CHECK2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = CHECK1;  						goto case CHECK1;  					}    					case CHECK1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						return Z_STREAM_END;  					}    					case BAD:  					{  						return Z_DATA_ERROR;  					}    					default:  					{  						return Z_STREAM_ERROR;  						break;  					}  				}  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: while (true)  			{  				switch (z.istate.mode)  				{  					case METHOD:  					{  						//System.out.println("mode: "+z.istate.mode);  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) !=  							 Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					}    					case FLAG:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff));  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					}    					case DICT4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = DICT3;  						goto case DICT3;  					}    					case DICT3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = DICT2;  						goto case DICT2;  					}    					case DICT2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = DICT1;  						goto case DICT1;  					}    					case DICT1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					}    					case DICT0:  					{  						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0;  						// can try inflateSync  						return Z_STREAM_ERROR;  					}    					case BLOCKS:  					{  						r = z.istate.blocks.Proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0;  							// can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.Reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					}    					case CHECK4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = CHECK3;  						goto case CHECK3;  					}    					case CHECK3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = CHECK2;  						goto case CHECK2;  					}    					case CHECK2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = CHECK1;  						goto case CHECK1;  					}    					case CHECK1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						return Z_STREAM_END;  					}    					case BAD:  					{  						return Z_DATA_ERROR;  					}    					default:  					{  						return Z_STREAM_ERROR;  						break;  					}  				}  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: while (true)  			{  				switch (z.istate.mode)  				{  					case METHOD:  					{  						//System.out.println("mode: "+z.istate.mode);  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) !=  							 Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					}    					case FLAG:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff));  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					}    					case DICT4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = DICT3;  						goto case DICT3;  					}    					case DICT3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = DICT2;  						goto case DICT2;  					}    					case DICT2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = DICT1;  						goto case DICT1;  					}    					case DICT1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					}    					case DICT0:  					{  						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0;  						// can try inflateSync  						return Z_STREAM_ERROR;  					}    					case BLOCKS:  					{  						r = z.istate.blocks.Proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0;  							// can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.Reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					}    					case CHECK4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = CHECK3;  						goto case CHECK3;  					}    					case CHECK3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = CHECK2;  						goto case CHECK2;  					}    					case CHECK2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = CHECK1;  						goto case CHECK1;  					}    					case CHECK1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						return Z_STREAM_END;  					}    					case BAD:  					{  						return Z_DATA_ERROR;  					}    					default:  					{  						return Z_STREAM_ERROR;  						break;  					}  				}  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: while (true)  			{  				switch (z.istate.mode)  				{  					case METHOD:  					{  						//System.out.println("mode: "+z.istate.mode);  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) !=  							 Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					}    					case FLAG:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff));  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					}    					case DICT4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = DICT3;  						goto case DICT3;  					}    					case DICT3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = DICT2;  						goto case DICT2;  					}    					case DICT2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = DICT1;  						goto case DICT1;  					}    					case DICT1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					}    					case DICT0:  					{  						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0;  						// can try inflateSync  						return Z_STREAM_ERROR;  					}    					case BLOCKS:  					{  						r = z.istate.blocks.Proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0;  							// can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.Reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					}    					case CHECK4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = CHECK3;  						goto case CHECK3;  					}    					case CHECK3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = CHECK2;  						goto case CHECK2;  					}    					case CHECK2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = CHECK1;  						goto case CHECK1;  					}    					case CHECK1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						return Z_STREAM_END;  					}    					case BAD:  					{  						return Z_DATA_ERROR;  					}    					default:  					{  						return Z_STREAM_ERROR;  						break;  					}  				}  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: while (true)  			{  				switch (z.istate.mode)  				{  					case METHOD:  					{  						//System.out.println("mode: "+z.istate.mode);  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) !=  							 Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					}    					case FLAG:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff));  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					}    					case DICT4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = DICT3;  						goto case DICT3;  					}    					case DICT3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = DICT2;  						goto case DICT2;  					}    					case DICT2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = DICT1;  						goto case DICT1;  					}    					case DICT1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					}    					case DICT0:  					{  						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0;  						// can try inflateSync  						return Z_STREAM_ERROR;  					}    					case BLOCKS:  					{  						r = z.istate.blocks.Proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0;  							// can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.Reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					}    					case CHECK4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = CHECK3;  						goto case CHECK3;  					}    					case CHECK3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = CHECK2;  						goto case CHECK2;  					}    					case CHECK2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = CHECK1;  						goto case CHECK1;  					}    					case CHECK1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						return Z_STREAM_END;  					}    					case BAD:  					{  						return Z_DATA_ERROR;  					}    					default:  					{  						return Z_STREAM_ERROR;  						break;  					}  				}  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: while (true)  			{  				switch (z.istate.mode)  				{  					case METHOD:  					{  						//System.out.println("mode: "+z.istate.mode);  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) !=  							 Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					}    					case FLAG:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff));  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					}    					case DICT4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = DICT3;  						goto case DICT3;  					}    					case DICT3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = DICT2;  						goto case DICT2;  					}    					case DICT2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = DICT1;  						goto case DICT1;  					}    					case DICT1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					}    					case DICT0:  					{  						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0;  						// can try inflateSync  						return Z_STREAM_ERROR;  					}    					case BLOCKS:  					{  						r = z.istate.blocks.Proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0;  							// can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.Reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					}    					case CHECK4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = CHECK3;  						goto case CHECK3;  					}    					case CHECK3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = CHECK2;  						goto case CHECK2;  					}    					case CHECK2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = CHECK1;  						goto case CHECK1;  					}    					case CHECK1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						return Z_STREAM_END;  					}    					case BAD:  					{  						return Z_DATA_ERROR;  					}    					default:  					{  						return Z_STREAM_ERROR;  						break;  					}  				}  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: while (true)  			{  				switch (z.istate.mode)  				{  					case METHOD:  					{  						//System.out.println("mode: "+z.istate.mode);  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) !=  							 Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					}    					case FLAG:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff));  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					}    					case DICT4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = DICT3;  						goto case DICT3;  					}    					case DICT3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = DICT2;  						goto case DICT2;  					}    					case DICT2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = DICT1;  						goto case DICT1;  					}    					case DICT1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					}    					case DICT0:  					{  						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0;  						// can try inflateSync  						return Z_STREAM_ERROR;  					}    					case BLOCKS:  					{  						r = z.istate.blocks.Proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0;  							// can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.Reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					}    					case CHECK4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = CHECK3;  						goto case CHECK3;  					}    					case CHECK3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = CHECK2;  						goto case CHECK2;  					}    					case CHECK2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = CHECK1;  						goto case CHECK1;  					}    					case CHECK1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						return Z_STREAM_END;  					}    					case BAD:  					{  						return Z_DATA_ERROR;  					}    					default:  					{  						return Z_STREAM_ERROR;  						break;  					}  				}  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: while (true)  			{  				switch (z.istate.mode)  				{  					case METHOD:  					{  						//System.out.println("mode: "+z.istate.mode);  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) !=  							 Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					}    					case FLAG:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff));  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					}    					case DICT4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = DICT3;  						goto case DICT3;  					}    					case DICT3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = DICT2;  						goto case DICT2;  					}    					case DICT2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = DICT1;  						goto case DICT1;  					}    					case DICT1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					}    					case DICT0:  					{  						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0;  						// can try inflateSync  						return Z_STREAM_ERROR;  					}    					case BLOCKS:  					{  						r = z.istate.blocks.Proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0;  							// can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.Reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					}    					case CHECK4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = CHECK3;  						goto case CHECK3;  					}    					case CHECK3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = CHECK2;  						goto case CHECK2;  					}    					case CHECK2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = CHECK1;  						goto case CHECK1;  					}    					case CHECK1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						return Z_STREAM_END;  					}    					case BAD:  					{  						return Z_DATA_ERROR;  					}    					default:  					{  						return Z_STREAM_ERROR;  						break;  					}  				}  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: while (true)  			{  				switch (z.istate.mode)  				{  					case METHOD:  					{  						//System.out.println("mode: "+z.istate.mode);  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) !=  							 Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					}    					case FLAG:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff));  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					}    					case DICT4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = DICT3;  						goto case DICT3;  					}    					case DICT3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = DICT2;  						goto case DICT2;  					}    					case DICT2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = DICT1;  						goto case DICT1;  					}    					case DICT1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					}    					case DICT0:  					{  						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0;  						// can try inflateSync  						return Z_STREAM_ERROR;  					}    					case BLOCKS:  					{  						r = z.istate.blocks.Proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0;  							// can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.Reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					}    					case CHECK4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = CHECK3;  						goto case CHECK3;  					}    					case CHECK3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = CHECK2;  						goto case CHECK2;  					}    					case CHECK2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = CHECK1;  						goto case CHECK1;  					}    					case CHECK1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						return Z_STREAM_END;  					}    					case BAD:  					{  						return Z_DATA_ERROR;  					}    					default:  					{  						return Z_STREAM_ERROR;  						break;  					}  				}  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,DoInflate,The following statement contains a magic number: while (true)  			{  				switch (z.istate.mode)  				{  					case METHOD:  					{  						//System.out.println("mode: "+z.istate.mode);  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & unchecked((int)(0xf))) !=  							 Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					}    					case FLAG:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						b = (z.next_in[z.next_in_index++]) & unchecked((int)(0xff));  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					}    					case DICT4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = DICT3;  						goto case DICT3;  					}    					case DICT3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = DICT2;  						goto case DICT2;  					}    					case DICT2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = DICT1;  						goto case DICT1;  					}    					case DICT1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					}    					case DICT0:  					{  						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0;  						// can try inflateSync  						return Z_STREAM_ERROR;  					}    					case BLOCKS:  					{  						r = z.istate.blocks.Proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0;  							// can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.Reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					}    					case CHECK4:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 24) &  							 unchecked((long)(0xff000000L));  						z.istate.mode = CHECK3;  						goto case CHECK3;  					}    					case CHECK3:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 16)   							& unchecked((long)(0xff0000L));  						z.istate.mode = CHECK2;  						goto case CHECK2;  					}    					case CHECK2:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & unchecked((int)(0xff))) << 8) &  							 unchecked((long)(0xff00L));  						z.istate.mode = CHECK1;  						goto case CHECK1;  					}    					case CHECK1:  					{  						if (z.avail_in == 0)  						{  							return r;  						}  						r = f;  						z.avail_in--;  						z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & unchecked((long)(0xffL)));  						if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5;  							// can't try inflateSync  							break;  						}  						z.istate.mode = DONE;  						goto case DONE;  					}    					case DONE:  					{  						return Z_STREAM_END;  					}    					case BAD:  					{  						return Z_DATA_ERROR;  					}    					default:  					{  						return Z_STREAM_ERROR;  						break;  					}  				}  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,InflateSync,The following statement contains a magic number: while (n != 0 && m < 4)  			{  				if (z.next_in[p] == mark[m])  				{  					m++;  				}  				else  				{  					if (z.next_in[p] != 0)  					{  						m = 0;  					}  					else  					{  						m = 4 - m;  					}  				}  				p++;  				n--;  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,InflateSync,The following statement contains a magic number: while (n != 0 && m < 4)  			{  				if (z.next_in[p] == mark[m])  				{  					m++;  				}  				else  				{  					if (z.next_in[p] != 0)  					{  						m = 0;  					}  					else  					{  						m = 4 - m;  					}  				}  				p++;  				n--;  			}
Magic Number,NSch.ZLib,Inflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Inflate.cs,InflateSync,The following statement contains a magic number: if (m != 4)  			{  				return Z_DATA_ERROR;  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,D_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + ((int)(((uint)(dist))   				>> 7))]);
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,D_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + ((int)(((uint)(dist))   				>> 7))]);
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,D_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + ((int)(((uint)(dist))   				>> 7))]);
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: tree[s.heap[s.heap_max] * 2 + 1] = 0;
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)  			{  				n = s.heap[h];  				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;  				if (bits > max_length)  				{  					bits = max_length;  					overflow++;  				}  				tree[n * 2 + 1] = (short)bits;  				// We overwrite tree[n*2+1] which is no longer needed  				if (n > max_code)  				{  					continue;  				}  				// not a leaf node  				s.bl_count[bits]++;  				xbits = 0;  				if (n >= @base)  				{  					xbits = extra[n - @base];  				}  				f = tree[n * 2];  				s.opt_len += f * (bits + xbits);  				if (stree != null)  				{  					s.static_len += f * (stree[n * 2 + 1] + xbits);  				}  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)  			{  				n = s.heap[h];  				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;  				if (bits > max_length)  				{  					bits = max_length;  					overflow++;  				}  				tree[n * 2 + 1] = (short)bits;  				// We overwrite tree[n*2+1] which is no longer needed  				if (n > max_code)  				{  					continue;  				}  				// not a leaf node  				s.bl_count[bits]++;  				xbits = 0;  				if (n >= @base)  				{  					xbits = extra[n - @base];  				}  				f = tree[n * 2];  				s.opt_len += f * (bits + xbits);  				if (stree != null)  				{  					s.static_len += f * (stree[n * 2 + 1] + xbits);  				}  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)  			{  				n = s.heap[h];  				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;  				if (bits > max_length)  				{  					bits = max_length;  					overflow++;  				}  				tree[n * 2 + 1] = (short)bits;  				// We overwrite tree[n*2+1] which is no longer needed  				if (n > max_code)  				{  					continue;  				}  				// not a leaf node  				s.bl_count[bits]++;  				xbits = 0;  				if (n >= @base)  				{  					xbits = extra[n - @base];  				}  				f = tree[n * 2];  				s.opt_len += f * (bits + xbits);  				if (stree != null)  				{  					s.static_len += f * (stree[n * 2 + 1] + xbits);  				}  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)  			{  				n = s.heap[h];  				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;  				if (bits > max_length)  				{  					bits = max_length;  					overflow++;  				}  				tree[n * 2 + 1] = (short)bits;  				// We overwrite tree[n*2+1] which is no longer needed  				if (n > max_code)  				{  					continue;  				}  				// not a leaf node  				s.bl_count[bits]++;  				xbits = 0;  				if (n >= @base)  				{  					xbits = extra[n - @base];  				}  				f = tree[n * 2];  				s.opt_len += f * (bits + xbits);  				if (stree != null)  				{  					s.static_len += f * (stree[n * 2 + 1] + xbits);  				}  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)  			{  				n = s.heap[h];  				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;  				if (bits > max_length)  				{  					bits = max_length;  					overflow++;  				}  				tree[n * 2 + 1] = (short)bits;  				// We overwrite tree[n*2+1] which is no longer needed  				if (n > max_code)  				{  					continue;  				}  				// not a leaf node  				s.bl_count[bits]++;  				xbits = 0;  				if (n >= @base)  				{  					xbits = extra[n - @base];  				}  				f = tree[n * 2];  				s.opt_len += f * (bits + xbits);  				if (stree != null)  				{  					s.static_len += f * (stree[n * 2 + 1] + xbits);  				}  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: do  			{  				// This happens for example on obj2 and pic of the Calgary corpus  				// Find the first bit length which could increase:  				bits = max_length - 1;  				while (s.bl_count[bits] == 0)  				{  					bits--;  				}  				s.bl_count[bits]--;  				// move one leaf down the tree  				s.bl_count[bits + 1] += 2;  				// move one overflow item as its brother  				s.bl_count[max_length]--;  				// The brother of the overflow item also moves one step up'  				// but this does not affect bl_count[max_length]  				overflow -= 2;  			}  			while (overflow > 0);
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: do  			{  				// This happens for example on obj2 and pic of the Calgary corpus  				// Find the first bit length which could increase:  				bits = max_length - 1;  				while (s.bl_count[bits] == 0)  				{  					bits--;  				}  				s.bl_count[bits]--;  				// move one leaf down the tree  				s.bl_count[bits + 1] += 2;  				// move one overflow item as its brother  				s.bl_count[max_length]--;  				// The brother of the overflow item also moves one step up'  				// but this does not affect bl_count[max_length]  				overflow -= 2;  			}  			while (overflow > 0);
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)  			{  				n = s.bl_count[bits];  				while (n != 0)  				{  					m = s.heap[--h];  					if (m > max_code)  					{  						continue;  					}  					if (tree[m * 2 + 1] != bits)  					{  						s.opt_len += (int)(((long)bits - (long)tree[m * 2 + 1]) * (long)tree[m * 2]);  						tree[m * 2 + 1] = (short)bits;  					}  					n--;  				}  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)  			{  				n = s.bl_count[bits];  				while (n != 0)  				{  					m = s.heap[--h];  					if (m > max_code)  					{  						continue;  					}  					if (tree[m * 2 + 1] != bits)  					{  						s.opt_len += (int)(((long)bits - (long)tree[m * 2 + 1]) * (long)tree[m * 2]);  						tree[m * 2 + 1] = (short)bits;  					}  					n--;  				}  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)  			{  				n = s.bl_count[bits];  				while (n != 0)  				{  					m = s.heap[--h];  					if (m > max_code)  					{  						continue;  					}  					if (tree[m * 2 + 1] != bits)  					{  						s.opt_len += (int)(((long)bits - (long)tree[m * 2 + 1]) * (long)tree[m * 2]);  						tree[m * 2 + 1] = (short)bits;  					}  					n--;  				}  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)  			{  				n = s.bl_count[bits];  				while (n != 0)  				{  					m = s.heap[--h];  					if (m > max_code)  					{  						continue;  					}  					if (tree[m * 2 + 1] != bits)  					{  						s.opt_len += (int)(((long)bits - (long)tree[m * 2 + 1]) * (long)tree[m * 2]);  						tree[m * 2 + 1] = (short)bits;  					}  					n--;  				}  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++)  			{  				if (tree[n * 2] != 0)  				{  					s.heap[++s.heap_len] = max_code = n;  					s.depth[n] = 0;  				}  				else  				{  					tree[n * 2 + 1] = 0;  				}  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++)  			{  				if (tree[n * 2] != 0)  				{  					s.heap[++s.heap_len] = max_code = n;  					s.depth[n] = 0;  				}  				else  				{  					tree[n * 2 + 1] = 0;  				}  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: while (s.heap_len < 2)  			{  				node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);  				tree[node * 2] = 1;  				s.depth[node] = 0;  				s.opt_len--;  				if (stree != null)  				{  					s.static_len -= stree[node * 2 + 1];  				}  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: while (s.heap_len < 2)  			{  				node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);  				tree[node * 2] = 1;  				s.depth[node] = 0;  				s.opt_len--;  				if (stree != null)  				{  					s.static_len -= stree[node * 2 + 1];  				}  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: while (s.heap_len < 2)  			{  				node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);  				tree[node * 2] = 1;  				s.depth[node] = 0;  				s.opt_len--;  				if (stree != null)  				{  					s.static_len -= stree[node * 2 + 1];  				}  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: while (s.heap_len < 2)  			{  				node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);  				tree[node * 2] = 1;  				s.depth[node] = 0;  				s.opt_len--;  				if (stree != null)  				{  					s.static_len -= stree[node * 2 + 1];  				}  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: for (n = s.heap_len / 2; n >= 1; n--)  			{  				s.Pqdownheap(tree' n);  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: do  			{  				// next internal node of the tree  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.Pqdownheap(tree' 1);  				m = s.heap[1];  				// m = node of next least frequency  				s.heap[--s.heap_max] = n;  				// keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				// Create a new node father of n and m  				tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);  				s.depth[node] = unchecked((byte)(Math.Max(s.depth[n]' s.depth[m]) + 1));  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short)node;  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.Pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: do  			{  				// next internal node of the tree  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.Pqdownheap(tree' 1);  				m = s.heap[1];  				// m = node of next least frequency  				s.heap[--s.heap_max] = n;  				// keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				// Create a new node father of n and m  				tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);  				s.depth[node] = unchecked((byte)(Math.Max(s.depth[n]' s.depth[m]) + 1));  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short)node;  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.Pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: do  			{  				// next internal node of the tree  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.Pqdownheap(tree' 1);  				m = s.heap[1];  				// m = node of next least frequency  				s.heap[--s.heap_max] = n;  				// keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				// Create a new node father of n and m  				tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);  				s.depth[node] = unchecked((byte)(Math.Max(s.depth[n]' s.depth[m]) + 1));  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short)node;  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.Pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: do  			{  				// next internal node of the tree  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.Pqdownheap(tree' 1);  				m = s.heap[1];  				// m = node of next least frequency  				s.heap[--s.heap_max] = n;  				// keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				// Create a new node father of n and m  				tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);  				s.depth[node] = unchecked((byte)(Math.Max(s.depth[n]' s.depth[m]) + 1));  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short)node;  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.Pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: do  			{  				// next internal node of the tree  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.Pqdownheap(tree' 1);  				m = s.heap[1];  				// m = node of next least frequency  				s.heap[--s.heap_max] = n;  				// keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				// Create a new node father of n and m  				tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);  				s.depth[node] = unchecked((byte)(Math.Max(s.depth[n]' s.depth[m]) + 1));  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short)node;  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.Pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Build_tree,The following statement contains a magic number: do  			{  				// next internal node of the tree  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.Pqdownheap(tree' 1);  				m = s.heap[1];  				// m = node of next least frequency  				s.heap[--s.heap_max] = n;  				// keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				// Create a new node father of n and m  				tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);  				s.depth[node] = unchecked((byte)(Math.Max(s.depth[n]' s.depth[m]) + 1));  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short)node;  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.Pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				int len = tree[n * 2 + 1];  				if (len == 0)  				{  					continue;  				}  				// Now reverse the bits  				tree[n * 2] = (short)(Bi_reverse(next_code[len]++' len));  			}
Magic Number,NSch.ZLib,Tree,C:\repos\mono_ngit\NSch\NSch.ZLib\Tree.cs,Gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				int len = tree[n * 2 + 1];  				if (len == 0)  				{  					continue;  				}  				// Now reverse the bits  				tree[n * 2] = (short)(Bi_reverse(next_code[len]++' len));  			}
Magic Number,NSch.ZLib,ZInputStream,C:\repos\mono_ngit\NSch\NSch.ZLib\ZInputStream.cs,Skip,The following statement contains a magic number: int len = 512;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table = new Deflate.Config[10];
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Deflate.Config(4' 4' 8' 4' FAST);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Deflate.Config(4' 4' 8' 4' FAST);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Deflate.Config(4' 4' 8' 4' FAST);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Deflate.Config(4' 4' 8' 4' FAST);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Deflate.Config(4' 5' 16' 8' FAST);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Deflate.Config(4' 5' 16' 8' FAST);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Deflate.Config(4' 5' 16' 8' FAST);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Deflate.Config(4' 5' 16' 8' FAST);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Deflate.Config(4' 5' 16' 8' FAST);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Deflate.Config(4' 6' 32' 32' FAST);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Deflate.Config(4' 6' 32' 32' FAST);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Deflate.Config(4' 6' 32' 32' FAST);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Deflate.Config(4' 6' 32' 32' FAST);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Deflate.Config(4' 6' 32' 32' FAST);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Deflate.Config(4' 4' 16' 16' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Deflate.Config(4' 4' 16' 16' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Deflate.Config(4' 4' 16' 16' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Deflate.Config(4' 4' 16' 16' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Deflate.Config(4' 4' 16' 16' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Deflate.Config(8' 16' 32' 32' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Deflate.Config(8' 16' 32' 32' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Deflate.Config(8' 16' 32' 32' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Deflate.Config(8' 16' 32' 32' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Deflate.Config(8' 16' 32' 32' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Deflate.Config(8' 16' 128' 128' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Deflate.Config(8' 16' 128' 128' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Deflate.Config(8' 16' 128' 128' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Deflate.Config(8' 16' 128' 128' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Deflate.Config(8' 16' 128' 128' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Deflate.Config(8' 32' 128' 256' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Deflate.Config(8' 32' 128' 256' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Deflate.Config(8' 32' 128' 256' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Deflate.Config(8' 32' 128' 256' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Deflate.Config(8' 32' 128' 256' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Deflate.Config(32' 128' 258' 1024' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Deflate.Config(32' 128' 258' 1024' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Deflate.Config(32' 128' 258' 1024' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Deflate.Config(32' 128' 258' 1024' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Deflate.Config(32' 128' 258' 1024' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Deflate.Config(32' 258' 258' 4096' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Deflate.Config(32' 258' 258' 4096' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Deflate.Config(32' 258' 258' 4096' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Deflate.Config(32' 258' 258' 4096' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Deflate.Config(32' 258' 258' 4096' SLOW);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_ltree = new short[HEAP_SIZE * 2];
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Lm_init,The following statement contains a magic number: window_size = 2 * w_size;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Tr_init,The following statement contains a magic number: last_eob_len = 8;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Init_block,The following statement contains a magic number: for (int i = 0; i < L_CODES; i++)  			{  				dyn_ltree[i * 2] = 0;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Init_block,The following statement contains a magic number: for (int i_1 = 0; i_1 < D_CODES; i_1++)  			{  				dyn_dtree[i_1 * 2] = 0;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Init_block,The following statement contains a magic number: for (int i_2 = 0; i_2 < BL_CODES; i_2++)  			{  				bl_tree[i_2 * 2] = 0;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Init_block,The following statement contains a magic number: dyn_ltree[END_BLOCK * 2] = 1;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Smaller,The following statement contains a magic number: short tn2 = tree[n * 2];
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Smaller,The following statement contains a magic number: short tm2 = tree[m * 2];
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: if (nextlen == 0)  			{  				max_count = 138;  				min_count = 3;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: if (nextlen == 0)  			{  				max_count = 138;  				min_count = 3;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: tree[(max_code + 1) * 2 + 1] = unchecked((short)0xffff);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						bl_tree[curlen * 2] += (short) count;  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								bl_tree[curlen * 2]++;  							}  							bl_tree[REP_3_6 * 2]++;  						}  						else  						{  							if (count <= 10)  							{  								bl_tree[REPZ_3_10 * 2]++;  							}  							else  							{  								bl_tree[REPZ_11_138 * 2]++;  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						bl_tree[curlen * 2] += (short) count;  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								bl_tree[curlen * 2]++;  							}  							bl_tree[REP_3_6 * 2]++;  						}  						else  						{  							if (count <= 10)  							{  								bl_tree[REPZ_3_10 * 2]++;  							}  							else  							{  								bl_tree[REPZ_11_138 * 2]++;  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						bl_tree[curlen * 2] += (short) count;  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								bl_tree[curlen * 2]++;  							}  							bl_tree[REP_3_6 * 2]++;  						}  						else  						{  							if (count <= 10)  							{  								bl_tree[REPZ_3_10 * 2]++;  							}  							else  							{  								bl_tree[REPZ_11_138 * 2]++;  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						bl_tree[curlen * 2] += (short) count;  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								bl_tree[curlen * 2]++;  							}  							bl_tree[REP_3_6 * 2]++;  						}  						else  						{  							if (count <= 10)  							{  								bl_tree[REPZ_3_10 * 2]++;  							}  							else  							{  								bl_tree[REPZ_11_138 * 2]++;  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						bl_tree[curlen * 2] += (short) count;  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								bl_tree[curlen * 2]++;  							}  							bl_tree[REP_3_6 * 2]++;  						}  						else  						{  							if (count <= 10)  							{  								bl_tree[REPZ_3_10 * 2]++;  							}  							else  							{  								bl_tree[REPZ_11_138 * 2]++;  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						bl_tree[curlen * 2] += (short) count;  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								bl_tree[curlen * 2]++;  							}  							bl_tree[REP_3_6 * 2]++;  						}  						else  						{  							if (count <= 10)  							{  								bl_tree[REPZ_3_10 * 2]++;  							}  							else  							{  								bl_tree[REPZ_11_138 * 2]++;  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						bl_tree[curlen * 2] += (short) count;  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								bl_tree[curlen * 2]++;  							}  							bl_tree[REP_3_6 * 2]++;  						}  						else  						{  							if (count <= 10)  							{  								bl_tree[REPZ_3_10 * 2]++;  							}  							else  							{  								bl_tree[REPZ_11_138 * 2]++;  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						bl_tree[curlen * 2] += (short) count;  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								bl_tree[curlen * 2]++;  							}  							bl_tree[REP_3_6 * 2]++;  						}  						else  						{  							if (count <= 10)  							{  								bl_tree[REPZ_3_10 * 2]++;  							}  							else  							{  								bl_tree[REPZ_11_138 * 2]++;  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						bl_tree[curlen * 2] += (short) count;  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								bl_tree[curlen * 2]++;  							}  							bl_tree[REP_3_6 * 2]++;  						}  						else  						{  							if (count <= 10)  							{  								bl_tree[REPZ_3_10 * 2]++;  							}  							else  							{  								bl_tree[REPZ_11_138 * 2]++;  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						bl_tree[curlen * 2] += (short) count;  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								bl_tree[curlen * 2]++;  							}  							bl_tree[REP_3_6 * 2]++;  						}  						else  						{  							if (count <= 10)  							{  								bl_tree[REPZ_3_10 * 2]++;  							}  							else  							{  								bl_tree[REPZ_11_138 * 2]++;  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						bl_tree[curlen * 2] += (short) count;  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								bl_tree[curlen * 2]++;  							}  							bl_tree[REP_3_6 * 2]++;  						}  						else  						{  							if (count <= 10)  							{  								bl_tree[REPZ_3_10 * 2]++;  							}  							else  							{  								bl_tree[REPZ_11_138 * 2]++;  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						bl_tree[curlen * 2] += (short) count;  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								bl_tree[curlen * 2]++;  							}  							bl_tree[REP_3_6 * 2]++;  						}  						else  						{  							if (count <= 10)  							{  								bl_tree[REPZ_3_10 * 2]++;  							}  							else  							{  								bl_tree[REPZ_11_138 * 2]++;  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						bl_tree[curlen * 2] += (short) count;  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								bl_tree[curlen * 2]++;  							}  							bl_tree[REP_3_6 * 2]++;  						}  						else  						{  							if (count <= 10)  							{  								bl_tree[REPZ_3_10 * 2]++;  							}  							else  							{  								bl_tree[REPZ_11_138 * 2]++;  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Build_bl_tree,The following statement contains a magic number: for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--)  			{  				if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0)  				{  					break;  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Build_bl_tree,The following statement contains a magic number: for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--)  			{  				if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0)  				{  					break;  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_all_trees,The following statement contains a magic number: Send_bits(lcodes - 257' 5);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_all_trees,The following statement contains a magic number: Send_bits(lcodes - 257' 5);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_all_trees,The following statement contains a magic number: Send_bits(dcodes - 1' 5);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_all_trees,The following statement contains a magic number: Send_bits(blcodes - 4' 4);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_all_trees,The following statement contains a magic number: Send_bits(blcodes - 4' 4);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++)  			{  				Send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++)  			{  				Send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: if (nextlen == 0)  			{  				max_count = 138;  				min_count = 3;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: if (nextlen == 0)  			{  				max_count = 138;  				min_count = 3;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						do  						{  							Send_code(curlen' bl_tree);  						}  						while (--count != 0);  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								Send_code(curlen' bl_tree);  								count--;  							}  							Send_code(REP_3_6' bl_tree);  							Send_bits(count - 3' 2);  						}  						else  						{  							if (count <= 10)  							{  								Send_code(REPZ_3_10' bl_tree);  								Send_bits(count - 3' 3);  							}  							else  							{  								Send_code(REPZ_11_138' bl_tree);  								Send_bits(count - 11' 7);  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						do  						{  							Send_code(curlen' bl_tree);  						}  						while (--count != 0);  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								Send_code(curlen' bl_tree);  								count--;  							}  							Send_code(REP_3_6' bl_tree);  							Send_bits(count - 3' 2);  						}  						else  						{  							if (count <= 10)  							{  								Send_code(REPZ_3_10' bl_tree);  								Send_bits(count - 3' 3);  							}  							else  							{  								Send_code(REPZ_11_138' bl_tree);  								Send_bits(count - 11' 7);  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						do  						{  							Send_code(curlen' bl_tree);  						}  						while (--count != 0);  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								Send_code(curlen' bl_tree);  								count--;  							}  							Send_code(REP_3_6' bl_tree);  							Send_bits(count - 3' 2);  						}  						else  						{  							if (count <= 10)  							{  								Send_code(REPZ_3_10' bl_tree);  								Send_bits(count - 3' 3);  							}  							else  							{  								Send_code(REPZ_11_138' bl_tree);  								Send_bits(count - 11' 7);  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						do  						{  							Send_code(curlen' bl_tree);  						}  						while (--count != 0);  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								Send_code(curlen' bl_tree);  								count--;  							}  							Send_code(REP_3_6' bl_tree);  							Send_bits(count - 3' 2);  						}  						else  						{  							if (count <= 10)  							{  								Send_code(REPZ_3_10' bl_tree);  								Send_bits(count - 3' 3);  							}  							else  							{  								Send_code(REPZ_11_138' bl_tree);  								Send_bits(count - 11' 7);  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						do  						{  							Send_code(curlen' bl_tree);  						}  						while (--count != 0);  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								Send_code(curlen' bl_tree);  								count--;  							}  							Send_code(REP_3_6' bl_tree);  							Send_bits(count - 3' 2);  						}  						else  						{  							if (count <= 10)  							{  								Send_code(REPZ_3_10' bl_tree);  								Send_bits(count - 3' 3);  							}  							else  							{  								Send_code(REPZ_11_138' bl_tree);  								Send_bits(count - 11' 7);  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						do  						{  							Send_code(curlen' bl_tree);  						}  						while (--count != 0);  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								Send_code(curlen' bl_tree);  								count--;  							}  							Send_code(REP_3_6' bl_tree);  							Send_bits(count - 3' 2);  						}  						else  						{  							if (count <= 10)  							{  								Send_code(REPZ_3_10' bl_tree);  								Send_bits(count - 3' 3);  							}  							else  							{  								Send_code(REPZ_11_138' bl_tree);  								Send_bits(count - 11' 7);  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						do  						{  							Send_code(curlen' bl_tree);  						}  						while (--count != 0);  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								Send_code(curlen' bl_tree);  								count--;  							}  							Send_code(REP_3_6' bl_tree);  							Send_bits(count - 3' 2);  						}  						else  						{  							if (count <= 10)  							{  								Send_code(REPZ_3_10' bl_tree);  								Send_bits(count - 3' 3);  							}  							else  							{  								Send_code(REPZ_11_138' bl_tree);  								Send_bits(count - 11' 7);  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						do  						{  							Send_code(curlen' bl_tree);  						}  						while (--count != 0);  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								Send_code(curlen' bl_tree);  								count--;  							}  							Send_code(REP_3_6' bl_tree);  							Send_bits(count - 3' 2);  						}  						else  						{  							if (count <= 10)  							{  								Send_code(REPZ_3_10' bl_tree);  								Send_bits(count - 3' 3);  							}  							else  							{  								Send_code(REPZ_11_138' bl_tree);  								Send_bits(count - 11' 7);  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						do  						{  							Send_code(curlen' bl_tree);  						}  						while (--count != 0);  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								Send_code(curlen' bl_tree);  								count--;  							}  							Send_code(REP_3_6' bl_tree);  							Send_bits(count - 3' 2);  						}  						else  						{  							if (count <= 10)  							{  								Send_code(REPZ_3_10' bl_tree);  								Send_bits(count - 3' 3);  							}  							else  							{  								Send_code(REPZ_11_138' bl_tree);  								Send_bits(count - 11' 7);  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						do  						{  							Send_code(curlen' bl_tree);  						}  						while (--count != 0);  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								Send_code(curlen' bl_tree);  								count--;  							}  							Send_code(REP_3_6' bl_tree);  							Send_bits(count - 3' 2);  						}  						else  						{  							if (count <= 10)  							{  								Send_code(REPZ_3_10' bl_tree);  								Send_bits(count - 3' 3);  							}  							else  							{  								Send_code(REPZ_11_138' bl_tree);  								Send_bits(count - 11' 7);  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						do  						{  							Send_code(curlen' bl_tree);  						}  						while (--count != 0);  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								Send_code(curlen' bl_tree);  								count--;  							}  							Send_code(REP_3_6' bl_tree);  							Send_bits(count - 3' 2);  						}  						else  						{  							if (count <= 10)  							{  								Send_code(REPZ_3_10' bl_tree);  								Send_bits(count - 3' 3);  							}  							else  							{  								Send_code(REPZ_11_138' bl_tree);  								Send_bits(count - 11' 7);  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						do  						{  							Send_code(curlen' bl_tree);  						}  						while (--count != 0);  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								Send_code(curlen' bl_tree);  								count--;  							}  							Send_code(REP_3_6' bl_tree);  							Send_bits(count - 3' 2);  						}  						else  						{  							if (count <= 10)  							{  								Send_code(REPZ_3_10' bl_tree);  								Send_bits(count - 3' 3);  							}  							else  							{  								Send_code(REPZ_11_138' bl_tree);  								Send_bits(count - 11' 7);  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						do  						{  							Send_code(curlen' bl_tree);  						}  						while (--count != 0);  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								Send_code(curlen' bl_tree);  								count--;  							}  							Send_code(REP_3_6' bl_tree);  							Send_bits(count - 3' 2);  						}  						else  						{  							if (count <= 10)  							{  								Send_code(REPZ_3_10' bl_tree);  								Send_bits(count - 3' 3);  							}  							else  							{  								Send_code(REPZ_11_138' bl_tree);  								Send_bits(count - 11' 7);  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen;  				nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else  				{  					if (count < min_count)  					{  						do  						{  							Send_code(curlen' bl_tree);  						}  						while (--count != 0);  					}  					else  					{  						if (curlen != 0)  						{  							if (curlen != prevlen)  							{  								Send_code(curlen' bl_tree);  								count--;  							}  							Send_code(REP_3_6' bl_tree);  							Send_bits(count - 3' 2);  						}  						else  						{  							if (count <= 10)  							{  								Send_code(REPZ_3_10' bl_tree);  								Send_bits(count - 3' 3);  							}  							else  							{  								Send_code(REPZ_11_138' bl_tree);  								Send_bits(count - 11' 7);  							}  						}  					}  				}  				count = 0;  				prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138;  					min_count = 3;  				}  				else  				{  					if (curlen == nextlen)  					{  						max_count = 6;  						min_count = 3;  					}  					else  					{  						max_count = 7;  						min_count = 4;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Put_short,The following statement contains a magic number: Put_byte(unchecked((byte)((int)(((uint)w) >> 8))));
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,PutShortMSB,The following statement contains a magic number: Put_byte(unchecked((byte)(b >> 8)));
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Send_code,The following statement contains a magic number: int c2 = c * 2;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: Send_bits(STATIC_TREES << 1' 3);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)  			{  				Send_bits(STATIC_TREES << 1' 3);  				Send_code(END_BLOCK' StaticTree.static_ltree);  				Bi_flush();  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)  			{  				Send_bits(STATIC_TREES << 1' 3);  				Send_code(END_BLOCK' StaticTree.static_ltree);  				Bi_flush();  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)  			{  				Send_bits(STATIC_TREES << 1' 3);  				Send_code(END_BLOCK' StaticTree.static_ltree);  				Bi_flush();  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_align,The following statement contains a magic number: last_eob_len = 7;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = unchecked((byte)((int)(((uint)dist) >> 8)));
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = unchecked((byte)((int)(((uint)dist) >> 8)));
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2 + 1] = unchecked((byte)dist);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)  			{  				// lc is the unmatched char  				dyn_ltree[lc * 2]++;  			}  			else  			{  				matches++;  				// Here' lc is the match length - MIN_MATCH  				dist--;  				// dist = match distance - 1  				dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;  				dyn_dtree[Tree.D_code(dist) * 2]++;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)  			{  				// lc is the unmatched char  				dyn_ltree[lc * 2]++;  			}  			else  			{  				matches++;  				// Here' lc is the match length - MIN_MATCH  				dist--;  				// dist = match distance - 1  				dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;  				dyn_dtree[Tree.D_code(dist) * 2]++;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)  			{  				// lc is the unmatched char  				dyn_ltree[lc * 2]++;  			}  			else  			{  				matches++;  				// Here' lc is the match length - MIN_MATCH  				dist--;  				// dist = match distance - 1  				dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;  				dyn_dtree[Tree.D_code(dist) * 2]++;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & unchecked((int)(0x1fff))) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				int out_length = last_lit * 8;  				int in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length += (int)dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);  				}  				out_length = (int)(((uint)out_length) >> 3);  				if ((matches < (last_lit / 2)) && out_length < in_length / 2)  				{  					return true;  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & unchecked((int)(0x1fff))) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				int out_length = last_lit * 8;  				int in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length += (int)dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);  				}  				out_length = (int)(((uint)out_length) >> 3);  				if ((matches < (last_lit / 2)) && out_length < in_length / 2)  				{  					return true;  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & unchecked((int)(0x1fff))) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				int out_length = last_lit * 8;  				int in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length += (int)dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);  				}  				out_length = (int)(((uint)out_length) >> 3);  				if ((matches < (last_lit / 2)) && out_length < in_length / 2)  				{  					return true;  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & unchecked((int)(0x1fff))) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				int out_length = last_lit * 8;  				int in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length += (int)dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);  				}  				out_length = (int)(((uint)out_length) >> 3);  				if ((matches < (last_lit / 2)) && out_length < in_length / 2)  				{  					return true;  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & unchecked((int)(0x1fff))) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				int out_length = last_lit * 8;  				int in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length += (int)dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);  				}  				out_length = (int)(((uint)out_length) >> 3);  				if ((matches < (last_lit / 2)) && out_length < in_length / 2)  				{  					return true;  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & unchecked((int)(0x1fff))) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				int out_length = last_lit * 8;  				int in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length += (int)dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);  				}  				out_length = (int)(((uint)out_length) >> 3);  				if ((matches < (last_lit / 2)) && out_length < in_length / 2)  				{  					return true;  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & unchecked((int)(0x1fff))) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				int out_length = last_lit * 8;  				int in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length += (int)dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);  				}  				out_length = (int)(((uint)out_length) >> 3);  				if ((matches < (last_lit / 2)) && out_length < in_length / 2)  				{  					return true;  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Compress_block,The following statement contains a magic number: if (last_lit != 0)  			{  				do  				{  					dist = ((pending_buf[d_buf + lx * 2] << 8) & unchecked((int)(0xff00))) | (pending_buf  						[d_buf + lx * 2 + 1] & unchecked((int)(0xff)));  					lc = (pending_buf[l_buf + lx]) & unchecked((int)(0xff));  					lx++;  					if (dist == 0)  					{  						Send_code(lc' ltree);  					}  					else  					{  						// send a literal byte  						// Here' lc is the match length - MIN_MATCH  						code = Tree._length_code[lc];  						Send_code(code + LITERALS + 1' ltree);  						// send the length code  						extra = Tree.extra_lbits[code];  						if (extra != 0)  						{  							lc -= Tree.base_length[code];  							Send_bits(lc' extra);  						}  						// send the extra length bits  						dist--;  						// dist is now the match distance - 1  						code = Tree.D_code(dist);  						Send_code(code' dtree);  						// send the distance code  						extra = Tree.extra_dbits[code];  						if (extra != 0)  						{  							dist -= Tree.base_dist[code];  							Send_bits(dist' extra);  						}  					}  				}  				while (lx < last_lit);  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Compress_block,The following statement contains a magic number: if (last_lit != 0)  			{  				do  				{  					dist = ((pending_buf[d_buf + lx * 2] << 8) & unchecked((int)(0xff00))) | (pending_buf  						[d_buf + lx * 2 + 1] & unchecked((int)(0xff)));  					lc = (pending_buf[l_buf + lx]) & unchecked((int)(0xff));  					lx++;  					if (dist == 0)  					{  						Send_code(lc' ltree);  					}  					else  					{  						// send a literal byte  						// Here' lc is the match length - MIN_MATCH  						code = Tree._length_code[lc];  						Send_code(code + LITERALS + 1' ltree);  						// send the length code  						extra = Tree.extra_lbits[code];  						if (extra != 0)  						{  							lc -= Tree.base_length[code];  							Send_bits(lc' extra);  						}  						// send the extra length bits  						dist--;  						// dist is now the match distance - 1  						code = Tree.D_code(dist);  						Send_code(code' dtree);  						// send the distance code  						extra = Tree.extra_dbits[code];  						if (extra != 0)  						{  							dist -= Tree.base_dist[code];  							Send_bits(dist' extra);  						}  					}  				}  				while (lx < last_lit);  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Compress_block,The following statement contains a magic number: if (last_lit != 0)  			{  				do  				{  					dist = ((pending_buf[d_buf + lx * 2] << 8) & unchecked((int)(0xff00))) | (pending_buf  						[d_buf + lx * 2 + 1] & unchecked((int)(0xff)));  					lc = (pending_buf[l_buf + lx]) & unchecked((int)(0xff));  					lx++;  					if (dist == 0)  					{  						Send_code(lc' ltree);  					}  					else  					{  						// send a literal byte  						// Here' lc is the match length - MIN_MATCH  						code = Tree._length_code[lc];  						Send_code(code + LITERALS + 1' ltree);  						// send the length code  						extra = Tree.extra_lbits[code];  						if (extra != 0)  						{  							lc -= Tree.base_length[code];  							Send_bits(lc' extra);  						}  						// send the extra length bits  						dist--;  						// dist is now the match distance - 1  						code = Tree.D_code(dist);  						Send_code(code' dtree);  						// send the distance code  						extra = Tree.extra_dbits[code];  						if (extra != 0)  						{  							dist -= Tree.base_dist[code];  							Send_bits(dist' extra);  						}  					}  				}  				while (lx < last_lit);  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Compress_block,The following statement contains a magic number: last_eob_len = ltree[END_BLOCK * 2 + 1];
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Set_data_type,The following statement contains a magic number: while (n < 7)  			{  				bin_freq += dyn_ltree[n * 2];  				n++;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Set_data_type,The following statement contains a magic number: while (n < 7)  			{  				bin_freq += dyn_ltree[n * 2];  				n++;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Set_data_type,The following statement contains a magic number: while (n < 128)  			{  				ascii_freq += dyn_ltree[n * 2];  				n++;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Set_data_type,The following statement contains a magic number: while (n < 128)  			{  				ascii_freq += dyn_ltree[n * 2];  				n++;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Set_data_type,The following statement contains a magic number: while (n < LITERALS)  			{  				bin_freq += dyn_ltree[n * 2];  				n++;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Set_data_type,The following statement contains a magic number: data_type = unchecked((byte)(bin_freq > ((int)(((uint)ascii_freq) >> 2)) ? Z_BINARY  				 : Z_ASCII));
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Bi_flush,The following statement contains a magic number: if (bi_valid == 16)  			{  				Put_short(bi_buf);  				bi_buf = 0;  				bi_valid = 0;  			}  			else  			{  				if (bi_valid >= 8)  				{  					Put_byte(unchecked((byte)bi_buf));  					bi_buf = (short)(((ushort)bi_buf) >> 8);  					bi_valid -= 8;  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Bi_flush,The following statement contains a magic number: if (bi_valid == 16)  			{  				Put_short(bi_buf);  				bi_buf = 0;  				bi_valid = 0;  			}  			else  			{  				if (bi_valid >= 8)  				{  					Put_byte(unchecked((byte)bi_buf));  					bi_buf = (short)(((ushort)bi_buf) >> 8);  					bi_valid -= 8;  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Bi_flush,The following statement contains a magic number: if (bi_valid == 16)  			{  				Put_short(bi_buf);  				bi_buf = 0;  				bi_valid = 0;  			}  			else  			{  				if (bi_valid >= 8)  				{  					Put_byte(unchecked((byte)bi_buf));  					bi_buf = (short)(((ushort)bi_buf) >> 8);  					bi_valid -= 8;  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Bi_flush,The following statement contains a magic number: if (bi_valid == 16)  			{  				Put_short(bi_buf);  				bi_buf = 0;  				bi_valid = 0;  			}  			else  			{  				if (bi_valid >= 8)  				{  					Put_byte(unchecked((byte)bi_buf));  					bi_buf = (short)(((ushort)bi_buf) >> 8);  					bi_valid -= 8;  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Bi_windup,The following statement contains a magic number: if (bi_valid > 8)  			{  				Put_short(bi_buf);  			}  			else  			{  				if (bi_valid > 0)  				{  					Put_byte(unchecked((byte)bi_buf));  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Copy_block,The following statement contains a magic number: last_eob_len = 8;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_stored,The following statement contains a magic number: if (max_block_size > pending_buf_size - 5)  			{  				max_block_size = pending_buf_size - 5;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_stored,The following statement contains a magic number: if (max_block_size > pending_buf_size - 5)  			{  				max_block_size = pending_buf_size - 5;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_stored_block,The following statement contains a magic number: Send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0)' 3);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  				{  					Set_data_type();  				}  				// Construct the literal and distance trees  				l_desc.Build_tree(this);  				d_desc.Build_tree(this);  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = Build_bl_tree();  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = (int)(((uint)(opt_len + 3 + 7)) >> 3);  				static_lenb = (int)(((uint)(static_len + 3 + 7)) >> 3);  				if (static_lenb <= opt_lenb)  				{  					opt_lenb = static_lenb;  				}  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  				{  					Set_data_type();  				}  				// Construct the literal and distance trees  				l_desc.Build_tree(this);  				d_desc.Build_tree(this);  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = Build_bl_tree();  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = (int)(((uint)(opt_len + 3 + 7)) >> 3);  				static_lenb = (int)(((uint)(static_len + 3 + 7)) >> 3);  				if (static_lenb <= opt_lenb)  				{  					opt_lenb = static_lenb;  				}  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  				{  					Set_data_type();  				}  				// Construct the literal and distance trees  				l_desc.Build_tree(this);  				d_desc.Build_tree(this);  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = Build_bl_tree();  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = (int)(((uint)(opt_len + 3 + 7)) >> 3);  				static_lenb = (int)(((uint)(static_len + 3 + 7)) >> 3);  				if (static_lenb <= opt_lenb)  				{  					opt_lenb = static_lenb;  				}  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  				{  					Set_data_type();  				}  				// Construct the literal and distance trees  				l_desc.Build_tree(this);  				d_desc.Build_tree(this);  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = Build_bl_tree();  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = (int)(((uint)(opt_len + 3 + 7)) >> 3);  				static_lenb = (int)(((uint)(static_len + 3 + 7)) >> 3);  				if (static_lenb <= opt_lenb)  				{  					opt_lenb = static_lenb;  				}  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  				{  					Set_data_type();  				}  				// Construct the literal and distance trees  				l_desc.Build_tree(this);  				d_desc.Build_tree(this);  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = Build_bl_tree();  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = (int)(((uint)(opt_len + 3 + 7)) >> 3);  				static_lenb = (int)(((uint)(static_len + 3 + 7)) >> 3);  				if (static_lenb <= opt_lenb)  				{  					opt_lenb = static_lenb;  				}  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  				{  					Set_data_type();  				}  				// Construct the literal and distance trees  				l_desc.Build_tree(this);  				d_desc.Build_tree(this);  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = Build_bl_tree();  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = (int)(((uint)(opt_len + 3 + 7)) >> 3);  				static_lenb = (int)(((uint)(static_len + 3 + 7)) >> 3);  				if (static_lenb <= opt_lenb)  				{  					opt_lenb = static_lenb;  				}  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  				{  					Set_data_type();  				}  				// Construct the literal and distance trees  				l_desc.Build_tree(this);  				d_desc.Build_tree(this);  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = Build_bl_tree();  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = (int)(((uint)(opt_len + 3 + 7)) >> 3);  				static_lenb = (int)(((uint)(static_len + 3 + 7)) >> 3);  				if (static_lenb <= opt_lenb)  				{  					opt_lenb = static_lenb;  				}  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1)  			{  				// 4: two words for the lengths  				// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.  				// Otherwise we can't have processed more than WSIZE input bytes since  				// the last block flush' because compression would have been  				// successful. If LIT_BUFSIZE <= WSIZE' it is never too late to  				// transform a block into a stored block.  				_tr_stored_block(buf' stored_len' eof);  			}  			else  			{  				if (static_lenb == opt_lenb)  				{  					Send_bits((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  					Compress_block(StaticTree.static_ltree' StaticTree.static_dtree);  				}  				else  				{  					Send_bits((DYN_TREES << 1) + (eof ? 1 : 0)' 3);  					Send_all_trees(l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);  					Compress_block(dyn_ltree' dyn_dtree);  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1)  			{  				// 4: two words for the lengths  				// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.  				// Otherwise we can't have processed more than WSIZE input bytes since  				// the last block flush' because compression would have been  				// successful. If LIT_BUFSIZE <= WSIZE' it is never too late to  				// transform a block into a stored block.  				_tr_stored_block(buf' stored_len' eof);  			}  			else  			{  				if (static_lenb == opt_lenb)  				{  					Send_bits((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  					Compress_block(StaticTree.static_ltree' StaticTree.static_dtree);  				}  				else  				{  					Send_bits((DYN_TREES << 1) + (eof ? 1 : 0)' 3);  					Send_all_trees(l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);  					Compress_block(dyn_ltree' dyn_dtree);  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1)  			{  				// 4: two words for the lengths  				// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.  				// Otherwise we can't have processed more than WSIZE input bytes since  				// the last block flush' because compression would have been  				// successful. If LIT_BUFSIZE <= WSIZE' it is never too late to  				// transform a block into a stored block.  				_tr_stored_block(buf' stored_len' eof);  			}  			else  			{  				if (static_lenb == opt_lenb)  				{  					Send_bits((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  					Compress_block(StaticTree.static_ltree' StaticTree.static_dtree);  				}  				else  				{  					Send_bits((DYN_TREES << 1) + (eof ? 1 : 0)' 3);  					Send_all_trees(l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);  					Compress_block(dyn_ltree' dyn_dtree);  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_slow,The following statement contains a magic number: while (true)  			{  				// Make sure that we always have enough lookahead' except  				// at the end of the input file. We need MAX_MATCH bytes  				// for the next match' plus MIN_MATCH bytes to insert the  				// string following the next match.  				if (lookahead < MIN_LOOKAHEAD)  				{  					Fill_window();  					if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)  					{  						return NeedMore;  					}  					if (lookahead == 0)  					{  						break;  					}  				}  				// flush the current block  				// Insert the string window[strstart .. strstart+2] in the  				// dictionary' and set hash_head to the head of the hash chain:  				if (lookahead >= MIN_MATCH)  				{  					ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & unchecked(  						(int)(0xff)))) & hash_mask;  					//	prev[strstart&w_mask]=hash_head=head[ins_h];  					hash_head = (head[ins_h] & unchecked((int)(0xffff)));  					prev[strstart & w_mask] = head[ins_h];  					head[ins_h] = (short)strstart;  				}  				// Find the longest match' discarding those <= prev_length.  				prev_length = match_length;  				prev_match = match_start;  				match_length = MIN_MATCH - 1;  				if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & unchecked(  					(int)(0xffff))) <= w_size - MIN_LOOKAHEAD)  				{  					// To simplify the code' we prevent matches with the string  					// of window index 0 (in particular we have to avoid a match  					// of the string with itself at the start of the input file).  					if (strategy != Z_HUFFMAN_ONLY)  					{  						match_length = Longest_match(hash_head);  					}  					// longest_match() sets match_start  					if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH &&  						 strstart - match_start > 4096)))  					{  						// If prev_match is also MIN_MATCH' match_start is garbage  						// but we will ignore the current match anyway.  						match_length = MIN_MATCH - 1;  					}  				}  				// If there was a match at the previous step and the current  				// match is not better' output the previous match:  				if (prev_length >= MIN_MATCH && match_length <= prev_length)  				{  					int max_insert = strstart + lookahead - MIN_MATCH;  					// Do not insert strings in hash table beyond this.  					//          check_match(strstart-1' prev_match' prev_length);  					bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);  					// Insert in hash table all strings up to the end of the match.  					// strstart-1 and strstart are already inserted. If there is not  					// enough lookahead' the last two strings are not inserted in  					// the hash table.  					lookahead -= prev_length - 1;  					prev_length -= 2;  					do  					{  						if (++strstart <= max_insert)  						{  							ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & unchecked(  								(int)(0xff)))) & hash_mask;  							//prev[strstart&w_mask]=hash_head=head[ins_h];  							hash_head = (head[ins_h] & unchecked((int)(0xffff)));  							prev[strstart & w_mask] = head[ins_h];  							head[ins_h] = (short)strstart;  						}  					}  					while (--prev_length != 0);  					match_available = 0;  					match_length = MIN_MATCH - 1;  					strstart++;  					if (bflush)  					{  						Flush_block_only(false);  						if (strm.avail_out == 0)  						{  							return NeedMore;  						}  					}  				}  				else  				{  					if (match_available != 0)  					{  						// If there was no match at the previous position' output a  						// single literal. If there was a match but the current match  						// is longer' truncate the previous match to a single literal.  						bflush = _tr_tally(0' window[strstart - 1] & unchecked((int)(0xff)));  						if (bflush)  						{  							Flush_block_only(false);  						}  						strstart++;  						lookahead--;  						if (strm.avail_out == 0)  						{  							return NeedMore;  						}  					}  					else  					{  						// There is no previous match to compare with' wait for  						// the next step to decide.  						match_available = 1;  						strstart++;  						lookahead--;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_slow,The following statement contains a magic number: while (true)  			{  				// Make sure that we always have enough lookahead' except  				// at the end of the input file. We need MAX_MATCH bytes  				// for the next match' plus MIN_MATCH bytes to insert the  				// string following the next match.  				if (lookahead < MIN_LOOKAHEAD)  				{  					Fill_window();  					if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)  					{  						return NeedMore;  					}  					if (lookahead == 0)  					{  						break;  					}  				}  				// flush the current block  				// Insert the string window[strstart .. strstart+2] in the  				// dictionary' and set hash_head to the head of the hash chain:  				if (lookahead >= MIN_MATCH)  				{  					ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & unchecked(  						(int)(0xff)))) & hash_mask;  					//	prev[strstart&w_mask]=hash_head=head[ins_h];  					hash_head = (head[ins_h] & unchecked((int)(0xffff)));  					prev[strstart & w_mask] = head[ins_h];  					head[ins_h] = (short)strstart;  				}  				// Find the longest match' discarding those <= prev_length.  				prev_length = match_length;  				prev_match = match_start;  				match_length = MIN_MATCH - 1;  				if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & unchecked(  					(int)(0xffff))) <= w_size - MIN_LOOKAHEAD)  				{  					// To simplify the code' we prevent matches with the string  					// of window index 0 (in particular we have to avoid a match  					// of the string with itself at the start of the input file).  					if (strategy != Z_HUFFMAN_ONLY)  					{  						match_length = Longest_match(hash_head);  					}  					// longest_match() sets match_start  					if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH &&  						 strstart - match_start > 4096)))  					{  						// If prev_match is also MIN_MATCH' match_start is garbage  						// but we will ignore the current match anyway.  						match_length = MIN_MATCH - 1;  					}  				}  				// If there was a match at the previous step and the current  				// match is not better' output the previous match:  				if (prev_length >= MIN_MATCH && match_length <= prev_length)  				{  					int max_insert = strstart + lookahead - MIN_MATCH;  					// Do not insert strings in hash table beyond this.  					//          check_match(strstart-1' prev_match' prev_length);  					bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);  					// Insert in hash table all strings up to the end of the match.  					// strstart-1 and strstart are already inserted. If there is not  					// enough lookahead' the last two strings are not inserted in  					// the hash table.  					lookahead -= prev_length - 1;  					prev_length -= 2;  					do  					{  						if (++strstart <= max_insert)  						{  							ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & unchecked(  								(int)(0xff)))) & hash_mask;  							//prev[strstart&w_mask]=hash_head=head[ins_h];  							hash_head = (head[ins_h] & unchecked((int)(0xffff)));  							prev[strstart & w_mask] = head[ins_h];  							head[ins_h] = (short)strstart;  						}  					}  					while (--prev_length != 0);  					match_available = 0;  					match_length = MIN_MATCH - 1;  					strstart++;  					if (bflush)  					{  						Flush_block_only(false);  						if (strm.avail_out == 0)  						{  							return NeedMore;  						}  					}  				}  				else  				{  					if (match_available != 0)  					{  						// If there was no match at the previous position' output a  						// single literal. If there was a match but the current match  						// is longer' truncate the previous match to a single literal.  						bflush = _tr_tally(0' window[strstart - 1] & unchecked((int)(0xff)));  						if (bflush)  						{  							Flush_block_only(false);  						}  						strstart++;  						lookahead--;  						if (strm.avail_out == 0)  						{  							return NeedMore;  						}  					}  					else  					{  						// There is no previous match to compare with' wait for  						// the next step to decide.  						match_available = 1;  						strstart++;  						lookahead--;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Deflate_slow,The following statement contains a magic number: while (true)  			{  				// Make sure that we always have enough lookahead' except  				// at the end of the input file. We need MAX_MATCH bytes  				// for the next match' plus MIN_MATCH bytes to insert the  				// string following the next match.  				if (lookahead < MIN_LOOKAHEAD)  				{  					Fill_window();  					if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)  					{  						return NeedMore;  					}  					if (lookahead == 0)  					{  						break;  					}  				}  				// flush the current block  				// Insert the string window[strstart .. strstart+2] in the  				// dictionary' and set hash_head to the head of the hash chain:  				if (lookahead >= MIN_MATCH)  				{  					ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & unchecked(  						(int)(0xff)))) & hash_mask;  					//	prev[strstart&w_mask]=hash_head=head[ins_h];  					hash_head = (head[ins_h] & unchecked((int)(0xffff)));  					prev[strstart & w_mask] = head[ins_h];  					head[ins_h] = (short)strstart;  				}  				// Find the longest match' discarding those <= prev_length.  				prev_length = match_length;  				prev_match = match_start;  				match_length = MIN_MATCH - 1;  				if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & unchecked(  					(int)(0xffff))) <= w_size - MIN_LOOKAHEAD)  				{  					// To simplify the code' we prevent matches with the string  					// of window index 0 (in particular we have to avoid a match  					// of the string with itself at the start of the input file).  					if (strategy != Z_HUFFMAN_ONLY)  					{  						match_length = Longest_match(hash_head);  					}  					// longest_match() sets match_start  					if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH &&  						 strstart - match_start > 4096)))  					{  						// If prev_match is also MIN_MATCH' match_start is garbage  						// but we will ignore the current match anyway.  						match_length = MIN_MATCH - 1;  					}  				}  				// If there was a match at the previous step and the current  				// match is not better' output the previous match:  				if (prev_length >= MIN_MATCH && match_length <= prev_length)  				{  					int max_insert = strstart + lookahead - MIN_MATCH;  					// Do not insert strings in hash table beyond this.  					//          check_match(strstart-1' prev_match' prev_length);  					bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);  					// Insert in hash table all strings up to the end of the match.  					// strstart-1 and strstart are already inserted. If there is not  					// enough lookahead' the last two strings are not inserted in  					// the hash table.  					lookahead -= prev_length - 1;  					prev_length -= 2;  					do  					{  						if (++strstart <= max_insert)  						{  							ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & unchecked(  								(int)(0xff)))) & hash_mask;  							//prev[strstart&w_mask]=hash_head=head[ins_h];  							hash_head = (head[ins_h] & unchecked((int)(0xffff)));  							prev[strstart & w_mask] = head[ins_h];  							head[ins_h] = (short)strstart;  						}  					}  					while (--prev_length != 0);  					match_available = 0;  					match_length = MIN_MATCH - 1;  					strstart++;  					if (bflush)  					{  						Flush_block_only(false);  						if (strm.avail_out == 0)  						{  							return NeedMore;  						}  					}  				}  				else  				{  					if (match_available != 0)  					{  						// If there was no match at the previous position' output a  						// single literal. If there was a match but the current match  						// is longer' truncate the previous match to a single literal.  						bflush = _tr_tally(0' window[strstart - 1] & unchecked((int)(0xff)));  						if (bflush)  						{  							Flush_block_only(false);  						}  						strstart++;  						lookahead--;  						if (strm.avail_out == 0)  						{  							return NeedMore;  						}  					}  					else  					{  						// There is no previous match to compare with' wait for  						// the next step to decide.  						match_available = 1;  						strstart++;  						lookahead--;  					}  				}  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Longest_match,The following statement contains a magic number: if (prev_length >= good_match)  			{  				chain_length >>= 2;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,Longest_match,The following statement contains a magic number: do  			{  				match = cur_match;  				// Skip to next match if the match length cannot increase  				// or if the match length is less than 2:  				if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1  					 || window[match] != window[scan] || window[++match] != window[scan + 1])  				{  					continue;  				}  				// The check at best_len-1 can be removed because it will be made  				// again later. (This heuristic is not always a win.)  				// It is not necessary to compare scan[2] and match[2] since they  				// are always equal when the other bytes match' given that  				// the hash keys are equal and that HASH_BITS >= 8.  				scan += 2;  				match++;  				do  				{  				}  				while (window[++scan] == window[++match] && window[++scan] == window[++match] &&   					window[++scan] == window[++match] && window[++scan] == window[++match] && window  					[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan  					] == window[++match] && window[++scan] == window[++match] && scan < strend);  				// We check for insufficient lookahead only every 8th comparison;  				// the 256th check will be made at strstart+258.  				len = MAX_MATCH - (int)(strend - scan);  				scan = strend - MAX_MATCH;  				if (len > best_len)  				{  					match_start = cur_match;  					best_len = len;  					if (len >= nice_match)  					{  						break;  					}  					scan_end1 = window[scan + best_len - 1];  					scan_end = window[scan + best_len];  				}  			}  			while ((cur_match = (prev[cur_match & wmask] & unchecked((int)(0xffff)))) > limit  				 && --chain_length != 0);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: if (level == Z_DEFAULT_COMPRESSION)  			{  				level = 6;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits  				 < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy >   				Z_HUFFMAN_ONLY)  			{  				return Z_STREAM_ERROR;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits  				 < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy >   				Z_HUFFMAN_ONLY)  			{  				return Z_STREAM_ERROR;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits  				 < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy >   				Z_HUFFMAN_ONLY)  			{  				return Z_STREAM_ERROR;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: hash_bits = memLevel + 7;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: window = new byte[w_size * 2];
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: lit_bufsize = 1 << (memLevel + 6);
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: pending_buf = new byte[lit_bufsize * 4];
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: pending_buf_size = lit_bufsize * 4;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: d_buf = lit_bufsize / 2;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateInit2,The following statement contains a magic number: l_buf = (1 + 2) * lit_bufsize;
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateParams,The following statement contains a magic number: if (_level == Z_DEFAULT_COMPRESSION)  			{  				_level = 6;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DeflateParams,The following statement contains a magic number: if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY)  			{  				return Z_STREAM_ERROR;  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & unchecked((int)(0xff))) >> 1;  				if (level_flags > 3)  				{  					level_flags = 3;  				}  				header |= (level_flags << 6);  				if (strstart != 0)  				{  					header |= PRESET_DICT;  				}  				header += 31 - (header % 31);  				status = BUSY_STATE;  				PutShortMSB(header);  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					PutShortMSB((int)((long)(((ulong)strm.adler) >> 16)));  					PutShortMSB((int)(strm.adler & unchecked((int)(0xffff))));  				}  				strm.adler = strm._adler.Adler(0' null' 0' 0);  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & unchecked((int)(0xff))) >> 1;  				if (level_flags > 3)  				{  					level_flags = 3;  				}  				header |= (level_flags << 6);  				if (strstart != 0)  				{  					header |= PRESET_DICT;  				}  				header += 31 - (header % 31);  				status = BUSY_STATE;  				PutShortMSB(header);  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					PutShortMSB((int)((long)(((ulong)strm.adler) >> 16)));  					PutShortMSB((int)(strm.adler & unchecked((int)(0xffff))));  				}  				strm.adler = strm._adler.Adler(0' null' 0' 0);  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & unchecked((int)(0xff))) >> 1;  				if (level_flags > 3)  				{  					level_flags = 3;  				}  				header |= (level_flags << 6);  				if (strstart != 0)  				{  					header |= PRESET_DICT;  				}  				header += 31 - (header % 31);  				status = BUSY_STATE;  				PutShortMSB(header);  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					PutShortMSB((int)((long)(((ulong)strm.adler) >> 16)));  					PutShortMSB((int)(strm.adler & unchecked((int)(0xffff))));  				}  				strm.adler = strm._adler.Adler(0' null' 0' 0);  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & unchecked((int)(0xff))) >> 1;  				if (level_flags > 3)  				{  					level_flags = 3;  				}  				header |= (level_flags << 6);  				if (strstart != 0)  				{  					header |= PRESET_DICT;  				}  				header += 31 - (header % 31);  				status = BUSY_STATE;  				PutShortMSB(header);  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					PutShortMSB((int)((long)(((ulong)strm.adler) >> 16)));  					PutShortMSB((int)(strm.adler & unchecked((int)(0xffff))));  				}  				strm.adler = strm._adler.Adler(0' null' 0' 0);  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & unchecked((int)(0xff))) >> 1;  				if (level_flags > 3)  				{  					level_flags = 3;  				}  				header |= (level_flags << 6);  				if (strstart != 0)  				{  					header |= PRESET_DICT;  				}  				header += 31 - (header % 31);  				status = BUSY_STATE;  				PutShortMSB(header);  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					PutShortMSB((int)((long)(((ulong)strm.adler) >> 16)));  					PutShortMSB((int)(strm.adler & unchecked((int)(0xffff))));  				}  				strm.adler = strm._adler.Adler(0' null' 0' 0);  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & unchecked((int)(0xff))) >> 1;  				if (level_flags > 3)  				{  					level_flags = 3;  				}  				header |= (level_flags << 6);  				if (strstart != 0)  				{  					header |= PRESET_DICT;  				}  				header += 31 - (header % 31);  				status = BUSY_STATE;  				PutShortMSB(header);  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					PutShortMSB((int)((long)(((ulong)strm.adler) >> 16)));  					PutShortMSB((int)(strm.adler & unchecked((int)(0xffff))));  				}  				strm.adler = strm._adler.Adler(0' null' 0' 0);  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & unchecked((int)(0xff))) >> 1;  				if (level_flags > 3)  				{  					level_flags = 3;  				}  				header |= (level_flags << 6);  				if (strstart != 0)  				{  					header |= PRESET_DICT;  				}  				header += 31 - (header % 31);  				status = BUSY_STATE;  				PutShortMSB(header);  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					PutShortMSB((int)((long)(((ulong)strm.adler) >> 16)));  					PutShortMSB((int)(strm.adler & unchecked((int)(0xffff))));  				}  				strm.adler = strm._adler.Adler(0' null' 0' 0);  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & unchecked((int)(0xff))) >> 1;  				if (level_flags > 3)  				{  					level_flags = 3;  				}  				header |= (level_flags << 6);  				if (strstart != 0)  				{  					header |= PRESET_DICT;  				}  				header += 31 - (header % 31);  				status = BUSY_STATE;  				PutShortMSB(header);  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					PutShortMSB((int)((long)(((ulong)strm.adler) >> 16)));  					PutShortMSB((int)(strm.adler & unchecked((int)(0xffff))));  				}  				strm.adler = strm._adler.Adler(0' null' 0' 0);  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & unchecked((int)(0xff))) >> 1;  				if (level_flags > 3)  				{  					level_flags = 3;  				}  				header |= (level_flags << 6);  				if (strstart != 0)  				{  					header |= PRESET_DICT;  				}  				header += 31 - (header % 31);  				status = BUSY_STATE;  				PutShortMSB(header);  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					PutShortMSB((int)((long)(((ulong)strm.adler) >> 16)));  					PutShortMSB((int)(strm.adler & unchecked((int)(0xffff))));  				}  				strm.adler = strm._adler.Adler(0' null' 0' 0);  			}
Magic Number,NSch.ZLib,Deflate,C:\repos\mono_ngit\NSch\NSch.ZLib\Deflate.cs,DoDeflate,The following statement contains a magic number: PutShortMSB((int)((long)(((ulong)strm.adler) >> 16)));
Duplicate Code,NSch,IdentityFile,C:\repos\mono_ngit\NSch\NSch\IdentityFile.cs,NewInstance,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (55' 74))
Duplicate Code,NSch,Session,C:\repos\mono_ngit\NSch\NSch\Session.cs,Run,The method contains a code clone-set at the following line numbers (starting from the method definition): ((100' 119)' (139' 158))
Duplicate Code,NSch.ZLib,Adler32,C:\repos\mono_ngit\NSch\NSch.ZLib\Adler32.cs,Adler,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (17' 36)' (19' 38)' (21' 40)' (23' 42)' (25' 44)' (27' 46))
Duplicate Code,NSch.ZLib,Adler32,C:\repos\mono_ngit\NSch\NSch.ZLib\Adler32.cs,Adler,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 43)' (17' 45))
Duplicate Code,NSch.ZLib,Adler32,C:\repos\mono_ngit\NSch\NSch.ZLib\Adler32.cs,Adler,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (19' 38)' (21' 40)' (23' 42)' (25' 44)' (27' 46))
Duplicate Code,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((33' 53)' (282' 302))
Duplicate Code,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((71' 92)' (174' 195))
Duplicate Code,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((72' 91)' (141' 160))
Duplicate Code,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((72' 91)' (141' 160)' (175' 194)' (231' 250))
Duplicate Code,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((72' 91)' (231' 250)' (141' 160)' (175' 194))
Duplicate Code,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((140' 159)' (230' 249))
Duplicate Code,NSch.ZLib,InfCodes,C:\repos\mono_ngit\NSch\NSch.ZLib\InfCodes.cs,Proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((270' 299)' (315' 344))
Missing Default,NSch,DHG1,C:\repos\mono_ngit\NSch\NSch\DHG1.cs,Next,The following switch statement is missing a default case: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Missing Default,NSch,DHGEX,C:\repos\mono_ngit\NSch\NSch\DHGEX.cs,Next,The following switch statement is missing a default case: switch (state)  			{  				case SSH_MSG_KEX_DH_GEX_GROUP:  				{  					// byte  SSH_MSG_KEX_DH_GEX_GROUP(31)  					// mpint p' safe prime  					// mpint g' generator for subgroup in GF (p)  					_buf.GetInt();  					_buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_GROUP)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_GROUP " + j);  						return false;  					}  					p = _buf.GetMPInt();  					g = _buf.GetMPInt();  					dh.SetP(p);  					dh.SetG(g);  					// The client responds with:  					// byte  SSH_MSG_KEX_DH_GEX_INIT(32)  					// mpint e <- g^x mod p  					//         x is a random number (1 < x < (p-1)/2)  					e = dh.GetE();  					packet.Reset();  					buf.PutByte(unchecked((byte)SSH_MSG_KEX_DH_GEX_INIT));  					buf.PutMPInt(e);  					session.Write(packet);  					if (JSch.GetLogger().IsEnabled(Logger.INFO))  					{  						JSch.GetLogger().Log(Logger.INFO' "SSH_MSG_KEX_DH_GEX_INIT sent");  						JSch.GetLogger().Log(Logger.INFO' "expecting SSH_MSG_KEX_DH_GEX_REPLY");  					}  					state = SSH_MSG_KEX_DH_GEX_REPLY;  					return true;  				}    				case SSH_MSG_KEX_DH_GEX_REPLY:  				{  					//break;  					// The server responds with:  					// byte      SSH_MSG_KEX_DH_GEX_REPLY(33)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != SSH_MSG_KEX_DH_GEX_REPLY)  					{  						System.Console.Error.WriteLine("type: must be SSH_MSG_KEX_DH_GEX_REPLY " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// uint32    min' minimal size in bits of an acceptable group  					// uint32   n' preferred size in bits of the group the server should send  					// uint32    max' maximal size in bits of an acceptable group  					// mpint     p' safe prime  					// mpint     g' generator for subgroup  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutInt(min);  					buf.PutInt(preferred);  					buf.PutInt(max);  					buf.PutMPInt(p);  					buf.PutMPInt(g);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					// System.err.print("H -> "); dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						//	SignatureRSA sig=new SignatureRSA();  						//	sig.init();  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							//	SignatureDSA sig=new SignatureDSA();  							//	sig.init();  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Missing Default,NSch,DHG14,C:\repos\mono_ngit\NSch\NSch\DHG14.cs,Next,The following switch statement is missing a default case: switch (state)  			{  				case SSH_MSG_KEXDH_REPLY:  				{  					// The server responds with:  					// byte      SSH_MSG_KEXDH_REPLY(31)  					// string    server public host key and certificates (K_S)  					// mpint     f  					// string    signature of H  					j = _buf.GetInt();  					j = _buf.GetByte();  					j = _buf.GetByte();  					if (j != 31)  					{  						System.Console.Error.WriteLine("type: must be 31 " + j);  						return false;  					}  					K_S = _buf.GetString();  					// K_S is server_key_blob' which includes ....  					// string ssh-dss  					// impint p of dsa  					// impint q of dsa  					// impint g of dsa  					// impint pub_key of dsa  					//System.err.print("K_S: "); //dump(K_S' 0' K_S.length);  					byte[] f = _buf.GetMPInt();  					byte[] sig_of_H = _buf.GetString();  					dh.SetF(f);  					K = dh.GetK();  					//The hash H is computed as the HASH hash of the concatenation of the  					//following:  					// string    V_C' the client's version string (CR and NL excluded)  					// string    V_S' the server's version string (CR and NL excluded)  					// string    I_C' the payload of the client's SSH_MSG_KEXINIT  					// string    I_S' the payload of the server's SSH_MSG_KEXINIT  					// string    K_S' the host key  					// mpint     e' exchange value sent by the client  					// mpint     f' exchange value sent by the server  					// mpint     K' the shared secret  					// This value is called the exchange hash' and it is used to authenti-  					// cate the key exchange.  					buf.Reset();  					buf.PutString(V_C);  					buf.PutString(V_S);  					buf.PutString(I_C);  					buf.PutString(I_S);  					buf.PutString(K_S);  					buf.PutMPInt(e);  					buf.PutMPInt(f);  					buf.PutMPInt(K);  					byte[] foo = new byte[buf.GetLength()];  					buf.GetByte(foo);  					sha.Update(foo' 0' foo.Length);  					H = sha.Digest();  					//System.err.print("H -> "); //dump(H' 0' H.length);  					i = 0;  					j = 0;  					j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  						(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  						++]) & unchecked((int)(0x000000ff)));  					string alg = Util.Byte2str(K_S' i' j);  					i += j;  					bool result = false;  					if (alg.Equals("ssh-rsa"))  					{  						byte[] tmp;  						byte[] ee;  						byte[] n;  						type = RSA;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						ee = tmp;  						j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  							(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  							++]) & unchecked((int)(0x000000ff)));  						tmp = new byte[j];  						System.Array.Copy(K_S' i' tmp' 0' j);  						i += j;  						n = tmp;  						NSch.SignatureRSA sig = null;  						try  						{  							Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.rsa"));  							sig = (NSch.SignatureRSA)(System.Activator.CreateInstance(c));  							sig.Init();  						}  						catch (Exception ex)  						{  							System.Console.Error.WriteLine(ex);  						}  						sig.SetPubKey(ee' n);  						sig.Update(H);  						result = sig.Verify(sig_of_H);  						if (JSch.GetLogger().IsEnabled(Logger.INFO))  						{  							JSch.GetLogger().Log(Logger.INFO' "ssh_rsa_verify: signature " + result);  						}  					}  					else  					{  						if (alg.Equals("ssh-dss"))  						{  							byte[] q = null;  							byte[] tmp;  							byte[] p;  							byte[] g;  							type = DSS;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							p = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							q = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							g = tmp;  							j = ((K_S[i++] << 24) & unchecked((int)(0xff000000))) | ((K_S[i++] << 16) & unchecked(  								(int)(0x00ff0000))) | ((K_S[i++] << 8) & unchecked((int)(0x0000ff00))) | ((K_S[i  								++]) & unchecked((int)(0x000000ff)));  							tmp = new byte[j];  							System.Array.Copy(K_S' i' tmp' 0' j);  							i += j;  							f = tmp;  							NSch.SignatureDSA sig = null;  							try  							{  								Type c = Sharpen.Runtime.GetType(session.GetConfig("signature.dss"));  								sig = (NSch.SignatureDSA)(System.Activator.CreateInstance(c));  								sig.Init();  							}  							catch (Exception ex)  							{  								System.Console.Error.WriteLine(ex);  							}  							sig.SetPubKey(f' p' q' g);  							sig.Update(H);  							result = sig.Verify(sig_of_H);  							if (JSch.GetLogger().IsEnabled(Logger.INFO))  							{  								JSch.GetLogger().Log(Logger.INFO' "ssh_dss_verify: signature " + result);  							}  						}  						else  						{  							System.Console.Error.WriteLine("unknown alg");  						}  					}  					state = STATE_END;  					return result;  				}  			}
Missing Default,NSch.ZLib,InfBlocks,C:\repos\mono_ngit\NSch\NSch.ZLib\InfBlocks.cs,Proc,The following switch statement is missing a default case: switch ((int)(((uint)t) >> 1))  						{  							case 0:  							{  								// stored   								b = (int)(((uint)b) >> (3));  								k -= (3);  								t = k & 7;  								// go to byte boundary  								b = (int)(((uint)b) >> (t));  								k -= (t);  								mode = LENS;  								// get length of stored block  								break;  							}    							case 1:  							{  								// fixed  								int[] bl = new int[1];  								int[] bd = new int[1];  								int[][] tl = new int[1][];  								int[][] td = new int[1][];  								InfTree.Inflate_trees_fixed(bl' bd' tl' td' z);  								codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = CODES;  								break;  							}    							case 2:  							{  								// dynamic  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = TABLE;  								break;  							}    							case 3:  							{  								// illegal  								b = (int)(((uint)b) >> (3));  								k -= (3);  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								bitb = b;  								bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index;  								z.next_in_index = p;  								write = q;  								return Inflate_flush(z' r);  							}  						}
Missing Default,Sharpen,Cipher,C:\repos\mono_ngit\NSch\NSch\Sharpen\Cipher.cs,GetInstance,The following switch statement is missing a default case: switch (name) {  			case "RC4": return new R4Cipher ();  			case "AES/CBC/NoPadding": return new AesCipher (CipherMode.CBC);  			case "AES/CTR/NoPadding": throw new NotSupportedException ();  			case "Blowfish/CBC/NoPadding": return new BlowfishCipher (CipherMode.CBC);  			case "DESede/CBC/NoPadding": return new DESedeCipher (CipherMode.CBC);  			case "DESede/CTR/NoPadding": throw new NotSupportedException ();  			}
Missing Default,Sharpen,KeyPairGenerator,C:\repos\mono_ngit\NSch\NSch\Sharpen\KeyPairGenerator.cs,GetInstance,The following switch statement is missing a default case: switch (name.ToUpper ()) {  			case "DH": return new DHKeyPairGenerator ();  			case "DSA": return new DSAKeyPairGenerator ();  			case "RSA": return new RSAKeyPairGenerator ();  			}
Missing Default,Sharpen,Mac,C:\repos\mono_ngit\NSch\NSch\Sharpen\Mac.cs,GetInstance,The following switch statement is missing a default case: switch (name.ToUpper ()) {  			case "HMACMD5": m.mac = new HMACMD5 (); break;  			case "HMACSHA1": m.mac = new HMACSHA1 (); break;  			}
Missing Default,Sharpen,KeyFactory,C:\repos\mono_ngit\NSch\NSch\Sharpen\KeyFactory.cs,GetInstance,The following switch statement is missing a default case: switch (id.ToUpper ()) {  			case "DSA": return new DSAKeyFactory ();  			case "DH": return new DHKeyFactory ();  			case "RSA": return new RSAKeyFactory ();  			}
Missing Default,Sharpen,Signature,C:\repos\mono_ngit\NSch\NSch\Sharpen\Signature.cs,GetInstance,The following switch statement is missing a default case: switch (id) {  			case "SHA1withDSA": return new SHA1withDSASignature ();  			case "SHA1withRSA": return new SHA1withRSASignature ();  			}
